# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the files AT ONCE just to copy paste code into Jetbrains Rider code editor and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
IF you generate code for Editor scripts, make sure to run game related logic only if Application.isPlaying is true.
include file path as first row for example(without quotes): "// Assets\-ZombieRoyale\Scripts\LLM AI\Personality\Personality.cs" # TASK: Add JOBS System to Ability is within range logic. # CODE: // Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Ability.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using DuloGames.UI;
using FishNet;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using Invector;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class Ability: NetworkBehaviour
{
    protected int _rank;
    [SerializeField] protected AbilityDefinition _abilityDefinition;
    public Buff Buff => _buff;
    [SerializeField] protected Buff _buff;
    [SerializeField] protected bool isPassiveSkill;
    public static Dictionary<NetworkConnection, uint> StacksCounter { get; private set; } = new ();
    public static Dictionary<NetworkConnection, uint> RankCounter { get; private set; } = new ();
    public AbilityDefinition AbilityDefinition => _abilityDefinition;
    public static Action OnAbilityLearned;
    public Action<NetworkConnection, byte, uint> OnRankLevelUp;
    protected string _abilityName => _abilityDefinition.Name;
    protected GameplayManager _gameplayManager;
    protected bool _isDebug = true;
    protected readonly string COLOR_DURATION = "#00F0FF";
    protected readonly string COLOR_AFFECTING_STAT = "#00F0FF";
    protected readonly string COLOR_DAMAGE = "#ff3517";
    protected readonly string COLOR_HEAL = "#0ec949";
    protected readonly string COLOR_STAT = "#96e33d";
    protected readonly string COLOR_XP = "#c3eb34";
    protected readonly string COLOR_COOLDOWN = "#c8e609";

    protected readonly Color DEBUG_SPHERE_DEFAULT_COLOR = new Color(1f, 0f, 0f, 0.5f);
    protected readonly Color DEBUG_SPHERE_ACTIVATE_COLOR = new Color(1f, 0f, 1f, 0.5f);
    protected Color _debugSphereColor;
    protected bool _showDebugSphere;
    protected Vector3 _debugSpherePos;
    protected float _debugSphereRadius = 1f;

    public override void OnStartServer()
    {
        base.OnStartServer();
        InstanceFinder.TimeManager.OnTick += OnServerTick;
    }

    public override void OnStartClient()
    {
        base.OnStartClient();
        InstanceFinder.TimeManager.OnTick += OnClientTick;
    }

    protected virtual void OnServerTick() { }

    protected virtual void OnClientTick() { }

    public override void OnStopServer()
    {
        base.OnStopServer();
        InstanceFinder.TimeManager.OnTick -= OnServerTick;
    }

    public override void OnStopClient()
    {
        base.OnStopClient();
        InstanceFinder.TimeManager.OnTick -= OnClientTick;
    }

    public virtual void InitAbility()
    {
        if (_buff != null) 
        {
            _buff.Init(GameplayManager.Instance);
        }
        else
        {
            Debug.LogWarning($"Buff is null during ability {_abilityName} initialization.");
        }
    }

    public virtual float CalculateValueBasedOnStacks(uint stacks) => .01f;
    
    public virtual int CalculateRankBasedOnStacks(uint stacks) => 1;
    
    public virtual float CalculateDamageBasedOnRank(int rank) => 1;
    
    public virtual uint GetStacksForRank() => 1;
    
    public uint AddRank(NetworkConnection connection)
    {
        if (RankCounter.ContainsKey(connection))
        {
            RankCounter[connection]++;
        }
        else
        {
            RankCounter.Add(connection, 1);
        }
        OnRankLevelUp?.Invoke(connection, _abilityDefinition.Id, RankCounter[connection]);
        return RankCounter[connection];
    }

    public uint ServerAddStack(FNAbilityController abilityController, uint amount)
    {
        if (!abilityController.LearnedAbilityDict.ContainsKey(AbilityDefinition.Id))
        {
            Debug.LogError($"Ability {AbilityDefinition.Name} is not learned by player {abilityController.gameObject.name}. Cannot add stacks.");
            return 0;
        }
        
        AbilityInfo targetsAbilityStats = abilityController.LearnedAbilityDict[AbilityDefinition.Id];
        targetsAbilityStats.Stacks = Math.Max(0, targetsAbilityStats.Stacks + amount);
        abilityController.AddOrSetAbility(targetsAbilityStats);
        return targetsAbilityStats.Stacks;
    }
    
    public uint AddStack(NetworkConnection connection)
    {
        if (StacksCounter.ContainsKey(connection))
        {
            StacksCounter[connection]++;
        }
        else
        {
            StacksCounter.Add(connection, 1);
        }
        
        if (EnoughStacksToLevelup(connection))
        {
            StacksCounter[connection] = 0;
            AddRank(connection);
            return 1;
        }
        else
        {
            return 0;
        }
        
        return StacksCounter[connection];
    }
    
    public UISpellInfo GetUISpellInfo(byte abilityId, uint stacks)
    {
        UISpellInfo spellInfo = new UISpellInfo();
        spellInfo.ID = _abilityDefinition.Id;
        uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId);
        int abilityRankBasedOnStacks = CalculateRankBasedOnStacks(abilityStacksForPlayer);
        spellInfo.Name = GetAbilityName(abilityRankBasedOnStacks);
        spellInfo.Icon = _abilityDefinition.Icon;
        spellInfo.Description = GetAbilityDescription(abilityRankBasedOnStacks, abilityStacksForPlayer);
        if (_abilityDefinition.IsPassive)
        {
            spellInfo.Flags = UISpellInfo_Flags.Passive;
        }
        else
        {
            AbilityDefinition.RPGAbilityRankData rankData = _abilityDefinition.RanksDatas[0];

            if (rankData != null)
            {
                switch (rankData.activationType)
                {
                    case AbilityDefinition.AbilityActivationType.Instant:
                        spellInfo.Flags = UISpellInfo_Flags.InstantCast;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCircle:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCircle;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCone:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCone;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedAim:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastAim;
                        break;
                    default:
                        spellInfo.Flags = UISpellInfo_Flags.PowerCostInPct;
                        break;

                }

                spellInfo.Range = rankData.maxRange;
                spellInfo.Cooldown = rankData.cooldown;

                if (UnitComponentsManager.GetAllPlayersHeroes().Count != 0)
                {
                    var nob = UnitComponentsManager.GetAllPlayersHeroes().First();
                    var unit = UnitComponentsManager.GetUnitComponents(nob);

                    if (GetAbilityCastingTime(0, unit.StatsController) > 0)
                    {
                        spellInfo.CastTime = GetAbilityCastingTime(0, unit.StatsController);
                    }
                }

                spellInfo.PowerCost = rankData.manaCost;
            }
            else
            {
                Debug.LogError($"Ability {spellInfo.Name} does not have rank {abilityId}. Setting default values.");
            }
        }
        return spellInfo;
    }

    private bool EnoughStacksToLevelup(NetworkConnection connection)
    {
        return StacksCounter[connection] >= GetStacksForRank();
    }

    public virtual string GetAbilityName(int rank) => _abilityDefinition.Name;
    public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description;
    public virtual string GetAbilityDescription(int rank, FNStatsController statsController) => _abilityDefinition.persistDescription;
    
    public virtual float GetAbilityCastingTime(int rank, FNStatsController statsController)
    {
        CombatEntityStat entityStat = statsController.GetStatByType(Stat.STAT_TYPE.HASTE);
        var value = entityStat.GetCurrentAmount();
        var defaultCastTime = _abilityDefinition.RanksDatas[rank].castTime;
        var castingTime = defaultCastTime * (1 / (1 + value));

        return castingTime;
    }

    public virtual IEnumerator Activate(AbilityCastingData data)
    {
        yield return null;
    }

    [Server]
    protected virtual void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f)
    {
        Debug.Log($"{_abilityName} Applying caster buff.");
        _buff.Activate(casterBuffData, new int[]{}, duration:duration);
    }
    
    [Server]
    public virtual void CasterRemoveBuff(Buff.BuffData casterBuffData)
    {
        Debug.Log($"{_abilityName} Removing caster buff.");
        _buff.RemoveBuff(casterBuffData.ObjectId, casterBuffData.ObjectId);
    }

    protected virtual List<Collider> TargetsSelection(Transform caster) 
    {
        Debug.LogWarning($"{_abilityName} TargetsSelection method has not been implemented yet.");
        throw new NotImplementedException();
    }

    [Server]
    protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage, bool isExcludeSelf = false)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        var targets = TargetsInSphereSelection(playerComps, radius);
        for (int i = 0; i < targets.Count; i++) 
        {
            if (isExcludeSelf && targets[i] == playerComps.HealthController)
            {
                continue;
            }
            damage.receiver = targets[i].transform;
            targets[i].TakeDamage(damage);

            Debug.Log($"[{_abilityDefinition.Name}] Damage applied to {targets[i].name}");
        }
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, Buff.BuffData caster, float radius)
    {
        //Debug.Log($"{_abilityName} Selecting targets in sphere.");
        List<FishnetInvectorHealthController> targets = EnemyTargetsInRadius(pos, caster, radius);
        //Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");
        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsExcludingTagsInSphereSelection(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = TargetsInRadiusExcludingTags(tags, pos, caster, radius);
        return targets;
    }
    
    public static List<FishnetInvectorHealthController> TargetsInRadiusExcludingTags(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            for (int i = 0; i < tags.Length; i++)
            {
                if (targetNob.CompareTag(tags[i]))
                {
                    continue;
                }
            }
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            targets.Add(targetComps.HealthController);
        }
        return targets;
    }

    public static bool IsAlly(UnitComponents caster, UnitComponents target)
    {
        bool isCasterPlayer = caster.HealthController.CompareTag(GameplayManager.TAG_PLAYER);
        bool isTargetPlayer = target.HealthController.CompareTag(GameplayManager.TAG_PLAYER);
        bool isCasterEnemy = false;
        bool isTargetEnemy = false;
        for (int i = 0; i < GameplayManager.SERVER_AI_CONTROLLED_TAGS.Length; i++)
        {
            if (caster.HealthController.CompareTag(GameplayManager.SERVER_AI_CONTROLLED_TAGS[i]))
            {
                isCasterEnemy = true;
            }
            if (target.HealthController.CompareTag(GameplayManager.SERVER_AI_CONTROLLED_TAGS[i]))
            {
                isTargetEnemy = true;
            }
        }
        
        if (isCasterPlayer && isTargetEnemy)
        {
            return false;
        }else if (isCasterEnemy && isTargetPlayer)
        {
            return false;
        }else if (isCasterEnemy && isTargetEnemy)
        {
            return true;
        }else if (isCasterPlayer && isTargetPlayer)
        {
            if (caster == target)
                return true;
            
            if (GameplayManager.Instance.RoomDetails.IsTeamsMode)
            {
                var teamClientInstancesMembers = GameplayManager.Instance.RoomDetails.GetActiveClientsFromSameTeam(caster.NetworkObject);
                if (teamClientInstancesMembers.Contains(target.Owner))
                {
                    return true;
                }
            }
            else
            {
                return false;
            }
        }

        return false;
    }

    public static List<FishnetInvectorHealthController> EnemyTargetsInRadius(Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            Buff.BuffData targetData = new Buff.BuffData(targetComps.HealthController.ObjectId, targetComps.HealthController.gameObject.tag, 0f, caster.abilityId, 0, null, null, 0);
            if (IsNotValidTargetEnemy(caster, targetData))
                continue;
            
            targets.Add(targetComps.HealthController);
        }

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsInSphereSelection(UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var target in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(target).NetworkObject;
            if (CommonMath.Math.IsWithinRange(caster.HealthController.transform.position, targetNob.transform.position, radius))
            {
                var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(target);
                targets.Add(targetComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> CorrectTargetsInSphereSelection(UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        var targets = TargetsInSphereSelection(caster, radius);
        
        foreach (var target in targets)
        {
            if (!IsCorrectTarget(_rank, caster, target.UnitComponents))
            {
                targets.Remove(target);
            }
        }
        
        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [ObserversRpc]
    protected void RpcShowEffectForObservers(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect for observers.");

        GameplayManager.Instance.StartCoroutine(ShowEffectOnTarget(targetNetId, abilityId, rank, timeout));
    }
    
    protected virtual IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if(targetComps == null)
        {
            Debug.LogError($"{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        List<GameObject> effects = new List<GameObject>(); 
        foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints)
        {
            Assert.IsNotNull(_abilityDefinition.RanksDatas[rank].hitEffect, $"Hit effect is null for {_abilityName}.");
            Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint);
            GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position + Vector3.up, Quaternion.identity, GameplayManager.Instance.transform);
            effect.transform.SetParent(pointTransform);
            effects.Add(effect);
        }

        yield return new WaitForSeconds(timeout);
        foreach (var effect in effects)
        {
            Destroy(effect, timeout);
        }
    }
    
    public static bool IsNotValidTargetEnemy(Buff.BuffData casterData, Buff.BuffData targetData)
    {
        if (casterData.ObjectId == targetData.ObjectId)
        {
            return true;
        }

        int casterTeam = GameplayManager.Instance.GetUnitTeamId(casterData.ObjectId);
        int targetTeam = GameplayManager.Instance.GetUnitTeamId(targetData.ObjectId);
        if (casterData.Tag == GameplayManager.TAG_PLAYER)
        {
            if (casterTeam == targetTeam)
            {
                return true;
            }
            return false;
        }else if (targetData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
        {
            if (casterData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
            {
                return true;
            }
            return false;
        }

        return false;
    }

    protected bool IsNotValidTargetEnemy(UnitComponents target, UnitComponents caster)
    {
        //Debug.Log($"{_abilityName} Checking if target is valid.");
        if (target == null)
            return true;
        
        if (target == caster)
        {
            //Debug.Log($"{_abilityName} Target is the same as caster. Invalid target.");
            return true;
        }

        var targetHealthController = target.HealthController;
        if (targetHealthController == null)
        {
            return true;
        }
        if (targetHealthController.CompareTag(GameplayManager.TAG_PLAYER))
        {
            //Debug.Log($"{_abilityName} Target is a player. Valid target.");
            return false;
        }else if (targetHealthController.CompareTag("Enemy"))
        {
            //Debug.Log($"{_abilityName} Target is an enemy. Valid target.");
            if (caster.HealthController.CompareTag("Enemy"))
            {
                return true;
            }
            return false;
        }

        //Debug.Log($"{_abilityName} Target does not have a Player or Enemy tag. Invalid target.");

        return false;
    }
    
    protected void DrawDebugSphere(Vector3 pos, float radius)
    {
        _debugSpherePos = pos;
        _debugSphereRadius = radius;
        _showDebugSphere = true;
        _debugSphereColor = DEBUG_SPHERE_ACTIVATE_COLOR;
        StartCoroutine(ResetDebugSphereColorAfterDelay(0.3f));
    }
    
    protected IEnumerator ResetDebugSphereColorAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        _debugSphereColor = DEBUG_SPHERE_DEFAULT_COLOR;
        _showDebugSphere = false;
    }
    
    public virtual float CalcAmount(FNStatsController statsController) {
        return 1f;
    }
    
    public virtual float CalcDuration(FNStatsController statsController) {
        return 1f;
    }
    
    public bool IsCorrectTarget(int rank, UnitComponents caster, UnitComponents target)
    {
        if (AbilityDefinition.RanksDatas[rank].CanHitSelf)
        {
            if (caster == target)
                return true;
        }
        bool isAlly = IsAlly(caster, target);
        
        if (AbilityDefinition.RanksDatas[rank].CanHitEnemy)
        {
            if (!isAlly)
            {
                return true;
            }
        }

        if (AbilityDefinition.RanksDatas[rank].CanHitAlly)
        {
            if (isAlly)
            {
                return true;
            }
        }
        
        return true;
    }

    public NetworkConnection[] FindNearbyPlayers(Vector3 casterTransformPosition, float distanceSquared)
    {
        var playerHeroes = UnitComponentsManager.GetAllPlayersHeroes();
        List<NetworkConnection> connections = new List<NetworkConnection>();
        foreach (var hero in playerHeroes)
        {
            if (Vector3.SqrMagnitude(hero.transform.position - casterTransformPosition) < distanceSquared)
            {
                connections.Add(hero.Owner);
            }
        }
        return connections.ToArray();
    }

    public class VfxOnClientData/* 48 bytes */
    {
        public Vector3 forwardDirection;/* 3×4=12 bytes */
        public Vector3 waveStartPosition;/* 3×4=12 bytes */
        public Quaternion rotation;/* 4×4=16 bytes */
        public float duration;/*  4 bytes */
        public int rank;/*  4 bytes */

        public VfxOnClientData(){}
        
        public VfxOnClientData(Vector3 forwardDirection, Vector3 waveStartPosition, Quaternion rotation, float duration, int rank)
        {
            this.forwardDirection = forwardDirection;
            this.waveStartPosition = waveStartPosition;
            this.rotation = rotation;
            this.duration = duration;
            this.rank = rank;
        }
    }

    public class VfxParticle
    {
        public int senderId;
        public int rank;
        public Transform transform;
        public ColliderInvoker collider;
        public Vector3 startPosition;
        public Vector3 endPosition;
        public float duration;
        public double elapsedTime;
        public List<FishnetInvectorHealthController> alreadyDamaged = new ();
        
        public VfxParticle(int senderId, int rank, Transform transform, ColliderInvoker collider, Vector3 startPosition, Vector3 endPosition, float duration, double elapsedTime, List<FishnetInvectorHealthController> alreadyDamaged)
        {
            this.senderId = senderId;
            this.transform = transform;
            this.collider = collider;
            this.startPosition = startPosition;
            this.endPosition = endPosition;
            this.duration = duration;
            this.elapsedTime = elapsedTime;
            this.alreadyDamaged = alreadyDamaged;
            this.rank = rank;
        }
    }

#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        if (_showDebugSphere)
        {
            Gizmos.color = _debugSphereColor;
            Gizmos.DrawSphere(_debugSpherePos, _debugSphereRadius);
        }
    }
#endif
} 

// Assets\-ZombieRoyale\Scripts\InRoomSystems\Gameplay\RespawnManager.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using DungeonScrollerCore;
using FishNet.Object;
using Pathfinding;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Serialization;
using Zomb.Creatures.Module;


namespace _ZombieRoyale.Scripts.Core
{
public struct SearchNearestCreaturesToEachPlayerJob : IJob
{
    //Unmanaged types:
    //sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, or bool, Any enum type, Any pointer type
    //NativeStream example: https://github.com/Unity-Technologies/SimpleUIDemo/blob/master/Tiny3D/Library/PackageCache/com.unity.collections%400.3.0-preview.0/Unity.Collections.Tests/NativeStreamTests.cs

    private static readonly float DISTANCE_TO_SPAWN_AI_SQUARED = 200f;//14.1f
    private static readonly float DISTANCE_TO_DESPAWN_AI_SQUARED = 1600f;//40f
    private static readonly float DISTANCE_TO_BLOCK_POINTS_SQUARED = 225f;
    // Jobs declare all data that will be accessed in the job
    // By declaring it as read only, multiple jobs are allowed to access the data in parallel
    [ReadOnly]
    public NativeArray<SpawnPointForJob> JSpawnPointsArray;
    public NativeArray<Vector3> PlayersPosArray;
    
    
    public NativeList<ushort> ResultPointsToSpawn;
    public NativeList<ushort> ResultPointsToDespawn;
    public bool IsSpawnBasedOnPlayers;
    

    public void Execute()
    {
        for (int j = 0; j < JSpawnPointsArray.Length; j++)
        {
            var spawnPoint = JSpawnPointsArray[j];
            if (spawnPoint.isUsed)
            {
                byte playerNearby = 0;
                for (int i = 0; i < PlayersPosArray.Length; i++)
                {
                    var playerPos = PlayersPosArray[i];
                    float distSquared = (playerPos - spawnPoint.position).sqrMagnitude;
                    if (distSquared < DISTANCE_TO_DESPAWN_AI_SQUARED)
                        playerNearby++;
                }
                if (playerNearby > 0)
                    continue;
                    
                ResultPointsToDespawn.Add(spawnPoint.id);
            }
            else
            {
                for (int i = 0; i < PlayersPosArray.Length; i++)
                {
                    var playerPos = PlayersPosArray[i];
                    float distSquared = (playerPos - spawnPoint.position).sqrMagnitude;
                    if (distSquared > DISTANCE_TO_SPAWN_AI_SQUARED)
                        continue;
                    
                    ResultPointsToSpawn.Add(spawnPoint.id);
                    break;
                }
            }
        }
        
        //TODO check and insert this logic
        // if (IsSpawnBasedOnPlayers)
        // {
        //     for (int i = 0; i < JSpawnPointsArray.Length; i++)
        //     {
        //         var spawnPoint = JSpawnPointsArray[i];
        //         if (spawnPoint.isUsed)
        //             continue;
        //         
        //         if (spawnPoint.IsUsedAsNeighbourToOtherPoint)
        //             continue;
        //         
        //         byte playerNearby = 0;
        //         for (int j = 0; j < PlayersPosArray.Length; j++)
        //         {
        //             var playerPos = PlayersPosArray[j];
        //             float distSquared = (playerPos - spawnPoint.position).sqrMagnitude;
        //             if (distSquared > DISTANCE_TO_BLOCK_POINTS_SQUARED)
        //                 continue;
        //             playerNearby++;
        //             spawnPoint.closestPlayerDistance = distSquared;
        //         }
        //         if (playerNearby <= 0)
        //             continue;
        //         ResultPointsToSpawn.Add(spawnPoint.id);
        //         for (int j = 0; j < JSpawnPointsArray.Length; j++)
        //         {
        //             if (i == j)
        //                 continue;
        //             var point = JSpawnPointsArray[j];
        //             if (point.isUsed)
        //             {
        //                 continue;
        //             }
        //             float distance = (spawnPoint.position - point.position).sqrMagnitude;
        //             if (distance > DISTANCE_TO_BLOCK_POINTS_SQUARED)
        //             {
        //                 continue;
        //             }
        //             point.IsUsedAsNeighbourToOtherPoint = true;
        //         }
        //     }
        // }
    }
}

[ExecuteInEditMode]
public class RespawnManager : RoomManager {
    protected const float DEFAULT_MONSTER_RESPAWN_TIME = 600f;
    public static string TAG_PORTAL_SPAWN_POINT = "EscapePortalPoint";
    public static string TAG_MONSTER_SPAWN_POINT = "MonsterSpawnPoint";
    public static string TAG_BOSS_SPAWN_POINT = "BossSpawnPoint";
    protected static float DISTANCE_TO_SPAWN_AI = 20f;
    protected static float DISTANCE_TO_DESPAWN_AI = 40f;
    protected static float DISTANCE_TO_BLOCK_POINTS = 15f;
    [SerializeField] protected List<SpawnPoint> _spawnPoints = new List<SpawnPoint>();
    protected NativeArray<SpawnPointForJob> SpawnPointsArray;
    [SerializeField] protected EnemyDefinitionsHolderSO _enemyDefinitionsHolderSO;
    [SerializeField] protected bool _isSpawnBasedOnPlayers;
    protected CreaturesFactory _creaturesFactory;
    protected bool _isActivated = true;
    protected ushort _startingFromIndex = 0;
    public Action<List<Vector3>> OnBossSpawnPointsPopulated;
    [field: SerializeField] public List<Vector3> PortalPoints { get; protected set; } = new (); 
    protected bool _isDebug = true;
    protected bool _isSpawnPointsInitialized;
    [SerializeField] private bool _isSpawnPointsInsideHolder = false;
    public static RespawnManager Instance { get; protected set; }

    protected void OnDisable() { Debug.Log($"[RespawnManager] OnDisable"); }
    protected void OnEnable() { Debug.Log($"[RespawnManager] OnEnable"); }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(this);
        }
    }

    public override void OnStartNetwork() {
        base.OnStartNetwork();

        if (IsServer || IsHost) {
            _creaturesFactory = GetComponent<CreaturesFactory>();
        }
    }
    
    public override void OnStopNetwork() {
        base.OnStopNetwork();
        if (IsServer || IsHost) {
            if (SpawnPointsArray.IsCreated)
                SpawnPointsArray.Dispose();
        }
    }

    protected IEnumerator CorUpdate()
    {
        var time = new WaitForSeconds(1f);
        while (true)
        {
            if (!_isActivated)
                yield return null;
            // StartCoroutine(SpawnCreaturesIfRequired());
            // StartCoroutine(DespawnCreaturesIfRequired());
            CheckPlayers();
            yield return time;
        }
    }

    private void CheckPlayers()
    {
        if (GameplayManager.SpawnedPlayerHeroes.Count == 0)
            return;
        
        if (SpawnPointsArray.Length == 0)
        {
            Debug.LogError($"[RespawnManager] SpawnPointsArray.Length == 0");
            return;
        }
        var playerPosArray = new NativeArray<Vector3>(GameplayManager.SpawnedPlayerHeroes.Count, Allocator.TempJob);
        for (int i = 0; i < GameplayManager.SpawnedPlayerHeroes.Count; i++)
        {
            playerPosArray[i] = GameplayManager.SpawnedPlayerHeroes[i].transform.position;
        }
        
        NativeList<ushort> resultPointsToSpawn = new NativeList<ushort>(Allocator.TempJob);
        NativeList<ushort> resultPointsToDespawn = new NativeList<ushort>(Allocator.TempJob);
        var job = new SearchNearestCreaturesToEachPlayerJob
        {
            JSpawnPointsArray = SpawnPointsArray,
            PlayersPosArray = playerPosArray,
            ResultPointsToSpawn = resultPointsToSpawn,
            ResultPointsToDespawn = resultPointsToDespawn,
            IsSpawnBasedOnPlayers = _isSpawnBasedOnPlayers
        };
        job.Schedule().Complete();
        StringBuilder result = new StringBuilder("[RespawnManager] CheckPlayers ");
        if (resultPointsToSpawn.Length > 0)
        {
            result.Append($"Spawn(resultPointsToSpawn.Length): ");
            for (int i = 0; i < resultPointsToSpawn.Length; i++)
            {
                result.Append($"{resultPointsToSpawn[i]}, ");
            }
        }
        
        if (resultPointsToDespawn.Length > 0)
        {
            result.Append($". Despawn(resultPointsToDespawn.Length): ");
            for (int i = 0; i < resultPointsToDespawn.Length; i++)
            {
                result.Append($"{resultPointsToDespawn[i]}, ");
            }
        }
        //Debug.Log($"{result}");
        
        foreach (var pointId in resultPointsToDespawn)
        {
            SpawnPoint point = _spawnPoints[pointId];
            point.UpdateClosestPlayerDistance(DISTANCE_TO_DESPAWN_AI+1f);
            _creaturesFactory.DeallocateCreature(point.SpawnedAI);
            point.RemoveAIUnit();
            point.SetUsedAs(false);
            SpawnPointsArray[pointId] = new SpawnPointForJob()
            {
                id = point.Id,
                type = point.GetCreatureType(),
                position = point.Position,
                isUsed = false,
                spawnedAIObjectId = -1,
                IsUsedAsNeighbourToOtherPoint = false
            };
            Debug.Log($"{ClassAndRoomName} despawned point {pointId}");
        }
        
        foreach (var pointId in resultPointsToSpawn)
        {
            SpawnPoint point = _spawnPoints[pointId];
            ushort creatureType = point.GetCreatureType();
            var creature = SpawnCreatureAtPoint(point.Position, creatureType);
            _spawnPoints[pointId].SetUsedAs(true);
            _spawnPoints[pointId].StoreAIUnit(creature.Controller);
            SpawnPointsArray[pointId] = new SpawnPointForJob()
            {
                id = point.Id,
                type = creatureType,
                position = point.Position,
                isUsed = true,
                spawnedAIObjectId = creature.Controller.ObjectId,
                IsUsedAsNeighbourToOtherPoint = false
            };
            creature.Controller.OnHideCreature += Controller_OnHideCreature;
        }
        
        resultPointsToSpawn.Dispose();
        resultPointsToDespawn.Dispose();
        playerPosArray.Dispose();
    }
    
    protected bool IsThereAnySpawnPointsToDespawn(out HashSet<int> pointsToDespawn) {
        pointsToDespawn = new HashSet<int>();
        for (int i = 0; i < _spawnPoints.Count; i++)
        {
            var spawnPoint = _spawnPoints[i];
            if (!spawnPoint.IsUsed)
                continue;
            
            if (spawnPoint.IsUsedAsNeighbourToOtherPoint) {
                continue;
            }
            
            int playersNearby = 0;
            foreach (var playerNob in UnitComponentsManager.GetAllPlayersHeroes())
            {
                var playerPosition = playerNob.transform.position;
                float distance = Vector3.Distance(spawnPoint.Position, playerPosition);
                if (distance < DISTANCE_TO_DESPAWN_AI)
                    playersNearby++;
            }
            
            if (playersNearby > 0)
                continue;
            
            pointsToDespawn.Add(spawnPoint.Id);
        }
        if (pointsToDespawn.Count == 0)
            return false;
        return true;
    }

    protected bool IsThereAnySpawnPointsToSpawn(out HashSet<int> pointsToSpawn) {
        //TODO optimize from O(n2) -> O(nlogn) using chunks
        pointsToSpawn = new HashSet<int>();

        for (int i = 0; i < _spawnPoints.Count; i++)
        {
            var spawnPoint = _spawnPoints[i];
            if (spawnPoint.IsUsed) {
                continue;
            }
            
            if (spawnPoint.IsUsedAsNeighbourToOtherPoint) {
                continue;
            }
            
            int playersNearby = 0;
            foreach (var playerNob in GameplayManager.SpawnedPlayerHeroes)
            {
                var playerPosition = playerNob.transform.position;
                float distance = Vector3.Distance(spawnPoint.Position, playerPosition);
                if (distance > DISTANCE_TO_SPAWN_AI) {
                    continue;
                }
                playersNearby++;
                spawnPoint.UpdateClosestPlayerDistance(distance);
            }
            if (playersNearby <= 0)
                continue;
            
            pointsToSpawn.Add(spawnPoint.Id);
            
            SpawnFilterBasedOnPlayersCountIfRequired(i, spawnPoint, playersNearby);
        }

        //Debug.Log($"{ClassAndRoomName} need to spawn {_pointsToSpawn.Count} points");
        if (pointsToSpawn.Count == 0)
            return false;
        return true;
    }

    protected void SpawnFilterBasedOnPlayersCountIfRequired(int i, SpawnPoint spawnPoint, int playersNearby)
    {
        if (!_isSpawnBasedOnPlayers) return;
        
        List<SpawnPoint> pointsNearby = new List<SpawnPoint>();
        //near each point should be only players*points active points
        for (int j = 0; j < _spawnPoints.Count; j++)
        {
            if (i == j)
                continue;
            var point = _spawnPoints[j];
            if (point.IsUsed)
            {
                continue;
            }

            float distance = Vector3.Distance(spawnPoint.Position, point.Position);
            if (distance > DISTANCE_TO_BLOCK_POINTS)
            {
                continue;
            }

            pointsNearby.Add(point);
        }

        foreach (var pointNear in pointsNearby)
        {
            if (playersNearby > 0)
            {
                playersNearby--;
                pointNear.IsUsedAsNeighbourToOtherPoint = true;
                continue;
            }
            else
            {
                pointNear.SetUsedAs(true);
            }
        }
    }

    public CreaturesFactory.PooledCreature SpawnCreatureAtPoint(Vector3 pos, ushort creatureType)
    {
        NNInfo astarPoint = GameplayManager.AstarPath.GetNearest(pos);
        Vector3 point = astarPoint.position;
        if(astarPoint.node == null)
        {
            Debug.LogError($"[RespawnManager] SpawnCreatureAtPoint {pos} astarPoint.node == null");
            point = pos;
        }
        CreaturesFactory.PooledCreature creature =
            _creaturesFactory.AllocateCreature(creatureType, point, GameplayManager);
        return creature;
    }

    protected void Controller_OnHideCreature(AIUnit controller) {
        //TODO spawn point id not setting properly
        ushort pointId = controller.SpawnPointId;
        SpawnPoint point = SpawnPointsGetFromId(pointId);
        point.SetUsedAs(false);
    }

    protected SpawnPoint SpawnPointsGetFromId(ushort id) { return _spawnPoints[id]; }

    [Server]
    public void MonsterSpawnPointsPopulate() {
        ushort index = 0;
        PopulateMonsterSpots(EnemyDefinition.Type.Monster);
        PopulateMonsterSpots(EnemyDefinition.Type.Boss);
        Debug.Log($"[RespawnManager] SpawnPointsPopulate: {_spawnPoints.Count}");
        _isSpawnPointsInitialized = true;
    }

    public void InitIfAllRequirementsMet()
    {
        StartCoroutine(LateInit());
    }

    protected IEnumerator LateInit()
    {
        if (!IsHost)
        {
            yield return new WaitUntil(() => GameplayManager.IsAllPlayersSpawned);
        }
        DebugWrite.Log($"[RespawnManager] Init", gameObject, _isDebug);
        StartCoroutine(CorUpdate());
    }
    
    public void RemovePortalSpawnPoints() {
        GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_PORTAL_SPAWN_POINT);
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            Destroy(spawnPointHolders[j]);
        }
    }
    
    public void RemoveMonsterSpawnPoints() {
        StringBuilder sb = new StringBuilder($"{ClassAndRoomName} RemoveMonsterSpawnPoints ");
        GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_MONSTER_SPAWN_POINT);
        sb.Append($"[RespawnManager] RemoveMonsterSpawnPoints {TAG_MONSTER_SPAWN_POINT}: {spawnPointHolders.Length}");
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            Destroy(spawnPointHolders[j]);
        }
        spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_BOSS_SPAWN_POINT);
        sb.Append($"[RespawnManager] RemoveMonsterSpawnPoints {TAG_BOSS_SPAWN_POINT}: {spawnPointHolders.Length}");
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            Destroy(spawnPointHolders[j]);
        }
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        if (!IsHost)
            Destroy(this.gameObject);
    }

    [Server]
    public void PopulatePortalPoints()
    {
        GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_PORTAL_SPAWN_POINT);
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            PortalPoints.Add(spawnPointHolders[j].transform.position);
            Destroy(spawnPointHolders[j]);
        }
    }

    [Server]
    protected void PopulateMonsterSpots(EnemyDefinition.Type type)
    {
        StringBuilder sb = new StringBuilder();
        string tag = "";
        float respawnTime = DEFAULT_MONSTER_RESPAWN_TIME;
        switch (type)
        {
            case EnemyDefinition.Type.Monster:
                tag = TAG_MONSTER_SPAWN_POINT;
                break;
            case EnemyDefinition.Type.Boss:
                tag = TAG_BOSS_SPAWN_POINT;
                respawnTime = 999999f;
                break;
        }

        sb.Append($"[RespawnManager] PopulateMonsterSpots of type: {tag}. ");
        GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(tag);
        sb.Append($"Found {spawnPointHolders.Length} points. ");
        List<Transform> spawnPoints = new List<Transform>();
        if (_isSpawnPointsInsideHolder)
        {
            List<Transform> spawnPointHoldersCleared = new List<Transform>();
            //Clear from those that dont have children, because in unity calling FindGameObjectsWithTag gives results with gameobjects that are not tagged with that tag, but they are children of game objects with that tag
            for (int i = 0; i < spawnPointHolders.Length; i++)
            {
                if (spawnPointHolders[i].transform.childCount > 0)
                {
                    spawnPointHoldersCleared.Add(spawnPointHolders[i].transform);
                }
            }
            sb.Append($"generate enemies: ");
            foreach (var holderGo in spawnPointHoldersCleared)
            {
                int childCount = holderGo.childCount;
                byte[] randomEnemies = new byte[childCount];
                for (int i = 0; i < childCount; i++)
                {
                    spawnPoints.Add(holderGo.GetChild(i));
                    randomEnemies[i] = _enemyDefinitionsHolderSO.GetRandomEnemyId(type);
                    sb.Append($"id: {randomEnemies[i]}, ");
                }
                PopulateSpawnPointsWith(randomEnemies, spawnPoints, respawnTime);
            }
            DebugWrite.Log($"[RespawnManager] {sb}", gameObject, _isDebug);
        }
        else
        {
            byte[] randomEnemies = new byte[spawnPointHolders.Length];
            for (int i = 0; i < spawnPointHolders.Length; i++)
            {
                spawnPoints.Add(spawnPointHolders[i].transform);
                randomEnemies[i] = _enemyDefinitionsHolderSO.GetRandomEnemyId(type);
                sb.Append($"id: {randomEnemies[i]}, ");
            }
            PopulateSpawnPointsWith(randomEnemies, spawnPoints, respawnTime);
            DebugWrite.Log($"[RespawnManager] {sb}", gameObject, _isDebug);
        }
        
        
        
        if (type == EnemyDefinition.Type.Boss)
            AddBossPoints(spawnPoints);
        
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            Destroy(spawnPointHolders[j]);
        }
    }

    [Server]
    protected void AddBossPoints(List<Transform> spawnPointHoldersCleared)
    {
        List<Vector3> positions = new List<Vector3>();
        foreach (var holderGo in spawnPointHoldersCleared)
        {
            positions.Add(holderGo.position);
        }
        Debug.Log($"[RespawnManager] Added {positions.Count} BossPoints");
        OnBossSpawnPointsPopulated?.Invoke(positions);
    }

    protected void PopulateSpawnPointsWith(byte[] randomEnemies, List<Transform> spawnPoints, float respawnTime)
    {
        foreach (var trans in spawnPoints)
        {
            byte randomEnemy = randomEnemies[spawnPoints.IndexOf(trans)];
            SpawnPoint spawnPoint = new SpawnPoint(_startingFromIndex, randomEnemy, trans.position, respawnTime);
            
            Debug.Log($"[RespawnManager] Added spawnPoint #{_startingFromIndex} with enemyId {randomEnemy}, at {trans.position} with respawnTime {respawnTime}", gameObject);
            _spawnPoints.Add(spawnPoint);
            _startingFromIndex++;
        }
        
        SpawnPointsArray = new NativeArray<SpawnPointForJob>(_spawnPoints.Count, Allocator.Persistent);
        for (int i = 0; i < _spawnPoints.Count; i++)
        {
            SpawnPointsArray[i] = new SpawnPointForJob()
            {
                id = _spawnPoints[i].Id,
                type = _spawnPoints[i].GetCreatureType(),
                position = _spawnPoints[i].Position,
                isUsed = _spawnPoints[i].IsUsed,
                spawnedAIObjectId = -1,
                IsUsedAsNeighbourToOtherPoint = false
            };
        }
    }
    
#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        //draw spheres
        if (_spawnPoints == null)
            return;
        for (int i = 0; i < _spawnPoints.Count; i++)
        {
            var spawnPoint = _spawnPoints[i];
            if (spawnPoint.IsUsed)
            {
                Gizmos.color = Color.red;
            }
            else
            {
                Gizmos.color = Color.green;
            }
            Gizmos.DrawSphere(spawnPoint.Position, 1f);
        }
    }
#endif
}
} 

// Assets\-ZombieRoyale\Scripts\Core\UnitComponents.cs:
 using System;
using _ZombieRoyale.Scripts.Clients;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;
using Zomb.Creatures.Helpers;

namespace _ZombieRoyale.Scripts.Core
{
    [Serializable]
    public class UnitComponents {
        public FishnetInvectorManager InvectorManager;
        public FishnetInvectorItemManager ItemManager;
        public FishnetInvectorHealthController HealthController;
        public FishnetInvectorShooterManager ShooterManager;
        public FishnetInvectorProjectilesManager ProjectilesManager;
        public FNStatsController StatsController;
        public FNXpController XpController;
        public FNAbilityController AbilityController;
        public FNvMeleeManager MeleeManager;
        public AttachmentPoints AttachmentPoints;
        public AIUnit AiUnit;
        public TeamUIController TeamUiController;
        public FishnetInvectorBuffController BuffController;
        public AnimatorDecorator AnimatorDecorator;
        public NetworkedActionsAnimator ActionsAnimator;
        public Transform Trans => HealthController.transform;
        public NetworkConnection Owner => HealthController.NetworkObject.Owner;
        public NetworkObject NetworkObject => HealthController.NetworkObject;
    
        public UnitComponents(){}
        public UnitComponents(NetworkObject netObj) {
            InvectorManager = netObj.GetComponent<FishnetInvectorManager>();
            ItemManager = netObj.GetComponent<FishnetInvectorItemManager>();
            HealthController = netObj.GetComponent<FishnetInvectorHealthController>();
            ShooterManager = netObj.GetComponent<FishnetInvectorShooterManager>();
            ProjectilesManager = netObj.GetComponent<FishnetInvectorProjectilesManager>();
            StatsController = netObj.GetComponent<FNStatsController>();
            XpController = netObj.GetComponent<FNXpController>();
            AbilityController = netObj.GetComponent<FNAbilityController>();
            MeleeManager = netObj.GetComponent<FNvMeleeManager>();
            AttachmentPoints = netObj.GetComponent<AttachmentPoints>();
            AiUnit = netObj.GetComponent<AIUnit>();
            TeamUiController = netObj.GetComponent<TeamUIController>();
            BuffController = netObj.GetComponent<FishnetInvectorBuffController>();
            AnimatorDecorator = netObj.GetComponent<AnimatorDecorator>();
            ActionsAnimator = netObj.GetComponent<NetworkedActionsAnimator>();
        
            SetParentReference();
        }

        public void Init()
        {
            SetParentReference();
        }

        private void SetParentReference() {
            if (ItemManager != null) ItemManager.UnitComponents = this;
            if (HealthController != null) HealthController.UnitComponents = this;
            if (ShooterManager != null) ShooterManager.UnitComponents = this;
            if (ProjectilesManager != null) ProjectilesManager.UnitComponents = this;
            if (StatsController != null) StatsController.UnitComponents = this;
            if (XpController != null) XpController.UnitComponents = this;
            if (AbilityController != null) AbilityController.UnitComponents = this;
            if (MeleeManager != null) MeleeManager.UnitComponents = this;
            if (AttachmentPoints != null) AttachmentPoints.UnitComponents = this;
            if (AiUnit != null) AiUnit.UnitComponents = this;
            if (TeamUiController != null) TeamUiController.UnitComponents = this;
            if (BuffController != null) BuffController.UnitComponents = this;
            if (AnimatorDecorator != null) AnimatorDecorator.UnitComponents = this;
            if (ActionsAnimator != null) ActionsAnimator.UnitComponents = this;
        }

        public static UnitComponents AssignUnitComponents(NetworkObject nob)
        {
            UnitComponents unitComps = nob.GetComponent<Unit>().UnitComps;
            unitComps.Init();
            return unitComps;
        }
    }
} 

// Assets\FishNet Invector\Scripts\Networked\FishnetInvectorHealthController.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using DamageNumbersPro;
using DungeonScrollerCore;
using FishNet;
using FishNet.Connection;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using Invector;
using UnityEngine;
using UnityEngine.Events;

namespace FishnetInvector {
    [RequireComponent(typeof(FishnetInvectorBuffController))]
    public class FishnetInvectorHealthController : NetworkBehaviour
    {
        private static float DEFAULT_HEALTH_VALUE = 500.0f;
        private static float DEFAULT_HEALTH_RECOVERY_DELAY = 1f;
        private static float HEALTH_REGEN_AMOUNT = 1f;
        private static float HEALTH_REGEN_INTERVAL = 1f;
        private static float MINIMAL_DAMAGE_TO_SHOW_DAMAGE_VFX = float.Epsilon;
        public static float TEAM_ADDITIONAL_XP_MODIFIER = 1.1f;

        #region Public Properties

        public FNvHealthController FNvHealthController { get; private set; }
        public float CurrentHealth => _currentHealth;
        public float MaxHealth => _maxHealth;
        public Action OnRessurect;
        public Action<vDamage> OnDead;
        public Action<vDamage> OnTakeDamage;
        public Action<FishnetInvectorHealthController, HealthType, float> OnHealthChanged;
        public Action<HealthType, float> OnMineHealthChanged;
        public Collider[] DamageReceivers => _damageReceivers;
        public FNvDamage LastDamageTaken => _lastDamageTaken;
        
        public bool IsAI => _isAI;
        public bool IsPlayer => _isPlayer;
        private string _className;
        public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());


        public enum HealthType
        {
            Current,
            Max,
            Regen
        }


        /// <summary>
        /// Subscribe to this event to update health bar on clients
        /// </summary>
        public Action<float> OnChangeCurrentHealthInfo;

        #endregion

        #region Private Properties

        [SyncVar(OnChange = nameof(OnCurrentHealthChange))]
        private float _currentHealth;

        [SyncVar(OnChange = nameof(OnMaxHealthChange))]
        private float _maxHealth;

        [SyncVar] private float _healthRecoveryDelay;
        [SyncVar] private float _healthRecoveryRate;
        [SyncVar] private bool _isImmortal = false;
        [SyncVar] private FNvDamage _lastDamageTaken;
        
        public bool IsDead => _isDead;
        [SyncVar(OnChange = nameof(OnIsDeadChanged))] private bool _isDead;
        [SerializeField] public UnitComponents UnitComponents;
        [SerializeField] private BloodController _bloodController;
        [SerializeField] private DamageNumber _critDamagePrefab;
        [SerializeField] private DamageNumber _damagePrefab;
        [SerializeField] private DamageNumber _healPrefab;
        [SerializeField] private FNArmor _armor;
        [SerializeField] private Collider[] _damageReceivers;
        [SerializeField] private bool _isAI;
        [SerializeField] private bool _isPlayer;
        private float _healthWithoutConstitution;
        private Coroutine _healthRegenCoroutine;
        private DamageSystem _damageSystem;
        [SerializeField] private Unit unit;
        public Action<bool> OnCollidersChanged;
        
        #endregion

        protected override void OnValidate()
        {
            base.OnValidate();
            AssignComponentsIfRequired();
        }

        private void AssignComponentsIfRequired()
        {
            unit ??= GetComponent<Unit>();
        }

        private void Awake()
        {
            AssignComponentsIfRequired();
            _armor ??= GetComponent<FNArmor>();
            if (unit.UnitComps.InvectorManager != null) {
                _isPlayer = true;
            }
            if (unit.UnitComps.AiUnit != null) {
                _isAI = true;
            }
        }

        public override void OnStartNetwork()
        {
            base.OnStartNetwork();
            if (base.Owner.IsLocalClient)
            {
                FNvHealthController = GetComponent<FNvHealthController>();
                FNvHealthController.InitLocalPlayer(this);
            }

            if (base.IsServer || base.IsHost)
            {
                StartCoroutine(OnStatsControllerActivatorListener());
                
            }
        }

        private IEnumerator OnStatsControllerActivatorListener()
        {
            yield return new WaitUntil(() => UnitComponents.StatsController != null);
            yield return new WaitUntil(() => UnitComponents.StatsController.IsStatsActivated);
            StatsControllerOnOnStatsActivated();
        }

        public void UpdateDamageSystem(UnitComponents damagerUnit, bool isAllyOnlyForPlayers)
        {
            _damageSystem = new DamageSystem(unit.UnitComps, damagerUnit, isAllyOnlyForPlayers);
        }

        public override void OnStartClient()
        {
            base.OnStartClient();
            GameplayManager.Instance.RegisterDamageReceivers(_damageReceivers, this);
            if (IsOwner && IsPlayer)
            {
                OnChangeCurrentHealthInfo?.Invoke(CurrentHealth);
            }
        }
        
        private void StatsControllerOnOnStatsActivated()
        {

            List<float> healthValues = new List<float>();
            healthValues.Add(UnitComponents.StatsController.GetAllCurrentValueServerOnly(Stat.STAT_TYPE.HEALTH));

            float resultHealthValue;

            if (UnitComponents.AiUnit != null)
            {
                healthValues.Add(UnitComponents.AiUnit.EnemyDefinition.MaxHealth);
                resultHealthValue = healthValues.Sum() * UnitComponents.AiUnit.GlobalPowerMultiplier;
            }
            else
            {
                resultHealthValue = healthValues.Sum();
            }
        
            var healData = new HealData {amount = resultHealthValue };
            SetHealth(HealthType.Max, healData);
            SetHealth(HealthType.Current, healData);
            RestartHealthRegen();
            if (FNvHealthController != null)
            {
                FNvHealthController.ResetHealth();
            }
            Debug.Log($"{ClassName}[InitHealth] {gameObject.name} [{_currentHealth}/{_maxHealth}]");
            UnitComponents.StatsController.GetStatByType(Stat.STAT_TYPE.HEALTH).OnStatChangedServerOnly += OnHealthAffectingStatChanged;
            UnitComponents.StatsController.OnHealthRegenChanged += CalcHealthRegen;
            UnitComponents.StatsController.OnConstitutionChanged += ConstitutionChanged;
            UnitComponents.StatsController.OnStatsActivated -= StatsControllerOnOnStatsActivated;
        }

        private void OnDestroy()
        {
            //Debug.Log($"[FishnetInvectorHealthController][OnDestroy] {gameObject.name} destroyed");
            FNvProjectileControl.ClearColliderToNetId(this.ObjectId);
        }

        [Server]
        public void ResetHealth()
        {
            HealData healData = new HealData {amount = unit.UnitComps.StatsController.GetAllCurrentValueServerOnly(Stat.STAT_TYPE.HEALTH)};
            SetHealth(HealthType.Current, healData);
            if (IsDead) _isDead = false;
        }

        [Server]
        public void Ressurect(float targetHealth)
        {
            HealData healData = new HealData {amount = targetHealth};
            AddHealth(HealthType.Current, healData);
            _isDead = false;
        }

        [Server]
        public virtual void TakeDamage(vDamage damage)
        {
            if (IsDead)
                return;
            
            if (CheckIsPlayerRolling()) return;

            if (IsPlayer)
            {
                MusicController.PlayCombatMusic();
            }
            
            string logPrefix = ClassName + " [TakeDamage] ";
            Debug.Log($"{logPrefix}{damage.Sender.name} -> {gameObject.name} damage:{damage.damageValue}; type: {damage.type}", gameObject);
            var damageSenderObject = GetDamageSender(damage);
            if (damageSenderObject == null)
            {
                Debug.LogError($"{logPrefix} damageSenderObject is null");
                return;
            }
            NetworkConnection damagerConnection = GetDamageSender(damage).Owner;
            UnitComponents damagerUnit = UnitComponentsManager.GetUnitComponentsServerAndClient(damage.senderNetworkObjectID);
            
            if (damagerUnit.HealthController.IsPlayer)
            {
                TargetPlayCombatMusic(damagerConnection);
            }
            
            bool isAllyOnlyForPlayers = GameplayManager.Instance.RoomDetails.IsTeamsMode && GameplayManager.Instance.RoomDetails.IsAlly(damagerConnection, Owner);

            UpdateDamageSystem(damagerUnit, isAllyOnlyForPlayers);
            _damageSystem.TakeDamage(damage);
            
            int remainingDamage = damage.damageValue;
            if (-remainingDamage < float.Epsilon)
            {
                Debug.Log($"{logPrefix} OnTakeDamage({damage.damageValue}) invoke", gameObject);
                _lastDamageTaken = damage.ToFNvDamage();
                OnTakeDamage?.Invoke(damage);
            }
            _healthRecoveryDelay = CurrentHealth <= 0 ? 0 : _healthRecoveryDelay;
            
            if (CurrentHealth > 0 && !_isImmortal)
            {
                HealData healData = new HealData {abilityId = damage.abilityId, amount = -remainingDamage};
                // Reduce health:
                AddHealth(HealthType.Current, healData);
                if (_bloodController && damage.damageValue > MINIMAL_DAMAGE_TO_SHOW_DAMAGE_VFX)
                {
                    Vector3 hitPos = damage.hitPosition == Vector3.zero ? transform.position + Vector3.up * 1.5f : damage.hitPosition;
                    RpcPlayBloodEffect(hitPos);
                }
            }
            
            if (damage.IsShowDamage)
            {
                TargetShowDamageTextForDamageDealer(damagerConnection, damage.damageValue, damage.IsCriticalDamage);
            }
            Debug.Log($"{logPrefix}{gameObject.name} remainingDamage:{remainingDamage} damage:{damage.damageValue}", gameObject);

            // Restart health regeneration after taking damage
            RestartHealthRegen();
        }
        
        [TargetRpc]
        private void TargetPlayCombatMusic(NetworkConnection conn)
        {
            MusicController.PlayCombatMusic();
        }

        private int ArmorBehaviour(vDamage damage, int remainingDamage) {
            if (_armor != null) {
                remainingDamage = _armor.TakeHit(damage.damageValue);
                damage.damageValue = remainingDamage;
            }

            return remainingDamage;
        }

        private bool CheckIsPlayerRolling()
        {
            if (unit.UnitComps.InvectorManager != null)
            {
                if (unit.UnitComps.InvectorManager.ThirdPersonController.isRolling)
                    return true;
            }

            return false;
        }

        [ObserversRpc]
        public void RpcPlayBloodEffect(Vector3 pos)
        {
            InternalPlayBloodEffect(pos);
        }

        private void InternalPlayBloodEffect(Vector3 pos)
        {
            _bloodController.PlayBloodEffect(pos);
        }

        [ServerRpc(RequireOwnership = false)]
        public void CmdDealMeDamagePlease(FNvDamage fNvDamage, NetworkConnection senderConn = null)
        {
            vDamage damage = fNvDamage.ToVDamage();
            damage.Sender = transform;
            TakeDamage(damage);
        }

        [TargetRpc]
        public void TargetShowDamageTextForDamageDealer(NetworkConnection conn, float value, bool isCritical = false)
        {
            Debug.Log($"[FishnetInvectorHealthController][TargetShowDamageTextForDamageDealer] {gameObject.name} value:{value} isCritical:{isCritical}");
            if (isCritical)
            {
                _critDamagePrefab.Spawn(transform.position + Vector3.up * 1.25f, value, transform);
            }
            else
            {
                _damagePrefab.Spawn(transform.position + Vector3.up * 1.2f, value, transform);
            }
        }

        public static NetworkObject GetDamageSender(vDamage damage)
        {
            if (InstanceFinder.ServerManager.Objects.Spawned.ContainsKey(damage.senderNetworkObjectID))
                return InstanceFinder.ServerManager.Objects.Spawned[damage.senderNetworkObjectID];
            return null;
        }

        [Server]
        private void OnHealthAffectingStatChanged(float newValue)
        {
            HealData healData = new HealData {amount = newValue};
            if (newValue > MaxHealth)
            {
                healData = new HealData {amount = newValue};
                SetHealth(HealthType.Max, healData);
                
                float delta = newValue - MaxHealth;
                healData = new HealData {amount = CurrentHealth + delta};
                SetHealth(HealthType.Current, healData);
            }
            else
            {
                healData = new HealData {amount = newValue};
                if (CurrentHealth > newValue)
                {
                    SetHealth(HealthType.Current, healData);
                }
                SetHealth(HealthType.Max, healData);
            }
        }

        [Server]
        public void ConstitutionChanged(float value)
        {
            var healData = new HealData();
            var healthType = HealthType.Current;
            var currHealthValue = UnitComponents.StatsController.GetAllCurrentValueServerOnly(Stat.STAT_TYPE.HEALTH);
            healData.amount = (float)Math.Floor(currHealthValue);
            _maxHealth = healData.amount;
            SetHealth(healthType, healData);
        }

        [Server]
        public void SetHealth(HealthType type, HealData healData)
        {
            switch (type)
            {
                case HealthType.Current:
                    if (healData.amount > _maxHealth)
                    {
                        _currentHealth = _maxHealth;
                    }
                    else
                    {
                        _currentHealth = healData.amount;
                    }
                    break;
                case HealthType.Max:
                    if (FNvHealthController != null)
                    {
                        FNvHealthController.maxHealth = (int)healData.amount;
                    }
                    _maxHealth = healData.amount;
                    break;
                case HealthType.Regen:
                    _currentHealth = healData.amount;
                    break;
            }
        }

        [Server]
        public void AddHealth(HealthType type, HealData healData, bool isShowBattleText = true)
        {
            float typeAmount = 0;
            float maxAmount = 0;

            switch (type)
            {
                case HealthType.Current:
                    typeAmount = CurrentHealth;
                    maxAmount = MaxHealth;
                    break;
                case HealthType.Max:
                    typeAmount = MaxHealth;
                    maxAmount = float.MaxValue;
                    break;
                case HealthType.Regen:
                    typeAmount = CurrentHealth;
                    maxAmount = MaxHealth;
                    break;
            }

            if (healData.amount > float.Epsilon && isShowBattleText && type != HealthType.Regen && !healData.isHideText)
                TargetShowHealingTextForOwner(NetworkObject.Owner, healData);

            float newHealth = typeAmount + healData.amount;
            float clampedHealth = Mathf.Clamp(newHealth, .0f, maxAmount);
            healData.amount = clampedHealth;
            SetHealth(type, healData);
        }

        public Action<HealData> OnHeal;

        public struct HealData
        {
            public int abilityId;
            public int senderNetId;
            public float amount;
            public bool isHideText;
        }
        
        [TargetRpc]
        private void TargetShowHealingTextForOwner(NetworkConnection conn, HealData healData)
        {
            OnHeal?.Invoke(healData);
            //_healPrefab.Spawn(transform.position + Vector3.up * 1.2f, value, transform);
        }

        private void OnMaxHealthChange(float prev, float next, bool asServer)
        {
            OnHealthChanged?.Invoke(this, HealthType.Max, next);
            OnMineHealthChanged?.Invoke(HealthType.Max, next);
        }

        private void OnIsDeadChanged(bool prev, bool isDead, bool asServer)
        {
            if (isDead)
            {
                if (asServer)
                {
                    AddXpToKiller();
                }
                
                OnDead?.Invoke(LastDamageTaken.ToVDamage());
                TurnOffColliders();
            }
            else
            {
                OnRessurect?.Invoke();
                TurnOnColliders();
            }
        }
        
        private void OnCurrentHealthChange(float prev, float next, bool asServer)
        {
            OnHealthChanged?.Invoke(this, HealthType.Current, next);
            OnMineHealthChanged?.Invoke(HealthType.Current, next);
            if (asServer)
            {
                if (IsDead)
                {
                    if (CurrentHealth > float.Epsilon)
                    {
                        _isDead = false;
                    }
                }
                else
                {
                    if (CurrentHealth < float.Epsilon)
                    {
                        _isDead = true;
                    }
                }
            }
            else
            {
                if (next < prev)
                {
                    DebugWrite.Log($"[FishnetInvectorHealthController][OnCurrentHealthChange] {gameObject.name} HP prev:{prev} next:{next}; CurrentHealth: {CurrentHealth}");
                    if (!IsHost)
                        OnTakeDamage?.Invoke(LastDamageTaken.ToVDamage());
                }

                if (IsOwner)
                {
                    OnChangeCurrentHealthInfo?.Invoke(next);
                }
            }
        }

        [Server]
        public void CalcHealthRegen(float amount)
        {
            HEALTH_REGEN_AMOUNT = amount;
        }

        private void RestartHealthRegen()
        {
            if (_healthRegenCoroutine != null)
            {
                StopCoroutine(_healthRegenCoroutine);
            }
            _healthRegenCoroutine = StartCoroutine(HealthRegenCoroutine());
        }

        private IEnumerator<YieldInstruction> HealthRegenCoroutine()
        {
            yield return new WaitForSeconds(_healthRecoveryDelay);

            while (!IsDead && CurrentHealth < MaxHealth)
            {
                HealData healData = new HealData { amount = HEALTH_REGEN_AMOUNT };
                AddHealth(HealthType.Regen, healData);
                yield return new WaitForSeconds(HEALTH_REGEN_INTERVAL);
            }
        }

        public UnityEvent<string> onValueChanged;
        
        public void UpdateTextInfo(string newText)
        {
            onValueChanged?.Invoke(newText);
        }
        
        public void TurnOnColliders()
        {
            OnCollidersChanged?.Invoke(true);
            SwitchColliders(true);
        }

        private void TurnOffColliders() {
            OnCollidersChanged?.Invoke(false);
            SwitchColliders(false);
        }

        private void SwitchColliders(bool isOn)
        {
            for (int i = 1; i < _damageReceivers.Length; i++)
            {
                Debug.Log($"[FishnetInvectorHealthController][SwitchColliders] {gameObject.name}", gameObject);
                if (_damageReceivers[i] != null)
                {
                    _damageReceivers[i].enabled = isOn;
                }
            }
        }

        private static Dictionary<int, FNXpController> _xpControllers;

        private FNXpController GetXpControllerByNetId(int netId)
        {
            if (_xpControllers == null)
            {
                _xpControllers = new Dictionary<int, FNXpController>();
            }

            if (!_xpControllers.ContainsKey(netId))
            {
                _xpControllers.Add(netId,
                    InstanceFinder.ServerManager.Objects.Spawned[netId].GetComponent<FNXpController>());
            }

            return _xpControllers[netId];
        }

        [Server]
        protected virtual void AddXpToKiller()
        {
            if (LastDamageTaken == null)
            {
                Debug.LogError($"{ClassName}[AddXpToKiller] LastDamageTaken is null");
                return;
            }
            int damageSenderId = LastDamageTaken.senderNetworkObjectId;
            if (damageSenderId == ObjectId)
                return;
            
            var killerXpController = UnitComponentsManager.GetUnitComponentsServerAndClient(damageSenderId).XpController;
            if (killerXpController == null)
                return;
            if (killerXpController.gameObject.CompareTag("Enemy"))
                return;
            
            var targetStatsController = UnitComponentsManager.GetUnitComponentsServerAndClient(NetworkObject.ObjectId)
                .StatsController;
            float xpAmount = (float)targetStatsController.CalculatedXpReward();
            
            killerXpController.AddXpToThisUnitObjectIDsTeam(xpAmount);
        }

        public void AssignDamageReceivers(Collider[] colliders) {
            _damageReceivers = colliders;
        }

        [Server]
        public void Heal(HealData healData)
        {
            Debug.Log($"{ClassName}[Heal] {gameObject.name} amount:{healData.amount}");
            AddHealth(HealthType.Current, healData);
        }

        [ServerRpc(RequireOwnership = false)] 
        public void CmdRegisterMeleeHitDamage(FNvDamage fnvDamage)
        {
            string logText = $"{ClassName} CmdRegisterDamage SwingCounter: {fnvDamage.SwingCounter}; inputDamage: {fnvDamage.damageValue}";
            vDamage damage = fnvDamage.ToVDamage();
            TakeDamage(damage);
            Debug.Log(logText);
        }
        
        [ServerRpc(RequireOwnership = false)]
        public void CmdRegisterHitByAI(int npcObjectId, int bodyMemberId, Vector3 hitPosition, NetworkConnection sender = null)
        {
            Debug.Log($"{ClassName} RegisterHitByAI AI id: {npcObjectId}; targetUnitId: {NetworkObject.ObjectId}; hitPosition: {hitPosition}; sender: {sender}");
            var dealerUnitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(npcObjectId);
            var damageDealingSource = dealerUnitComps.MeleeManager.Members[bodyMemberId].attackObject;
            vDamage damage = new vDamage();
            damage.Copy(damageDealingSource.damage);
            damage.hitPosition = hitPosition;
            damage.Sender = dealerUnitComps.MeleeManager.transform;
            damage.senderNetworkObjectID = npcObjectId;
            TakeDamage(damage);
        }

        [Server]
        public void SetImmortal(bool b)
        {
            _isImmortal = b;
        }
    }
} 

 # SOLUTION: // Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Ability.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using DuloGames.UI;
using FishNet;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using Invector;
using UnityEngine;
using UnityEngine.Assertions;
using Unity.Jobs;
using Unity.Collections;

[Serializable]
public class Ability: NetworkBehaviour
{
    protected int _rank;
    [SerializeField] protected AbilityDefinition _abilityDefinition;
    public Buff Buff => _buff;
    [SerializeField] protected Buff _buff;
    [SerializeField] protected bool isPassiveSkill;
    public static Dictionary<NetworkConnection, uint> StacksCounter { get; private set; } = new ();
    public static Dictionary<NetworkConnection, uint> RankCounter { get; private set; } = new ();
    public AbilityDefinition AbilityDefinition => _abilityDefinition;
    public static Action OnAbilityLearned;
    public Action<NetworkConnection, byte, uint> OnRankLevelUp;
    protected string _abilityName => _abilityDefinition.Name;
    protected GameplayManager _gameplayManager;
    protected bool _isDebug = true;
    protected readonly string COLOR_DURATION = "#00F0FF";
    protected readonly string COLOR_AFFECTING_STAT = "#00F0FF";
    protected readonly string COLOR_DAMAGE = "#ff3517";
    protected readonly string COLOR_HEAL = "#0ec949";
    protected readonly string COLOR_STAT = "#96e33d";
    protected readonly string COLOR_XP = "#c3eb34";
    protected readonly string COLOR_COOLDOWN = "#c8e609";

    protected readonly Color DEBUG_SPHERE_DEFAULT_COLOR = new Color(1f, 0f, 0f, 0.5f);
    protected readonly Color DEBUG_SPHERE_ACTIVATE_COLOR = new Color(1f, 0f, 1f, 0.5f);
    protected Color _debugSphereColor;
    protected bool _showDebugSphere;
    protected Vector3 _debugSpherePos;
    protected float _debugSphereRadius = 1f;

    public override void OnStartServer()
    {
        base.OnStartServer();
        InstanceFinder.TimeManager.OnTick += OnServerTick;
    }

    public override void OnStartClient()
    {
        base.OnStartClient();
        InstanceFinder.TimeManager.OnTick += OnClientTick;
    }

    protected virtual void OnServerTick() { }

    protected virtual void OnClientTick() { }

    public override void OnStopServer()
    {
        base.OnStopServer();
        InstanceFinder.TimeManager.OnTick -= OnServerTick;
    }

    public override void OnStopClient()
    {
        base.OnStopClient();
        InstanceFinder.TimeManager.OnTick -= OnClientTick;
    }

    public virtual void InitAbility()
    {
        if (_buff != null) 
        {
            _buff.Init(GameplayManager.Instance);
        }
        else
        {
            Debug.LogWarning($"Buff is null during ability {_abilityName} initialization.");
        }
    }

    public virtual float CalculateValueBasedOnStacks(uint stacks) => .01f;
    
    public virtual int CalculateRankBasedOnStacks(uint stacks) => 1;
    
    public virtual float CalculateDamageBasedOnRank(int rank) => 1;
    
    public virtual uint GetStacksForRank() => 1;
    
    public uint AddRank(NetworkConnection connection)
    {
        if (RankCounter.ContainsKey(connection))
        {
            RankCounter[connection]++;
        }
        else
        {
            RankCounter.Add(connection, 1);
        }
        OnRankLevelUp?.Invoke(connection, _abilityDefinition.Id, RankCounter[connection]);
        return RankCounter[connection];
    }

    public uint ServerAddStack(FNAbilityController abilityController, uint amount)
    {
        if (!abilityController.LearnedAbilityDict.ContainsKey(AbilityDefinition.Id))
        {
            Debug.LogError($"Ability {AbilityDefinition.Name} is not learned by player {abilityController.gameObject.name}. Cannot add stacks.");
            return 0;
        }
        
        AbilityInfo targetsAbilityStats = abilityController.LearnedAbilityDict[AbilityDefinition.Id];
        targetsAbilityStats.Stacks = Math.Max(0, targetsAbilityStats.Stacks + amount);
        abilityController.AddOrSetAbility(targetsAbilityStats);
        return targetsAbilityStats.Stacks;
    }
    
    public uint AddStack(NetworkConnection connection)
    {
        if (StacksCounter.ContainsKey(connection))
        {
            StacksCounter[connection]++;
        }
        else
        {
            StacksCounter.Add(connection, 1);
        }
        
        if (EnoughStacksToLevelup(connection))
        {
            StacksCounter[connection] = 0;
            AddRank(connection);
            return 1;
        }
        else
        {
            return 0;
        }
        
        return StacksCounter[connection];
    }
    
    public UISpellInfo GetUISpellInfo(byte abilityId, uint stacks)
    {
        UISpellInfo spellInfo = new UISpellInfo();
        spellInfo.ID = _abilityDefinition.Id;
        uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId);
        int abilityRankBasedOnStacks = CalculateRankBasedOnStacks(abilityStacksForPlayer);
        spellInfo.Name = GetAbilityName(abilityRankBasedOnStacks);
        spellInfo.Icon = _abilityDefinition.Icon;
        spellInfo.Description = GetAbilityDescription(abilityRankBasedOnStacks, abilityStacksForPlayer);
        if (_abilityDefinition.IsPassive)
        {
            spellInfo.Flags = UISpellInfo_Flags.Passive;
        }
        else
        {
            AbilityDefinition.RPGAbilityRankData rankData = _abilityDefinition.RanksDatas[0];

            if (rankData != null)
            {
                switch (rankData.activationType)
                {
                    case AbilityDefinition.AbilityActivationType.Instant:
                        spellInfo.Flags = UISpellInfo_Flags.InstantCast;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCircle:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCircle;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCone:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCone;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedAim:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastAim;
                        break;
                    default:
                        spellInfo.Flags = UISpellInfo_Flags.PowerCostInPct;
                        break;

                }

                spellInfo.Range = rankData.maxRange;
                spellInfo.Cooldown = rankData.cooldown;

                if (UnitComponentsManager.GetAllPlayersHeroes().Count != 0)
                {
                    var nob = UnitComponentsManager.GetAllPlayersHeroes().First();
                    var unit = UnitComponentsManager.GetUnitComponents(nob);

                    if (GetAbilityCastingTime(0, unit.StatsController) > 0)
                    {
                        spellInfo.CastTime = GetAbilityCastingTime(0, unit.StatsController);
                    }
                }

                spellInfo.PowerCost = rankData.manaCost;
            }
            else
            {
                Debug.LogError($"Ability {spellInfo.Name} does not have rank {abilityId}. Setting default values.");
            }
        }
        return spellInfo;
    }

    private bool EnoughStacksToLevelup(NetworkConnection connection)
    {
        return StacksCounter[connection] >= GetStacksForRank();
    }

    public virtual string GetAbilityName(int rank) => _abilityDefinition.Name;
    public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description;
    public virtual string GetAbilityDescription(int rank, FNStatsController statsController) => _abilityDefinition.persistDescription;
    
    public virtual float GetAbilityCastingTime(int rank, FNStatsController statsController)
    {
        CombatEntityStat entityStat = statsController.GetStatByType(Stat.STAT_TYPE.HASTE);
        var value = entityStat.GetCurrentAmount();
        var defaultCastTime = _abilityDefinition.RanksDatas[rank].castTime;
        var castingTime = defaultCastTime * (1 / (1 + value));

        return castingTime;
    }

    public virtual IEnumerator Activate(AbilityCastingData data)
    {
        yield return null;
    }

    [Server]
    protected virtual void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f)
    {
        Debug.Log($"{_abilityName} Applying caster buff.");
        _buff.Activate(casterBuffData, new int[]{}, duration:duration);
    }
    
    [Server]
    public virtual void CasterRemoveBuff(Buff.BuffData casterBuffData)
    {
        Debug.Log($"{_abilityName} Removing caster buff.");
        _buff.RemoveBuff(casterBuffData.ObjectId, casterBuffData.ObjectId);
    }

    protected virtual List<Collider> TargetsSelection(Transform caster) 
    {
        Debug.LogWarning($"{_abilityName} TargetsSelection method has not been implemented yet.");
        throw new NotImplementedException();
    }

    [Server]
    protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage, bool isExcludeSelf = false)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        var targets = TargetsInSphereSelection(playerComps, radius);
        for (int i = 0; i < targets.Count; i++) 
        {
            if (isExcludeSelf && targets[i] == playerComps.HealthController)
            {
                continue;
            }
            damage.receiver = targets[i].transform;
            targets[i].TakeDamage(damage);

            Debug.Log($"[{_abilityDefinition.Name}] Damage applied to {targets[i].name}");
        }
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, Buff.BuffData caster, float radius)
    {
        //Debug.Log($"{_abilityName} Selecting targets in sphere.");
        List<FishnetInvectorHealthController> targets = EnemyTargetsInRadius(pos, caster, radius);
        //Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");
        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsExcludingTagsInSphereSelection(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = TargetsInRadiusExcludingTags(tags, pos, caster, radius);
        return targets;
    }
    
    public static List<FishnetInvectorHealthController> TargetsInRadiusExcludingTags(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        NativeArray<JobHandle> jobHandles = new NativeArray<JobHandle>(GameplayManager.Instance.UnitCharacters.Count, Allocator.Temp);
        for (int i = 0; i < GameplayManager.Instance.UnitCharacters.Count; i++)
        {
            int index = i;
            jobHandles[index] = new IsWithinRangeJob()
            {
                pos = pos,
                radiusSquared = radius * radius,
                targetPosition = GameplayManager.Instance.UnitCharacters[index].transform.position,
            }.Schedule();
        }
        JobHandle.CompleteAll(jobHandles);
        jobHandles.Dispose();
        
        return targets;
    }

    public struct IsWithinRangeJob : IJob
    {
        public Vector3 pos;
        public float radiusSquared;
        public Vector3 targetPosition;
        
        public void Execute()
        {
            float distSquared = (targetPosition - pos).sqrMagnitude;
            if (distSquared < radiusSquared)
            {
                
            }
        }
    }

    public static bool IsAlly(UnitComponents caster, UnitComponents target)
    {
        bool isCasterPlayer = caster.HealthController.CompareTag(GameplayManager.TAG_PLAYER);
        bool isTargetPlayer = target.HealthController.CompareTag(GameplayManager.TAG_PLAYER);
        bool isCasterEnemy = false;
        bool isTargetEnemy = false;
        for (int i = 0; i < GameplayManager.SERVER_AI_CONTROLLED_TAGS.Length; i++)
        {
            if (caster.HealthController.CompareTag(GameplayManager.SERVER_AI_CONTROLLED_TAGS[i]))
            {
                isCasterEnemy = true;
            }
            if (target.HealthController.CompareTag(GameplayManager.SERVER_AI_CONTROLLED_TAGS[i]))
            {
                isTargetEnemy = true;
            }
        }
        
        if (isCasterPlayer && isTargetEnemy)
        {
            return false;
        }else if (isCasterEnemy && isTargetPlayer)
        {
            return false;
        }else if (isCasterEnemy && isTargetEnemy)
        {
            return true;
        }else if (isCasterPlayer && isTargetPlayer)
        {
            if (caster == target)
                return true;
            
            if (GameplayManager.Instance.RoomDetails.IsTeamsMode)
            {
                var teamClientInstancesMembers = GameplayManager.Instance.RoomDetails.GetActiveClientsFromSameTeam(caster.NetworkObject);
                if (teamClientInstancesMembers.Contains(target.Owner))
                {
                    return true;
                }
            }
            else
            {
                return false;
            }
        }

        return false;
    }

    public static List<FishnetInvectorHealthController> EnemyTargetsInRadius(Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            Buff.BuffData targetData = new Buff.BuffData(targetComps.HealthController.ObjectId, targetComps.HealthController.gameObject.tag, 0f, caster.abilityId, 0, null, null, 0);
            if (IsNotValidTargetEnemy(caster, targetData))
                continue;
            
            targets.Add(targetComps.HealthController);
        }

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsInSphereSelection(UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var target in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(target).NetworkObject;
            if (CommonMath.Math.IsWithinRange(caster.HealthController.transform.position, targetNob.transform.position, radius))
            {
                var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(target);
                targets.Add(targetComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> CorrectTargetsInSphereSelection(UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        var targets = TargetsInSphereSelection(caster, radius);
        
        foreach (var target in targets)
        {
            if (!IsCorrectTarget(_rank, caster, target.UnitComponents))
            {
                targets.Remove(target);
            }
        }
        
        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [ObserversRpc]
    protected void RpcShowEffectForObservers(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect for observers.");

        GameplayManager.Instance.StartCoroutine(ShowEffectOnTarget(targetNetId, abilityId, rank, timeout));
    }
    
    protected virtual IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if(targetComps == null)
        {
            Debug.LogError($"{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        List<GameObject> effects = new List<GameObject>(); 
        foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints)
        {
            Assert.IsNotNull(_abilityDefinition.RanksDatas[rank].hitEffect, $"Hit effect is null for {_abilityName}.");
            Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint);
            GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position + Vector3.up, Quaternion.identity, GameplayManager.Instance.transform);
            effect.transform.SetParent(pointTransform);
            effects.Add(effect);
        }

        yield return new WaitForSeconds(timeout);
        foreach (var effect in effects)
        {
            Destroy(effect, timeout);
        }
    }
    
    public static bool IsNotValidTargetEnemy(Buff.BuffData casterData, Buff.BuffData targetData)
    {
        if (casterData.ObjectId == targetData.ObjectId)
        {
            return true;
        }

        int casterTeam = GameplayManager.Instance.GetUnitTeamId(casterData.ObjectId);
        int targetTeam = GameplayManager.Instance.GetUnitTeamId(targetData.ObjectId);
        if (casterData.Tag == GameplayManager.TAG_PLAYER)
        {
            if (casterTeam == targetTeam)
            {
                return true;
            }
            return false;
        }else if (targetData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
        {
            if (casterData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
            {
                return true;
            }
            return false;
        }

        return false;
    }

    protected bool IsNotValidTargetEnemy(UnitComponents target, UnitComponents caster)
    {
        //Debug.Log($"{_abilityName} Checking if target is valid.");
        if (target == null)
            return true;
        
        if (target == caster)
        {
            //Debug.Log($"{_abilityName} Target is the same as caster. Invalid target.");
            return true;
        }

        var targetHealthController = target.HealthController;
        if (targetHealthController == null)
        {
            return true;
        }
        if (targetHealthController.CompareTag(GameplayManager.TAG_PLAYER))
        {
            //Debug.Log($"{_abilityName} Target is a player. Valid target.");
            return false;
        }else if (targetHealthController.CompareTag("Enemy"))
        {
            //Debug.Log($"{_abilityName} Target is an enemy. Valid target.");
            if (caster.HealthController.CompareTag("Enemy"))
            {
                return true;
            }
            return false;
        }

        //Debug.Log($"{_abilityName} Target does not have a Player or Enemy tag. Invalid target.");

        return false;
    }
    
    protected void DrawDebugSphere(Vector3 pos, float radius)
    {
        _debugSpherePos = pos;
        _debugSphereRadius = radius;
        _showDebugSphere = true;
        _debugSphereColor = DEBUG_SPHERE_ACTIVATE_COLOR;
        StartCoroutine(ResetDebugSphereColorAfterDelay(0.3f));
    }
    
    protected IEnumerator ResetDebugSphereColorAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        _debugSphereColor = DEBUG_SPHERE_DEFAULT_COLOR;
        _showDebugSphere = false;
    }
    
    public virtual float CalcAmount(FNStatsController statsController) {
        return 1f;
    }
    
    public virtual float CalcDuration(FNStatsController statsController) {
        return 1f;
    }
    
    public bool IsCorrectTarget(int rank, UnitComponents caster, UnitComponents target)
    {
        if (AbilityDefinition.RanksDatas[rank].CanHitSelf)
        {
            if (caster == target)
                return true;
        }
        bool isAlly = IsAlly(caster, target);
        
        if (AbilityDefinition.RanksDatas[rank].CanHitEnemy)
        {
            if (!isAlly)
            {
                return true;
            }
        }

        if (AbilityDefinition.RanksDatas[rank].CanHitAlly)
        {
            if (isAlly)
            {
                return true;
            }
        }
        
        return true;
    }

    public NetworkConnection[] FindNearbyPlayers(Vector3 casterTransformPosition, float distanceSquared)
    {
        var playerHeroes = UnitComponentsManager.GetAllPlayersHeroes();
        List<NetworkConnection> connections = new List<NetworkConnection>();
        foreach (var hero in playerHeroes)
        {
            if (Vector3.SqrMagnitude(hero.transform.position - casterTransformPosition) < distanceSquared)
            {
                connections.Add(hero.Owner);
            }
        }
        return connections.ToArray();
    }

    public class VfxOnClientData/* 48 bytes */
    {
        public Vector3 forwardDirection;/* 3×4=12 bytes */
        public Vector3 waveStartPosition;/* 3×4=12 bytes */
        public Quaternion rotation;/* 4×4=16 bytes */
        public float duration;/*  4 bytes */
        public int rank;/*  4 bytes */

        public VfxOnClientData(){}
        
        public VfxOnClientData(Vector3 forwardDirection, Vector3 waveStartPosition, Quaternion rotation, float duration, int rank)
        {
            this.forwardDirection = forwardDirection;
            this.waveStartPosition = waveStartPosition;
            this.rotation = rotation;
            this.duration = duration;
            this.rank = rank;
        }
    }

    public class VfxParticle
    {
        public int senderId;
        public int rank;
        public Transform transform;
        public ColliderInvoker collider;
        public Vector3 startPosition;
        public Vector3 endPosition;
        public float duration;
        public double elapsedTime;
        public List<FishnetInvectorHealthController> alreadyDamaged = new ();
        
        public VfxParticle(int senderId, int rank, Transform transform, ColliderInvoker collider, Vector3 startPosition, Vector3 endPosition, float duration, double elapsedTime, List<FishnetInvectorHealthController> alreadyDamaged)
        {
            this.senderId = senderId;
            this.transform = transform;
            this.collider = collider;
            this.startPosition = startPosition;
            this.endPosition = endPosition;
            this.duration = duration;
            this.elapsedTime = elapsedTime;
            this.alreadyDamaged = alreadyDamaged;
            this.rank = rank;
        }
    }

#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        if (_showDebugSphere)
        {
            Gizmos.color = _debugSphereColor;
            Gizmos.DrawSphere(_debugSpherePos, _debugSphereRadius);
        }
    }
#endif
} # VALIDATION: INVALID. 
Explanation: The `IsWithinRangeJob` is still missing the logic to handle the `caster` parameter and to filter targets based on whether they are allies or enemies. Also, the `TargetsExcludingTagsInSphereSelection` should be filtering targets based on tags, but the job is not checking for that. Lastly, the job should not be adding items directly to the `targets` list, as it can lead to race conditions. A better approach would be to use a `NativeList` to store the results inside the job and then copy them to the `targets` list after the job has completed.