using UnityEngine;
using UnityEditor;
using System.IO;
using System;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Sanat.CodeGenerator
{
    public static class BackupManager
    {
        public const string BACKUP_FOLDER_NAME = "ScriptBackups";
        public const string BACKUP_ROOT = "Assets/Sanat/CodeGenerator";
        private const string BACKUP_FOLDER = BACKUP_ROOT + "/" + BACKUP_FOLDER_NAME + "/Files/";
        private const string BACKUP_META_FOLDER = BACKUP_ROOT + "/" + BACKUP_FOLDER_NAME + "/Meta/";
        private const int MAX_BACKUPS_PER_FILE = 10;

        public static void BackupScriptFile(string filePath, string content)
        {
            try
            {
                EnsureBackupFoldersExist();
                CleanupOldBackups(filePath);
                CreateBackup(filePath, content);
            }
            catch (Exception ex)
            {
                Debug.LogError($"Failed to create backup for {filePath}: {ex.Message}");
            }
        }

        private static void EnsureBackupFoldersExist()
        {
            if (!AssetDatabase.IsValidFolder($"{BACKUP_ROOT}/{BACKUP_FOLDER_NAME}"))
                AssetDatabase.CreateFolder($"{BACKUP_ROOT}", $"{BACKUP_FOLDER_NAME}");

            if (!AssetDatabase.IsValidFolder(BACKUP_FOLDER.TrimEnd('/')))
                AssetDatabase.CreateFolder($"{BACKUP_ROOT}/{BACKUP_FOLDER_NAME}", "Files");

            if (!AssetDatabase.IsValidFolder(BACKUP_META_FOLDER.TrimEnd('/')))
                AssetDatabase.CreateFolder($"{BACKUP_ROOT}/{BACKUP_FOLDER_NAME}", "Meta");
        }

        private static void CleanupOldBackups(string filePath)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string[] existingBackups = Directory.GetFiles(BACKUP_FOLDER, $"{fileName}_Backup_*.txt")
                .OrderByDescending(f => f)
                .ToArray();

            if (existingBackups.Length >= MAX_BACKUPS_PER_FILE)
            {
                for (int i = MAX_BACKUPS_PER_FILE - 1; i < existingBackups.Length; i++)
                {
                    string backupPath = existingBackups[i];
                    string metaPath = Path.Combine(BACKUP_META_FOLDER,
                        Path.GetFileNameWithoutExtension(backupPath) + ".asset");

                    if (File.Exists(backupPath))
                        File.Delete(backupPath);

                    if (File.Exists(metaPath))
                        AssetDatabase.DeleteAsset(metaPath);
                }
            }
        }

        private static void CreateBackup(string filePath, string content)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
            string backupFileName = $"{timestamp}_Backup_{fileName}";

            ScriptFileBackup backup = ScriptableObject.CreateInstance<ScriptFileBackup>();
            backup.filePath = filePath;
            backup.dateTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            backup.content = content;
            backup.version = GetFileVersion(filePath);
            backup.comment = "Automatic backup before code generation";
            backup.modifiedBy = Environment.UserName;
            backup.originalHash = CalculateHash(content);
            backup.backupType = "AutoGenerated";

            string metaPath = $"{BACKUP_META_FOLDER}{backupFileName}.asset";
            string backupPath = $"{BACKUP_FOLDER}{backupFileName}.txt";

            File.WriteAllText(backupPath, content);
            AssetDatabase.CreateAsset(backup, metaPath);

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }

        private static string GetFileVersion(string filePath)
        {
            if (File.Exists(filePath))
            {
                var fileInfo = new FileInfo(filePath);
                return $"{fileInfo.LastWriteTime:yyyyMMdd}.{DateTime.Now.ToString("HHmmss")}";
            }

            return "1.0.0";
        }

        private static string CalculateHash(string content)
        {
            using (var sha256 = SHA256.Create())
            {
                var contentBytes = Encoding.UTF8.GetBytes(content);
                var hashBytes = sha256.ComputeHash(contentBytes);
                return BitConverter.ToString(hashBytes).Replace("-", "");
            }
        }
    }
}