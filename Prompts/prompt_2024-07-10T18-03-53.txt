# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
# CODE: // Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_DoorCategories\SGFT_GameController.cs:
 using System.Collections;
using System.Collections.Generic;
using DungeonArchitect;
using UnityEngine;

public class SGFT_GameController : MonoBehaviour
{
    public Dungeon dungeon;
    
    void Start()
    {
        if (dungeon != null)
        {
            dungeon.Build();
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_Snap_Query\DoorTracker.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect.Builders.Snap;

public class DoorTracker : MonoBehaviour
{
    public SnapQuery snapQuery;

    void OnDrawGizmosSelected()
    {
        var position = transform.position;
        SnapQueryModuleInfo moduleInfo;
        if (snapQuery.GetModuleInfo(position, out moduleInfo))
        {
            var bounds = moduleInfo.instanceInfo.WorldBounds;
            DrawGizmoBounds(bounds, Color.red);

            var incomingDoors = snapQuery.GetModuleIncomingDoors(position);
            foreach (var incomingDoor in incomingDoors)
            {
                var doorRenderer = incomingDoor.GetComponent<Renderer>();
                if (doorRenderer != null)
                {
                    DrawGizmoBounds(doorRenderer.bounds, Color.green);
                }
            }

            var outgoingDoors = snapQuery.GetModuleOutgoingDoors(position);
            foreach (var outgoingDoor in outgoingDoors)
            {
                var doorRenderer = outgoingDoor.GetComponent<Renderer>();
                if (doorRenderer != null)
                {
                    DrawGizmoBounds(doorRenderer.bounds, Color.cyan);
                }
            }

        }
    }

    void DrawGizmoBounds(Bounds bounds, Color color)
    {
        Gizmos.color = color;
        Gizmos.DrawWireCube(bounds.center, bounds.size + new Vector3(0.1f, 0.1f, 0.1f));
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\DungeonConfigEditors.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.GridFlow;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors
{
    //[CustomEditor(typeof(DungeonConfig), true)]
    public abstract class DungeonConfigEditorBase : DAInspectorBase
    {
        protected abstract string Title { get; }

        
        public override void OnInspectorGUI()
        {
            sobject.Update();

            DrawHeader(Title, false);
            using (new EditorGUI.IndentLevelScope())
            {
                DrawProperty("Seed");
                DrawConfigProperties();
            }
            
            DrawExtraConfigProperties();

            InspectorNotify.Dispatch(sobject, target);
        }

        protected abstract void DrawConfigProperties();
        protected abstract void DrawExtraConfigProperties();
    }
    
    [CustomEditor(typeof(GridFlowDungeonConfig), true)]
    public class GridFlowDungeonConfigEditor : DungeonConfigEditorBase
    {
        protected override string Title => "Grid Flow Dungeon";
        protected override void DrawConfigProperties()
        {
            DrawProperties("flowAsset", "gridSize", "numGraphRetries", "Mode2D");
        }

        protected override void DrawExtraConfigProperties()
        {
            DrawHeader("Advanced");
            using (new EditorGUI.IndentLevelScope())
            {
                DrawProperty("flipEdgeWalls");
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\DungeonNavMeshEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using SVector3 = SharpNav.Geometry.Vector3;
using PolyMesh = SharpNav.PolyMesh;
using DungeonArchitect.Navigation;

namespace DungeonArchitect.Editors
{
	[CustomEditor(typeof(DungeonNavMesh))]
	public class DungeonNavMeshEditor : Editor
	{
		SerializedObject sobject;
		SerializedProperty agentHeight;
		SerializedProperty agentRadius;
		SerializedProperty agentClimbHeight;
		SerializedProperty cellSize;
		SerializedProperty maxCrowdAgents;
		SerializedProperty visualize2D;

		public void OnEnable()
		{
			sobject = new SerializedObject(target);
			agentHeight = sobject.FindProperty("agentHeight");
			agentRadius = sobject.FindProperty("agentRadius");
			agentClimbHeight = sobject.FindProperty("agentClimbHeight");
			cellSize = sobject.FindProperty("cellSize");
			maxCrowdAgents = sobject.FindProperty("maxCrowdAgents");
			visualize2D = sobject.FindProperty("visualize2D");

			var navMesh = target as DungeonNavMesh;
			navMesh.SetNavMeshVisible(true);
		}

		public void OnDisable()
		{
			var navMesh = target as DungeonNavMesh;
			navMesh.SetNavMeshVisible(false);
		}

		public override void OnInspectorGUI()
		{
			sobject.Update();
			GUILayout.Label("Dungeon Nav Mesh Builder", EditorStyles.boldLabel);
			EditorGUILayout.PropertyField(agentHeight);
			EditorGUILayout.PropertyField(agentRadius);
			EditorGUILayout.PropertyField(agentClimbHeight);
			EditorGUILayout.PropertyField(cellSize);
			EditorGUILayout.PropertyField(maxCrowdAgents);
			EditorGUILayout.PropertyField(visualize2D);

			agentHeight.floatValue = Mathf.Max(0, agentHeight.floatValue);
			agentRadius.floatValue = Mathf.Max(0, agentRadius.floatValue);
			agentClimbHeight.floatValue = Mathf.Max(0, agentClimbHeight.floatValue);
			cellSize.floatValue = Mathf.Max(0.01f, cellSize.floatValue);
			maxCrowdAgents.intValue = Mathf.Max(0, maxCrowdAgents.intValue);

			if (GUILayout.Button("Build Nav Mesh"))
			{
				BuildNavMesh();
			}

			sobject.ApplyModifiedProperties();
		}

		void BuildNavMesh()
		{
			var navMesh = target as DungeonNavMesh;
			navMesh.Build();

			/*
			// Since this is called from the editor, save the nav mesh on to the disk 
			var scenePath = EditorApplication.currentScene;
			if (scenePath == null || scenePath.Length == 0) {
				Debug.Log ("Save the scene and rebuild to serialize the nav mesh");
			} else {
				var file = new FileInfo(scenePath);
				var name = Path.GetFileNameWithoutExtension(file.Name);
	
				var navName = file.Directory.FullName + Path.DirectorySeparatorChar + name + "_Navigation.asset";
				var graph = ScriptableObject.CreateInstance<Graph>();
				AssetDatabase.CreateAsset(graph, navName);
	            Debug.Log ("Saved navmesh to: " + navName);
			}
			*/
		}

		Vector3 ToV3(SharpNav.PolyVertex v)
		{
			return new Vector3(v.X, v.Y, v.Z);
		}

		void OnSceneGUI()
		{
			var navMesh = target as DungeonNavMesh;
			var polyMesh = navMesh.PolyMesh;
			if (polyMesh == null) return;
			var polyScale = new Vector3(polyMesh.CellSize, polyMesh.CellHeight, polyMesh.CellSize);
			var polyTrans = new Vector3(polyMesh.Bounds.Min.X, polyMesh.Bounds.Min.Y, polyMesh.Bounds.Min.Z);

			var color = new Color(0, 0, 0, 1);
			for (int i = 0; i < polyMesh.PolyCount; i++)
			{
				for (int j = 0; j < polyMesh.NumVertsPerPoly; j++)
				{
					if (polyMesh.Polys[i].Vertices[j] == PolyMesh.NullId)
						break;

					if (PolyMesh.IsInteriorEdge(polyMesh.Polys[i].NeighborEdges[j]))
						continue;

					int nj = (j + 1 >= polyMesh.NumVertsPerPoly || polyMesh.Polys[i].Vertices[j + 1] == PolyMesh.NullId) ? 0 : j + 1;

					int vertIndex0 = polyMesh.Polys[i].Vertices[j];
					int vertIndex1 = polyMesh.Polys[i].Vertices[nj];

					var v = polyMesh.Verts[vertIndex0];
					var v0 = ToV3(v);
					v0 = Vector3.Scale(v0, polyScale) + polyTrans;

					v = polyMesh.Verts[vertIndex1];
					var v1 = ToV3(v);
					v1 = Vector3.Scale(v1, polyScale) + polyTrans;

					if (visualize2D.boolValue)
					{
						FlipFor2D(ref v0);
						FlipFor2D(ref v1);
					}

					Handles.color = color;
					Handles.DrawLine(v0, v1);
					//Debug.DrawLine(v0, v1, color);
				}
			}
		}

		void FlipFor2D(ref Vector3 v)
		{
			var t = v.y;
			v.y = v.z;
			v.z = t;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\InspectorCommon.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors
{
    
    public class DAInspectorBase : Editor
    {
        protected SerializedObject sobject;
        Dictionary<string, SerializedProperty> properties = new Dictionary<string, SerializedProperty>();

        public DAInspectorMonoScriptProperty<T> CreateScriptProperty<T>(string className)
        {
            return new DAInspectorMonoScriptProperty<T>(className);
        }

        public void DrawHeader(string title)
        {
            DrawHeader(title, true);
        }
        
        public void DrawHeader(string title, bool paddingTop)
        {
            if (paddingTop)
            {
                EditorGUILayout.Space();
            }
            GUILayout.Label(title, InspectorStyles.HeaderStyle);
        }
        
        public void DrawProperty(string name)
        {
            DrawProperty(name, false);
        }

        public void DrawProperties(params string[] names)
        {
            foreach (var name in names)
            {
                DrawProperty(name, false);
            }
        }

        protected SerializedProperty GetProperty(string name)
        {
            if (properties.ContainsKey(name))
            {
                return properties[name];
            }

            if (!name.Contains("."))
            {
                var property = sobject.FindProperty(name);
                properties.Add(name, property);
                return property;
            }
            else
            {
                var tokens = name.Split(".".ToCharArray());
                var property = GetProperty(tokens[0]);
                for (int i = 1; i < tokens.Length; i++)
                {
                    property = property.FindPropertyRelative(tokens[i]);
                }
                properties[name] = property;
                return property;
            }
        }

        public void DrawProperty(string name, bool includeChildren)
        {
            var property = GetProperty(name);
            if (property != null)
            {
                EditorGUILayout.PropertyField(property, includeChildren);
            }
            else
            {
                Debug.LogError("Invalid property name: " + name);
            }
        }

        protected virtual void OnEnable()
        {
            sobject = new SerializedObject(target);
        }
    }

    
    public class DAInspectorMonoScriptProperty<T>
    {
        public string ClassName { get; private set; }
        public MonoScript ScriptCache { get; set; }

        public DAInspectorMonoScriptProperty(string propertyValue)
        {
            ClassName = propertyValue;
            UpdateScriptCache();
        }

        public void Draw(System.Action<string> ClassSetter)
        {
            var newScript = EditorGUILayout.ObjectField("Script", ScriptCache, typeof(MonoScript), false) as MonoScript;
            if (newScript != ScriptCache)
            {
                if (newScript == null)
                {
                    ClassName = null;
                }
                else
                {
                    if (!newScript.GetClass().GetInterfaces().Contains(typeof(T)))
                    {
                        // The script doesn't implement the interface
                        ClassName = null;
                    }
                    else
                    {
                        ClassName = newScript.GetClass().AssemblyQualifiedName;
                    }
                }
                UpdateScriptCache();
            }

            ClassSetter(ClassName);
        }

        public void Destroy()
        {
            if (ScriptCache != null)
            {
                ScriptableObject.DestroyImmediate(ScriptCache);
                ScriptCache = null;
            }
        }

        void UpdateScriptCache()
        {
            if (ClassName == null || ClassName.Length == 0)
            {
                ScriptCache = null;
                return;
            }

            var type = System.Type.GetType(ClassName);
            if (type == null)
            {
                ScriptCache = null;
                return;
            }

            var instance = ScriptableObject.CreateInstance(type);
            ScriptCache = MonoScript.FromScriptableObject(instance);
            Object.DestroyImmediate(instance);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\InspectorNotify.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using DungeonArchitect.Editors.SnapFlow;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Grammar;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Grid;
using DungeonArchitect.MarkerGenerator.Nodes.Actions;
using DungeonArchitect.MarkerGenerator.Nodes.Condition;
using DungeonArchitect.MarkerGenerator.Rule.Grid;
using UnityEditor;

namespace DungeonArchitect.Editors
{
    public class InspectorNotify
    {
        // Delegates
        public delegate void OnFlowTaskPropertyChanged(FlowExecTask task);
        public delegate void OnSnapPropertyChanged(Object obj);

        public delegate void OnMarkerGenPropertyChanged(Object obj);
        
        // Events
        public static event OnFlowTaskPropertyChanged FlowTaskPropertyChanged;
        public static event OnSnapPropertyChanged SnapPropertyChanged;
        public static event OnMarkerGenPropertyChanged MarkerGenPropertyChanged;

        private static readonly HashSet<System.Type> SnapEditorTypes;
        private static readonly HashSet<System.Type> MarkerGenEditorTypes;

        static InspectorNotify()
        {
            SnapEditorTypes = new HashSet<Type>()
            {
                typeof(GrammarExecRuleNode),
                typeof(GrammarGraph),
                typeof(GrammarTaskNode),
                typeof(SnapEdResultGraphEditorConfig),
                typeof(GrammarProductionRule),
                typeof(GrammarNodeType),
                typeof(WeightedGrammarGraph)
            };
            
            MarkerGenEditorTypes = new HashSet<Type>()
            {
                typeof(GridMarkerGenRule),
                typeof(GridMarkerGenPattern),
                typeof(MarkerGenRuleNodeAddMarker),
                typeof(MarkerGenRuleNodeRemoveMarker),
                typeof(MarkerGenRuleNodeMarkerExists),
                typeof(MarkerGenRuleNodeConditionScript),
            };
        }
        
        public static void Dispatch(SerializedObject sobject, Object target)
        {
            if (sobject == null || target == null) return;
            var modified = sobject.ApplyModifiedProperties();
            if (modified)
            {
                if (target is FlowExecTask)
                {
                    if (FlowTaskPropertyChanged != null)
                    {
                        FlowTaskPropertyChanged.Invoke((FlowExecTask)target);
                    }
                }
                else if (SnapEditorTypes.Contains(target.GetType()))
                {
                    if (SnapPropertyChanged != null)
                    {
                        SnapPropertyChanged.Invoke(target);
                    }
                }
                else if (MarkerGenEditorTypes.Contains(target.GetType()))
                {
                    if (MarkerGenPropertyChanged != null)
                    {
                        MarkerGenPropertyChanged.Invoke(target);
                    }
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\InspectorStyles.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors
{
    public class InspectorStyles
    {
        public static readonly GUIStyle TitleStyle;
        public static readonly GUIStyle HeaderStyle;

        static InspectorStyles()
        {
            TitleStyle = new GUIStyle(EditorStyles.label);
            TitleStyle.fontSize += 4;
            
            HeaderStyle = new GUIStyle(EditorStyles.boldLabel);
            HeaderStyle.fontSize += 2;  
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\MinimapEditors.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.GridFlow;
using UnityEditor;
using UnityEngine;


namespace DungeonArchitect.Editors
{
    [CustomEditor(typeof(GridFlowMinimapTrackedObject), true)]
    public class GridFlowMinimapTrackedObjectInspector : Editor
    {
        SerializedObject sobject;
        SerializedProperty icon;
        SerializedProperty iconScale;
        SerializedProperty rotateIcon;
        SerializedProperty tint;
        SerializedProperty exploresFogOfWar;
        SerializedProperty fogOfWarNumTileRadius;
        SerializedProperty fogOfWarLightFalloffStart;


        protected virtual void OnEnable()
        {
            sobject = new SerializedObject(target);
            icon = sobject.FindProperty("icon");
            iconScale = sobject.FindProperty("iconScale");
            rotateIcon = sobject.FindProperty("rotateIcon");
            tint = sobject.FindProperty("tint");
            exploresFogOfWar = sobject.FindProperty("exploresFogOfWar");
            fogOfWarNumTileRadius = sobject.FindProperty("fogOfWarNumTileRadius");
            fogOfWarLightFalloffStart = sobject.FindProperty("fogOfWarLightFalloffStart");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            var trackedObject = target as GridFlowMinimapTrackedObject;

            GUILayout.Label("Icon Settings", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(icon);
            EditorGUILayout.PropertyField(iconScale);
            EditorGUILayout.PropertyField(rotateIcon);
            EditorGUILayout.PropertyField(tint);

            GUILayout.Label("Fog of War", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(exploresFogOfWar);
            if (trackedObject.exploresFogOfWar)
            {
                EditorGUILayout.PropertyField(fogOfWarNumTileRadius);
                EditorGUILayout.PropertyField(fogOfWarLightFalloffStart);
            }

            sobject.ApplyModifiedProperties();
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\SplatmapPropertyEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Splatmap;

namespace DungeonArchitect.Editors
{
    [CustomEditor(typeof(DungeonSplatmap))]
    public class SplatmapPropertyEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            if (GUILayout.Button("Generate"))
            {
                var component = target as DungeonSplatmap;
                if (component.splatmap == null)
                {
                    CreateSplatMapAsset(component);
                }
                else
                {
                    RegenerateSplatmaps(component);
                }
            }
        }

        public static void RegenerateSplatmaps(DungeonSplatmap splatComponent)
        {
            // Destroy all the existing splatmaps
            var asset = splatComponent.splatmap;
            foreach (var splatTexture in asset.splatTextures)
            {
                DestroyImmediate(splatTexture, true);
            }

            var targetTextures = new List<Texture2D>();
            
            foreach (var textureInfo in splatComponent.textures)
            {
                var texSize = textureInfo.textureSize;
                var texFormat = textureInfo.textureFormat;

                var splatTexture = new Texture2D(texSize, texSize, texFormat, false);
                splatTexture.name = textureInfo.id;
                AssetDatabase.AddObjectToAsset(splatTexture, asset);
                targetTextures.Add(splatTexture);
            }

            asset.splatTextures = targetTextures.ToArray();

            EditorUtility.SetDirty(asset);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }

        public static void CreateSplatMapAsset(DungeonSplatmap splatComponent)
        {
            if (splatComponent == null)
            {
                // No splatmap attached to this dungeon configuration
                return;
            }

            // Check if the splatmap asset has been assigned
            if (splatComponent.splatmap == null)
            {
                // Create a new splatmap asset in the correct directory and assign it to the dungeon
                var defaultFileName = "DungeonSplatmap.asset";
                var scenePath = DungeonEditorHelper.GetActiveScenePath();
                splatComponent.splatmap = DungeonEditorHelper.CreateAssetInBrowser<DungeonSplatAsset>(scenePath, defaultFileName);
                
                RegenerateSplatmaps(splatComponent);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\UI\UnityEditorUIPlatform.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

namespace DungeonArchitect.UI.Impl.UnityEditor
{
    public class UnityEditorUIPlatform : UIPlatform
    {
        public void ShowObjectProperty(object obj)
        {
            Selection.activeObject = obj as Object;
        }

        public void ShowObjectProperties(object[] objs)
        {
            var unityObjs = new List<Object>();
            foreach (var obj in objs)
            {
                var unityObj = obj as Object;
                if (unityObj != null)
                {
                    unityObjs.Add(unityObj);
                }
            }
            Selection.objects = unityObjs.ToArray();
        }

        public string GetAssetPath(object obj)
        {
            var unityObj = obj as Object;
            return unityObj != null ? AssetDatabase.GetAssetPath(unityObj) : "";
        }

        public void MarkAssetDirty(object obj)
        {
            var unityObj = obj as Object;
            if (unityObj != null)
            {
                EditorUtility.SetDirty(unityObj);
            }
        }

        public IContextMenu CreateContextMenu()
        {
            return new UnityEditorContextMenu();
        }

        public void AddObjectToAsset(Object objectToAdd, Object assetObject)
        {
            AssetDatabase.AddObjectToAsset(objectToAdd, assetObject);
        }

        public double timeSinceStartup
        {
            get
            {
                return EditorApplication.timeSinceStartup;
            }
        }

        public string clipboardText { get; set; }
        public Event CurrentEvent { get => Event.current; }

        UIDragDrop dragDropImpl = new UnityEditorUIDragDrop();
        public UIDragDrop DragDrop
        {
            get
            {
                return dragDropImpl;
            }
        }
    }


    public class UnityEditorContextMenu : IContextMenu
    {
        GenericMenu menu;
        public UnityEditorContextMenu()
        {
            menu = new GenericMenu();
        }

        public void AddItem(string path, ContextMenuFunction func)
        {
            menu.AddItem(new GUIContent(path), false, () => func());
        }

        public void AddItem(string path, ContextMenuFunctionUserData func, object userData)
        {
            menu.AddItem(new GUIContent(path), false, (data) => func(data), userData);
        }
        public void AddSeparator(string path)
        {
            menu.AddSeparator(path);
        }

        public void Show()
        {
            menu.ShowAsContext();
        }
    }

    public class UnityEditorUIDragDrop : UIDragDrop
    {
        public void PrepareStartDrag()
        {
            DragAndDrop.PrepareStartDrag();
        }

        public void StartDrag(string title)
        {
            DragAndDrop.StartDrag(title);
        }

        public void SetVisualMode(UIDragDropVisualMode visualMode)
        {
            DragAndDropVisualMode unityVisualMode;
            if (visualMode == UIDragDropVisualMode.Copy) unityVisualMode = DragAndDropVisualMode.Copy;
            else if (visualMode == UIDragDropVisualMode.Generic) unityVisualMode = DragAndDropVisualMode.Generic;
            else if (visualMode == UIDragDropVisualMode.Move) unityVisualMode = DragAndDropVisualMode.Move;
            else if (visualMode == UIDragDropVisualMode.None) unityVisualMode = DragAndDropVisualMode.None;
            else if (visualMode == UIDragDropVisualMode.Reject) unityVisualMode = DragAndDropVisualMode.Rejected;
            else unityVisualMode = DragAndDropVisualMode.Generic;

            DragAndDrop.visualMode = unityVisualMode;
        }

        public void AcceptDrag()
        {
            DragAndDrop.AcceptDrag();
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\UI\UnityEditorUIRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

namespace DungeonArchitect.UI.Impl.UnityEditor
{
    public class UnityEditorUIRenderer : UIRenderer
    {
        public void BeginGroup(Rect bounds)
        {
            GUI.BeginGroup(bounds);
        }
        public void EndGroup()
        {
            GUI.EndGroup();
        }
        public bool Button(Rect bounds, GUIContent content, GUIStyle style)
        {
            return GUI.Button(bounds, content, style);
        }

        public bool Button(Rect bounds, string text, GUIStyle style)
        {
            return GUI.Button(bounds, text, style);
        }

        public bool Button(Rect bounds, string text)
        {
            return GUI.Button(bounds, text);
        }

        public bool Toggle(Rect bounds, bool value, string text)
        {
            return GUI.Toggle(bounds, value, text);
        }

        public bool Toggle(Rect bounds, bool value, string text, GUIStyle style)
        {
            return GUI.Toggle(bounds, value, text, style);
        }
        
        public void Box(Rect bounds, string text)
        {
            GUI.Box(bounds, text);
        }

        public void Box(Rect bounds, GUIContent content)
        {
            GUI.Box(bounds, content);
        }

        public void Box(Rect bounds, GUIContent content, GUIStyle style)
        {
            GUI.Box(bounds, content, style);
        }

        public void Label(Rect bounds, string text, GUIStyle style)
        {
            GUI.Label(bounds, text, style);
        }

        public void Label(Rect bounds, GUIContent content, GUIStyle style)
        {
            GUI.Label(bounds, content, style);
        }

        public Vector2 BeginScrollView(Rect bounds, Vector2 scrollPosition, Rect viewRect)
        {
            return GUI.BeginScrollView(bounds, scrollPosition, viewRect);
        }

        public void DrawTexture(Rect bounds, Texture texture)
        {
            if (texture != null)
            {
                GUI.DrawTexture(bounds, texture);
            }
        }

        public void DrawTexture(Rect bounds, Texture texture, ScaleMode scaleMode, bool alphaBlend, Color color)
        {
            if (texture != null)
            {
                GUI.DrawTexture(bounds, texture, scaleMode, alphaBlend, 1.0f, color, 0, 0);
            }
        }

        public void EndScrollView(bool handleScrollWheel)
        {
            GUI.EndScrollView(handleScrollWheel);
        }

        public void BeginGUI()
        {
            Handles.BeginGUI();
        }

        public void EndGUI()
        {
            Handles.EndGUI();
        }

        public void DrawLine(Vector3 v0, Vector3 v1)
        {
            Handles.DrawLine(v0, v1);
        }

        public void DrawLine(Color color, Vector3 v0, Vector3 v1)
        {
            Handles.color = color;
            Handles.DrawLine(v0, v1);
        }

        public void DrawLines(Color color, Vector3[] lineSegments)
        {
            Handles.color = color;
            Handles.DrawLines(lineSegments);
        }
        
        public void DrawPolyLine(params Vector3[] points)
        {
            Handles.DrawPolyLine(points);
        }

        public void DrawPolyLine(Color color, params Vector3[] points)
        {
            Handles.color = color;
            Handles.DrawPolyLine(points);
        }

        public void DrawAAPolyLine(float thickness, params Vector3[] points)
        {
            Handles.DrawAAPolyLine(thickness, points);
        }

        public void DrawAAPolyLine(float thickness, Color color, params Vector3[] points)
        {
            Handles.color = color;
            Handles.DrawAAPolyLine(thickness, points);
        }

        public void DrawAAPolyLine(Texture2D texture, float thickness, params Vector3[] points)
        {
            Handles.DrawAAPolyLine(texture, thickness, points);
        }

        public void DrawAAPolyLine(Texture2D texture, float thickness, Color color, params Vector3[] points)
        {
            Handles.color = color;
            Handles.DrawAAPolyLine(texture, thickness, points);
        }

        public void DrawBezier(Vector3 startPos, Vector3 endPos, Vector3 startTangent, Vector3 endTangent, Color lineColor, Texture2D texture, float lineThickness)
        {
            Handles.DrawBezier(startPos, endPos, startTangent, endTangent, lineColor, texture, lineThickness);
        }

        public void DrawAAConvexPolygon(params Vector3[] points)
        {
            Handles.DrawAAConvexPolygon(points);
        }

        public void DrawAAConvexPolygon(Color color, params Vector3[] points)
        {
            Handles.color = color;
            Handles.DrawAAConvexPolygon(points);
        }

        public void DrawRect(Rect bounds, Color color)
        {
            EditorGUI.DrawRect(bounds, color);
        }

        public void AddCursorRect(Rect bounds, UICursorType cursorType)
        {
            MouseCursor cursor;
            if (cursorType == UICursorType.ResizeHorizontal) cursor = MouseCursor.ResizeHorizontal;
            else if (cursorType == UICursorType.ResizeVertical) cursor = MouseCursor.ResizeVertical;
            else if (cursorType == UICursorType.Link) cursor = MouseCursor.Link;
            else cursor = MouseCursor.Arrow;

            EditorGUIUtility.AddCursorRect(bounds, cursor);
        }

        public Color color
        {
            get
            {
                return GUI.color;
            }
            set
            {
                GUI.color = value;
            }
        }

        public Color backgroundColor
        {
            get
            {
                return GUI.backgroundColor;
            }
            set
            {
                GUI.backgroundColor = value;
            }
        }

        private UIStyleManager styleManager = new UnityEditorUIStyleManager();
        public UIStyleManager StyleManager
        {
            get { return styleManager; }
        }

        Dictionary<string, Object> resources = new Dictionary<string, Object>();
        public object GetResource<T>(string path)
        {
            if (resources.ContainsKey(path) && resources[path] == null)
            {
                resources.Remove(path);
            }

            if (!resources.ContainsKey(path))
            {
                Object resource = Resources.Load(path, typeof(T)) as Object;
                resources.Add(path, resource);
            }

            return resources[path];
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\UI\UnityEditorUIStyleManager.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;

namespace DungeonArchitect.UI.Impl.UnityEditor
{
    public class UnityEditorUIStyleManager : UIStyleManager
    {
        public GUIStyle GetToolbarButtonStyle()
        {
            return new GUIStyle(EditorStyles.toolbarButton);
        }

        public GUIStyle GetButtonStyle()
        {
            return new GUIStyle(GUI.skin.button);
        }

        public GUIStyle GetBoxStyle()
        {
            return new GUIStyle(GUI.skin.box);
        }

        public GUIStyle GetLabelStyle()
        {
            return new GUIStyle(GUI.skin.label);
        }

        public GUIStyle GetBoldLabelStyle()
        {
            return new GUIStyle(EditorStyles.boldLabel);
        }

        public Font GetFontStandard()
        {
            return EditorStyles.standardFont;
        }

        public Font GetFontBold()
        {
            return EditorStyles.boldFont;
        }

        public Font GetFontMini()
        {
            return EditorStyles.miniFont;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\UI\UnityEditorUISystem.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.UI.Impl.UnityEditor
{
    public class UnityEditorUISystem : UISystem
    {
        protected override UIPlatform CreatePlatformInstance()
        {
            return new UnityEditorUIPlatform();
        }

        protected override UIStyleManager CreateStyleManagerInstance()
        {
            return new UnityEditorUIStyleManager();
        }

        protected override UIUndoSystem CreateUndoSystemInstance()
        {
            return new UnityEditorUIUndoSystem(this);
        }

        public override bool SupportsDragDrop
        {
            get
            {
                bool supported = true;
                
                #if UNITY_EDITOR_OSX
                // Disable drag/drop on mac as it is causing issues while rendering
                supported = false;
                #endif

                return supported;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\UI\UnityEditorUIUndoSystem.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using System.Linq;

namespace DungeonArchitect.UI.Impl.UnityEditor
{
    public class UnityEditorUIUndoSystem : UIUndoSystem
    {
        UISystem uiSystem;
        event UIUndoRedoDelegate undoRedoPerformed;
        public event UIUndoRedoDelegate UndoRedoPerformed
        {
            add
            {
                var references = 0;
                if (undoRedoPerformed == null || !undoRedoPerformed.GetInvocationList().Contains(undoRedoPerformed))
                {
                    undoRedoPerformed += value;
                    references = undoRedoPerformed.GetInvocationList().Length;
                }

                if (references > 0)
                {
                    CreateHook();
                }
            }
            remove
            {
                undoRedoPerformed -= value;

                var references = 0;
                if (undoRedoPerformed != null)
                {
                    references = undoRedoPerformed.GetInvocationList().Length;
                }
                if (references == 0)
                {
                    RemoveHook();
                }
            }
        }

        public UnityEditorUIUndoSystem(UISystem uiSystem)
        {
            this.uiSystem = uiSystem;
        }

        public void CreateHook()
        {
            Undo.undoRedoPerformed += __InternalUndoRedoCallback;
        }

        public void RemoveHook()
        {
            Undo.undoRedoPerformed -= __InternalUndoRedoCallback;
        }

        
        public void __InternalUndoRedoCallback()
        {
            if (undoRedoPerformed != null)
            {
                undoRedoPerformed.Invoke(uiSystem);
            }
        }

        public void RecordObject(object obj, string name)
        {
            var unityObj = obj as Object;
            if (unityObj != null)
            {
                Undo.RecordObject(unityObj, name);
            }
        }
        public void RegisterCreatedObjectUndo(object obj, string name)
        {
            var unityObj = obj as Object;
            if (unityObj != null)
            {
                Undo.RegisterCreatedObjectUndo(unityObj, name);
            }
        }
        public void DestroyObjectImmediate(object obj)
        {
            var unityObj = obj as Object;
            if (unityObj != null)
            {
                Undo.DestroyObjectImmediate(unityObj);
            }
        }

        public void RegisterCompleteObjectUndo(object obj, string name)
        {
            var unityObj = obj as Object;
            if (unityObj != null)
            {
                Undo.RegisterCompleteObjectUndo(unityObj, name);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\UI\UnityEditorUIWindow.cs:
 using System;
using System.Collections.Generic;
using DungeonArchitect.UI.Windows;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.UI.Impl.UnityEditor
{
    public class UnityEditorUIWindow<TImpl> : EditorWindow, IUIWindow<TImpl> where TImpl : IUIWindowImpl, new()
    {
        public TImpl Impl { get; private set; }

        public UnityEditorUIWindow()
        {
            Impl = new TImpl();
        }
        
        private void OnEnable()
        {
            if (_instance != null)
            {
                _instance.OnEnable();
            }
        }

        private void OnDisable()
        {
            if (_instance != null)
            {
                _instance.OnDisable();
            }
        }

        private void OnDestroy()
        {
            if (_instance != null)
            {
                _instance.OnDestroy();
            }
        }
        
        private void CreateGUI()
        {
            if (_instance != null)
            {
                _instance.CreateGUI();
            }
        }

        private void OnGUI()
        {
            if (_instance != null)
            {
                _instance.OnGUI();
            }
        }

        private void Update()
        {
            if (_instance != null)
            {
                _instance.Update();
            }
        }

        public static UnityEditorUIWindow<TImpl> Get()
        {
            _instance = EditorWindow.GetWindow<UnityEditorUIWindow<TImpl>>();
            return _instance;
        }

        private static UnityEditorUIWindow<TImpl> _instance;
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\AssetBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Frameworks.Snap;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors
{
    public class AssetBuilder
    {
        public static void CreatePlaceableMarkerAsset(string path)
        {
            var gameObject = new GameObject("PlaceableMarker");
            gameObject.AddComponent<PlaceableMarker>();
            bool success;
            try
            {
                PrefabUtility.SaveAsPrefabAsset(gameObject, path, out success);
            }
            catch
            {
                success = false;
            }

            if (!success)
            {
                Debug.LogError("Failed to create Placeable Marker asset");
            }
            
            Object.DestroyImmediate(gameObject);
        }
        
        public static void CreateSnapConnection(string path)
        {
            // Create the main snap connection game object and attach the snap connection component to it
            var gameObject = new GameObject("SnapConnection");
            var connection = gameObject.AddComponent<SnapConnection>();
            
            // Create child game objects to hold the wall and door
            var wall = new GameObject("Wall");
            var door = new GameObject("Door");
            wall.transform.parent = gameObject.transform;
            door.transform.parent = gameObject.transform;
            
            // Link them up with the connection object
            connection.wallObject = wall;
            connection.doorObject = door;

            bool success;
            try
            {
                PrefabUtility.SaveAsPrefabAsset(gameObject, path, out success);
            }
            catch
            {
                success = false;
            }

            if (!success)
            {
                Debug.LogError("Failed to create Snap Connection asset");
            }

            Object.DestroyImmediate(gameObject);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\AssetThumbnailCache.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Manages the asset thumbnails to display in the visual nodes
    /// </summary>
    public class AssetThumbnailCache
    {
        Dictionary<Object, Texture2D> thumbnails = new Dictionary<Object, Texture2D>();

		/// <summary>
		/// List of paths which we have alread requested for reimporting. 
		/// This is used to disallow repeated reimport requests if a thumbnail is still not found
		/// </summary>
		HashSet<string> reimportRequestPaths = new HashSet<string>();

        /// <summary>
        /// The texture to display if the thumbnail for an object cannot be created / retrieved
        /// </summary>
        Texture2D defaultTexture = null;

        private static AssetThumbnailCache instance = null;
        /// <summary>
        /// Singleton access
        /// </summary>
        public static AssetThumbnailCache Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new AssetThumbnailCache();
                }
                return instance;
            }
        }

        private AssetThumbnailCache()
        {
            Reset();
            AssetPreview.SetPreviewTextureCacheSize(100);
        }

        /// <summary>
        /// Clears all the thumbnail from the cache
        /// </summary>
        public void Reset()
        {
            thumbnails.Clear();
			reimportRequestPaths.Clear();
            defaultTexture = AssetPreview.GetMiniTypeThumbnail(typeof(GameObject));
        }

        /// <summary>
        /// Gets the thumbnail of the specified asset.   Tries to retrieve it from the cache, if it was accessed earlier
        /// </summary>
        /// <param name="asset">The asset to get the thumbnail for</param>
        /// <returns>The thumbnail of the asset.  If thumbnail cannot be created, returns the defaultTexture instead</returns>
        public Texture2D GetThumb(Object asset)
        {
            if (thumbnails.ContainsKey(asset))
            {
                var thumbnail = thumbnails[asset];
                if (thumbnail != null)
                {
                    return thumbnail;
                }
                else
                {
                    thumbnails.Remove(asset);
                }
            }

            var thumb = AssetPreview.GetAssetPreview(asset);

            thumbnails.Add(asset, thumb);
            return thumb == null ? defaultTexture : thumb;
        }

        // Update is called once per frame
        public void Update()
        {

        }
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\DebugText3DEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;


namespace DungeonArchitect.Editors
{
    [CustomEditor(typeof(DebugText3D)), CanEditMultipleObjects]
    public class DebugText3DEditor : Editor {
        protected virtual void OnSceneGUI()
        {
            DebugText3D debugText3D = (DebugText3D)target;
            foreach (var item in debugText3D.items)
            {
                Handles.color = item.color;
                Handles.Label(item.position, item.message);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\DungeonEditorHelper.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using DungeonArchitect.Builders;
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Graphs;
using DungeonArchitect.SpatialConstraints;
using DungeonArchitect.Graphs.SpatialConstraints;
using DungeonArchitect.Grammar;
using DungeonArchitect.Editors.SnapFlow;
using DungeonArchitect.Editors.Flow;
using DungeonArchitect.Editors.Flow.Impl;
using DungeonArchitect.Editors.MarkerGenerator;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using DungeonArchitect.Landscape;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Impl.UnityEditor;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Utility functions for various editor based features of Dungeon Architect
    /// </summary>
    public class DungeonEditorHelper
    {
        /// <summary>
        /// Creates a new Dungeon Theme in the specified asset folder.  Access from the Create context menu in the Project window
        /// </summary>
        [MenuItem("Assets/Create/Dungeon Architect/Theme Engine/Dungeon Theme", false, 100)]
        public static void CreateThemeAssetInBrowser()
        {
            var defaultFileName = "DungeonTheme.asset";
            var path = GetAssetBrowserPath();
            var graph = CreateAssetInBrowser<Graph>(path, defaultFileName);
            CreateDefaultMarkerNodes(graph);
            HandlePostAssetCreated(graph);
        }

        /// <summary>
        /// Creates a new Dungeon Theme in the specified asset folder.  Access from the Create context menu in the Project window
        /// </summary>
        [MenuItem("Assets/Create/Dungeon Architect/Theme Engine/Pattern Matcher", false, 101)]
        public static void CreateMarkerGeneratorAssetInBrowser()
        {
            var defaultFileName = "PatternMatcher.asset";
            var path = GetAssetBrowserPath();
            var asset = CreateAssetInBrowser<MarkerGeneratorAsset>(path, defaultFileName);
            MarkerGenEditorUtils.InitAsset(asset, new UnityEditorUIPlatform());
            HandlePostAssetCreated(asset);
        }

        
        [MenuItem("Assets/Create/Dungeon Architect/Snap Builder/Snap Graph", false, 1000)]
        public static void CreateSnapAssetInBrowser()
        {
            var defaultFileName = "DungeonSnapFlow.asset";
            var path = GetAssetBrowserPath();
            var dungeonFlow = CreateAssetInBrowser<SnapFlowAsset>(path, defaultFileName);
            SnapEditorUtils.InitAsset(dungeonFlow, new UnityEditorUIPlatform());
            HandlePostAssetCreated(dungeonFlow);
        }

        [MenuItem("Assets/Create/Dungeon Architect/Snap Builder/Snap Connection", false, 1000)]
        public static void CreateSnapConnectionAssetInBrowser()
        {
            CreateSnapConnectionAssetImpl();
        }
        
        [MenuItem("Assets/Create/Dungeon Architect/Grid Flow Builder/Grid Flow Graph", false, 1000)]
        public static void CreateGridFlowAssetInBrowser()
        {
            var defaultFileName = "DungeonGridFlow.asset";
            var path = GetAssetBrowserPath();
            var gridFlow = CreateAssetInBrowser<GridFlowAsset>(path, defaultFileName);
            FlowEditorUtils.InitAsset(gridFlow, new UnityEditorUIPlatform());
            HandlePostAssetCreated(gridFlow);
        }

        [MenuItem("Assets/Create/Dungeon Architect/Snap Grid Flow Builder/Snap Grid Flow Graph", false, 1000)]
        public static void CreateSnapGridFlowGraphAssetInBrowser()
        {
            var defaultFileName = "SnapGridFlow.asset";
            var path = GetAssetBrowserPath();
            var gridFlow = CreateAssetInBrowser<SnapGridFlowAsset>(path, defaultFileName);
            FlowEditorUtils.InitAsset(gridFlow, new UnityEditorUIPlatform());
            HandlePostAssetCreated(gridFlow);
        }

        [MenuItem("Assets/Create/Dungeon Architect/Snap Grid Flow Builder/Module Bounds", false, 1000)]
        public static void CreateSnapGridFlowModuleBoundsAssetInBrowser()
        {
            var defaultFileName = "SnapGridFlowModuleBounds.asset";
            var path = GetAssetBrowserPath();
            var moduleBounds = CreateAssetInBrowser<SnapGridFlowModuleBounds>(path, defaultFileName);
            SnapGridFlowEditorUtils.InitAsset(moduleBounds);
            HandlePostAssetCreated(moduleBounds);
        }
        
        [MenuItem("Assets/Create/Dungeon Architect/Snap Grid Flow Builder/Module Database", false, 1000)]
        public static void CreateSnapGridFlowModuleDatabaseAssetInBrowser()
        {
            var defaultFileName = "SnapGridFlowModuleDB.asset";
            var path = GetAssetBrowserPath();
            var moduleDatabase = CreateAssetInBrowser<SnapGridFlowModuleDatabase>(path, defaultFileName);
            SnapGridFlowEditorUtils.InitAsset(moduleDatabase);
            HandlePostAssetCreated(moduleDatabase);
        }

        [MenuItem("Assets/Create/Dungeon Architect/Snap Grid Flow Builder/Placeable Marker", false, 1000)]
        public static void CreateSnapGridFlowPlaceableMarkerAssetInBrowser()
        {
            var path = GetAssetBrowserPath();
            var fileName = MakeFilenameUnique(path, "PlaceableMarker.prefab");
            var fullPath = path + "/" + fileName;
            
            AssetBuilder.CreatePlaceableMarkerAsset(fullPath);
        }

        [MenuItem("Assets/Create/Dungeon Architect/Snap Grid Flow Builder/Snap Connection", false, 1000)]
        public static void CreateSnapGridFlowConnectionAssetInBrowser()
        {
            CreateSnapConnectionAssetImpl();
        }

        private static void CreateSnapConnectionAssetImpl()
        {
            var path = GetAssetBrowserPath();
            var fileName = MakeFilenameUnique(path, "SnapConnection.prefab");
            var fullPath = path + "/" + fileName;
            
            AssetBuilder.CreateSnapConnection(fullPath);
        }
        
        [MenuItem("Assets/Create/Dungeon Architect/Landscape/Landscape Restoration Cache", false, 3000)]
        public static void CreateDungeonLandscapeRestCacheInBrowser()
        {
            var defaultFileName = "DungeonLandscapeRestorationCache.asset";
            var path = GetAssetBrowserPath();
            var cacheAsset = CreateAssetInBrowser<DungeonLandscapeRestorationCache>(path, defaultFileName);
            HandlePostAssetCreated(cacheAsset);
        }

        /// <summary>
        /// Handle opening of theme graphs.
        /// When the user right clicks on the theme graph and selects open, the graph is shown in the theme editor
        /// </summary>
        /// <param name="instanceID"></param>
        /// <param name="line"></param>
        /// <returns>true if trying to open a dungeon theme, indicating that it has been handled.  false otherwise</returns>
        [UnityEditor.Callbacks.OnOpenAsset(1)]
        public static bool OnOpenAsset(int instanceID, int line)
        {
            Object activeObject = EditorUtility.InstanceIDToObject(instanceID);
            if (activeObject is Graph)
            {
                var graph = Selection.activeObject as Graph;
                ShowThemeEditor(graph);
                return true; //catch open file
            }
            else if (activeObject is MarkerGeneratorAsset)
            {
                var asset = Selection.activeObject as MarkerGeneratorAsset;
                ShowMarkerGeneratorEditor(asset);
                return true;
            }
            else if (activeObject is SnapFlowAsset)
            {
                var dungeonFlow = Selection.activeObject as SnapFlowAsset;
                ShowDungeonFlowEditor(dungeonFlow);
                return true;
            }
            else if (activeObject is GridFlowAsset)
            {
                var dungeonFlow = Selection.activeObject as GridFlowAsset;
                ShowDungeonGridFlowEditor(dungeonFlow);
                return true;
            }
            else if (activeObject is SnapGridFlowAsset)
            {
                var dungeonFlow = Selection.activeObject as SnapGridFlowAsset;
                ShowSnapGridFlowEditor(dungeonFlow);
                return true;
            }
            return false; // let unity open the file
        }

        public static T CreateAssetInBrowser<T>(string path, string defaultFilename) where T : ScriptableObject
        {
            var fileName = MakeFilenameUnique(path, defaultFilename);
            var fullPath = path + "/" + fileName;

            var asset = ScriptableObject.CreateInstance<T>();
            AssetDatabase.CreateAsset(asset, fullPath);
            
            return asset;
        }

        public static void HandlePostAssetCreated(ScriptableObject asset)
        {
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            ProjectWindowUtil.ShowCreatedAsset(asset);
        }

        public static string GetActiveScenePath()
        {
            var scenePath = UnityEngine.SceneManagement.SceneManager.GetActiveScene().path;
            scenePath = scenePath.Replace('\\', '/');
            int trimIndex = scenePath.LastIndexOf('/');
            scenePath = scenePath.Substring(0, trimIndex);
            return scenePath;
        }

        /// <summary>
        /// Shows the dungeon theme editor window and loads the specified graph into it
        /// </summary>
        /// <param name="graph">The graph to load in the dungeon theme editor window</param>
        public static void ShowThemeEditor(Graph graph)
        {
            if (graph != null)
            {
                var window = EditorWindow.GetWindow<DungeonThemeEditorWindow>();
                if (window != null)
                {
                    window.Init(graph);
                }
            }
            else
            {
                Debug.LogWarning("Invalid Dungeon theme file");
            }
        }

        /// <summary>
        /// Shows the Pattern Matcher editor window
        /// </summary>
        /// <param name="graph">The graph to load in the dungeon theme editor window</param>
        public static void ShowMarkerGeneratorEditor(MarkerGeneratorAsset asset)
        {
            if (asset != null)
            {
                var window = EditorWindow.GetWindow<MarkerGenEditorWindow>();
                if (window != null)
                {
                    window.Init(asset);
                }
            }
            else
            {
                Debug.LogWarning("Invalid pattern matcher file");
            }
        }


        /// <summary>
        /// Shows the dungeon flow editor window and loads the specified graph into it
        /// </summary>
        /// <param name="graph">The graph to load in the dungeon theme editor window</param>
        public static void ShowDungeonFlowEditor(SnapFlowAsset snapFlow)
        {
            if (snapFlow != null)
            {
                var window = EditorWindow.GetWindow<SnapEditorWindow>();
                if (window != null)
                {
                    window.Init(snapFlow);
                }
            }
            else
            {
                Debug.LogWarning("Invalid Dungeon flow file");
            }
        }

        /// <summary>
        /// Shows the dungeon grid flow editor window and loads the specified graph into it
        /// </summary>
        /// <param name="graph">The graph to load in the dungeon theme editor window</param>
        public static void ShowDungeonGridFlowEditor(GridFlowAsset gridFlow)
        {
            if (gridFlow != null)
            {
                var window = EditorWindow.GetWindow<GridFlowEditorWindow>();
                if (window != null)
                {
                    window.Init(gridFlow);
                }
            }
            else
            {
                Debug.LogWarning("Invalid Dungeon grid flow file");
            }
        }

        /// <summary>
        /// Shows the dungeon grid flow editor window and loads the specified graph into it
        /// </summary>
        /// <param name="graph">The graph to load in the dungeon theme editor window</param>
        public static void ShowSnapGridFlowEditor(SnapGridFlowAsset snapGridFlow)
        {
            if (snapGridFlow != null)
            {
                var window = EditorWindow.GetWindow<SnapGridFlowEditorWindow>();
                if (window != null)
                {
                    window.Init(snapGridFlow);
                }
            }
            else
            {
                Debug.LogWarning("Invalid Dungeon grid flow file");
            }
        }
        
        /// <summary>
        /// Creates a unique filename in the specified asset directory
        /// </summary>
        /// <param name="dir">The target directory this file will be placed in.  Used for finding non-colliding filenames</param>
        /// <param name="filename">The prefered filename.  Will add incremental numbers to it till it finds a free filename</param>
        /// <returns>A filename not currently used in the specified directory</returns>
        public static string MakeFilenameUnique(string dir, string filename)
        {
            string fileNamePart = System.IO.Path.GetFileNameWithoutExtension(filename);
            string fileExt = System.IO.Path.GetExtension(filename);
            var indexedFileName = fileNamePart + fileExt;
            string path = System.IO.Path.Combine(dir, indexedFileName);
            for (int i = 1; ; ++i)
            {
                if (!System.IO.File.Exists(path))
                    return indexedFileName;

                indexedFileName = fileNamePart + " " + i + fileExt;
                path = System.IO.Path.Combine(dir, indexedFileName);
            }
        }

        public static T CreateConstraintRule<T>(SpatialConstraintAsset spatialConstraint) where T : ConstraintRule
        {
            if (spatialConstraint == null || spatialConstraint.hostThemeNode == null) return null;

            var rule = ScriptableObject.CreateInstance<T>();
            var assetObject = spatialConstraint.hostThemeNode.Graph;

            AssetDatabase.AddObjectToAsset(rule, assetObject);
            return rule;
        }

        public static void DestroySpatialConstraintAsset(SpatialConstraintAsset spatialConstraint)
        {
            if (spatialConstraint == null)
            {
                return;
            }
            if (spatialConstraint.hostThemeNode == null)
            {
                return;
            }

            var asset = spatialConstraint.hostThemeNode.Graph;
            Undo.RegisterCompleteObjectUndo(asset, "Delete Node Spatial Constraint");

            var objectsToDestroy = new List<ScriptableObject>();
            if (spatialConstraint != null && spatialConstraint.Graph != null)
            {
                foreach (var node in spatialConstraint.Graph.Nodes)
                {
                    if (node is SCRuleNode)
                    {
                        var ruleNode = node as SCRuleNode;
                        foreach (var constraint in ruleNode.constraints)
                        {
                            objectsToDestroy.Add(constraint);
                        }
                    }
                    objectsToDestroy.Add(node);
                }
                objectsToDestroy.Add(spatialConstraint.Graph);
                objectsToDestroy.Add(spatialConstraint);
            }

            foreach (var objectToDestroy in objectsToDestroy)
            {
                if (objectToDestroy != null)
                {
                    Undo.DestroyObjectImmediate(objectToDestroy);
                }
            }
        }

        public static string GetAssetBrowserPath()
        {
            string path = AssetDatabase.GetAssetPath(Selection.activeObject);
            if (path == "")
            {
                path = "Assets";
            }

            else if (System.IO.Path.GetExtension(path) != "")
            {
                path = path.Replace(System.IO.Path.GetFileName(AssetDatabase.GetAssetPath(Selection.activeObject)), "");
            }
            return path;
        }
        
        public static T GetWindowIfOpen<T>() where T : Object
        {
            T[] existingWindows = Resources.FindObjectsOfTypeAll<T>();
            T existingWindow = null;
            if (existingWindows.Length > 0)
            {
                existingWindow = existingWindows[0];
            }
            return existingWindow;
        }


        /// <summary>
        /// Marks the graph as dirty so that it is serialized to disk again when saved
        /// </summary>
        /// <param name="graph"></param>
        public static void MarkAsDirty(Graph graph)
        {
            EditorUtility.SetDirty(graph);
        }

        public static void CreateDefaultSpatialConstraintNodes(SpatialConstraintAsset constraintAsset, UIUndoSystem undo)
        {
            var position = SCBaseDomainNode.TileSize * 0.5f * Vector2.one;
            CreateSpatialConstraintNode<SCReferenceNode>(constraintAsset, position, undo);
        }

        public static T CreateSpatialConstraintNode<T>(SpatialConstraintAsset constraintAsset, Vector2 worldPosition, UIUndoSystem undo) where T : SCBaseDomainNode
        {
            var graph = constraintAsset.Graph;
            var node = GraphOperations.CreateNode<T>(graph, undo);
            node.Position = worldPosition;
            node.SnapNode();

            var hostAsset = constraintAsset.hostThemeNode.Graph;
            GraphEditorUtils.AddToAsset(new UnityEditorUIPlatform(), hostAsset, node);

            return node;
        }

        /// <summary>
        /// Creates default marker nodes when a new graph is created
        /// </summary>
        static void CreateDefaultMarkerNodes(Graph graph)
        {
            if (graph == null)
            {
                Debug.LogWarning("Cannot create default marker nodes. graph is null");
                return;
            }
            var markerNames = DungeonBuilderDefaultMarkers.GetDefaultMarkers(typeof(GridDungeonBuilder));
            
            // Make sure we don't have any nodes in the graph
            if (graph.Nodes.Count > 0)
            {
                return;
            }

            const int INTER_NODE_X = 200;
            const int INTER_NODE_Y = 300;
            int itemsPerRow = markerNames.Length / 2;
            for (int i = 0; i < markerNames.Length; i++)
            {
                int ix = i % itemsPerRow;
                int iy = i / itemsPerRow;
                int x = ix * INTER_NODE_X;
                int y = iy * INTER_NODE_Y;
                var node = GraphOperations.CreateNode<MarkerNode>(graph, null);
                GraphEditorUtils.AddToAsset(new UnityEditorUIPlatform(), graph, node);
                node.Position = new Vector2(x, y);
                node.Caption = markerNames[i];
            }
        }


        /// <summary>
        /// Creates an editor tag
        /// </summary>
        /// <param name="tag"></param>
        public static void CreateEditorTag(string tag)
        {
            SerializedObject tagManager = new SerializedObject(AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/TagManager.asset")[0]);
            SerializedProperty tagsProp = tagManager.FindProperty("tags");

            // Check if the tag is already present
            for (int i = 0; i < tagsProp.arraySize; i++)
            {
                SerializedProperty t = tagsProp.GetArrayElementAtIndex(i);
                if (t.stringValue.Equals(tag))
                {
                    // Tag already exists.  do not add a duplicate
                    return;
                }
            }

            tagsProp.InsertArrayElementAtIndex(0);
            SerializedProperty n = tagsProp.GetArrayElementAtIndex(0);
            n.stringValue = tag;

            tagManager.ApplyModifiedProperties();
        }


		// Resets the node IDs of the graph. Useful if you have cloned another graph
		//[MenuItem("Debug DA/Fix Node Ids")]
		public static void _Advanced_RecreateGraphNodeIds()
		{
			var editor = EditorWindow.GetWindow<DungeonThemeEditorWindow>();
			if (editor != null && editor.GraphEditor != null && editor.GraphEditor.Graph != null)
			{
				var graph = editor.GraphEditor.Graph;
				foreach (var node in graph.Nodes)
				{
					node.Id = System.Guid.NewGuid().ToString();
				}
			}
			
		}

        public static void MarkSceneDirty()
        {
            if (!Application.isPlaying)
            {
                UnityEditor.SceneManagement.EditorSceneManager.MarkSceneDirty(UnityEditor.SceneManagement.EditorSceneManager.GetActiveScene());
            }
        }
        
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\DungeonEditorStyles.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors
{
    public class DungeonEditorStyles
    {
        public static readonly GUIStyle discordToolButtonStyle;
        public static readonly GUIStyle docsToolButtonStyle;
        static DungeonEditorStyles()
        {
            discordToolButtonStyle = new GUIStyle(EditorStyles.toolbarButton);
            discordToolButtonStyle.normal.textColor = Color.white;
            discordToolButtonStyle.hover.textColor = new Color(1, 1, 1, 0.9f);
            
            docsToolButtonStyle = new GUIStyle(EditorStyles.toolbarButton);
            docsToolButtonStyle.normal.textColor = Color.white;
            docsToolButtonStyle.hover.textColor = new Color(1, 1, 1, 0.9f);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\EditorDeltaTime.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors
{
    public class EditorDeltaTime
    {
        private double lastUpdateTimestamp = EditorApplication.timeSinceStartup;
        public float DeltaTime { get; set; } = 0;
        
        public void Tick()
        {
            double currentTime = EditorApplication.timeSinceStartup;
            DeltaTime = (float)(currentTime - lastUpdateTimestamp);
            lastUpdateTimestamp = currentTime;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\ExternalLinks.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Editors
{
    public class ExternalLinks
    {
        public static readonly string DiscordInvite = "https://discord.gg/N3rHt4h";
        public static readonly string Documentation = "https://docs.dungeonarchitect.dev/unity";
        public static readonly string DocumentationPatternEditor = "https://docs.dungeonarchitect.dev/unity/pattern-matcher/getting-started";
        
        public static readonly string ProductPage = "https://u3d.as/nAL";
        
        public static void LaunchUrl(string url)
        {
            Application.OpenURL(url);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\GraphInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;
namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for graph objects
    /// Shows the graph editor when a theme graph asset is selected
    /// </summary>
    [CustomEditor(typeof(Graph))]
    public class GraphInspector : Editor
    {
        SerializedObject sobject;

        public void OnEnable()
        {
            sobject = new SerializedObject(target);
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            GUILayout.Label("Dungeon Theme", EditorStyles.boldLabel);

            sobject.ApplyModifiedProperties();

            ///ShowEditor();
        }

        void ShowEditor()
        {
            var graph = target as Graph;
            if (graph != null)
            {
                var window = EditorWindow.GetWindow<DungeonThemeEditorWindow>();
                if (window != null)
                {
                    window.Init(graph);
                }
            }
            else
            {
                Debug.LogWarning("Invalid Dungeon theme file");
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\InspectorUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Utility functions for drawing UI in the Inspector window
    /// </summary>
    public class InspectorUtils
    {
        /// <summary>
        /// Draws the translation / rotation / scale widgets for a Matrix4x4
        /// </summary>
        /// <param name="caption">The caption to display above the widget</param>
        /// <param name="matrix">The transform matrix to modify</param>
        public static void DrawMatrixProperty(string caption, ref Matrix4x4 matrix)
        {
            Vector3 position;
            Quaternion rotation;
            Vector3 scale;
            Matrix.DecomposeMatrix(ref matrix, out position, out rotation, out scale);
            Vector3 rotationEular = rotation.eulerAngles;

            int precision = 4;
            RoundVector(ref position, precision);
            RoundVector(ref rotationEular, precision);
            RoundVector(ref scale, precision);

            DrawVectorProperty("Position", ref position);
            DrawVectorProperty("Rotation", ref rotationEular);
            DrawVectorProperty("Scale", ref scale);

            if (GUI.changed)
            {
                rotation = Quaternion.Euler(rotationEular);
                matrix = Matrix4x4.TRS(position, rotation, scale);
            }

        }

        /// <summary>
        /// Rounds the Vector to the nearest precision
        /// </summary>
        /// <param name="vector">The vector to round</param>
        /// <param name="precision">The precision in digits</param>
        public static void RoundVector(ref Vector3 vector, int precision)
        {
            vector.x = Round(vector.x, precision);
            vector.y = Round(vector.y, precision);
            vector.z = Round(vector.z, precision);
        }

        /// <summary>
        /// rounds a float to the nearest precision
        /// </summary>
        /// <param name="f">The value to round</param>
        /// <param name="precision">The precision in digits</param>
        /// <returns></returns>
        public static float Round(float f, int precision)
        {
            var multiplier = Mathf.Pow(10, precision);
            return Mathf.Round(f * multiplier) / multiplier;
        }

        /// <summary>
        /// Draws XYZ components of a Vector3 in the inspector window within the same line for better usability and asthetics
        /// </summary>
        /// <param name="caption">The caption to use on the property</param>
        /// <param name="vector">The vector to modify</param>
        public static void DrawVectorProperty(string caption, ref Vector3 vector)
        {
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label(caption, EditorStyles.label, GUILayout.Width(60));
            GUILayout.Label("X:", EditorStyles.label);
            vector.x = EditorGUILayout.FloatField(vector.x);

            GUILayout.Label("Y:", EditorStyles.label);
            vector.y = EditorGUILayout.FloatField(vector.y);

            GUILayout.Label("Z:", EditorStyles.label);
            vector.z = EditorGUILayout.FloatField(vector.z);
            EditorGUILayout.EndHorizontal();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\ReflectionUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Reflection;
using System.Linq;

namespace DungeonArchitect.Editors
{
    public class ReflectionUtils
    {
        public static System.Type[] GetAllSubtypes(System.Type baseType, bool fromAllAssemblies)
        {
            var types = GetAllTypes(fromAllAssemblies);
            return (from System.Type type in types where type.IsSubclassOf(baseType) select type).ToArray();
        }

        public static System.Type[] GetAllTypes(bool fromAllAssemblies)
        {
            var assemblies = new List<Assembly>();
            assemblies.Add(System.Reflection.Assembly.GetExecutingAssembly());
            if (fromAllAssemblies)
            {
                foreach (var assemblyName in System.Reflection.Assembly.GetExecutingAssembly().GetReferencedAssemblies())
                {
                    var assembly = System.Reflection.Assembly.Load(assemblyName.ToString());
                    assemblies.Add(assembly);
                }
            }

            var types = new List<System.Type>();
            foreach (var assembly in assemblies)
            {
                types.AddRange(assembly.GetTypes());
            }

            return types.ToArray();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\SxEditorEngine.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Editors
{
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\Timer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Ticks every few milli-seconds
    /// </summary>
    public class Timer
    {
        private float hertz;
        /// <summary>
        /// Ticks per second
        /// </summary>
        public float Hertz
        {
            get
            {
                return hertz;
            }
            set
            {
                hertz = value;
                if (hertz == 0)
                {
                    hertz = 1e-6f;
                }
                frameTime = 1.0f / hertz;
            }
        }

        float frameTime;
        float timeSinceFrameStart = 0;
        public delegate void OnTick(float elapsedTime);
        public event OnTick Tick;

        public Timer()
        {
            Hertz = 30;
        }

        /// <summary>
        /// Update should be called once per frame
        /// </summary>
        /// <param name="deltaSeconds">The frame time between calls</param>
        public void Update(float deltaSeconds)
        {
            timeSinceFrameStart += deltaSeconds;
            if (timeSinceFrameStart >= frameTime)
            {
                timeSinceFrameStart = 0;
                if (Tick != null)
                {
                    Tick(frameTime);
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Area.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Runtime.InteropServices;

namespace SharpNav
{
	/// <summary>
	/// An area groups together pieces of data through the navmesh generation process.
	/// </summary>
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct Area : IEquatable<Area>, IEquatable<byte>
	{
		/// <summary>
		/// The null area is one that is considered unwalkable.
		/// </summary>
		public static readonly Area Null = new Area(0);

		/// <summary>
		/// This is a default <see cref="Area"/> in the event that the user does not provide one.
		/// </summary>
		/// <remarks>
		/// If a user only applies IDs to some parts of a <see cref="Heightfield"/>, they will most likely choose low
		/// integer values. Choosing the maximum value makes it unlikely for the "default" area to collide with any
		/// user-defined areas.
		/// </remarks>
		public static readonly Area Default = new Area(0xff);

		/// <summary>
		/// The identifier for an area, represented as a byte.
		/// </summary>
		public readonly byte Id;

		/// <summary>
		/// Initializes a new instance of the <see cref="Area"/> struct.
		/// </summary>
		/// <param name="id">An identifier for the area.</param>
		public Area(byte id)
		{
			this.Id = id;
		}

		/// <summary>
		/// Gets a value indicating whether the area is considered walkable (not <see cref="Area.Null"/>).
		/// </summary>
		public bool IsWalkable
		{
			get
			{
				return Id != 0;
			}
		}

		/// <summary>
		/// Implicitly casts a byte to an Area. This is included since an Area is a very thin wrapper around a byte.
		/// </summary>
		/// <param name="value">The identifier for an area.</param>
		/// <returns>An area with the specified identifier.</returns>
		public static implicit operator Area(byte value)
		{
			return new Area(value);
		}

		/// <summary>
		/// Compares two areas for equality.
		/// </summary>
		/// <param name="left">An <see cref="Area"/>.</param>
		/// <param name="right">Another <see cref="Area"/></param>
		/// <returns>A value indicating whether the two <see cref="Area"/>s are equal.</returns>
		public static bool operator ==(Area left, Area right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two areas for inequality.
		/// </summary>
		/// <param name="left">An <see cref="Area"/>.</param>
		/// <param name="right">Another <see cref="Area"/></param>
		/// <returns>A value indicating whether the two <see cref="Area"/>s are unequal.</returns>
		public static bool operator !=(Area left, Area right)
		{
			return !(left == right);
		}
		
		/// <summary>
		/// Compares this instance with another instance of <see cref="Area"/> for equality.
		/// </summary>
		/// <param name="other">An <see cref="Area"/>.</param>
		/// <returns>A value indicating whether the two <see cref="Area"/>s are equal.</returns>
		public bool Equals(Area other)
		{
			return this.Id == other.Id;
		}

		/// <summary>
		/// Compares this instance with a byte representing another <see cref="Area"/> for equality.
		/// </summary>
		/// <param name="other">A byte.</param>
		/// <returns>A value indicating whether this instance and the specified byte are equal.</returns>
		public bool Equals(byte other)
		{
			return this.Id == other;
		}

		/// <summary>
		/// Compares this instance with another object for equality.
		/// </summary>
		/// <param name="obj">An object.</param>
		/// <returns>A value indicating whether this instance and the specified object are equal.</returns>
		public override bool Equals(object obj)
		{
			var areaObj = obj as Area?;
			var byteObj = obj as byte?;

			if (areaObj.HasValue)
				return this.Equals(areaObj.Value);
			else if (byteObj.HasValue)
				return this.Equals(byteObj.Value);
			else
				return false;
		}

		/// <summary>
		/// Generates a hashcode unique to the <see cref="Id"/> of this instance.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			return Id.GetHashCode();
		}

		/// <summary>
		/// Converts this instance to a human-readable string.
		/// </summary>
		/// <returns>A string representing this instance.</returns>
		public override string ToString()
		{
			if (Id == 0)
				return "Null/Unwalkable";
			else
				return Id.ToString();
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\AreaIdGenerator.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;
using System.Linq;
using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// A class that filters geometry and applies an <see cref="Area"/> to it.
	/// </summary>
	public class AreaGenerator
	{
		private IEnumerable<Triangle3> tris;
		private int triCount;
		private List<Tuple<Func<Triangle3, bool>, Area>> conditions;
		private Area defaultArea;

		/// <summary>
		/// Initializes a new instance of the <see cref="SharpNav.AreaGenerator"/> class.
		/// </summary>
		/// <param name="verts">collection of Triangles.</param>
		/// <param name="triCount">The number of triangles to enumerate..</param>
		/// <param name="defaultArea">Default area.</param>
		private AreaGenerator(IEnumerable<Triangle3> verts, int triCount, Area defaultArea)
		{
			this.tris = verts;
			this.triCount = triCount;
			this.defaultArea = defaultArea;
			conditions = new List<Tuple<Func<Triangle3, bool>, Area>>();
		}

		/// <summary>
		/// Create instance from the specified triangles with specified area.
		/// </summary>
		/// <param name="tris">Collection of Triangles.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(IEnumerable<Triangle3> tris, Area area)
		{
			return new AreaGenerator(tris, tris.Count(), area);
		}

		/// <summary>
		/// Create instance from triCount(a integer) specified triangles with specified area
		/// </summary>
		/// <param name="tris">Collection of Triangles.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(IEnumerable<Triangle3> tris, int triCount, Area area)
		{
			return new AreaGenerator(tris, triCount, area);
		}

		/// <summary>
		/// Create instance from every specified triangles in array of tris with specified area.
		/// </summary>
		/// <param name="tris">An array of triangles.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(Triangle3[] tris, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromTriangle(tris, 0, tris.Length), tris.Length, area);
		}

		/// <summary>
		/// Create instance from specified triangles in array of tris from tris[triOffset] to tris[triOffset+triCount] with specified area.
		/// </summary>
		/// <param name="tris">An array of triangles.</param>
		/// <param name="triOffset">Tri offset.</param>
		/// <param name="triCount">Tri count.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(Triangle3[] tris, int triOffset, int triCount, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromTriangle(tris, triOffset, triCount), triCount, area);
		}

		/// <summary>
		/// Create instance from the triangles created from points in verts with specified area 
		/// </summary>
		/// <param name="verts">An array of Vectors3.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(Vector3[] verts, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromVector3(verts, 0, 1, verts.Length / 3), verts.Length / 3, area);
		}

		/// <summary>
		/// Create instance from the triangles created from points start from verts[0*vertStride+vertOffset] to verts[(triCount-1)*vertStride+vertOffset]with specified area
		/// </summary>
		/// <param name="verts">An array of Vectors3.</param>
		/// <param name="vertOffset">The index of the first Vectex to be enumerated.</param>
		/// <param name="vertStride">The distance between the start of two triangles. A value of 0 means the data is tightly packed.</param>
		/// <param name="triCount">The number of triangles to enumerate..</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(Vector3[] verts, int vertOffset, int vertStride, int triCount, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromVector3(verts, vertOffset, vertStride, triCount), triCount, area);
		}

		/// <summary>
		/// Create instance from the triangles created from points in verts with specified area
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(float[] verts, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromFloat(verts, 0, 3, verts.Length / 9), verts.Length / 9, area);
		}

		/// <summary>
		/// Create instance from the triangles created from points start from verts[0*vertStride+vertOffset] to verts[(triCount-1)*vertStride+vertOffset]with specified area.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="floatOffset">The index of the first float to be enumerated.</param>
		/// <param name="floatStride">The distance between the start of two vertices. A value of 0 means the data is tightly packed.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(float[] verts, int floatOffset, int floatStride, int triCount, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromFloat(verts, floatOffset, floatStride, triCount), triCount, area);
		}

		/// <summary>
		/// Create instance from triangles created from points of verts which is created from array of index of vertices array with specified area 
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(Vector3[] verts, int[] inds, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromIndexedVector3(verts, inds, 0, 1, 0, inds.Length / 3), inds.Length / 3, area);
		}

		/// <summary>
		/// Create instance from triangles created from points of verts which is created from array of index of vertices array with specified area 
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="vertOffset">The index of the first vertex to be enumerated.</param>
		/// <param name="vertStride">The distance between the start of two triangles. A value of 0 means the data is tightly packed.</param>
		/// <param name="indexOffset">The index of the first index to be enumerated.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(Vector3[] verts, int[] inds, int vertOffset, int vertStride, int indexOffset, int triCount, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromIndexedVector3(verts, inds, vertOffset, vertStride, indexOffset, triCount), triCount, area);
		}

		/// <summary>
		/// Create instance from triangles created from points of verts which is created from array of index of vertices array with specified area 
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(float[] verts, int[] inds, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromIndexedFloat(verts, inds, 0, 3, 0, inds.Length / 3), inds.Length / 3, area);
		}

		/// <summary>
		/// Create instance from triangles created from points of verts which is created from array of index of vertices array with specified area 
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="floatOffset">The index of the first float to be enumerated.</param>
		/// <param name="floatStride">The distance between the start of two vertices. A value of 0 means the data is tightly packed.</param>
		/// <param name="indexOffset">The index of the first index to be enumerated.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <param name="area">Area of Triangle.</param>
		/// <returns>A new AreaIdGenerator.</returns>
		public static AreaGenerator From(float[] verts, int[] inds, int floatOffset, int floatStride, int indexOffset, int triCount, Area area)
		{
			return new AreaGenerator(TriangleEnumerable.FromIndexedFloat(verts, inds, floatOffset, floatStride, indexOffset, triCount), triCount, area);
		}

		/// <summary>
		/// Takes the mesh query, runs it, and outputs the result as an array of <see cref="Area"/>.
		/// </summary>
		/// <returns>The result of the query.</returns>
		public Area[] ToArray()
		{
			Area[] areas = new Area[triCount];

			int i = 0;
			foreach (var tri in tris)
			{
				areas[i] = defaultArea;

				foreach (var condition in conditions)
					if (condition.Item1(tri))
						areas[i] = condition.Item2;

				i++;
			}

			return areas;
		}

		/// <summary>
		/// Marks all triangles above a specified angle with a sepcified area ID.
		/// </summary>
		/// <param name="angle">The minimum angle in radians.</param>
		/// <param name="area">The area ID to set for triangles above the slope.</param>
		/// <returns>The same instance.</returns>
		public AreaGenerator MarkAboveSlope(float angle, Area area)
		{
			conditions.Add(new SharpNav.Tuple<Func<Triangle3, bool>, Area>(
				tri =>
				{
					Vector3 n = tri.Normal;
					float a;
					Vector3Extensions.CalculateSlopeAngle(ref n, out a);
					return a <= angle;
				},
				area));

			return this;
		}

		/// <summary>
		/// Marks all triangles below a specified angle with a sepcified area ID.
		/// </summary>
		/// <param name="angle">The maximum angle.</param>
		/// <param name="area">The area ID to set for triangles below the slope.</param>
		/// <returns>The same instance.</returns>
		public AreaGenerator MarkBelowSlope(float angle, Area area)
		{
			conditions.Add(new SharpNav.Tuple<Func<Triangle3, bool>, Area>(
				tri =>
				{
					Vector3 n = tri.Normal;
					float a;
					Vector3Extensions.CalculateSlopeAngle(ref n, out a);
					return a >= angle;
				},
				area));

			return this;
		}

		/// <summary>
		/// Marks all triangles around a specified angle with a sepcified area ID.
		/// </summary>
		/// <param name="angle">The angle.</param>
		/// <param name="range">The maximum allowed difference between the angle and a triangle's angle.</param>
		/// <param name="area">The area ID to set for triangles around the slope.</param>
		/// <returns>The same instance.</returns>
		public AreaGenerator MarkAtSlope(float angle, float range, Area area)
		{
			conditions.Add(new SharpNav.Tuple<Func<Triangle3, bool>, Area>(
				tri =>
				{
					Vector3 n = tri.Normal;
					float a;
					Vector3Extensions.CalculateSlopeAngle(ref n, out a);
					return a >= angle - range && a <= angle + range;
				},
				area));

			return this;
		}

		/// <summary>
		/// Marks all triangles below a specified height with a sepcified area ID.
		/// </summary>
		/// <param name="y">The height threshold of a triangle.</param>
		/// <param name="area">The area ID to set for triangles below the threshold.</param>
		/// <returns>The same instance.</returns>
		public AreaGenerator MarkBelowHeight(float y, Area area)
		{
			conditions.Add(new SharpNav.Tuple<Func<Triangle3, bool>, Area>(
				tri =>
				{
					if (tri.A.Y <= y || tri.B.Y <= y || tri.C.Y <= y)
						return true;

					return false;
				},
				area));

			return this;
		}

		/// <summary>
		/// Marks all triangles around a specified height with a sepcified area ID.
		/// </summary>
		/// <param name="y">The height value.</param>
		/// <param name="radius">The maximum allowed difference between the height and a triangle's height.</param>
		/// <param name="area">The area ID to set for triangles around the height.</param>
		/// <returns>The same instance.</returns>
		public AreaGenerator MarkAtHeight(float y, float radius, Area area)
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Marks all triangles above a specified height with a sepcified area ID.
		/// </summary>
		/// <param name="y">The height threshold of a triangle.</param>
		/// <param name="area">The area ID to set for triangles above the threshold.</param>
		/// <returns>The same instance.</returns>
		public AreaGenerator MarkAboveHeight(float y, Area area)
		{
			conditions.Add(new SharpNav.Tuple<Func<Triangle3, bool>, Area>(
				tri =>
				{
					if (tri.A.Y >= y || tri.B.Y >= y || tri.C.Y >= y)
						return true;

					return false;
				},
				area));

			return this;
		}

		/// <summary>
		/// Marks all triangles that meet a specified condition with a specified area ID.
		/// </summary>
		/// <param name="func">The condition to be tested on each triangle.</param>
		/// <param name="area">The area ID to set for triangles that match the condition.</param>
		/// <returns>The same instance.</returns>
		public AreaGenerator MarkCustomFilter(Func<Triangle3, bool> func, Area area)
		{
			conditions.Add(new SharpNav.Tuple<Func<Triangle3, bool>, Area>(func, area));

			return this;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Cell.cs:
 // Copyright (c) 2013-2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace SharpNav
{
	/// <summary>
	/// A cell is a column of voxels represented in <see cref="Span"/>s.
	/// </summary>
	public class Cell
	{
		private List<Span> spans;
		private int height;

		/// <summary>
		/// Initializes a new instance of the <see cref="Cell"/> class.
		/// </summary>
		/// <param name="height">The number of voxels in the column.</param>
		public Cell(int height)
		{
			this.height = height;
			spans = new List<Span>();
		}

		/// <summary>
		/// Gets the height of the cell in number of voxels.
		/// </summary>
		public int Height
		{
			get
			{
				return height;
			}
		}

		/// <summary>
		/// Gets the number of spans in the cell.
		/// </summary>
		public int SpanCount
		{
			get
			{
				return spans.Count;
			}
		}

		/// <summary>
		/// Gets the number of spans that are in walkable <see cref="Area"/>s.
		/// </summary>
		public int WalkableSpanCount
		{
			get
			{
				int count = 0;
				for (int i = 0; i < spans.Count; i++)
					if (spans[i].Area.IsWalkable)
						count++;

				return count;
			}
		}

		/// <summary>
		/// Gets a readonly list of all the <see cref="Span"/>s contained in the cell.
		/// </summary>
		/// <value>A readonly list of spans.</value>
		public ReadOnlyCollection<Span> Spans
		{
			get
			{
				return spans.AsReadOnly();
			}
		}

		/// <summary>
		/// Gets a modifiable list of all the <see cref="Span"/>s contained in the cell.
		/// Should only be used for filtering in <see cref="Heightfield"/>.
		/// </summary>
		/// <value>A list of spans for modification.</value>
		internal List<Span> MutableSpans
		{
			get
			{
				return spans;
			}
		}

		/// <summary>
		/// Gets the <see cref="Span"/> that contains the specified voxel.
		/// </summary>
		/// <param name="location">The voxel to search for.</param>
		/// <returns>The span containing the voxel. Null if the voxel is empty.</returns>
		public Span? this[int location]
		{
			get
			{
				if (location < 0 || location >= height)
					throw new ArgumentOutOfRangeException("Location must be a value between 0 and " + height + ".");

				//iterate the list of spans
				foreach (Span s in spans)
				{
					if (s.Minimum > location)
						break;
					else if (s.Maximum >= location)
						return s;
				}

				return null;
			}
		}

		/// <summary>
		/// Adds a <see cref="Span"/> to the cell.
		/// </summary>
		/// <param name="span">A span.</param>
		/// <exception cref="ArgumentException">Thrown if an invalid span is provided.</exception>
		public void AddSpan(Span span)
		{
			if (span.Minimum > span.Maximum)
			{
				int tmp = span.Minimum;
				span.Minimum = span.Maximum;
				span.Maximum = tmp;
			}

			//clamp the span to the cell's range of [0, maxHeight]
			MathHelper.Clamp(ref span.Minimum, 0, height);
			MathHelper.Clamp(ref span.Maximum, 0, height);

			lock (spans)
			{
				for (int i = 0; i < spans.Count; i++)
				{
					//Check whether the current span is below, or overlapping existing spans.
					//If the span is completely above the current span the loop will continue.
					Span cur = spans[i];
					if (cur.Minimum > span.Maximum)
					{
						//The new span is below the current one and is not intersecting.
						spans.Insert(i, span);
						return;
					}
					else if (cur.Maximum >= span.Minimum)
					{
						//The new span is colliding with the current one, merge them together.
						if (cur.Minimum < span.Minimum)
							span.Minimum = cur.Minimum;

						if (cur.Maximum == span.Maximum)
						{
							//In the case that both spans end at the same voxel, the area gets merged. The new span's area
							//has priority if both spans are walkable, so the only case where the area gets set is when
							//the new area isn't walkable and the old one is.
							if (!span.Area.IsWalkable && cur.Area.IsWalkable)
								span.Area = cur.Area;
						}
						else if (cur.Maximum > span.Maximum)
						{
							span.Maximum = cur.Maximum;
							span.Area = cur.Area;
						}

						//Remove the current span and adjust i.
						//We do this to avoid duplicating the current span.
						spans.RemoveAt(i);
						i--;
					}
				}

				//If the span is not inserted, it is the highest span and will be added to the end.
				spans.Add(span);
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\CompactCell.cs:
 // Copyright (c) 2013 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System.Runtime.InteropServices;

namespace SharpNav
{
	/// <summary>
	/// Represents a cell in a <see cref="CompactHeightfield"/>.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CompactCell
	{
		/// <summary>
		/// The starting index of spans in a <see cref="CompactHeightfield"/> for this cell.
		/// </summary>
		public int StartIndex;

		/// <summary>
		/// The number of spans in a <see cref="CompactHeightfield"/> for this cell.
		/// </summary>
		public int Count;

		/// <summary>
		/// Initializes a new instance of the <see cref="CompactCell"/> struct.
		/// </summary>
		/// <param name="start">The start index.</param>
		/// <param name="count">The count.</param>
		public CompactCell(int start, int count)
		{
			StartIndex = start;
			Count = count;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\CompactHeightfield.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

using SharpNav.Geometry;

namespace SharpNav
{
	/// <summary>
	/// A more memory-compact heightfield that stores open spans of voxels instead of closed ones.
	/// </summary>
	public class CompactHeightfield
	{
		private BBox3 bounds;

		private int width, height, length;
		private float cellSize, cellHeight;

		private CompactCell[] cells;
		private CompactSpan[] spans;
		private Area[] areas;

		//distance field
		private int[] distances;
		private int maxDistance;

		//region
		private int maxRegions;
		private int borderSize;

		/// <summary>
		/// Initializes a new instance of the <see cref="CompactHeightfield"/> class.
		/// </summary>
		/// <param name="field">A <see cref="Heightfield"/> to build from.</param>
		/// <param name="settings">The settings to build with.</param>
		public CompactHeightfield(Heightfield field, NavMeshGenerationSettings settings)
			: this(field, settings.VoxelAgentHeight, settings.VoxelMaxClimb)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="CompactHeightfield"/> class.
		/// </summary>
		/// <param name="field">A <see cref="Heightfield"/> to build from.</param>
		/// <param name="walkableHeight">The maximum difference in height to filter.</param>
		/// <param name="walkableClimb">The maximum difference in slope to filter.</param>
		public CompactHeightfield(Heightfield field, int walkableHeight, int walkableClimb)
		{
			this.bounds = field.Bounds;
			this.width = field.Width;
			this.height = field.Height;
			this.length = field.Length;
			this.cellSize = field.CellSizeXZ;
			this.cellHeight = field.CellHeight;

			int spanCount = field.SpanCount;
			cells = new CompactCell[width * length];
			spans = new CompactSpan[spanCount];
			areas = new Area[spanCount];

			//iterate over the Heightfield's cells
			int spanIndex = 0;
			for (int i = 0; i < cells.Length; i++)
			{
				//get the heightfield span list, skip if empty
				var fs = field[i].Spans;
				if (fs.Count == 0)
					continue;

				CompactCell c = new CompactCell(spanIndex, 0);

				//convert the closed spans to open spans
				int lastInd = fs.Count - 1;
				for (int j = 0; j < lastInd; j++)
				{
					var s = fs[j];
					if (s.Area.IsWalkable)
					{
						CompactSpan.FromMinMax(s.Maximum, fs[j + 1].Minimum, out spans[spanIndex]);
						areas[spanIndex] = s.Area;
						spanIndex++;
						c.Count++;
					}
				}

				//the last closed span that has an "infinite" height
				var lastS = fs[lastInd];
				if (lastS.Area.IsWalkable)
				{
					spans[spanIndex] = new CompactSpan(fs[lastInd].Maximum, int.MaxValue);
					areas[spanIndex] = lastS.Area;
					spanIndex++;
					c.Count++;
				}

				cells[i] = c;
			}

			//set neighbor connections
			for (int z = 0; z < length; z++)
			{
				for (int x = 0; x < width; x++)
				{
					CompactCell c = cells[z * width + x];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						CompactSpan s = spans[i];

						for (var dir = Direction.West; dir <= Direction.South; dir++)
						{
							int dx = x + dir.GetHorizontalOffset();
							int dz = z + dir.GetVerticalOffset();

							if (dx < 0 || dz < 0 || dx >= width || dz >= length)
								continue;

							CompactCell dc = cells[dz * width + dx];
							for (int j = dc.StartIndex, cellEnd = dc.StartIndex + dc.Count; j < cellEnd; j++)
							{
								CompactSpan ds = spans[j];

								int overlapBottom, overlapTop;
								CompactSpan.OverlapMin(ref s, ref ds, out overlapBottom);
								CompactSpan.OverlapMax(ref s, ref ds, out overlapTop);

								//Make sure that the agent can walk to the next span and that the span isn't a huge drop or climb
								if ((overlapTop - overlapBottom) >= walkableHeight && Math.Abs(ds.Minimum - s.Minimum) <= walkableClimb)
								{
									int con = j - dc.StartIndex;
									CompactSpan.SetConnection(dir, con, ref spans[i]);
									break;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Gets the width of the <see cref="CompactHeightfield"/> in voxel units.
		/// </summary>
		public int Width
		{
			get
			{
				return width;
			}
		}

		/// <summary>
		/// Gets the height of the <see cref="CompactHeightfield"/> in voxel units.
		/// </summary>
		public int Height
		{
			get
			{
				return height;
			}
		}

		/// <summary>
		/// Gets the length of the <see cref="CompactHeightfield"/> in voxel units.
		/// </summary>
		public int Length
		{
			get
			{
				return length;
			}
		}

		/// <summary>
		/// Gets the world-space bounding box.
		/// </summary>
		public BBox3 Bounds
		{
			get
			{
				return bounds;
			}
		}

		/// <summary>
		/// Gets the world-space size of a cell in the XZ plane.
		/// </summary>
		public float CellSize
		{
			get
			{
				return cellSize;
			}
		}

		/// <summary>
		/// Gets the world-space size of a cell in the Y direction.
		/// </summary>
		public float CellHeight
		{
			get
			{
				return cellHeight;
			}
		}

		/// <summary>
		/// Gets the maximum distance to a border based on the distance field. This value is undefined prior to
		/// calling <see cref="BuildDistanceField"/>.
		/// </summary>
		public int MaxDistance
		{
			get
			{
				return maxDistance;
			}
		}

		/// <summary>
		/// Gets an array of distances from a span to the nearest border. This value is undefined prior to calling
		/// <see cref="BuildDistanceField"/>.
		/// </summary>
		public int[] Distances
		{
			get
			{
				return distances;
			}
		}

		/// <summary>
		/// Gets the size of the border.
		/// </summary>
		public int BorderSize
		{
			get
			{
				return borderSize;
			}
		}

		/// <summary>
		/// Gets the maximum number of allowed regions.
		/// </summary>
		public int MaxRegions
		{
			get
			{
				return maxRegions;
			}
		}

		/// <summary>
		/// Gets the cells.
		/// </summary>
		public CompactCell[] Cells
		{
			get
			{
				return cells;
			}
		}

		/// <summary>
		/// Gets the spans.
		/// </summary>
		public CompactSpan[] Spans
		{
			get
			{
				return spans;
			}
		}

		/// <summary>
		/// Gets the area flags.
		/// </summary>
		public Area[] Areas
		{
			get
			{
				return areas;
			}
		}

		/// <summary>
		/// Gets an <see cref="IEnumerable{T}"/> of <see cref="CompactSpan"/> of the spans at a specified coordiante.
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		/// <returns>An <see cref="IEnumerable{T}"/> of <see cref="CompactSpan"/>.</returns>
		public IEnumerable<CompactSpan> this[int x, int y]
		{
			get
			{
				if (x < 0 || x >= width || y < 0 || y >= length)
					throw new IndexOutOfRangeException();

				CompactCell c = cells[y * width + x];

				int end = c.StartIndex + c.Count;
				for (int i = c.StartIndex; i < end; i++)
					yield return spans[i];
			}
		}

		/// <summary>
		/// Gets an <see cref="IEnumerable{T}"/> of <see cref="CompactSpan"/>s at a specified index.
		/// </summary>
		/// <param name="i">The index.</param>
		/// <returns>An <see cref="IEnumerable{T}"/> of <see cref="CompactSpan"/>.</returns>
		public IEnumerable<CompactSpan> this[int i]
		{
			get
			{
				CompactCell c = cells[i];

				int end = c.StartIndex + c.Count;
				for (int j = c.StartIndex; j < end; j++)
					yield return spans[j];
			}
		}

		/// <summary>
		/// Gets the <see cref="CompactSpan"/> specified by the reference.
		/// </summary>
		/// <param name="spanRef">A reference to a span in this <see cref="CompactHeightfield"/>.</param>
		/// <returns>The referenced span.</returns>
		public CompactSpan this[CompactSpanReference spanRef]
		{
			get
			{
				return spans[spanRef.Index];
			}
		}

		/// <summary>
		/// Builds a distance field, or the distance to the nearest unwalkable area.
		/// </summary>
		public void BuildDistanceField()
		{
			if (distances == null)
				distances = new int[spans.Length];

			//fill up all the values in src
			CalculateDistanceField(distances);

			//blur the distances
			BoxBlur(distances, 1, null);

			//find the maximum distance
			this.maxDistance = 0;
			for (int i = 0; i < distances.Length; i++)
				this.maxDistance = Math.Max(distances[i], this.maxDistance);
		}

		/// <summary>
		/// Erodes the walkable areas in the map.
		/// </summary>
		/// <remarks>
		/// If you have already called <see cref="BuildDistanceField"/>, it will automatically be called again after
		/// erosion because it needs to be recalculated.
		/// </remarks>
		/// <param name="radius">The radius to erode from unwalkable areas.</param>
		public void Erode(int radius)
		{
			radius *= 2;

			//get a distance field
			int[] dists = new int[spans.Length];
			CalculateDistanceField(dists);

			//erode close-to-null areas to null areas.
			for (int i = 0; i < spans.Length; i++)
				if (dists[i] < radius)
					areas[i] = Area.Null;

			//marking areas as null changes the distance field, so recalculate it.
			if (distances != null)
				BuildDistanceField();
		}

		/// <summary>
		/// The central method for building regions, which consists of connected, non-overlapping walkable spans.
		/// </summary>
		/// <param name="borderSize">The border size</param>
		/// <param name="minRegionArea">If smaller than this value, region will be null</param>
		/// <param name="mergeRegionArea">Reduce unneccesarily small regions</param>
		public void BuildRegions(int borderSize, int minRegionArea, int mergeRegionArea)
		{
			if (distances == null)
				BuildDistanceField();

			const int LogStackCount = 3;
			const int StackCount = 1 << LogStackCount;
			List<CompactSpanReference>[] stacks = new List<CompactSpanReference>[StackCount];
			for (int i = 0; i < stacks.Length; i++)
				stacks[i] = new List<CompactSpanReference>(1024);

			RegionId[] regions = new RegionId[spans.Length];
			int[] floodDistances = new int[spans.Length];

			RegionId[] regionBuffer = new RegionId[spans.Length];
			int[] distanceBuffer = new int[spans.Length];

			int regionIndex = 1;
			int level = ((maxDistance + 1) / 2) * 2;
			 
			const int ExpandIters = 8;

			if (borderSize > 0)
			{
				//make sure border doesn't overflow
				int borderWidth = Math.Min(width, borderSize);
				int borderHeight = Math.Min(length, borderSize);

				//fill regions
				FillRectangleRegion(regions, new RegionId(regionIndex++, RegionFlags.Border), 0, borderWidth, 0, length);
				FillRectangleRegion(regions, new RegionId(regionIndex++, RegionFlags.Border), width - borderWidth, width, 0, length);
				FillRectangleRegion(regions, new RegionId(regionIndex++, RegionFlags.Border), 0, width, 0, borderHeight);
				FillRectangleRegion(regions, new RegionId(regionIndex++, RegionFlags.Border), 0, width, length - borderHeight, length);

				this.borderSize = borderSize;
			}

			int stackId = -1;
			while (level > 0)
			{
				level = level >= 2 ? level - 2 : 0;
				stackId = (stackId + 1) & (StackCount - 1);

				if (stackId == 0)
					SortCellsByLevel(regions, stacks, level, StackCount, 1);
				else
					AppendStacks(stacks[stackId - 1], stacks[stackId], regions);

				//expand current regions until no new empty connected cells found
				ExpandRegions(regions, floodDistances, ExpandIters, level, stacks[stackId], regionBuffer, distanceBuffer);

				//mark new regions with ids
				for (int j = 0; j < stacks[stackId].Count; j++)
				{
					var spanRef = stacks[stackId][j];
					if (spanRef.Index >= 0 && regions[spanRef.Index] == 0)
						if (FloodRegion(regions, floodDistances, regionIndex, level, ref spanRef))
							regionIndex++;
				}
			}

			//expand current regions until no new empty connected cells found
			ExpandRegions(regions, floodDistances, ExpandIters * 8, 0, null, regionBuffer, distanceBuffer);

			//filter out small regions
			this.maxRegions = FilterSmallRegions(regions, minRegionArea, mergeRegionArea, regionIndex);

			//write the result out
			for (int i = 0; i < spans.Length; i++)
				spans[i].Region = regions[i];
		}

		/// <summary>
		/// Merge two stacks to get a single stack.
		/// </summary>
		/// <param name="source">The original stack</param>
		/// <param name="destination">The new stack</param>
		/// <param name="regions">Region ids</param>
		private static void AppendStacks(List<CompactSpanReference> source, List<CompactSpanReference> destination, RegionId[] regions)
		{
			for (int j = 0; j < source.Count; j++)
			{
				var spanRef = source[j];
				if (spanRef.Index < 0 || regions[spanRef.Index] != 0)
					continue;

				destination.Add(spanRef);
			}
		}

		/// <summary>
		/// Discards regions that are too small. 
		/// </summary>
		/// <param name="regionIds">region data</param>
		/// <param name="minRegionArea">The minimum area a region can have</param>
		/// <param name="mergeRegionSize">The size of the regions after merging</param>
		/// <param name="maxRegionId">determines the number of regions available</param>
		/// <returns>The reduced number of regions.</returns>
		private int FilterSmallRegions(RegionId[] regionIds, int minRegionArea, int mergeRegionSize, int maxRegionId)
		{
			int numRegions = maxRegionId + 1;
			Region[] regions = new Region[numRegions];

			//construct regions
			for (int i = 0; i < numRegions; i++)
				regions[i] = new Region(i);

			//find edge of a region and find connections around a contour
			for (int y = 0; y < length; y++)
			{
				for (int x = 0; x < width; x++)
				{
					CompactCell c = cells[x + y * width];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						CompactSpanReference spanRef = new CompactSpanReference(x, y, i);

						//HACK since the border region flag makes r negative, I changed r == 0 to r <= 0. Figure out exactly what maxRegionId's purpose is and see if Region.IsBorderOrNull is all we need.
						int r = (int)regionIds[i];
						if (r <= 0 || (int)r >= numRegions)
							continue;

						Region reg = regions[(int)r];
						reg.SpanCount++;

						//update floors
						for (int j = c.StartIndex; j < end; j++)
						{
							if (i == j) continue;
							RegionId floorId = regionIds[j];
							if (floorId == 0 || (int)floorId >= numRegions)
								continue;
							reg.AddUniqueFloorRegion(floorId);
						}

						//have found contour
						if (reg.Connections.Count > 0)
							continue;

						reg.AreaType = areas[i];

						//check if this cell is next to a border
						for (var dir = Direction.West; dir <= Direction.South; dir++)
						{
							if (IsSolidEdge(regionIds, ref spanRef, dir))
							{
								//The cell is at a border. 
								//Walk around contour to find all neighbors
								WalkContour(regionIds, spanRef, dir, reg.Connections);
								break;
							}
						}
					}
				}
			}

			//Remove too small regions
			Stack<RegionId> stack = new Stack<RegionId>();
			List<RegionId> trace = new List<RegionId>();
			for (int i = 0; i < numRegions; i++)
			{
				Region reg = regions[i];
				if (reg.IsBorderOrNull || reg.SpanCount == 0 || reg.Visited)
					continue;

				//count the total size of all connected regions
				//also keep track of the regions connections to a tile border
				bool connectsToBorder = false;
				int spanCount = 0;
				stack.Clear();
				trace.Clear();

				reg.Visited = true;
				stack.Push(reg.Id);

				while (stack.Count > 0)
				{
					//pop
					RegionId ri = stack.Pop();

					Region creg = regions[(int)ri];

					spanCount += creg.SpanCount;
					trace.Add(ri);

					for (int j = 0; j < creg.Connections.Count; j++)
					{
						if (RegionId.HasFlags(creg.Connections[j], RegionFlags.Border))
						{
							connectsToBorder = true;
							continue;
						}

						Region neiReg = regions[(int)creg.Connections[j]];
						if (neiReg.Visited || neiReg.IsBorderOrNull)
							continue;

						//visit
						stack.Push(neiReg.Id);
						neiReg.Visited = true;
					}
				}

				//if the accumulated region size is too small, remove it
				//do not remove areas which connect to tile borders as their size can't be estimated correctly
				//and removing them can potentially remove necessary areas
				if (spanCount < minRegionArea && !connectsToBorder)
				{
					//kill all visited regions
					for (int j = 0; j < trace.Count; j++)
					{
						int index = (int)trace[j];

						regions[index].SpanCount = 0;
						regions[index].Id = RegionId.Null;
					}
				}
			}

			//Merge too small regions to neighbor regions
			int mergeCount = 0;
			do
			{
				mergeCount = 0;
				for (int i = 0; i < numRegions; i++)
				{
					Region reg = regions[i];
					if (reg.IsBorderOrNull || reg.SpanCount == 0)
						continue;

					//check to see if region should be merged
					if (reg.SpanCount > mergeRegionSize && reg.IsConnectedToBorder())
						continue;

					//small region with more than one connection or region which is not connected to border at all
					//find smallest neighbor that connects to this one
					int smallest = int.MaxValue;
					RegionId mergeId = reg.Id;
					for (int j = 0; j < reg.Connections.Count; j++)
					{
						if (RegionId.HasFlags(reg.Connections[j], RegionFlags.Border))
							continue;

						Region mreg = regions[(int)reg.Connections[j]];
						if (mreg.IsBorderOrNull)
							continue;

						if (mreg.SpanCount < smallest && reg.CanMergeWith(mreg) && mreg.CanMergeWith(reg))
						{
							smallest = mreg.SpanCount;
							mergeId = mreg.Id;
						}
					}

					//found new id
					if (mergeId != reg.Id)
					{
						RegionId oldId = reg.Id;
						Region target = regions[(int)mergeId];

						//merge regions
						if (target.MergeWithRegion(reg))
						{
							//fix regions pointing to current region
							for (int j = 0; j < numRegions; j++)
							{
								if (regions[j].IsBorderOrNull)
									continue;

								//if another regions was already merged into current region
								//change the nid of the previous region too
								if (regions[j].Id == oldId)
									regions[j].Id = mergeId;

								//replace current region with new one if current region is neighbor
								regions[j].ReplaceNeighbour(oldId, mergeId);
							}

							mergeCount++;
						}
					}
				}
			}
			while (mergeCount > 0);

			//Compress region ids
			for (int i = 0; i < numRegions; i++)
			{
				regions[i].Remap = false;

				if (regions[i].IsBorderOrNull)
					continue;

				regions[i].Remap = true;
			}

			int regIdGen = 0;
			for (int i = 0; i < numRegions; i++)
			{
				if (!regions[i].Remap)
					continue;

				RegionId oldId = regions[i].Id;
				RegionId newId = new RegionId(++regIdGen);
				for (int j = i; j < numRegions; j++)
				{
					if (regions[j].Id == oldId)
					{
						regions[j].Id = newId;
						regions[j].Remap = false;
					}
				}
			}

			//Remap regions
			for (int i = 0; i < spans.Length; i++)
			{
				if (!RegionId.HasFlags(regionIds[i], RegionFlags.Border))
					regionIds[i] = regions[(int)regionIds[i]].Id;
			}

			return regIdGen;
		}

		/// <summary>
		/// A distance field estimates how far each span is from its nearest border span. This data is needed for region generation.
		/// </summary>
		/// <param name="src">Array of values, each corresponding to an individual span</param>
		private void CalculateDistanceField(int[] src)
		{
			//initialize distance and points
			for (int i = 0; i < spans.Length; i++)
				src[i] = int.MaxValue;

			//mark boundary cells
			for (int y = 0; y < length; y++)
			{
				for (int x = 0; x < width; x++)
				{
					CompactCell c = cells[y * width + x];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						CompactSpan s = spans[i];
						Area area = areas[i];

						bool isBoundary = false;
						if (s.ConnectionCount != 4)
							isBoundary = true;
						else
						{
							for (var dir = Direction.West; dir <= Direction.South; dir++)
							{
								int dx = x + dir.GetHorizontalOffset();
								int dy = y + dir.GetVerticalOffset();
								int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, dir);
								if (area != areas[di])
								{
									isBoundary = true;
									break;
								}
							}
						}

						if (isBoundary)
							src[i] = 0;
					}
				}
			}

			//pass 1
			for (int y = 0; y < length; y++)
			{
				for (int x = 0; x < width; x++)
				{
					CompactCell c = cells[y * width + x];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						CompactSpan s = spans[i];

						if (s.IsConnected(Direction.West))
						{
							//(-1, 0)
							int dx = x + Direction.West.GetHorizontalOffset();
							int dy = y + Direction.West.GetVerticalOffset();
							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, Direction.West);
							CompactSpan ds = spans[di];
							if (src[di] + 2 < src[i])
								src[i] = src[di] + 2;

							//(-1, -1)
							if (ds.IsConnected(Direction.South))
							{
								int ddx = dx + Direction.South.GetHorizontalOffset();
								int ddy = dy + Direction.South.GetVerticalOffset();
								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds, Direction.South);
								if (src[ddi] + 3 < src[i])
									src[i] = src[ddi] + 3;
							}
						}

						if (s.IsConnected(Direction.South))
						{
							//(0, -1)
							int dx = x + Direction.South.GetHorizontalOffset();
							int dy = y + Direction.South.GetVerticalOffset();
							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, Direction.South);
							CompactSpan ds = spans[di];
							if (src[di] + 2 < src[i])
								src[i] = src[di] + 2;

							//(1, -1)
							if (ds.IsConnected(Direction.East))
							{
								int ddx = dx + Direction.East.GetHorizontalOffset();
								int ddy = dy + Direction.East.GetVerticalOffset();
								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds, Direction.East);
								if (src[ddi] + 3 < src[i])
									src[i] = src[ddi] + 3;
							}
						}
					}
				}
			}

			//pass 2
			for (int y = length - 1; y >= 0; y--)
			{
				for (int x = width - 1; x >= 0; x--)
				{
					CompactCell c = cells[y * width + x];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						CompactSpan s = spans[i];

						if (s.IsConnected(Direction.East))
						{
							//(1, 0)
							int dx = x + Direction.East.GetHorizontalOffset();
							int dy = y + Direction.East.GetVerticalOffset();
							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, Direction.East);
							CompactSpan ds = spans[di];
							if (src[di] + 2 < src[i])
								src[i] = src[di] + 2;

							//(1, 1)
							if (ds.IsConnected(Direction.North))
							{
								int ddx = dx + Direction.North.GetHorizontalOffset();
								int ddy = dy + Direction.North.GetVerticalOffset();
								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds, Direction.North);
								if (src[ddi] + 3 < src[i])
									src[i] = src[ddi] + 3;
							}
						}

						if (s.IsConnected(Direction.North))
						{
							//(0, 1)
							int dx = x + Direction.North.GetHorizontalOffset();
							int dy = y + Direction.North.GetVerticalOffset();
							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, Direction.North);
							CompactSpan ds = spans[di];
							if (src[di] + 2 < src[i])
								src[i] = src[di] + 2;

							//(-1, 1)
							if (ds.IsConnected(Direction.West))
							{
								int ddx = dx + Direction.West.GetHorizontalOffset();
								int ddy = dy + Direction.West.GetVerticalOffset();
								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds, Direction.West);
								if (src[ddi] + 3 < src[i])
									src[i] = src[ddi] + 3;
							}
						}
					}
				}
			}
		}
		
		/// <summary>
		/// Part of building the distance field. It may or may not return an array equal to src.
		/// </summary>
		/// <param name="distances">The original distances.</param>
		/// <param name="threshold">The distance threshold below which no blurring occurs.</param>
		/// <param name="buffer">A buffer that is at least the same length as <see cref="distances"/> for working memory.</param>
		private void BoxBlur(int[] distances, int threshold, int[] buffer)
		{
			threshold *= 2;

			//if the optional buffer parameter wasn't passed in, or is too small, make a new one.
			if (buffer == null || buffer.Length < distances.Length)
				buffer = new int[distances.Length];

			Buffer.BlockCopy(distances, 0, buffer, 0, distances.Length * sizeof(int)); 

			//horizontal pass
			for (int y = 0; y < length; y++)
			{
				for (int x = 0; x < width; x++)
				{
					CompactCell c = cells[y * width + x];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						CompactSpan s = spans[i];
						int cellDist = buffer[i];

						//if the distance is below the threshold, skip the span.
						if (cellDist <= threshold)
							continue;

						//iterate the full neighborhood of 8 spans.
						int d = cellDist;
						for (Direction dir = Direction.West; dir <= Direction.South; dir++)
						{
							if (s.IsConnected(dir))
							{
								int dx = x + dir.GetHorizontalOffset();
								int dy = y + dir.GetVerticalOffset();
								int di = cells[dy * width + dx].StartIndex + CompactSpan.GetConnection(ref s, dir);

								d += buffer[di];

								CompactSpan ds = spans[di];
								Direction dir2 = dir.NextClockwise();
								if (ds.IsConnected(dir2))
								{
									int dx2 = dx + dir2.GetHorizontalOffset();
									int dy2 = dy + dir2.GetVerticalOffset();
									int di2 = cells[dy2 * width + dx2].StartIndex + CompactSpan.GetConnection(ref ds, dir2);

									d += buffer[di2];
								}
								else
								{
									d += cellDist;
								}
							}
							else
							{
								//add the center span if there's no connection.
								d += cellDist * 2;
							}
						}

						//save new value to destination
						distances[i] = (d + 5) / 9;
					}
				}
			}
		}

		/// <summary>
		/// Expands regions to include spans above a specified water level.
		/// </summary>
		/// <param name="regions">The array of region IDs.</param>
		/// <param name="floodDistances">The array of flooding distances.</param>
		/// <param name="maxIterations">The maximum number of allowed iterations before breaking.</param>
		/// <param name="level">The current water level.</param>
		/// <param name="stack">A stack of span references that are being expanded.</param>
		/// <param name="regionBuffer">A buffer to store region IDs. Must be at least the same size as <c>regions</c>.</param>
		/// <param name="distanceBuffer">A buffer to store flood distances. Must be at least the same size as <c>floodDistances</c>.</param>
		private void ExpandRegions(RegionId[] regions, int[] floodDistances, int maxIterations, int level, List<CompactSpanReference> stack, RegionId[] regionBuffer, int[] distanceBuffer)
		{
			//generate buffers if they're not passed in or if they're too small.
			if (regionBuffer == null || regionBuffer.Length < regions.Length)
				regionBuffer = new RegionId[regions.Length];

			if (distanceBuffer == null || distanceBuffer.Length < floodDistances.Length)
				distanceBuffer = new int[floodDistances.Length];

			//copy existing data into the buffers.
			Array.Copy(regions, 0, regionBuffer, 0, regions.Length);
			Array.Copy(floodDistances, 0, distanceBuffer, 0, floodDistances.Length);

			//find cells that are being expanded to.
			if (stack == null)
			{
				stack = new List<CompactSpanReference>();
				for (int y = 0; y < length; y++)
				{
					for (int x = 0; x < width; x++)
					{
						CompactCell c = cells[x + y * width];
						for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
						{
							//a cell is being expanded to if it's distance is greater than the current level,
							//but no region has been asigned yet. It must also not be in a null area.
							if (this.distances[i] >= level && regions[i] == 0 && areas[i].IsWalkable)
								stack.Add(new CompactSpanReference(x, y, i));
						}
					}
				}
			}
			else
			{
				for (int j = 0; j < stack.Count; j++)
				{
					if (regions[stack[j].Index] != 0)
						stack[j] = CompactSpanReference.Null;
				}
			}

			//assign regions to all the cells that are being expanded to.
			//will run until it's done or it runs maxIterations times.
			int iter = 0;
			while (stack.Count > 0)
			{
				//spans in the stack that are skipped:
				// - assigned a region ID in an earlier iteration
				// - not neighboring any spans with region IDs
				int skipped = 0;

				for (int j = 0; j < stack.Count; j++)
				{
					CompactSpanReference spanRef = stack[j];
					int x = spanRef.X;
					int y = spanRef.Y;
					int i = spanRef.Index;

					//skip regions already assigned to
					if (i < 0)
					{
						skipped++;
						continue;
					}

					RegionId r = regions[i];
					Area area = areas[i];
					CompactSpan s = spans[i];

					//search direct neighbors for the one with the smallest distance value
					int minDist = int.MaxValue;
					for (var dir = Direction.West; dir <= Direction.South; dir++)
					{
						if (!s.IsConnected(dir))
							continue;

						int dx = x + dir.GetHorizontalOffset();
						int dy = y + dir.GetVerticalOffset();
						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, dir);

						if (areas[di] != area)
							continue;

						//compare distance to previous best
						RegionId ri = regions[di];
						int dist = floodDistances[di];
						if (!(ri.IsNull || RegionId.HasFlags(ri, RegionFlags.Border)))
						{
							//set region and distance if better
							if (dist + 2 < minDist)
							{
								r = ri;
								minDist = dist + 2;
							}
						}
					}

					if (r != 0)
					{
						//set the region and distance for this span
						regionBuffer[i] = r;
						distanceBuffer[i] = minDist;

						//mark this item in the stack as assigned for the next iteration.
						stack[j] = CompactSpanReference.Null;
					}
					else
					{
						//skip spans that don't neighbor any regions
						skipped++;
					}
				}

				//if the entire stack is being skipped, we're done.
				if (skipped == stack.Count)
					break;

				//Copy from the buffers back to the original arrays. This is done after each iteration
				//because changing it in-place has some side effects for the other spans in the stack.
				Array.Copy(regionBuffer, 0, regions, 0, regions.Length);
				Array.Copy(distanceBuffer, 0, floodDistances, 0, floodDistances.Length);

				if (level > 0)
				{
					//if we hit maxIterations before expansion is done, break out anyways.
					++iter;
					if (iter >= maxIterations)
						break;
				}
			}
		}

		/// <summary>
		/// Floods the regions at a certain level
		/// </summary>
		/// <param name="regions">source region</param>
		/// <param name="floodDistances">source distances</param>
		/// <param name="regionIndex">region id</param>
		/// <param name="level">current level</param>
		/// <param name="start">A reference to the starting span.</param>
		/// <returns>Always true.</returns>
		private bool FloodRegion(RegionId[] regions, int[] floodDistances, int regionIndex, int level, ref CompactSpanReference start)
		{
			//TODO this method should always return true, make it not return a bool?
			//flood fill mark region
			Stack<CompactSpanReference> stack = new Stack<CompactSpanReference>();
			stack.Push(start);

			Area area = areas[start.Index];
			regions[start.Index] = new RegionId(regionIndex);
			floodDistances[start.Index] = 0;

			int lev = level >= 2 ? level - 2 : 0;
			int count = 0;

			while (stack.Count > 0)
			{
				CompactSpanReference cell = stack.Pop();
				CompactSpan cs = spans[cell.Index];

				//check if any of the neighbors already have a valid reigon set
				RegionId ar = RegionId.Null;
				for (var dir = Direction.West; dir <= Direction.South; dir++)
				{
					//8 connected
					if (cs.IsConnected(dir))
					{
						int dx = cell.X + dir.GetHorizontalOffset();
						int dy = cell.Y + dir.GetVerticalOffset();
						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref cs, dir);

						if (areas[di] != area)
							continue;

						RegionId nr = regions[di];

						if (RegionId.HasFlags(nr, RegionFlags.Border)) //skip borders
							continue;

						if (nr != 0 && nr != regionIndex)
						{
							ar = nr;
							break;
						}

						CompactSpan ds = spans[di];
						Direction dir2 = dir.NextClockwise();
						if (ds.IsConnected(dir2))
						{
							int dx2 = dx + dir2.GetHorizontalOffset();
							int dy2 = dy + dir2.GetVerticalOffset();
							int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds, dir2);

							if (areas[di2] != area)
								continue;

							RegionId nr2 = regions[di2];
							if (nr2 != 0 && nr2 != regionIndex)
							{
								ar = nr2;
								break;
							}
						}
					}
				}

				if (ar != 0)
				{
					regions[cell.Index] = RegionId.Null;
					continue;
				}

				count++;

				//expand neighbors
				for (var dir = Direction.West; dir <= Direction.South; dir++)
				{
					if (cs.IsConnected(dir))
					{
						int dx = cell.X + dir.GetHorizontalOffset();
						int dy = cell.Y + dir.GetVerticalOffset();
						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref cs, dir);

						if (areas[di] != area)
							continue;

						if (distances[di] >= lev && regions[di] == 0)
						{
							regions[di] = new RegionId(regionIndex);
							floodDistances[di] = 0;
							stack.Push(new CompactSpanReference(dx, dy, di));
						}
					}
				}
			}

			return count > 0;
		}

		/// <summary>
		/// Checks whether the edge from a span in a direction is a solid edge.
		/// A solid edge is an edge between two regions.
		/// </summary>
		/// <param name="regions">The region ID array.</param>
		/// <param name="spanRef">A reference to the span connected to the edge.</param>
		/// <param name="dir">The direction of the edge.</param>
		/// <returns>A value indicating whether the described edge is solid.</returns>
		private bool IsSolidEdge(RegionId[] regions, ref CompactSpanReference spanRef, Direction dir)
		{
			CompactSpan s = spans[spanRef.Index];
			RegionId r = RegionId.Null;

			if (s.IsConnected(dir))
			{
				int dx = spanRef.X + dir.GetHorizontalOffset();
				int dy = spanRef.Y + dir.GetVerticalOffset();
				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, dir);
				r = regions[di];
			}

			if (r == regions[spanRef.Index])
				return false;

			return true;
		}

		/// <summary>
		/// Try to visit all the spans. May be needed in filtering small regions. 
		/// </summary>
		/// <param name="regions">an array of region values</param>
		/// <param name="spanRef">The span to start walking from.</param>
		/// <param name="dir">The direction to start walking in.</param>
		/// <param name="cont">A collection of regions to append to.</param>
		private void WalkContour(RegionId[] regions, CompactSpanReference spanRef, Direction dir, List<RegionId> cont)
		{
			Direction startDir = dir;
			int starti = spanRef.Index;

			CompactSpan ss = spans[starti];
			RegionId curReg = RegionId.Null;

			if (ss.IsConnected(dir))
			{
				int dx = spanRef.X + dir.GetHorizontalOffset();
				int dy = spanRef.Y + dir.GetVerticalOffset();
				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref ss, dir);
				curReg = regions[di];
			}

			cont.Add(curReg);

			int iter = 0;
			while (++iter < 40000)
			{
				CompactSpan s = spans[spanRef.Index];

				if (IsSolidEdge(regions, ref spanRef, dir))
				{
					//choose the edge corner
					RegionId r = RegionId.Null;
					if (s.IsConnected(dir))
					{
						int dx = spanRef.X + dir.GetHorizontalOffset();
						int dy = spanRef.Y + dir.GetVerticalOffset();
						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, dir);
						r = regions[di];
					}

					if (r != curReg)
					{
						curReg = r;
						cont.Add(curReg);
					}

					dir = dir.NextClockwise(); //rotate clockwise
				}
				else
				{
					int di = -1;
					int dx = spanRef.X + dir.GetHorizontalOffset();
					int dy = spanRef.Y + dir.GetVerticalOffset();

					if (s.IsConnected(dir))
					{
						CompactCell dc = cells[dx + dy * width];
						di = dc.StartIndex + CompactSpan.GetConnection(ref s, dir);
					}

					if (di == -1)
					{
						//shouldn't happen
						return;
					}

					spanRef = new CompactSpanReference(dx, dy, di);
					dir = dir.NextCounterClockwise(); //rotate counterclockwise
				}

				if (starti == spanRef.Index && startDir == dir)
					break;
			}

			//remove adjacent duplicates
			if (cont.Count > 1)
			{
				for (int j = 0; j < cont.Count;)
				{
					//next element
					int nj = (j + 1) % cont.Count;

					//adjacent duplicate found
					if (cont[j] == cont[nj]) 
						cont.RemoveAt(j);
					else
						j++; 
				}
			}
		}

		/// <summary>
		/// Fill in a rectangular area with a region ID. Spans in a null area are skipped.
		/// </summary>
		/// <param name="regions">The region ID array.</param>
		/// <param name="newRegionId">The ID to fill in.</param>
		/// <param name="left">The left edge of the rectangle.</param>
		/// <param name="right">The right edge of the rectangle.</param>
		/// <param name="bottom">The bottom edge of the rectangle.</param>
		/// <param name="top">The top edge of the rectangle.</param>
		private void FillRectangleRegion(RegionId[] regions, RegionId newRegionId, int left, int right, int bottom, int top)
		{
			for (int y = bottom; y < top; y++)
			{
				for (int x = left; x < right; x++)
				{
					CompactCell c = cells[x + y * width];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						if (areas[i].IsWalkable)
							regions[i] = newRegionId;
					}
				}
			}
		}

		/// <summary>
		/// Sort the compact spans
		/// </summary>
		/// <param name="regions">Region data</param>
		/// <param name="stacks">Temporary stack of CompactSpanReference values</param>
		/// <param name="startlevel">Starting level</param>
		/// <param name="numStacks">The number of layers</param>
		/// <param name="logLevelsPerStack">log base 2 of stack levels</param>
		private void SortCellsByLevel(RegionId[] regions, List<CompactSpanReference>[] stacks, int startlevel, int numStacks, int logLevelsPerStack)
		{
			startlevel = startlevel >> logLevelsPerStack;
			for (int j = 0; j < numStacks; j++)
				stacks[j].Clear();

			for (int y = 0; y < length; y++)
			{
				for (int x = 0; x < width; x++)
				{
					CompactCell c = cells[y * width + x];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						if (!areas[i].IsWalkable || !regions[i].IsNull)
							continue;

						int level = distances[i] >> logLevelsPerStack;
						int sId = startlevel - level;
						if (sId >= numStacks)
							continue;
						if (sId < 0)
							sId = 0;

						stacks[sId].Add(new CompactSpanReference(x, y, i));
					}
				}
			}
		}

		/// <summary>
		/// Builds a set of <see cref="Contour"/>s around the generated regions. Must be called after regions are generated.
		/// </summary>
		/// <param name="settings">Settings for building the <see cref="ContourSet"/>.</param>
		/// <returns>A <see cref="ContourSet"/> containing one contour per region.</returns>
		public ContourSet BuildContourSet(NavMeshGenerationSettings settings)
		{
			return BuildContourSet(settings.MaxEdgeError, settings.MaxEdgeLength, settings.ContourFlags);
		}

		/// <summary>
		/// Builds a set of <see cref="Contour"/>s around the generated regions. Must be called after regions are generated.
		/// </summary>
		/// <param name="maxError">The maximum allowed deviation in a simplified contour from a raw one.</param>
		/// <param name="maxEdgeLength">The maximum edge length.</param>
		/// <param name="buildFlags">Flags that change settings for the build process.</param>
		/// <returns>A <see cref="ContourSet"/> containing one contour per region.</returns>
		public ContourSet BuildContourSet(float maxError, int maxEdgeLength, ContourBuildFlags buildFlags)
		{
			BBox3 contourSetBounds = bounds;
			if (borderSize > 0)
			{
				//remove offset
				float pad = borderSize * cellSize;
				contourSetBounds.Min.X += pad;
				contourSetBounds.Min.Z += pad;
				contourSetBounds.Max.X -= pad;
				contourSetBounds.Max.Z -= pad;
			}

			int contourSetWidth = width - borderSize * 2;
			int contourSetLength = length - borderSize * 2;

			int maxContours = Math.Max(maxRegions, 8);
			var contours = new List<Contour>(maxContours);

			EdgeFlags[] flags = new EdgeFlags[spans.Length];

			//Modify flags array by using the CompactHeightfield data
			//mark boundaries
			for (int z = 0; z < length; z++)
			{
				for (int x = 0; x < width; x++)
				{
					//loop through all the spans in the cell
					CompactCell c = cells[x + z * width];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						CompactSpan s = spans[i];

						//set the flag to 0 if the region is a border region or null.
						if (s.Region.IsNull || RegionId.HasFlags(s.Region, RegionFlags.Border))
						{
							flags[i] = 0;
							continue;
						}

						//go through all the neighboring cells
						for (var dir = Direction.West; dir <= Direction.South; dir++)
						{
							//obtain region id
							RegionId r = RegionId.Null;
							if (s.IsConnected(dir))
							{
								int dx = x + dir.GetHorizontalOffset();
								int dz = z + dir.GetVerticalOffset();
								int di = cells[dx + dz * width].StartIndex + CompactSpan.GetConnection(ref s, dir);
								r = spans[di].Region;
							}

							//region ids are equal
							if (r == s.Region)
							{
								//res marks all the internal edges
								EdgeFlagsHelper.AddEdge(ref flags[i], dir);
							}
						}

						//flags represents all the nonconnected edges, edges that are only internal
						//the edges need to be between different regions
						EdgeFlagsHelper.FlipEdges(ref flags[i]);
					}
				}
			}

			var verts = new List<ContourVertex>();
			var simplified = new List<ContourVertex>();

			for (int z = 0; z < length; z++)
			{
				for (int x = 0; x < width; x++)
				{
					CompactCell c = cells[x + z * width];
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						//flags is either 0000 or 1111
						//in other words, not connected at all 
						//or has all connections, which means span is in the middle and thus not an edge.
						if (flags[i] == EdgeFlags.None || flags[i] == EdgeFlags.All)
						{
							flags[i] = EdgeFlags.None;
							continue;
						}

						var spanRef = new CompactSpanReference(x, z, i);
						RegionId reg = this[spanRef].Region;
						if (reg.IsNull || RegionId.HasFlags(reg, RegionFlags.Border))
							continue;

						//reset each iteration
						verts.Clear();
						simplified.Clear();

						//Walk along a contour, then build it
						WalkContour(spanRef, flags, verts);
						Contour.Simplify(verts, simplified, maxError, maxEdgeLength, buildFlags);
						Contour.RemoveDegenerateSegments(simplified);
						Contour contour = new Contour(simplified, reg, areas[i], borderSize);

						if (!contour.IsNull)
							contours.Add(contour);
					}
				}
			}

			//Check and merge bad contours
			for (int i = 0; i < contours.Count; i++)
			{
				Contour cont = contours[i];

				//Check if contour is backwards
				if (cont.Area2D < 0)
				{
					//Find another contour to merge with
					int mergeIndex = -1;
					for (int j = 0; j < contours.Count; j++)
					{
						if (i == j)
							continue;

						//Must have at least one vertex, the same region ID, and be going forwards.
						Contour contj = contours[j];
						if (contj.Vertices.Length != 0 && contj.RegionId == cont.RegionId && contj.Area2D > 0)
						{
							mergeIndex = j;
							break;
						}
					}

					//Merge if found.
					if (mergeIndex != -1)
					{
						contours[mergeIndex].MergeWith(cont);
						contours.RemoveAt(i);
						i--;
					}
				}
			}

			return new ContourSet(contours, contourSetBounds, contourSetWidth, contourSetLength);
		}

		/// <summary>
		/// Initial generation of the contours
		/// </summary>
		/// <param name="spanReference">A referecne to the span to start walking from.</param>
		/// <param name="flags">An array of flags determinining </param>
		/// <param name="points">The vertices of a contour.</param>
		private void WalkContour(CompactSpanReference spanReference, EdgeFlags[] flags, List<ContourVertex> points)
		{
			Direction dir = Direction.West;

			//find the first direction that has a connection 
			while (!EdgeFlagsHelper.IsConnected(ref flags[spanReference.Index], dir))
				dir++;

			Direction startDir = dir;
			int startIndex = spanReference.Index;

			Area area = areas[startIndex];

			//TODO make the max iterations value a variable
			int iter = 0;
			while (++iter < 40000)
			{
				// this direction is connected
				if (EdgeFlagsHelper.IsConnected(ref flags[spanReference.Index], dir))
				{
					// choose the edge corner
					bool isBorderVertex;
					bool isAreaBorder = false;

					int px = spanReference.X;
					int py = GetCornerHeight(spanReference, dir, out isBorderVertex);
					int pz = spanReference.Y;

					switch (dir)
					{
						case Direction.West:
							pz++;
							break;
						case Direction.North:
							px++;
							pz++;
							break;
						case Direction.East:
							px++;
							break;
					}

					RegionId r = RegionId.Null;
					CompactSpan s = this[spanReference];
					if (s.IsConnected(dir))
					{
						int dx = spanReference.X + dir.GetHorizontalOffset();
						int dy = spanReference.Y + dir.GetVerticalOffset();
						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, dir);
						r = spans[di].Region;
						if (area != areas[di])
							isAreaBorder = true;
					}

					// apply flags if neccessary
					if (isBorderVertex)
						r = RegionId.WithFlags(r, RegionFlags.VertexBorder);

					if (isAreaBorder)
						r = RegionId.WithFlags(r, RegionFlags.AreaBorder);

					//save the point
					points.Add(new ContourVertex(px, py, pz, r));

					EdgeFlagsHelper.RemoveEdge(ref flags[spanReference.Index], dir);	// remove visited edges
					dir = dir.NextClockwise();			// rotate clockwise
				}
				else
				{
					//get a new cell(x, y) and span index(i)
					int di = -1;
					int dx = spanReference.X + dir.GetHorizontalOffset();
					int dy = spanReference.Y + dir.GetVerticalOffset();

					CompactSpan s = this[spanReference];
					if (s.IsConnected(dir))
					{
						CompactCell dc = cells[dx + dy * width];
						di = dc.StartIndex + CompactSpan.GetConnection(ref s, dir);
					}

					if (di == -1)
					{
						// shouldn't happen
						// TODO if this shouldn't happen, this check shouldn't be necessary.
						throw new InvalidOperationException("Something went wrong");
					}

					spanReference = new CompactSpanReference(dx, dy, di);
					dir = dir.NextCounterClockwise(); // rotate counterclockwise
				}

				if (startIndex == spanReference.Index && startDir == dir)
					break;
			}
		}

		/// <summary>
		/// Helper method for WalkContour function
		/// </summary>
		/// <param name="sr">The span to get the corner height for.</param>
		/// <param name="dir">The direction to get the corner height from.</param>
		/// <param name="isBorderVertex">Determine whether the vertex is a border or not.</param>
		/// <returns>The corner height.</returns>
		private int GetCornerHeight(CompactSpanReference sr, Direction dir, out bool isBorderVertex)
		{
			isBorderVertex = false;

			CompactSpan s = this[sr];
			int cornerHeight = s.Minimum;
			Direction dirp = dir.NextClockwise(); //new clockwise direction

			RegionId[] cornerRegs = new RegionId[4];
			Area[] cornerAreas = new Area[4];

			//combine region and area codes in order to prevent border vertices, which are in between two areas, to be removed 
			cornerRegs[0] = s.Region;
			cornerAreas[0] = areas[sr.Index];

			if (s.IsConnected(dir))
			{
				//get neighbor span
				int dx = sr.X + dir.GetHorizontalOffset();
				int dy = sr.Y + dir.GetVerticalOffset();
				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, dir);
				CompactSpan ds = spans[di];

				cornerHeight = Math.Max(cornerHeight, ds.Minimum);
				cornerRegs[1] = spans[di].Region;
				cornerAreas[1] = areas[di];

				//get neighbor of neighbor's span
				if (ds.IsConnected(dirp))
				{
					int dx2 = dx + dirp.GetHorizontalOffset();
					int dy2 = dy + dirp.GetVerticalOffset();
					int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds, dirp);
					CompactSpan ds2 = spans[di2];

					cornerHeight = Math.Max(cornerHeight, ds2.Minimum);
					cornerRegs[2] = ds2.Region;
					cornerAreas[2] = areas[di2];
				}
			}

			//get neighbor span
			if (s.IsConnected(dirp))
			{
				int dx = sr.X + dirp.GetHorizontalOffset();
				int dy = sr.Y + dirp.GetVerticalOffset();
				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s, dirp);
				CompactSpan ds = spans[di];

				cornerHeight = Math.Max(cornerHeight, ds.Minimum);
				cornerRegs[3] = ds.Region;
				cornerAreas[3] = areas[di];

				//get neighbor of neighbor's span
				if (ds.IsConnected(dir))
				{
					int dx2 = dx + dir.GetHorizontalOffset();
					int dy2 = dy + dir.GetVerticalOffset();
					int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds, dir);
					CompactSpan ds2 = spans[di2];

					cornerHeight = Math.Max(cornerHeight, ds2.Minimum);
					cornerRegs[2] = ds2.Region;
					cornerAreas[2] = areas[di2];
				}
			}

			//check if vertex is special edge vertex
			//if so, these vertices will be removed later
			for (int j = 0; j < 4; j++)
			{
				int a = j;
				int b = (j + 1) % 4;
				int c = (j + 2) % 4;
				int d = (j + 3) % 4;

				RegionId ra = cornerRegs[a], rb = cornerRegs[b], rc = cornerRegs[c], rd = cornerRegs[d];
				Area aa = cornerAreas[a], ab = cornerAreas[b], ac = cornerAreas[c], ad = cornerAreas[d];

				//the vertex is a border vertex if:
				//two same exterior cells in a row followed by two interior cells and none of the regions are out of bounds
				bool twoSameExteriors = RegionId.HasFlags(ra, RegionFlags.Border) && RegionId.HasFlags(rb, RegionFlags.Border) && (ra == rb && aa == ab);
				bool twoSameInteriors = !(RegionId.HasFlags(rc, RegionFlags.Border) || RegionId.HasFlags(rd, RegionFlags.Border));
				bool intsSameArea = ac == ad;
				bool noZeros = ra != 0 && rb != 0 && rc != 0 && rd != 0 && aa != 0 && ab != 0 && ac != 0 && ad != 0;
				if (twoSameExteriors && twoSameInteriors && intsSameArea && noZeros)
				{
					isBorderVertex = true;
					break;
				}
			}

			return cornerHeight;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\CompactSpan.cs:
 // Copyright (c) 2013-2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Runtime.InteropServices;

namespace SharpNav
{
	/// <summary>
	/// Represents a voxel span in a <see cref="CompactHeightfield"/>.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CompactSpan
	{
		/// <summary>
		/// The span minimum.
		/// </summary>
		public int Minimum;

		/// <summary>
		/// The number of voxels contained in the span.
		/// </summary>
		public int Height;

		/// <summary>
		/// A byte representing the index of the connected span in the cell directly to the west.
		/// </summary>
		public byte ConnectionWest;

		/// <summary>
		/// A byte representing the index of the connected span in the cell directly to the north.
		/// </summary>
		public byte ConnectionNorth;

		/// <summary>
		/// A byte representing the index of the connected span in the cell directly to the east.
		/// </summary>
		public byte ConnectionEast;

		/// <summary>
		/// A byte representing the index of the connected span in the cell directly to the south.
		/// </summary>
		public byte ConnectionSouth;

		/// <summary>
		/// The region the span belongs to.
		/// </summary>
		public RegionId Region;

		/// <summary>
		/// A constant that means there is no connection for the values <see cref="ConnectionWest"/>,
		/// <see cref="ConnectionNorth"/>, <see cref="ConnectionEast"/>, and <see cref="ConnectionSouth"/>.
		/// </summary>
		private const byte NotConnected = 0xff;

		/// <summary>
		/// Initializes a new instance of the <see cref="CompactSpan"/> struct.
		/// </summary>
		/// <param name="minimum">The span minimum.</param>
		/// <param name="height">The number of voxels the span contains.</param>
		public CompactSpan(int minimum, int height)
		{
			this.Minimum = minimum;
			this.Height = height;
			this.ConnectionWest = NotConnected;
			this.ConnectionNorth = NotConnected;
			this.ConnectionEast = NotConnected;
			this.ConnectionSouth = NotConnected;
			this.Region = RegionId.Null;
		}

		/// <summary>
		/// Gets a value indicating whether the span has an upper bound or goes to "infinity".
		/// </summary>
		public bool HasUpperBound
		{
			get
			{
				return Height != int.MaxValue;
			}
		}

		/// <summary>
		/// Gets the upper bound of the span.
		/// </summary>
		public int Maximum
		{
			get
			{
				return Minimum + Height;
			}
		}

		/// <summary>
		/// Gets the number of connections the current CompactSpan has with its neighbors.
		/// </summary>
		public int ConnectionCount
		{
			get
			{
				int count = 0;
				if (ConnectionWest != NotConnected)
					count++;
				if (ConnectionNorth != NotConnected)
					count++;
				if (ConnectionEast != NotConnected)
					count++;
				if (ConnectionSouth != NotConnected)
					count++;

				return count;
			}
		}

		/// <summary>
		/// If two CompactSpans overlap, find the minimum of the new overlapping CompactSpans.
		/// </summary>
		/// <param name="left">The first CompactSpan</param>
		/// <param name="right">The second CompactSpan</param>
		/// <param name="min">The minimum of the overlapping ComapctSpans</param>
		public static void OverlapMin(ref CompactSpan left, ref CompactSpan right, out int min)
		{
			min = Math.Max(left.Minimum, right.Minimum);
		}

		/// <summary>
		/// If two CompactSpans overlap, find the maximum of the new overlapping CompactSpans.
		/// </summary>
		/// <param name="left">The first CompactSpan</param>
		/// <param name="right">The second CompactSpan</param>
		/// <param name="max">The maximum of the overlapping CompactSpans</param>
		public static void OverlapMax(ref CompactSpan left, ref CompactSpan right, out int max)
		{
			if (left.Height == int.MaxValue)
			{
				if (right.Height == int.MaxValue)
					max = int.MaxValue;
				else
					max = right.Minimum + right.Height;
			}
			else if (right.Height == int.MaxValue)
				max = left.Minimum + left.Height;
			else
				max = Math.Min(left.Minimum + left.Height, right.Minimum + right.Height);
		}

		/// <summary>
		/// Creates a <see cref="CompactSpan"/> from a minimum boundary and a maximum boundary.
		/// </summary>
		/// <param name="min">The minimum.</param>
		/// <param name="max">The maximum.</param>
		/// <returns>A <see cref="CompactSpan"/>.</returns>
		public static CompactSpan FromMinMax(int min, int max)
		{
			CompactSpan s;
			FromMinMax(min, max, out s);
			return s;
		}

		/// <summary>
		/// Creates a <see cref="CompactSpan"/> from a minimum boundary and a maximum boundary.
		/// </summary>
		/// <param name="min">The minimum.</param>
		/// <param name="max">The maximum.</param>
		/// <param name="span">A <see cref="CompactSpan"/>.</param>
		public static void FromMinMax(int min, int max, out CompactSpan span)
		{
			span.Minimum = min;
			span.Height = max - min;
			span.ConnectionWest = NotConnected;
			span.ConnectionNorth = NotConnected;
			span.ConnectionEast = NotConnected;
			span.ConnectionSouth = NotConnected;
			span.Region = RegionId.Null;
		}

		/// <summary>
		/// Sets connection data to a span contained in a neighboring cell.
		/// </summary>
		/// <param name="dir">The direction of the cell.</param>
		/// <param name="i">The index of the span in the neighboring cell.</param>
		/// <param name="s">The <see cref="CompactSpan"/> to set the data for.</param>
		public static void SetConnection(Direction dir, int i, ref CompactSpan s)
		{
			if (i >= NotConnected)
				throw new ArgumentOutOfRangeException("Index of connecting span is too high to be stored. Try increasing cell height.", "i");

			switch (dir)
			{
				case Direction.West:
					s.ConnectionWest = (byte)i;
					break;
				case Direction.North:
					s.ConnectionNorth = (byte)i;
					break;
				case Direction.East:
					s.ConnectionEast = (byte)i;
					break;
				case Direction.South:
					s.ConnectionSouth = (byte)i;
					break;
				default:
					throw new ArgumentException("dir isn't a valid Direction.");
			}
		}

		/// <summary>
		/// Un-sets connection data from a neighboring cell.
		/// </summary>
		/// <param name="dir">The direction of the cell.</param>
		/// <param name="s">The <see cref="CompactSpan"/> to set the data for.</param>
		public static void UnsetConnection(Direction dir, ref CompactSpan s)
		{
			switch (dir)
			{
				case Direction.West:
					s.ConnectionWest = NotConnected;
					break;
				case Direction.North:
					s.ConnectionNorth = NotConnected;
					break;
				case Direction.East:
					s.ConnectionEast = NotConnected;
					break;
				case Direction.South:
					s.ConnectionSouth = NotConnected;
					break;
				default:
					throw new ArgumentException("dir isn't a valid Direction.");
			}
		}

		/// <summary>
		/// Gets the connection data for a neighboring cell in a specified direction.
		/// </summary>
		/// <param name="s">The <see cref="CompactSpan"/> to get the connection data from.</param>
		/// <param name="dir">The direction.</param>
		/// <returns>The index of the span in the neighboring cell.</returns>
		public static int GetConnection(ref CompactSpan s, Direction dir)
		{
			switch (dir)
			{
				case Direction.West:
					return s.ConnectionWest;
				case Direction.North:
					return s.ConnectionNorth;
				case Direction.East:
					return s.ConnectionEast;
				case Direction.South:
					return s.ConnectionSouth;
				default:
					throw new ArgumentException("dir isn't a valid Direction.");
			}
		}

		/// <summary>
		/// Gets the connection data for a neighboring call in a specified direction.
		/// </summary>
		/// <param name="dir">The direction.</param>
		/// <returns>The index of the span in the neighboring cell.</returns>
		public int GetConnection(Direction dir)
		{
			return GetConnection(ref this, dir);
		}

		/// <summary>
		/// Gets a value indicating whether the span is connected to another span in a specified direction.
		/// </summary>
		/// <param name="dir">The direction.</param>
		/// <returns>A value indicating whether the specified direction has a connected span.</returns>
		public bool IsConnected(Direction dir)
		{
			switch (dir)
			{
				case Direction.West:
					return ConnectionWest != NotConnected;
				case Direction.North:
					return ConnectionNorth != NotConnected;
				case Direction.East:
					return ConnectionEast != NotConnected;
				case Direction.South:
					return ConnectionSouth != NotConnected;
				default:
					throw new ArgumentException("dir isn't a valid Direction.");
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\CompactSpanReference.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Runtime.InteropServices;

namespace SharpNav
{
	/// <summary>
	/// A reference to a <see cref="CompactSpan"/> in a <see cref="CompactHeightfield"/>.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct CompactSpanReference : IEquatable<CompactSpanReference>
	{
		/// <summary>
		/// A "null" reference is one with a negative index.
		/// </summary>
		public static readonly CompactSpanReference Null = new CompactSpanReference(0, 0, -1);

		/// <summary>
		/// The X coordinate of the referenced span.
		/// </summary>
		public readonly int X;

		/// <summary>
		/// The Y coordinate of the referenced span.
		/// </summary>
		public readonly int Y;

		/// <summary>
		/// The index of the referenced span in the spans array.
		/// </summary>
		public readonly int Index;

		/// <summary>
		/// Initializes a new instance of the <see cref="CompactSpanReference"/> struct.
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		/// <param name="i">The index of the span in the spans array.</param>
		public CompactSpanReference(int x, int y, int i)
		{
			this.X = x;
			this.Y = y;
			this.Index = i;
		}

		/// <summary>
		/// Compares two instances of <see cref="CompactSpanReference"/> for equality.
		/// </summary>
		/// <remarks>
		/// If both references have a negative <see cref="Index"/>, they are considered equal, as both would be considered "null".
		/// </remarks>
		/// <param name="left">A reference.</param>
		/// <param name="right">Another reference.</param>
		/// <returns>A value indicating whether the two references are equal.</returns>
		public static bool operator ==(CompactSpanReference left, CompactSpanReference right)
		{
			//A negative index is considered null.
			//these two cases quickly compare null references.
			bool leftNull = left.Index < 0, rightNull = right.Index < 0;
			if (leftNull && rightNull)
				return true;
			else if (leftNull ^ rightNull)
				return false;

			//if the references are not null, 
			else if (left.X == right.X && left.Y == right.Y && left.Index == right.Index)
				return true;

			return false;
		}

		/// <summary>
		/// Compare two instances of <see cref="CompactSpanReference"/> for inequality.
		/// </summary>
		/// <remarks>
		/// If both references have a negative <see cref="Index"/>, they are considered equal, as both would be considered "null".
		/// </remarks>
		/// <param name="left">A reference.</param>
		/// <param name="right">Another reference.</param>
		/// <returns>A value indicating whether the two references are not equal.</returns>
		public static bool operator !=(CompactSpanReference left, CompactSpanReference right)
		{
			return !(left == right);
		}

		/// <summary>
		/// Compares this instance to another instance of <see cref="CompactSpanReference"/> for equality.
		/// </summary>
		/// <param name="other">Another instance of <see cref="CompactSpanReference"/>.</param>
		/// <returns>A value indicating whether this instance and another instance are equal.</returns>
		public bool Equals(CompactSpanReference other)
		{
			return this == other;
		}

		/// <summary>
		/// Compares this instance to another object for equality.
		/// </summary>
		/// <param name="obj">An object.</param>
		/// <returns>A value indicating whether the object is equal to this instance.</returns>
		public override bool Equals(object obj)
		{
			CompactSpanReference? r = obj as CompactSpanReference?;
			if (r.HasValue)
				return this == r.Value;
			return false;
		}

		/// <summary>
		/// Gets a hash code unique to this instance.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			//TODO should "null" references all have the same hash?
			int hash = 27;
			hash = (13 * hash) + X.GetHashCode();
			hash = (13 * hash) + Y.GetHashCode();
			hash = (13 * hash) + Index.GetHashCode();

			return hash;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Contour.cs:
 // Copyright (c) 2013-2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System.Collections.Generic;

using SharpNav.Geometry;

namespace SharpNav
{
	/// <summary>
	/// A contour is formed from a region.
	/// </summary>
	public class Contour
	{
		//simplified vertices have much less edges
		private ContourVertex[] vertices;
		private RegionId regionId;
		private Area area;

		/// <summary>
		/// Initializes a new instance of the <see cref="Contour"/> class.
		/// </summary>
		/// <param name="verts">The raw vertices of the contour.</param>
		/// <param name="region">The region ID of the contour.</param>
		/// <param name="area">The area ID of the contour.</param>
		/// <param name="borderSize">The size of the border.</param>
		public Contour(List<ContourVertex> verts, RegionId region, Area area, int borderSize)
		{
			this.vertices = verts.ToArray();
			this.regionId = region;
			this.area = area;

			//remove offset
			if (borderSize > 0)
			{
				for (int j = 0; j < vertices.Length; j++)
				{
					vertices[j].X -= borderSize;
					vertices[j].Z -= borderSize;
				}
			}
		}

		/// <summary>
		/// Gets the simplified vertices of the contour.
		/// </summary>
		public ContourVertex[] Vertices
		{
			get
			{
				return vertices;
			}
		}

		/// <summary>
		/// Gets a value indicating whether the contour is "null" (has less than 3 vertices).
		/// </summary>
		public bool IsNull
		{
			get
			{
				//TODO operator overload == and != with null?
				if (vertices == null || vertices.Length < 3)
					return true;

				return false;
			}
		}

		/// <summary>
		/// Gets the area ID of the contour.
		/// </summary>
		public Area Area
		{
			get
			{
				return area;
			}
		}

		/// <summary>
		/// Gets the region ID of the contour.
		/// </summary>
		public RegionId RegionId
		{
			get
			{
				return regionId;
			}
		}

		/// <summary>
		/// Gets the 2D area of the contour. A positive area means the contour is going forwards, a negative
		/// area maens it is going backwards.
		/// </summary>
		public int Area2D
		{
			get
			{
				int area = 0;
				for (int i = 0, j = vertices.Length - 1; i < vertices.Length; j = i++)
				{
					ContourVertex vi = vertices[i], vj = vertices[j];
					area += vi.X * vj.Z - vj.X * vi.Z;
				}

				return (area + 1) / 2; 
			}
		}

		/// <summary>
		/// Merges another contour into this instance.
		/// </summary>
		/// <param name="contour">The contour to merge.</param>
		public void MergeWith(Contour contour)
		{
			int lengthA = vertices.Length;
			int lengthB = contour.vertices.Length;

			int ia, ib;
			GetClosestIndices(this, contour, out ia, out ib);

			//create a list with the capacity set to the max number of possible verts to avoid expanding the list.
			var newVerts = new List<ContourVertex>(vertices.Length + contour.vertices.Length + 2);

			//copy contour A
			for (int i = 0; i <= lengthA; i++)
				newVerts.Add(vertices[(ia + i) % lengthA]);

			//add contour B (other contour) to contour A (this contour)
			for (int i = 0; i <= lengthB; i++)
				newVerts.Add(contour.vertices[(ib + i) % lengthB]);

			vertices = newVerts.ToArray();
			
			//delete the other contour
			contour.vertices = null;
		}

		/// <summary>
		/// Finds the closest indices between two contours. Useful for merging contours.
		/// </summary>
		/// <param name="a">A contour.</param>
		/// <param name="b">Another contour.</param>
		/// <param name="indexA">The nearest index on contour A.</param>
		/// <param name="indexB">The nearest index on contour B.</param>
		private static void GetClosestIndices(Contour a, Contour b, out int indexA, out int indexB)
		{
			int closestDistance = int.MaxValue;
			int lengthA = a.vertices.Length;
			int lengthB = b.vertices.Length;

			indexA = -1;
			indexB = -1;

			for (int i = 0; i < lengthA; i++)
			{
				int vertA = i;
				int vertANext = (i + 1) % lengthA;
				int vertAPrev = (i + lengthA - 1) % lengthA;

				for (int j = 0; j < lengthB; j++)
				{
					int vertB = j;

					//vertB must be infront of vertA
					if (ContourVertex.IsLeft(ref a.vertices[vertAPrev], ref a.vertices[vertA], ref b.vertices[vertB]) &&
						ContourVertex.IsLeft(ref a.vertices[vertA], ref a.vertices[vertANext], ref b.vertices[vertB]))
					{
						int dx = b.vertices[vertB].X - a.vertices[vertA].X;
						int dz = b.vertices[vertB].Z - a.vertices[vertA].Z;
						int tempDist = dx * dx + dz * dz;
						if (tempDist < closestDistance)
						{
							indexA = i;
							indexB = j;
							closestDistance = tempDist;
						}
					}
				}
			}
		}

		/// <summary>
		/// Simplify the contours by reducing the number of edges
		/// </summary>
		/// <param name="rawVerts">Initial vertices</param>
		/// <param name="simplified">New and simplified vertices</param>
		/// <param name="maxError">Maximum error allowed</param>
		/// <param name="maxEdgeLen">The maximum edge length allowed</param>
		/// <param name="buildFlags">Flags determines how to split the long edges</param>
		public static void Simplify(List<ContourVertex> rawVerts, List<ContourVertex> simplified, float maxError, int maxEdgeLen, ContourBuildFlags buildFlags)
		{
			bool tesselateWallEdges = (buildFlags & ContourBuildFlags.TessellateWallEdges) == ContourBuildFlags.TessellateWallEdges;
			bool tesselateAreaEdges = (buildFlags & ContourBuildFlags.TessellateAreaEdges) == ContourBuildFlags.TessellateAreaEdges;

			//add initial points
			bool hasConnections = false;
			for (int i = 0; i < rawVerts.Count; i++)
			{
				if (rawVerts[i].RegionId.Id != 0)
				{
					hasConnections = true;
					break;
				}
			}

			if (hasConnections)
			{
				//contour has some portals to other regions
				//add new point to every location where region changes
				for (int i = 0, end = rawVerts.Count; i < end; i++)
				{
					int ii = (i + 1) % end;
					bool differentRegions = rawVerts[i].RegionId.Id != rawVerts[ii].RegionId.Id;
					bool areaBorders = RegionId.HasFlags(rawVerts[i].RegionId, RegionFlags.AreaBorder) != RegionId.HasFlags(rawVerts[ii].RegionId, RegionFlags.AreaBorder);

					if (differentRegions || areaBorders)
					{
						simplified.Add(new ContourVertex(rawVerts[i], i));
					}
				}
			}

			//add some points if thhere are no connections
			if (simplified.Count == 0)
			{
				//find lower-left and upper-right vertices of contour
				int lowerLeftX = rawVerts[0].X;
				int lowerLeftY = rawVerts[0].Y;
				int lowerLeftZ = rawVerts[0].Z;
				RegionId lowerLeftI = RegionId.Null;

				int upperRightX = rawVerts[0].X;
				int upperRightY = rawVerts[0].Y;
				int upperRightZ = rawVerts[0].Z;
				RegionId upperRightI = RegionId.Null;

				//iterate through points
				for (int i = 0; i < rawVerts.Count; i++)
				{
					int x = rawVerts[i].X;
					int y = rawVerts[i].Y;
					int z = rawVerts[i].Z;

					if (x < lowerLeftX || (x == lowerLeftX && z < lowerLeftZ))
					{
						lowerLeftX = x;
						lowerLeftY = y;
						lowerLeftZ = z;
						lowerLeftI = new RegionId(i);
					}

					if (x > upperRightX || (x == upperRightX && z > upperRightZ))
					{
						upperRightX = x;
						upperRightY = y;
						upperRightZ = z;
						upperRightI = new RegionId(i);
					}
				}

				//save the points
				simplified.Add(new ContourVertex(lowerLeftX, lowerLeftY, lowerLeftZ, lowerLeftI));
				simplified.Add(new ContourVertex(upperRightX, upperRightY, upperRightZ, upperRightI));
			}

			//add points until all points are within error tolerance of simplified slope
			int numPoints = rawVerts.Count;
			for (int i = 0; i < simplified.Count;)
			{
				int ii = (i + 1) % simplified.Count;

				//obtain (x, z) coordinates, along with region id
				int ax = simplified[i].X;
				int az = simplified[i].Z;
				int ai = (int)simplified[i].RegionId;

				int bx = simplified[ii].X;
				int bz = simplified[ii].Z;
				int bi = (int)simplified[ii].RegionId;

				float maxDeviation = 0;
				int maxi = -1;
				int ci, countIncrement, endi;

				//traverse segment in lexilogical order (try to go from smallest to largest coordinates?)
				if (bx > ax || (bx == ax && bz > az))
				{
					countIncrement = 1;
					ci = (int)(ai + countIncrement) % numPoints;
					endi = (int)bi;
				}
				else
				{
					countIncrement = numPoints - 1;
					ci = (int)(bi + countIncrement) % numPoints;
					endi = (int)ai;
				}

				//tessellate only outer edges or edges between areas
				if (rawVerts[ci].RegionId.Id == 0 || RegionId.HasFlags(rawVerts[ci].RegionId, RegionFlags.AreaBorder))
				{
					//find the maximum deviation
					while (ci != endi)
					{
						float deviation = Distance.PointToSegment2DSquared(rawVerts[ci].X, rawVerts[ci].Z, ax, az, bx, bz);

						if (deviation > maxDeviation)
						{
							maxDeviation = deviation;
							maxi = ci;
						}

						ci = (ci + countIncrement) % numPoints;
					}
				}

				//If max deviation is larger than accepted error, add new point
				if (maxi != -1 && maxDeviation > (maxError * maxError))
				{
					simplified.Insert(i + 1, new ContourVertex(rawVerts[maxi], maxi));
				}
				else
				{
					i++;
				}
			}

			//split too long edges
			if (maxEdgeLen > 0 && (tesselateAreaEdges || tesselateWallEdges))
			{
				for (int i = 0; i < simplified.Count;)
				{
					int ii = (i + 1) % simplified.Count;

					//get (x, z) coordinates along with region id
					int ax = simplified[i].X;
					int az = simplified[i].Z;
					int ai = (int)simplified[i].RegionId;

					int bx = simplified[ii].X;
					int bz = simplified[ii].Z;
					int bi = (int)simplified[ii].RegionId;

					//find maximum deviation from segment
					int maxi = -1;
					int ci = (int)(ai + 1) % numPoints;

					//tessellate only outer edges or edges between areas
					bool tess = false;

					//wall edges
					if (tesselateWallEdges && rawVerts[ci].RegionId.Id == 0)
						tess = true;

					//edges between areas
					if (tesselateAreaEdges && RegionId.HasFlags(rawVerts[ci].RegionId, RegionFlags.AreaBorder))
						tess = true;

					if (tess)
					{
						int dx = bx - ax;
						int dz = bz - az;
						if (dx * dx + dz * dz > maxEdgeLen * maxEdgeLen)
						{
							//round based on lexilogical direction (smallest to largest cooridinates, first by x.
							//if x coordinates are equal, then compare z coordinates)
							int n = bi < ai ? (bi + numPoints - ai) : (bi - ai);

							if (n > 1)
							{
								if (bx > ax || (bx == ax && bz > az))
									maxi = (int)(ai + n / 2) % numPoints;
								else
									maxi = (int)(ai + (n + 1) / 2) % numPoints;
							}
						}
					}

					//add new point
					if (maxi != -1)
					{
						simplified.Insert(i + 1, new ContourVertex(rawVerts[maxi], maxi));
					}
					else
					{
						i++;
					}
				}
			}

			for (int i = 0; i < simplified.Count; i++)
			{
				ContourVertex sv = simplified[i];

				//take edge vertex flag from current raw point and neighbor region from next raw point
				int ai = ((int)sv.RegionId + 1) % numPoints;
				RegionId bi = sv.RegionId;

				//save new region id
				sv.RegionId = RegionId.FromRawBits(((int)rawVerts[ai].RegionId & (RegionId.MaskId | (int)RegionFlags.AreaBorder)) | ((int)rawVerts[(int)bi].RegionId & (int)RegionFlags.VertexBorder));

				simplified[i] = sv;
			}
		}

		/// <summary>
		/// Removes degenerate segments from a simplified contour.
		/// </summary>
		/// <param name="simplified">The simplified contour.</param>
		public static void RemoveDegenerateSegments(List<ContourVertex> simplified)
		{
			//remove adjacent vertices which are equal on the xz-plane
			for (int i = 0; i < simplified.Count; i++)
			{
				int ni = i + 1;
				if (ni >= simplified.Count)
					ni = 0;

				if (simplified[i].X == simplified[ni].X &&
					simplified[i].Z == simplified[ni].Z)
				{
					//remove degenerate segment
					simplified.RemoveAt(i);
					i--;
				}
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\ContourBuildFlags.cs:
 // Copyright (c) 2013, 2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav
{
	/// <summary>
	/// A set of flags that control the way contours are built.
	/// </summary>
	[Flags]
	public enum ContourBuildFlags
	{
		/// <summary>Build normally.</summary>
		None = 0,

		/// <summary>Tessellate solid edges during contour simplification.</summary>
		TessellateWallEdges = 0x01,

		/// <summary>Tessellate edges between areas during contour simplification.</summary>
		TessellateAreaEdges = 0x02
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\ContourSet.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;
using System.Linq;

using SharpNav.Geometry;

namespace SharpNav
{
	//TODO should this be ISet<Contour>? Are the extra methods useful?
	
	/// <summary>
	/// A set of contours around the regions of a <see cref="CompactHeightfield"/>, used as the edges of a
	/// <see cref="PolyMesh"/>.
	/// </summary>
	public class ContourSet : ICollection<Contour>
	{
		private List<Contour> contours;
		private BBox3 bounds;
		private int width;
		private int height;

		/// <summary>
		/// Initializes a new instance of the <see cref="ContourSet"/> class.
		/// </summary>
		/// <param name="contours">A collection of <see cref="Contour"/>s.</param>
		/// <param name="bounds">The bounding box that contains all of the <see cref="Contour"/>s.</param>
		/// <param name="width">The width, in voxel units, of the world.</param>
		/// <param name="height">The height, in voxel units, of the world.</param>
		public ContourSet(IEnumerable<Contour> contours, BBox3 bounds, int width, int height)
		{
			this.contours = contours.ToList();
			this.bounds = bounds;
			this.width = width;
			this.height = height;
		}

		/// <summary>
		/// Gets the number of <see cref="Contour"/>s in the set.
		/// </summary>
		public int Count
		{
			get
			{
				return contours.Count;
			}
		}

		/// <summary>
		/// Gets the world-space bounding box of the set.
		/// </summary>
		public BBox3 Bounds
		{
			get
			{
				return bounds;
			}
		}

		/// <summary>
		/// Gets the width of the set, not including the border size specified in <see cref="CompactHeightfield"/>.
		/// </summary>
		public int Width
		{
			get
			{
				return width;
			}
		}

		/// <summary>
		/// Gets the height of the set, not including the border size specified in <see cref="CompactHeightfield"/>.
		/// </summary>
		public int Height
		{
			get
			{
				return height;
			}
		}

		/// <summary>
		/// Gets a value indicating whether the <see cref="ContourSet"/> is read-only.
		/// </summary>
		bool ICollection<Contour>.IsReadOnly
		{
			get { return true; }
		}

		/// <summary>
		/// Checks if a specified <see cref="ContourSet"/> is contained in the <see cref="ContourSet"/>.
		/// </summary>
		/// <param name="item">A contour.</param>
		/// <returns>A value indicating whether the set contains the specified contour.</returns>
		public bool Contains(Contour item)
		{
			return contours.Contains(item);
		}

		/// <summary>
		/// Copies the <see cref="Contour"/>s in the set to an array.
		/// </summary>
		/// <param name="array">The array to copy to.</param>
		/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
		public void CopyTo(Contour[] array, int arrayIndex)
		{
			contours.CopyTo(array, arrayIndex);
		}

		/// <summary>
		/// Returns an enumerator that iterates through the entire <see cref="ContourSet"/>.
		/// </summary>
		/// <returns>An enumerator.</returns>
		public IEnumerator<Contour> GetEnumerator()
		{
			return contours.GetEnumerator();
		}

		//TODO support the extra ICollection methods later?

		/// <summary>
		/// Add a new contour to the set
		/// </summary>
		/// <param name="item">The contour to add</param>
		void ICollection<Contour>.Add(Contour item)
		{
			throw new InvalidOperationException();
		}
		
		/// <summary>
		/// (Not implemented) Clear the list
		/// </summary>
		void ICollection<Contour>.Clear()
		{
			throw new InvalidOperationException();
		}

		/// <summary>
		/// (Not implemented) Remove a contour from the set
		/// </summary>
		/// <param name="item">The contour to remove</param>
		/// <returns>throw InvalidOperatorException</returns>
		bool ICollection<Contour>.Remove(Contour item)
		{
			throw new InvalidOperationException();
		}

		/// <summary>
		/// Gets an enumerator that iterates through the set
		/// </summary>
		/// <returns>The enumerator</returns>
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\ContourVertex.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System.Runtime.InteropServices;

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// A <see cref="ContourVertex"/> is a vertex that stores 3 integer coordinates and a region ID, and is used to build <see cref="Contour"/>s.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct ContourVertex
	{
		/// <summary>
		/// The X coordinate.
		/// </summary>
		public int X;

		/// <summary>
		/// The Y coordinate.
		/// </summary>
		public int Y;

		/// <summary>
		/// The Z coordinate.
		/// </summary>
		public int Z;

		/// <summary>
		/// The region that the vertex belongs to.
		/// </summary>
		public RegionId RegionId;

		/// <summary>
		/// Initializes a new instance of the <see cref="ContourVertex"/> struct.
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		/// <param name="z">The Z coordinate.</param>
		/// <param name="region">The region ID.</param>
		public ContourVertex(int x, int y, int z, RegionId region)
		{
			this.X = x;
			this.Y = y;
			this.Z = z;
			this.RegionId = region;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="SharpNav.ContourVertex"/> struct.
		/// </summary>
		/// <param name="vec">The array of X,Y,Z coordinates.</param>
		/// <param name="region">The Region ID.</param>
		public ContourVertex(Vector3 vec, RegionId region)
		{
			this.X = (int)vec.X;
			this.Y = (int)vec.Y;
			this.Z = (int)vec.Z;
			this.RegionId = region;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="ContourVertex"/> struct as a copy.
		/// </summary>
		/// <param name="vert">The original vertex.</param>
		/// <param name="index">The index of the original vertex, which is temporarily stored in the <see cref="RegionId"/> field.</param>
		public ContourVertex(ContourVertex vert, int index)
		{
			this.X = vert.X;
			this.Y = vert.Y;
			this.Z = vert.Z;
			this.RegionId = new RegionId(index);
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="ContourVertex"/> struct as a copy.
		/// </summary>
		/// <param name="vert">The original vertex.</param>
		/// <param name="region">The region that the vertex belongs to.</param>
		public ContourVertex(ContourVertex vert, RegionId region)
		{
			this.X = vert.X;
			this.Y = vert.Y;
			this.Z = vert.Z;
			this.RegionId = region;
		}

		/// <summary>
		/// Gets the leftness of a triangle formed from 3 contour vertices.
		/// </summary>
		/// <param name="a">The first vertex.</param>
		/// <param name="b">The second vertex.</param>
		/// <param name="c">The third vertex.</param>
		/// <returns>A value indicating the leftness of the triangle.</returns>
		public static bool IsLeft(ref ContourVertex a, ref ContourVertex b, ref ContourVertex c)
		{
			int area;
			Area2D(ref a, ref b, ref c, out area);
			return area < 0;
		}

		/// <summary>
		/// Gets the 2D area of the triangle ABC.
		/// </summary>
		/// <param name="a">Point A of triangle ABC.</param>
		/// <param name="b">Point B of triangle ABC.</param>
		/// <param name="c">Point C of triangle ABC.</param>
		/// <param name="area">The 2D area of the triangle.</param>
		public static void Area2D(ref ContourVertex a, ref ContourVertex b, ref ContourVertex c, out int area)
		{
			area = (b.X - a.X) * (c.Z - a.Z) - (c.X - a.X) * (b.Z - a.Z);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Direction.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav
{
	/// <summary>
	/// A set of cardinal directions.
	/// </summary>
	public enum Direction
	{
		/// <summary>
		/// The west direction.
		/// </summary>
		West = 0,

		/// <summary>
		/// The north direction.
		/// </summary>
		North = 1,

		/// <summary>
		/// The east direction.
		/// </summary>
		East = 2,

		/// <summary>
		/// The south direction.
		/// </summary>
		South = 3
	}

	/// <summary>
	/// A set of extension methods to make using the Direction enum a lot simpler.
	/// </summary>
	public static class DirectionExtensions
	{
		private static readonly int[] OffsetsX = { -1, 0, 1, 0 };
		private static readonly int[] OffsetsY = { 0, 1, 0, -1 };

		/// <summary>
		/// Gets an X offset.
		/// </summary>
		/// <remarks>
		/// The directions cycle between the following, starting from 0: west, north, east, south.
		/// </remarks>
		/// <param name="dir">The direction.</param>
		/// <returns>The offset for the X coordinate.</returns>
		public static int GetHorizontalOffset(this Direction dir)
		{
			return OffsetsX[(int)dir];
		}

		/// <summary>
		/// Get a Y offset.
		/// </summary>
		/// <remarks>
		/// The directions cycle between the following, starting from 0: west, north, east, south.
		/// </remarks>
		/// <param name="dir">The direction.</param>
		/// <returns>The offset for the Y coordinate.</returns>
		public static int GetVerticalOffset(this Direction dir)
		{
			return OffsetsY[(int)dir];
		}

		/// <summary>
		/// Gets the next cardinal direction in clockwise order.
		/// </summary>
		/// <param name="dir">The current direction.</param>
		/// <returns>The next direction.</returns>
		public static Direction NextClockwise(this Direction dir)
		{
			switch (dir)
			{
				case Direction.West:
					return Direction.North;
				case Direction.North:
					return Direction.East;
				case Direction.East:
					return Direction.South;
				case Direction.South:
					return Direction.West;
				default:
					throw new ArgumentException("dir isn't a valid Direction.");
			}
		}

		/// <summary>
		/// Gets the next cardinal direction in counter-clockwise order.
		/// </summary>
		/// <param name="dir">The current direction.</param>
		/// <returns>The next direction.</returns>
		public static Direction NextCounterClockwise(this Direction dir)
		{
			switch (dir)
			{
				case Direction.West:
					return Direction.South;
				case Direction.South:
					return Direction.East;
				case Direction.East:
					return Direction.North;
				case Direction.North:
					return Direction.West;
				default:
					throw new ArgumentException("dir isn't a valid Direction.");
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\EdgeFlags.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav
{
	/// <summary>
	/// An enum similar to <see cref="Direction"/>, but with the ability to store multiple directions.
	/// </summary>
	[Flags]
	public enum EdgeFlags : byte
	{
		/// <summary>No edges are selected.</summary>
		None = 0x0,

		/// <summary>The west edge is selected.</summary>
		West = 0x1,

		/// <summary>The north edge is selected.</summary>
		North = 0x2,

		/// <summary>The east edge is selected.</summary>
		East = 0x4,

		/// <summary>The south edge is selected.</summary>
		South = 0x8,

		/// <summary>All of the edges are selected.</summary>
		All = West | North | East | South
	}

	/// <summary>
	/// A static class with helper functions to modify instances of the <see cref="EdgeFlags"/> enum.
	/// </summary>
	public static class EdgeFlagsHelper
	{
		/// <summary>
		/// Adds an edge in a specified direction to an instance of <see cref="EdgeFlags"/>.
		/// </summary>
		/// <param name="edges">An existing set of edges.</param>
		/// <param name="dir">The direction to add.</param>
		public static void AddEdge(ref EdgeFlags edges, Direction dir)
		{
			edges |= (EdgeFlags)(1 << (int)dir);
		}

		/// <summary>
		/// Flips the set of edges in an instance of <see cref="EdgeFlags"/>.
		/// </summary>
		/// <param name="edges">An existing set of edges.</param>
		public static void FlipEdges(ref EdgeFlags edges)
		{
			edges ^= EdgeFlags.All;
		}

		/// <summary>
		/// Determines whether an instance of <see cref="EdgeFlags"/> includes an edge in a specified direction.
		/// </summary>
		/// <param name="edges">A set of edges.</param>
		/// <param name="dir">The direction to check for an edge.</param>
		/// <returns>A value indicating whether the set of edges contains an edge in the specified direction.</returns>
		public static bool IsConnected(ref EdgeFlags edges, Direction dir)
		{
			return (edges & (EdgeFlags)(1 << (int)dir)) != EdgeFlags.None;
		}

		/// <summary>
		/// Removes an edge from an instance of <see cref="EdgeFlags"/>.
		/// </summary>
		/// <param name="edges">A set of edges.</param>
		/// <param name="dir">The direction to remove.</param>
		public static void RemoveEdge(ref EdgeFlags edges, Direction dir)
		{
			edges &= (EdgeFlags)(~(1 << (int)dir));
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Heightfield.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// A Heightfield represents a "voxel" grid represented as a 2-dimensional grid of <see cref="Cell"/>s.
	/// </summary>
	public partial class Heightfield
	{
		private BBox3 bounds;

		private int width, height, length;
		private float cellSize, cellHeight;

		private Cell[] cells;

		/// <summary>
		/// Initializes a new instance of the <see cref="Heightfield"/> class.
		/// </summary>
		/// <param name="b">The world-space bounds.</param>
		/// <param name="settings">The settings to build with.</param>
		public Heightfield(BBox3 b, NavMeshGenerationSettings settings)
			: this(b, settings.CellSize, settings.CellHeight)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="Heightfield"/> class.
		/// </summary>
		/// <param name="b">The world-space bounds.</param>
		/// <param name="cellSize">The world-space size of each cell in the XZ plane.</param>
		/// <param name="cellHeight">The world-space height of each cell.</param>
		public Heightfield(BBox3 b, float cellSize, float cellHeight)
		{
			if (!BBox3.IsValid(ref bounds))
				throw new ArgumentException("The bounds are considered invalid. See BBox3.IsValid for details.");

			if (cellSize <= 0)
				throw new ArgumentOutOfRangeException("cellSize", "Cell size must be greater than 0.");

			if (cellHeight <= 0)
				throw new ArgumentOutOfRangeException("cellHeight", "Cell height must be greater than 0.");

			this.cellSize = cellSize;
			this.cellHeight = cellHeight;
			this.bounds = b;

			//make sure the bbox contains all the possible voxels.
			width = (int)Math.Ceiling((b.Max.X - b.Min.X) / cellSize);
			height = (int)Math.Ceiling((b.Max.Y - b.Min.Y) / cellHeight);
			length = (int)Math.Ceiling((b.Max.Z - b.Min.Z) / cellSize);

			bounds.Max.X = bounds.Min.X + width * cellSize;
			bounds.Max.Y = bounds.Min.Y + height * cellHeight;
			bounds.Max.Z = bounds.Min.Z + length * cellSize;

			cells = new Cell[width * length];
			for (int i = 0; i < cells.Length; i++)
				cells[i] = new Cell(height);
		}

		/// <summary>
		/// Gets the bounding box of the heightfield.
		/// </summary>
		public BBox3 Bounds
		{
			get
			{
				return bounds;
			}
		}

		/// <summary>
		/// Gets the world-space minimum.
		/// </summary>
		/// <value>The minimum.</value>
		public Vector3 Minimum
		{
			get
			{
				return bounds.Min;
			}
		}

		/// <summary>
		/// Gets the world-space maximum.
		/// </summary>
		/// <value>The maximum.</value>
		public Vector3 Maximum
		{
			get
			{
				return bounds.Max;
			}
		}

		/// <summary>
		/// Gets the number of cells in the X direction.
		/// </summary>
		/// <value>The width.</value>
		public int Width
		{
			get
			{
				return width;
			}
		}

		/// <summary>
		/// Gets the number of cells in the Y (up) direction.
		/// </summary>
		/// <value>The height.</value>
		public int Height
		{
			get
			{
				return height;
			}
		}

		/// <summary>
		/// Gets the number of cells in the Z direction.
		/// </summary>
		/// <value>The length.</value>
		public int Length
		{
			get
			{
				return length;
			}
		}

		/// <summary>
		/// Gets the size of a cell (voxel).
		/// </summary>
		/// <value>The size of the cell.</value>
		public Vector3 CellSize
		{
			get
			{
				return new Vector3(cellSize, cellHeight, cellSize);
			}
		}

		/// <summary>
		/// Gets the size of a cell on the X and Z axes.
		/// </summary>
		public float CellSizeXZ
		{
			get
			{
				return cellSize;
			}
		}

		/// <summary>
		/// Gets the size of a cell on the Y axis.
		/// </summary>
		public float CellHeight
		{
			get
			{
				return cellHeight;
			}
		}

		/// <summary>
		/// Gets the total number of spans.
		/// </summary>
		public int SpanCount
		{
			get
			{
				int count = 0;
				for (int i = 0; i < cells.Length; i++)
					count += cells[i].WalkableSpanCount;

				return count;
			}
		}

		/// <summary>
		/// Gets the <see cref="Cell"/> at the specified coordinate.
		/// </summary>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		/// <returns>The cell at [x, y].</returns>
		public Cell this[int x, int y]
		{
			get
			{
				if (x < 0 || x >= width || y < 0 || y >= length)
					throw new ArgumentOutOfRangeException();

				return cells[y * width + x];
			}
		}

		/// <summary>
		/// Gets the <see cref="Cell"/> at the specified index.
		/// </summary>
		/// <param name="i">The index.</param>
		/// <returns>The cell at index i.</returns>
		public Cell this[int i]
		{
			get
			{
				if (i < 0 || i >= cells.Length)
					throw new ArgumentOutOfRangeException();

				return cells[i];
			}
		}

		/// <summary>
		/// Gets the <see cref="Span"/> at the reference.
		/// </summary>
		/// <param name="spanRef">A reference to a span.</param>
		/// <returns>The span at the reference.</returns>
		public Span this[SpanReference spanRef]
		{
			get
			{
				return cells[spanRef.Y * width + spanRef.X].Spans[spanRef.Index];
			}
		}

		/// <summary>
		/// Filters the heightmap to allow two neighboring spans have a small difference in maximum height (such as
		/// stairs) to be walkable.
		/// </summary>
		/// <remarks>
		/// This filter may override the results of <see cref="FilterLedgeSpans"/>.
		/// </remarks>
		/// <param name="walkableClimb">The maximum difference in height to filter.</param>
		public void FilterLowHangingWalkableObstacles(int walkableClimb)
		{
			//Loop through every cell in the Heightfield
			for (int i = 0; i < cells.Length; i++)
			{
				Cell c = cells[i];
				List<Span> spans = c.MutableSpans;

				//store the first span's data as the "previous" data
				Area prevArea = Area.Null;
				bool prevWalkable = prevArea != Area.Null;
				int prevMax = 0;

				//iterate over all the spans in the cell
				for (int j = 0; j < spans.Count; j++)
				{
					Span s = spans[j];
					bool walkable = s.Area != Area.Null;

					//if the current span isn't walkable but there's a walkable span right below it,
					//mark this span as walkable too.
					if (!walkable && prevWalkable)
					{
						if (Math.Abs(s.Maximum - prevMax) < walkableClimb)
							s.Area = prevArea;
					}

					//save changes back to the span list.
					spans[j] = s;

					//set the previous data for the next iteration
					prevArea = s.Area;
					prevWalkable = walkable;
					prevMax = s.Maximum;
				}
			}
		}

		/// <summary>
		/// If two spans have little vertical space in between them, 
		/// then span is considered unwalkable
		/// </summary>
		/// <param name="walkableHeight">The clearance.</param>
		public void FilterWalkableLowHeightSpans(int walkableHeight)
		{
			for (int i = 0; i < cells.Length; i++)
			{
				Cell c = cells[i];
				List<Span> spans = c.MutableSpans;

				//Iterate over all spans
				for (int j = 0; j < spans.Count - 1; j++)
				{
					Span currentSpan = spans[j];

					//too low, not enough space to walk through
					if ((spans[j + 1].Minimum - currentSpan.Maximum) <= walkableHeight)
					{
						currentSpan.Area = Area.Null;
						spans[j] = currentSpan;
					}
				}
			}
		}

		/// <summary>
		/// A ledge is unwalkable because the difference between the maximum height of two spans
		/// is too large of a drop (i.e. greater than walkableClimb).
		/// </summary>
		/// <param name="walkableHeight">The maximum walkable height to filter.</param>
		/// <param name="walkableClimb">The maximum walkable climb to filter.</param>
		public void FilterLedgeSpans(int walkableHeight, int walkableClimb)
		{
			//Mark border spans.
			//Parallel.For(0, length, y =>
			for (int y = 0; y < length; y++)
			{
				for (int x = 0; x < width; x++)
				{
					Cell c = cells[x + y * width];
					List<Span> spans = c.MutableSpans;

					//Examine all the spans in each cell
					for (int i = 0; i < spans.Count; i++)
					{
						Span currentSpan = spans[i];

						// Skip non walkable spans.
						if (currentSpan.Area == Area.Null)
							continue;

						int bottom = (int)currentSpan.Maximum;
						int top = (i == spans.Count - 1) ? int.MaxValue : spans[i + 1].Minimum;

						// Find neighbours minimum height.
						int minHeight = int.MaxValue;

						// Min and max height of accessible neighbours.
						int accessibleMin = currentSpan.Maximum;
						int accessibleMax = currentSpan.Maximum;

						for (var dir = Direction.West; dir <= Direction.South; dir++)
						{
							int dx = x + dir.GetHorizontalOffset();
							int dy = y + dir.GetVerticalOffset();

							// Skip neighbours which are out of bounds.
							if (dx < 0 || dy < 0 || dx >= width || dy >= length)
							{
								minHeight = Math.Min(minHeight, -walkableClimb - bottom);
								continue;
							}

							// From minus infinity to the first span.
							Cell neighborCell = cells[dy * width + dx];
							List<Span> neighborSpans = neighborCell.MutableSpans;
							int neighborBottom = -walkableClimb;
							int neighborTop = neighborSpans.Count > 0 ? neighborSpans[0].Minimum : int.MaxValue;

							// Skip neightbour if the gap between the spans is too small.
							if (Math.Min(top, neighborTop) - Math.Max(bottom, neighborBottom) > walkableHeight)
								minHeight = Math.Min(minHeight, neighborBottom - bottom);

							// Rest of the spans.
							for (int j = 0; j < neighborSpans.Count; j++)
							{
								Span currentNeighborSpan = neighborSpans[j];

								neighborBottom = currentNeighborSpan.Maximum;
								neighborTop = (j == neighborSpans.Count - 1) ? int.MaxValue : neighborSpans[j + 1].Minimum;

								// Skip neightbour if the gap between the spans is too small.
								if (Math.Min(top, neighborTop) - Math.Max(bottom, neighborBottom) > walkableHeight)
								{
									minHeight = Math.Min(minHeight, neighborBottom - bottom);

									// Find min/max accessible neighbour height.
									if (Math.Abs(neighborBottom - bottom) <= walkableClimb)
									{
										if (neighborBottom < accessibleMin) accessibleMin = neighborBottom;
										if (neighborBottom > accessibleMax) accessibleMax = neighborBottom;
									}
								}
							}
						}

						// The current span is close to a ledge if the drop to any
						// neighbour span is less than the walkableClimb.
						if (minHeight < -walkableClimb)
							currentSpan.Area = Area.Null;

						// If the difference between all neighbours is too large,
						// we are at steep slope, mark the span as ledge.
						if ((accessibleMax - accessibleMin) > walkableClimb)
							currentSpan.Area = Area.Null;

						//save span data
						spans[i] = currentSpan;
					}
				}
			}
			//});
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Heightfield.Rasterization.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;
using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <content>
	/// This file contains various methods to rasterize objects into voxel data.
	/// </content>
	public partial class Heightfield
	{
		//private ConcurrentQueue<Tuple<int, int, Span>> spanQueue;

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array with per-triangle area flags.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesIndexedWithAreas(Vector3[] verts, int[] inds, Area[] areas)
		{
			RasterizeTrianglesIndexedWithAreas(verts, inds, 0, 1, 0, inds.Length / 3, areas);
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array with per-triangle area flags.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="vertOffset">An offset into the vertex array.</param>
		/// <param name="vertStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (one Vector3 per vertex).</param>
		/// <param name="indexOffset">An offset into the index array.</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesIndexedWithAreas(Vector3[] verts, int[] inds, int vertOffset, int vertStride, int indexOffset, int triCount, Area[] areas)
		{
			int indexEnd = triCount * 3 + indexOffset;

			if (verts == null)
				throw new ArgumentNullException("verts");

			if (inds == null)
				throw new ArgumentNullException("inds");

			if (indexEnd > inds.Length)
				throw new ArgumentOutOfRangeException("indexCount", "The specified index offset and length end outside the provided index array.");

			if (vertOffset < 0)
				throw new ArgumentOutOfRangeException("vertOffset", "vertOffset must be greater than or equal to 0.");

			if (vertStride < 0)
				throw new ArgumentOutOfRangeException("vertStride", "vertStride must be greater than or equal to 0.");
			else if (vertStride == 0)
				vertStride = 1;

			if (areas.Length < triCount)
				throw new ArgumentException("There must be at least as many AreaFlags as there are triangles.", "areas");

			for (int i = indexOffset, j = 0; i < indexEnd; i += 3, j++)
			{
				int indA = inds[i] * vertStride + vertOffset;
				int indB = inds[i + 1] * vertStride + vertOffset;
				int indC = inds[i + 2] * vertStride + vertOffset;

				RasterizeTriangle(ref verts[indA], ref verts[indB], ref verts[indC], areas[j]);
			}
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array with per-triangle area flags.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesIndexedWithAreas(float[] verts, int[] inds, Area[] areas)
		{
			RasterizeTrianglesIndexedWithAreas(verts, inds, 0, 3, 0, inds.Length / 3, areas);
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array with per-triangle area flags.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="floatOffset">An offset into the vertex array.</param>
		/// <param name="floatStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (3 floats per vertex).</param>
		/// <param name="indexOffset">An offset into the index array.</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesIndexedWithAreas(float[] verts, int[] inds, int floatOffset, int floatStride, int indexOffset, int triCount, Area[] areas)
		{
			int indexEnd = triCount * 3 + indexOffset;

			if (verts == null)
				throw new ArgumentNullException("verts");

			if (inds == null)
				throw new ArgumentNullException("inds");

			if (indexEnd > inds.Length)
				throw new ArgumentOutOfRangeException("indexCount", "The specified index offset and length end outside the provided index array.");

			if (floatOffset < 0)
				throw new ArgumentOutOfRangeException("floatOffset", "floatOffset must be greater than or equal to 0.");

			if (floatStride < 0)
				throw new ArgumentOutOfRangeException("floatStride", "floatStride must be greater than or equal to 0.");
			else if (floatStride == 0)
				floatStride = 3;

			if (areas.Length < triCount)
				throw new ArgumentException("There must be at least as many AreaFlags as there are triangles.", "areas");

			Vector3 a, b, c;

			for (int i = indexOffset, j = 0; i < indexEnd; i += 3, j++)
			{
				int indA = inds[i] * floatStride + floatOffset;
				int indB = inds[i + 1] * floatStride + floatOffset;
				int indC = inds[i + 2] * floatStride + floatOffset;

				a.X = verts[indA];
				a.Y = verts[indA + 1];
				a.Z = verts[indA + 2];

				b.X = verts[indB];
				b.Y = verts[indB + 1];
				b.Z = verts[indB + 2];

				c.X = verts[indC];
				c.Y = verts[indC + 1];
				c.Z = verts[indC + 2];

				RasterizeTriangle(ref a, ref b, ref c, areas[j]);
			}
		}

		/// <summary>
		/// Rasterizes several triangles at once with per-triangle area flags.
		/// </summary>
		/// <param name="tris">An array of triangles.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesWithAreas(Triangle3[] tris, Area[] areas)
		{
			RasterizeTrianglesWithAreas(tris, 0, tris.Length, areas);
		}

		/// <summary>
		/// Rasterizes several triangles at once with per-triangle area flags.
		/// </summary>
		/// <param name="tris">An array of triangles.</param>
		/// <param name="triOffset">An offset into the array.</param>
		/// <param name="triCount">The number of triangles to rasterize, starting from the offset.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesWithAreas(Triangle3[] tris, int triOffset, int triCount, Area[] areas)
		{
			int triEnd = triOffset + triCount;

			if (tris == null)
				throw new ArgumentNullException("verts");

			if (triOffset < 0)
				throw new ArgumentOutOfRangeException("triOffset", "triOffset must be greater than or equal to 0.");

			if (triCount < 0)
				throw new ArgumentOutOfRangeException("triCount", "triCount must be greater than or equal to 0.");

			if (triEnd > tris.Length)
				throw new ArgumentOutOfRangeException("triCount", "The specified offset and count end outside the bounds of the provided array.");

			if (areas.Length < triCount)
				throw new ArgumentException("There must be at least as many AreaFlags as there are triangles.", "areas");

			for (int i = triOffset, j = 0; i < triEnd; i++, j++)
				RasterizeTriangle(ref tris[i].A, ref tris[i].B, ref tris[i].C, areas[j]);
		}

		/// <summary>
		/// Rasterizes several triangles at once with per-triangle area flags.
		/// </summary>
		/// <remarks>
		/// If the length of the array is not a multiple of 3, the extra vertices at the end will be skipped.
		/// </remarks>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesWithAreas(Vector3[] verts, Area[] areas)
		{
			RasterizeTrianglesWithAreas(verts, 0, 1, verts.Length / 3, areas);
		}

		/// <summary>
		/// Rasterizes several triangles at once with per-triangle area flags.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="vertOffset">An offset into the array.</param>
		/// <param name="vertStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (1 Vector3 per vertex).</param>
		/// <param name="triCount">The number of triangles to rasterize, starting from the offset.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesWithAreas(Vector3[] verts, int vertOffset, int vertStride, int triCount, Area[] areas)
		{
			if (verts == null)
				throw new ArgumentNullException("verts");

			if (vertOffset < 0)
				throw new ArgumentOutOfRangeException("vertOffset", "vertOffset must be greater than or equal to 0.");

			if (triCount < 0)
				throw new ArgumentOutOfRangeException("triCount", "triCount must be greater than or equal to 0.");

			if (vertStride < 0)
				throw new ArgumentOutOfRangeException("vertStride", "vertStride must be greater than or equal to 0.");
			else if (vertStride == 0)
				vertStride = 1;

			int vertEnd = triCount * vertStride + vertOffset;

			if (vertEnd > verts.Length)
				throw new ArgumentOutOfRangeException("triCount", "The specified offset, count, and stride end outside the bounds of the provided array.");

			if (areas.Length < triCount)
				throw new ArgumentException("There must be at least as many AreaFlags as there are triangles.", "areas");

			for (int i = vertOffset, j = 0; i < vertEnd; i += vertStride * 3, j++)
				RasterizeTriangle(ref verts[i], ref verts[i + vertStride], ref verts[i + vertStride * 2], areas[j]);
		}

		/// <summary>
		/// Rasterizes several triangles at once with per-triangle area flags.
		/// </summary>
		/// <remarks>
		/// If the length of the array is not a multiple of 9, the extra floats at the end will be skipped.
		/// </remarks>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesWithAreas(float[] verts, Area[] areas)
		{
			RasterizeTrianglesWithAreas(verts, 0, 3, verts.Length / 9, areas);
		}

		/// <summary>
		/// Rasterizes several triangles at once with per-triangle area flags.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="floatOffset">An offset into the array.</param>
		/// <param name="floatStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (3 floats per vertex).</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		/// <param name="areas">An array of area flags, one for each triangle.</param>
		public void RasterizeTrianglesWithAreas(float[] verts, int floatOffset, int floatStride, int triCount, Area[] areas)
		{
			if (verts == null)
				throw new ArgumentNullException("verts");

			if (floatOffset < 0)
				throw new ArgumentOutOfRangeException("floatOffset", "floatOffset must be greater than or equal to 0.");

			if (triCount < 0)
				throw new ArgumentOutOfRangeException("triCount", "triCount must be greater than or equal to 0.");

			if (floatStride < 0)
				throw new ArgumentOutOfRangeException("floatStride", "floatStride must be a positive integer.");
			else if (floatStride == 0)
				floatStride = 3;

			int floatEnd = triCount * (floatStride * 3) + floatOffset;

			if (floatEnd > verts.Length)
				throw new ArgumentOutOfRangeException("triCount", "The specified offset, count, and stride end outside the bounds of the provided array.");

			if (areas.Length < triCount)
				throw new ArgumentException("There must be at least as many AreaFlags as there are triangles.", "areas");

			Vector3 a, b, c;

			for (int i = floatOffset, j = 0; i < floatEnd; i += floatStride * 3, j++)
			{
				int floatStride2 = floatStride * 2;

				a.X = verts[i];
				a.Y = verts[i + 1];
				a.Z = verts[i + 2];

				b.X = verts[i + floatStride];
				b.Y = verts[i + floatStride + 1];
				b.Z = verts[i + floatStride + 2];

				c.X = verts[i + floatStride2];
				c.Y = verts[i + floatStride2 + 1];
				c.Z = verts[i + floatStride2 + 2];

				RasterizeTriangle(ref a, ref b, ref c, areas[j]);
			}
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		public void RasterizeTrianglesIndexed(Vector3[] verts, int[] inds)
		{
			RasterizeTrianglesIndexed(verts, inds, 0, 1, 0, inds.Length / 3, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="area">The area flags for all the triangles.</param>
		public void RasterizeTrianglesIndexed(Vector3[] verts, int[] inds, Area area)
		{
			RasterizeTrianglesIndexed(verts, inds, 0, 1, 0, inds.Length / 3, area);
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="vertOffset">An offset into the vertex array.</param>
		/// <param name="vertStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (one Vector3 per vertex).</param>
		/// <param name="indexOffset">An offset into the index array.</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		public void RasterizeTrianglesIndexed(Vector3[] verts, int[] inds, int vertOffset, int vertStride, int indexOffset, int triCount)
		{
			RasterizeTrianglesIndexed(verts, inds, vertOffset, vertStride, indexOffset, triCount, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="vertOffset">An offset into the vertex array.</param>
		/// <param name="vertStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (one Vector3 per vertex).</param>
		/// <param name="indexOffset">An offset into the index array.</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTrianglesIndexed(Vector3[] verts, int[] inds, int vertOffset, int vertStride, int indexOffset, int triCount, Area area)
		{
			int indexEnd = triCount * 3 + indexOffset;

			if (verts == null)
				throw new ArgumentNullException("verts");

			if (inds == null)
				throw new ArgumentNullException("inds");

			if (indexEnd > inds.Length)
				throw new ArgumentOutOfRangeException("indexCount", "The specified index offset and length end outside the provided index array.");

			if (vertOffset < 0)
				throw new ArgumentOutOfRangeException("vertOffset", "vertOffset must be greater than or equal to 0.");

			if (vertStride < 0)
				throw new ArgumentOutOfRangeException("vertStride", "vertStride must be greater than or equal to 0.");
			else if (vertStride == 0)
				vertStride = 1;

			for (int i = indexOffset; i < indexEnd; i += 3)
			{
				int indA = inds[i] * vertStride + vertOffset;
				int indB = inds[i + 1] * vertStride + vertOffset;
				int indC = inds[i + 2] * vertStride + vertOffset;

				RasterizeTriangle(ref verts[indA], ref verts[indB], ref verts[indC], area);
			}
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		public void RasterizeTrianglesIndexed(float[] verts, int[] inds)
		{
			RasterizeTrianglesIndexed(verts, inds, 0, 3, 0, inds.Length / 3, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="area">The area flags for all the triangles.</param>
		public void RasterizeTrianglesIndexed(float[] verts, int[] inds, Area area)
		{
			RasterizeTrianglesIndexed(verts, inds, 0, 3, 0, inds.Length / 3, area);
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="floatOffset">An offset into the vertex array.</param>
		/// <param name="floatStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (3 floats per vertex).</param>
		/// <param name="indexOffset">An offset into the index array.</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		public void RasterizeTrianglesIndexed(float[] verts, int[] inds, int floatOffset, int floatStride, int indexOffset, int triCount)
		{
			RasterizeTrianglesIndexed(verts, inds, floatOffset, floatStride, indexOffset, triCount, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once from an indexed array.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="inds">An array of indices.</param>
		/// <param name="floatOffset">An offset into the vertex array.</param>
		/// <param name="floatStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (3 floats per vertex).</param>
		/// <param name="indexOffset">An offset into the index array.</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTrianglesIndexed(float[] verts, int[] inds, int floatOffset, int floatStride, int indexOffset, int triCount, Area area)
		{
			int indexEnd = triCount * 3 + indexOffset;

			if (verts == null)
				throw new ArgumentNullException("verts");

			if (inds == null)
				throw new ArgumentNullException("inds");

			if (indexEnd > inds.Length)
				throw new ArgumentOutOfRangeException("indexCount", "The specified index offset and length end outside the provided index array.");

			if (floatOffset < 0)
				throw new ArgumentOutOfRangeException("floatOffset", "floatOffset must be greater than or equal to 0.");

			if (floatStride < 0)
				throw new ArgumentOutOfRangeException("floatStride", "floatStride must be greater than or equal to 0.");
			else if (floatStride == 0)
				floatStride = 3;

			Vector3 a, b, c;

			for (int i = indexOffset; i < indexEnd; i += 3)
			{
				int indA = inds[i] * floatStride + floatOffset;
				int indB = inds[i + 1] * floatStride + floatOffset;
				int indC = inds[i + 2] * floatStride + floatOffset;

				a.X = verts[indA];
				a.Y = verts[indA + 1];
				a.Z = verts[indA + 2];

				b.X = verts[indB];
				b.Y = verts[indB + 1];
				b.Z = verts[indB + 2];

				c.X = verts[indC];
				c.Y = verts[indC + 1];
				c.Z = verts[indC + 2];

				RasterizeTriangle(ref a, ref b, ref c, area);
			}
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="tris">A collection of triangles.</param>
		public void RasterizeTriangles(IEnumerable<Triangle3> tris)
		{
			RasterizeTriangles(tris, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="tris">A collection of triangles.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTriangles(IEnumerable<Triangle3> tris, Area area)
		{
			foreach (var t in tris) {
				Triangle3 tref = t;
				RasterizeTriangle(ref tref, area);
			}
			/*
			Parallel.ForEach(tris, t =>
			{
				RasterizeTriangle(ref t, area);
			});
			*/
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="tris">An array of triangles.</param>
		public void RasterizeTriangles(Triangle3[] tris)
		{
			RasterizeTriangles(tris, 0, tris.Length, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="tris">An array of triangles.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTriangles(Triangle3[] tris, Area area)
		{
			RasterizeTriangles(tris, 0, tris.Length, area);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="tris">An array of triangles.</param>
		/// <param name="triOffset">An offset into the array.</param>
		/// <param name="triCount">The number of triangles to rasterize, starting from the offset.</param>
		public void RasterizeTriangles(Triangle3[] tris, int triOffset, int triCount)
		{
			RasterizeTriangles(tris, triOffset, triCount, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="tris">An array of triangles.</param>
		/// <param name="triOffset">An offset into the array.</param>
		/// <param name="triCount">The number of triangles to rasterize, starting from the offset.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTriangles(Triangle3[] tris, int triOffset, int triCount, Area area)
		{
			int triEnd = triOffset + triCount;

			if (tris == null)
				throw new ArgumentNullException("verts");

			if (triOffset < 0)
				throw new ArgumentOutOfRangeException("triOffset", "triOffset must be greater than or equal to 0.");

			if (triCount < 0)
				throw new ArgumentOutOfRangeException("triCount", "triCount must be greater than or equal to 0.");

			if (triEnd > tris.Length)
				throw new ArgumentOutOfRangeException("triCount", "The specified offset and count end outside the bounds of the provided array.");

			int numBatches = 8;
			int threads = (triCount / numBatches) + 1;

			/*spanQueue = new ConcurrentQueue<Tuple<int, int, Span>>();
			bool allProcessed;

			var task = Task.Factory.StartNew(() =>
			{
				while (true)
				{
					if (spanQueue.IsEmpty)
						Thread.Sleep(1);

					Tuple<int, int, Span> spanEntry;
					while (spanQueue.TryDequeue(out spanEntry))
						cells[spanEntry.Item2 * width + spanEntry.Item1].AddSpan(spanEntry.Item3);
				}
			});*/

			//Parallel.For(0, threads, i =>
			for (int i = 0; i < threads; i++)
			{
				int start = triOffset + i * numBatches;
				int end = triOffset + (i + 1) * numBatches;
				if (end > triEnd)
					end = triEnd;

				for (int j = start; j < end; j++)
				{
					Triangle3 t = tris[j];
					RasterizeTriangle(ref t.A, ref t.B, ref t.C, area);
				}
			}
			//});
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <remarks>
		/// If the length of the array is not a multiple of 3, the extra vertices at the end will be skipped.
		/// </remarks>
		/// <param name="verts">An array of vertices.</param>
		public void RasterizeTriangles(Vector3[] verts)
		{
			RasterizeTriangles(verts, 0, 1, verts.Length / 3, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <remarks>
		/// If the length of the array is not a multiple of 3, the extra vertices at the end will be skipped.
		/// </remarks>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTriangles(Vector3[] verts, Area area)
		{
			RasterizeTriangles(verts, 0, 1, verts.Length / 3, area);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="vertOffset">An offset into the array.</param>
		/// <param name="vertStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (1 Vector3 per vertex).</param>
		/// <param name="triCount">The number of triangles to rasterize, starting from the offset.</param>
		public void RasterizeTriangles(Vector3[] verts, int vertOffset, int vertStride, int triCount)
		{
			RasterizeTriangles(verts, vertOffset, vertStride, triCount, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="vertOffset">An offset into the array.</param>
		/// <param name="vertStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (1 Vector3 per vertex).</param>
		/// <param name="triCount">The number of triangles to rasterize, starting from the offset.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTriangles(Vector3[] verts, int vertOffset, int vertStride, int triCount, Area area)
		{
			int vertEnd = triCount * vertStride + vertOffset;

			if (verts == null)
				throw new ArgumentNullException("verts");

			if (vertOffset < 0)
				throw new ArgumentOutOfRangeException("vertOffset", "vertOffset must be greater than or equal to 0.");

			if (triCount < 0)
				throw new ArgumentOutOfRangeException("triCount", "triCount must be greater than or equal to 0.");

			if (vertStride < 0)
				throw new ArgumentOutOfRangeException("vertStride", "vertStride must be greater than or equal to 0.");
			else if (vertStride == 0)
				vertStride = 1;

			if (vertEnd > verts.Length)
				throw new ArgumentOutOfRangeException("triCount", "The specified offset, count, and stride end outside the bounds of the provided array.");

			//Parallel.For(0, triCount, i => {
			for (int i = 0; i < triCount; i++) {
				i = vertOffset + (i * vertStride * 3);
				RasterizeTriangle(ref verts[i], ref verts[i + vertStride], ref verts[i + vertStride * 2], area);
			}
			//});
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <remarks>
		/// If the length of the array is not a multiple of 9, the extra floats at the end will be skipped.
		/// </remarks>
		/// <param name="verts">An array of vertices.</param>
		public void RasterizeTriangles(float[] verts)
		{
			RasterizeTriangles(verts, 0, 3, verts.Length / 9, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <remarks>
		/// If the length of the array is not a multiple of 9, the extra floats at the end will be skipped.
		/// </remarks>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTriangles(float[] verts, Area area)
		{
			RasterizeTriangles(verts, 0, 3, verts.Length / 9, area);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="floatOffset">An offset into the array.</param>
		/// <param name="floatStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (3 floats per vertex).</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		public void RasterizeTriangles(float[] verts, int floatOffset, int floatStride, int triCount)
		{
			RasterizeTriangles(verts, floatOffset, floatStride, triCount, Area.Default);
		}

		/// <summary>
		/// Rasterizes several triangles at once.
		/// </summary>
		/// <param name="verts">An array of vertices.</param>
		/// <param name="floatOffset">An offset into the array.</param>
		/// <param name="floatStride">The number of array elements that make up a vertex. A value of 0 is interpreted as tightly-packed data (3 floats per vertex).</param>
		/// <param name="triCount">The number of triangles to rasterize.</param>
		/// <param name="area">The area flags for all of the triangles.</param>
		public void RasterizeTriangles(float[] verts, int floatOffset, int floatStride, int triCount, Area area)
		{
			int floatEnd = triCount * (floatStride * 3) + floatOffset;

			if (verts == null)
				throw new ArgumentNullException("verts");

			if (floatOffset < 0)
				throw new ArgumentOutOfRangeException("floatOffset", "floatOffset must be greater than or equal to 0.");

			if (triCount < 0)
				throw new ArgumentOutOfRangeException("triCount", "triCount must be greater than or equal to 0.");

			if (floatStride < 0)
				throw new ArgumentOutOfRangeException("floatStride", "floatStride must be a positive integer.");
			else if (floatStride == 0)
				floatStride = 3;

			if (floatEnd > verts.Length)
				throw new ArgumentOutOfRangeException("triCount", "The specified offset, count, and stride end outside the bounds of the provided array.");

			Vector3 a, b, c;

			//Parallel.For(0, triCount, i =>
			for (int i = 0; i < triCount; i++)
			{
				i = floatOffset + (i * floatStride * 3);
				int floatStride2 = floatStride * 2;

				a.X = verts[i];
				a.Y = verts[i + 1];
				a.Z = verts[i + 2];

				b.X = verts[i + floatStride];
				b.Y = verts[i + floatStride + 1];
				b.Z = verts[i + floatStride + 2];

				c.X = verts[i + floatStride2];
				c.Y = verts[i + floatStride2 + 1];
				c.Z = verts[i + floatStride2 + 2];

				RasterizeTriangle(ref a, ref b, ref c, area);
			}
			//});
		}

		/// <summary>
		/// Rasterizes a triangle using conservative voxelization.
		/// </summary>
		/// <param name="tri">The triangle as a <see cref="Triangle3"/> struct.</param>
		public void RasterizeTriangle(ref Triangle3 tri)
		{
			RasterizeTriangle(ref tri.A, ref tri.B, ref tri.C, Area.Default);
		}

		/// <summary>
		/// Rasterizes a triangle using conservative voxelization.
		/// </summary>
		/// <param name="tri">The triangle as a <see cref="Triangle3"/> struct.</param>
		/// <param name="area">The area flags for the triangle.</param>
		public void RasterizeTriangle(ref Triangle3 tri, Area area)
		{
			RasterizeTriangle(ref tri.A, ref tri.B, ref tri.C, area);
		}

		/// <summary>
		/// Rasterizes a triangle using conservative voxelization.
		/// </summary>
		/// <param name="ax">The X component of the first vertex of the triangle.</param>
		/// <param name="ay">The Y component of the first vertex of the triangle.</param>
		/// <param name="az">The Z component of the first vertex of the triangle.</param>
		/// <param name="bx">The X component of the second vertex of the triangle.</param>
		/// <param name="by">The Y component of the second vertex of the triangle.</param>
		/// <param name="bz">The Z component of the second vertex of the triangle.</param>
		/// <param name="cx">The X component of the third vertex of the triangle.</param>
		/// <param name="cy">The Y component of the third vertex of the triangle.</param>
		/// <param name="cz">The Z component of the third vertex of the triangle.</param>
		public void RasterizeTriangle(float ax, float ay, float az, float bx, float by, float bz, float cx, float cy, float cz)
		{
			RasterizeTriangle(ax, ay, az, bx, by, bz, cx, cy, cz, Area.Default);
		}

		/// <summary>
		/// Rasterizes a triangle using conservative voxelization.
		/// </summary>
		/// <param name="ax">The X component of the first vertex of the triangle.</param>
		/// <param name="ay">The Y component of the first vertex of the triangle.</param>
		/// <param name="az">The Z component of the first vertex of the triangle.</param>
		/// <param name="bx">The X component of the second vertex of the triangle.</param>
		/// <param name="by">The Y component of the second vertex of the triangle.</param>
		/// <param name="bz">The Z component of the second vertex of the triangle.</param>
		/// <param name="cx">The X component of the third vertex of the triangle.</param>
		/// <param name="cy">The Y component of the third vertex of the triangle.</param>
		/// <param name="cz">The Z component of the third vertex of the triangle.</param>
		/// <param name="area">The area flags for the triangle.</param>
		public void RasterizeTriangle(float ax, float ay, float az, float bx, float by, float bz, float cx, float cy, float cz, Area area)
		{
			Vector3 a, b, c;

			a.X = ax;
			a.Y = ay;
			a.Z = az;
			b.X = bx;
			b.Y = by;
			b.Z = bz;
			c.X = cx;
			c.Y = cy;
			c.Z = cz;

			RasterizeTriangle(ref a, ref b, ref c, area);
		}

		/// <summary>
		/// Rasterizes a triangle using conservative voxelization.
		/// </summary>
		/// <param name="a">The first vertex of the triangle.</param>
		/// <param name="b">The second vertex of the triangle.</param>
		/// <param name="c">The third vertex of the triangle.</param>
		public void RasterizeTriangle(ref Vector3 a, ref Vector3 b, ref Vector3 c)
		{
			RasterizeTriangle(ref a, ref b, ref c, Area.Default);
		}

		/// <summary>
		/// Rasterizes a triangle using conservative voxelization.
		/// </summary>
		/// <param name="a">The first vertex of the triangle.</param>
		/// <param name="b">The second vertex of the triangle.</param>
		/// <param name="c">The third vertex of the triangle.</param>
		/// <param name="area">The area flags for the triangle.</param>
		public void RasterizeTriangle(ref Vector3 a, ref Vector3 b, ref Vector3 c, Area area)
		{
			//distances buffer for ClipPolygonToBounds
			float[] distances = new float[12];

			float invCellSize = 1f / cellSize;
			float invCellHeight = 1f / cellHeight;
			float boundHeight = bounds.Max.Y - bounds.Min.Y;

			//calculate the triangle's bounding box
			BBox3 bbox;
			Triangle3.GetBoundingBox(ref a, ref b, ref c, out bbox);

			//make sure that the triangle is at least in one cell.
			if (!BBox3.Overlapping(ref bbox, ref bounds))
				return;

			//figure out which rows.
			int z0 = (int)((bbox.Min.Z - bounds.Min.Z) * invCellSize);
			int z1 = (int)((bbox.Max.Z - bounds.Min.Z) * invCellSize);

			//clamp to the field boundaries.
			MathHelper.Clamp(ref z0, 0, length - 1);
			MathHelper.Clamp(ref z1, 0, length - 1);

			Vector3[] inVerts = new Vector3[7], outVerts = new Vector3[7], inRowVerts = new Vector3[7];

			for (int z = z0; z <= z1; z++)
			{
				//copy the original vertices to the array.
				inVerts[0] = a;
				inVerts[1] = b;
				inVerts[2] = c;

				//clip the triangle to the row
				int nvrow = 3;
				float cz = bounds.Min.Z + z * cellSize;
				nvrow = MathHelper.ClipPolygonToPlane(inVerts, outVerts, distances, nvrow, 0, 1, -cz);
				if (nvrow < 3)
					continue;
				nvrow = MathHelper.ClipPolygonToPlane(outVerts, inRowVerts, distances, nvrow, 0, -1, cz + cellSize);
				if (nvrow < 3)
					continue;

				float minX = inRowVerts[0].X, maxX = minX;
				for (int i = 1; i < nvrow; i++)
				{
					float vx = inRowVerts[i].X;
					if (minX > vx)
						minX = vx;
					if (maxX < vx)
						maxX = vx;
				}

				int x0 = (int)((minX - bounds.Min.X) * invCellSize);
				int x1 = (int)((maxX - bounds.Min.X) * invCellSize);

				MathHelper.Clamp(ref x0, 0, width - 1);
				MathHelper.Clamp(ref x1, 0, width - 1);

				for (int x = x0; x <= x1; x++)
				{
					//clip the triangle to the column
					int nv = nvrow;
					float cx = bounds.Min.X + x * cellSize;
					nv = MathHelper.ClipPolygonToPlane(inRowVerts, outVerts, distances, nv, 1, 0, -cx);
					if (nv < 3)
						continue;
					nv = MathHelper.ClipPolygonToPlane(outVerts, inVerts, distances, nv, -1, 0, cx + cellSize);
					if (nv < 3)
						continue;

					//calculate the min/max of the polygon
					float polyMin = inVerts[0].Y, polyMax = polyMin;
					for (int i = 1; i < nv; i++)
					{
						float y = inVerts[i].Y;
						polyMin = Math.Min(polyMin, y);
						polyMax = Math.Max(polyMax, y);
					}

					//normalize span bounds to bottom of heightfield
					float boundMinY = bounds.Min.Y;
					polyMin -= boundMinY;
					polyMax -= boundMinY;

					//if the spans are outside the heightfield, skip.
					if (polyMax < 0f || polyMin > boundHeight)
						continue;

					//clamp the span to the heightfield.
					if (polyMin < 0)
						polyMin = 0;
					if (polyMax > boundHeight)
						polyMax = boundHeight;

					//snap to grid
					int spanMin = (int)(polyMin * invCellHeight);
					int spanMax = (int)Math.Ceiling(polyMax * invCellHeight);

					//add the span
					cells[z * width + x].AddSpan(new Span(spanMin, spanMax, area));
				}
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\HeightPatch.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav
{
	/// <summary>
	/// Stores height data in a grid.
	/// </summary>
	public class HeightPatch
	{
		/// <summary>
		/// The value used when a height value has not yet been set.
		/// </summary>
		public const int UnsetHeight = -1;

		private int xmin, ymin, width, length;
		private int[] data;

		/// <summary>
		/// Initializes a new instance of the <see cref="HeightPatch"/> class.
		/// </summary>
		/// <param name="x">The initial X coordinate of the patch.</param>
		/// <param name="y">The initial Y coordinate of the patch.</param>
		/// <param name="width">The width of the patch.</param>
		/// <param name="length">The length of the patch.</param>
		public HeightPatch(int x, int y, int width, int length)
		{
			if (x < 0 || y < 0 || width <= 0 || length <= 0)
				throw new ArgumentOutOfRangeException("Invalid bounds.");

			this.xmin = x;
			this.ymin = y;
			this.width = width;
			this.length = length;

			this.data = new int[width * length];
			Clear();
		}

		/// <summary>
		/// Gets the X coordinate of the patch.
		/// </summary>
		public int X
		{
			get
			{
				return xmin;
			}
		}

		/// <summary>
		/// Gets the Y coordinate of the patch.
		/// </summary>
		public int Y
		{
			get
			{
				return ymin;
			}
		}

		/// <summary>
		/// Gets the width of the patch.
		/// </summary>
		public int Width
		{
			get
			{
				return width;
			}
		}

		/// <summary>
		/// Gets the length of the patch.
		/// </summary>
		public int Length
		{
			get
			{
				return length;
			}
		}

		/// <summary>
		/// Gets or sets the height at a specified index.
		/// </summary>
		/// <param name="index">The index inside the patch.</param>
		/// <returns>The height at the specified index.</returns>
		public int this[int index]
		{
			get
			{
				return data[index];
			}

			set
			{
				data[index] = value;
			}
		}

		/// <summary>
		/// Gets or sets the height at a specified coordinate (x, y).
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		/// <returns>The height at the specified index.</returns>
		public int this[int x, int y]
		{
			get
			{
				return data[y * width + x];
			}

			set
			{
				data[y * width + x] = value;
			}
		}

		/// <summary>
		/// Checks an index to see whether or not it's height value has been set.
		/// </summary>
		/// <param name="index">The index to check.</param>
		/// <returns>A value indicating whether or not the height value at the index is set.</returns>
		public bool IsSet(int index)
		{
			return data[index] != UnsetHeight;
		}

		/// <summary>
		/// Gets the height value at a specified index. A return value indicates whether the height value is set.
		/// </summary>
		/// <param name="index">The index to use.</param>
		/// <param name="value">Contains the height at the value.</param>
		/// <returns>A value indicating whether the value at the specified index is set.</returns>
		public bool TryGetHeight(int index, out int value)
		{
			value = this[index];
			return value != UnsetHeight;
		}

		/// <summary>
		/// Gets the height value at a specified index. A return value indicates whether the height value is set.
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		/// <param name="value">Contains the height at the value.</param>
		/// <returns>A value indicating whether the value at the specified index is set.</returns>
		public bool TryGetHeight(int x, int y, out int value)
		{
			value = this[x, y];
			return value != UnsetHeight;
		}

		/// <summary>
		/// Resizes the patch. Only works if the new size is smaller than or equal to the initial size.
		/// </summary>
		/// <param name="x">The new X coordinate.</param>
		/// <param name="y">The new Y coordinate.</param>
		/// <param name="width">The new width.</param>
		/// <param name="length">The new length.</param>
		public void Resize(int x, int y, int width, int length)
		{
			if (data.Length < width * length)
				throw new ArgumentException("Only resizing down is allowed right now.");

			this.xmin = x;
			this.ymin = y;
			this.width = width;
			this.length = length;
		}

		/// <summary>
		/// Clears the <see cref="HeightPatch"/> by unsetting every value.
		/// </summary>
		public void Clear()
		{
			for (int i = 0; i < data.Length; i++)
				data[i] = UnsetHeight;
		}

		/// <summary>
		/// Sets all of the height values to the same value.
		/// </summary>
		/// <param name="h">The height to apply to all values.</param>
		public void SetAll(int h)
		{
			for (int i = 0; i < data.Length; i++)
				data[i] = h;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\MathHelper.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// A class where all the small, miscellaneous math functions are stored.
	/// </summary>
	internal static class MathHelper
	{
		/// <summary>
		/// Clamps an integer value to be within a specified range.
		/// </summary>
		/// <param name="val">The value to clamp.</param>
		/// <param name="min">The inclusive minimum of the range.</param>
		/// <param name="max">The inclusive maximum of the range.</param>
		/// <returns>The clamped value.</returns>
		internal static int Clamp(int val, int min, int max)
		{
			return val < min ? min : (val > max ? max : val);
		}

		/// <summary>
		/// Clamps an integer value to be within a specified range.
		/// </summary>
		/// <param name="val">The value to clamp.</param>
		/// <param name="min">The inclusive minimum of the range.</param>
		/// <param name="max">The inclusive maximum of the range.</param>
		internal static void Clamp(ref int val, int min, int max)
		{
			val = val < min ? min : (val > max ? max : val);
		}

		/// <summary>
		/// Clamps an integer value to be within a specified range.
		/// </summary>
		/// <param name="val">The value to clamp.</param>
		/// <param name="min">The inclusive minimum of the range.</param>
		/// <param name="max">The inclusive maximum of the range.</param>
		/// <returns>The clamped value.</returns>
		internal static uint Clamp(uint val, uint min, uint max)
		{
			return val < min ? min : (val > max ? max : val);
		}

		/// <summary>
		/// Clamps an integer value to be within a specified range.
		/// </summary>
		/// <param name="val">The value to clamp.</param>
		/// <param name="min">The inclusive minimum of the range.</param>
		/// <param name="max">The inclusive maximum of the range.</param>
		internal static void Clamp(ref uint val, uint min, uint max)
		{
			val = val < min ? min : (val > max ? max : val);
		}

		/// <summary>
		/// Clamps an integer value to be within a specified range.
		/// </summary>
		/// <param name="val">The value to clamp.</param>
		/// <param name="min">The inclusive minimum of the range.</param>
		/// <param name="max">The inclusive maximum of the range.</param>
		/// <returns>The clamped value.</returns>
		internal static float Clamp(float val, float min, float max)
		{
			return val < min ? min : (val > max ? max : val);
		}

		/// <summary>
		/// Clamps an integer value to be within a specified range.
		/// </summary>
		/// <param name="val">The value to clamp.</param>
		/// <param name="min">The inclusive minimum of the range.</param>
		/// <param name="max">The inclusive maximum of the range.</param>
		internal static void Clamp(ref float val, float min, float max)
		{
			val = val < min ? min : (val > max ? max : val);
		}

		/// <summary>
		/// Normalizes a value in a specified range to be between 0 and 1.
		/// </summary>
		/// <param name="t">The value</param>
		/// <param name="t0">The lower bound of the range.</param>
		/// <param name="t1">The upper bound of the range.</param>
		/// <returns>A normalized value.</returns>
		public static float Normalize(float t, float t0, float t1)
		{
			return MathHelper.Clamp((t - t0) / (t1 - t0), 0.0f, 1.0f);
		}

		/// <summary>
		/// Calculates the next highest power of two.
		/// </summary>
		/// <remarks>
		/// This is a minimal method meant to be fast. There is a known edge case where an input of 0 will output 0
		/// instead of the mathematically correct value of 1. It will not be fixed.
		/// </remarks>
		/// <param name="v">A value.</param>
		/// <returns>The next power of two after the value.</returns>
		internal static int NextPowerOfTwo(int v)
		{
			v--;
			v |= v >> 1;
			v |= v >> 2;
			v |= v >> 4;
			v |= v >> 8;
			v |= v >> 16;
			v++;

			return v;
		}

		/// <summary>
		/// Calculates the next highest power of two.
		/// </summary>
		/// <remarks>
		/// This is a minimal method meant to be fast. There is a known edge case where an input of 0 will output 0
		/// instead of the mathematically correct value of 1. It will not be fixed.
		/// </remarks>
		/// <param name="v">A value.</param>
		/// <returns>The next power of two after the value.</returns>
		internal static uint NextPowerOfTwo(uint v)
		{
			v--;
			v |= v >> 1;
			v |= v >> 2;
			v |= v >> 4;
			v |= v >> 8;
			v |= v >> 16;
			v++;

			return v;
		}

		/// <summary>
		/// Calculates the binary logarithm of the input.
		/// </summary>
		/// <remarks>
		/// Inputs 0 and below have undefined output.
		/// </remarks>
		/// <param name="v">A value.</param>
		/// <returns>The binary logarithm of v.</returns>
		internal static int Log2(int v)
		{
			int r;
			int shift;

			r = (v > 0xffff) ? 1 << 4 : 0 << 4;
			v >>= r;

			shift = (v > 0xff) ? 1 << 3 : 0 << 3;
			v >>= shift;
			r |= shift;

			shift = (v > 0xf) ? 1 << 2 : 0 << 2;
			v >>= shift;
			r |= shift;

			shift = (v > 0x3) ? 1 << 1 : 0 << 1;
			v >>= shift;
			r |= shift;

			r |= v >> 1;

			return r;
		}

		/// <summary>
		/// Calculates the binary logarithm of the input.
		/// </summary>
		/// <remarks>
		/// An input of 0 has an undefined output.
		/// </remarks>
		/// <param name="v">A value.</param>
		/// <returns>The binary logarithm of v.</returns>
		internal static uint Log2(uint v)
		{
			uint r;
			int shift;

			r = (uint)((v > 0xffff) ? 1 << 4 : 0 << 4);
			v >>= (int)r;

			shift = (v > 0xff) ? 1 << 3 : 0 << 3;
			v >>= shift;
			r |= (uint)shift;

			shift = (v > 0xf) ? 1 << 2 : 0 << 2;
			v >>= shift;
			r |= (uint)shift;

			shift = (v > 0x3) ? 1 << 1 : 0 << 1;
			v >>= shift;
			r |= (uint)shift;

			r |= v >> 1;

			return r;
		}

		/// <summary>
		/// Clips a polygon to a plane using the Sutherland-Hodgman algorithm.
		/// </summary>
		/// <param name="inVertices">The input array of vertices.</param>
		/// <param name="outVertices">The output array of vertices.</param>
		/// <param name="numVerts">The number of vertices to read from the arrays.</param>
		/// <param name="planeX">The clip plane's X component.</param>
		/// <param name="planeZ">The clip plane's Z component.</param>
		/// <param name="planeD">The clip plane's D component.</param>
		/// <returns>The number of vertices stored in outVertices.</returns>
		internal static int ClipPolygonToPlane(Vector3[] inVertices, Vector3[] outVertices, int numVerts, float planeX, float planeZ, float planeD)
		{
			float[] distances = new float[12];
			return ClipPolygonToPlane(inVertices, outVertices, distances, numVerts, planeX, planeZ, planeD);
		}

		/// <summary>
		/// Clips a polygon to a plane using the Sutherland-Hodgman algorithm.
		/// </summary>
		/// <param name="inVertices">The input array of vertices.</param>
		/// <param name="outVertices">The output array of vertices.</param>
		/// <param name="distances">A buffer that stores intermediate data</param>
		/// <param name="numVerts">The number of vertices to read from the arrays.</param>
		/// <param name="planeX">The clip plane's X component.</param>
		/// <param name="planeZ">The clip plane's Z component.</param>
		/// <param name="planeD">The clip plane's D component.</param>
		/// <returns>The number of vertices stored in outVertices.</returns>
		internal static int ClipPolygonToPlane(Vector3[] inVertices, Vector3[] outVertices, float[] distances, int numVerts, float planeX, float planeZ, float planeD)
		{
			for (int i = 0; i < numVerts; i++)
				distances[i] = planeX * inVertices[i].X + planeZ * inVertices[i].Z + planeD;

			int m = 0;
			Vector3 temp;
			for (int i = 0, j = numVerts - 1; i < numVerts; j = i, i++)
			{
				bool inj = distances[j] >= 0;
				bool ini = distances[i] >= 0;

				if (inj != ini)
				{
					float s = distances[j] / (distances[j] - distances[i]);

					Vector3.Subtract(ref inVertices[i], ref inVertices[j], out temp);
					Vector3.Multiply(ref temp, s, out temp);
					Vector3.Add(ref inVertices[j], ref temp, out outVertices[m]);
					m++;
				}

				if (ini)
				{
					outVertices[m] = inVertices[i];
					m++;
				}
			}

			return m;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\NavMesh.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System.Collections.Generic;

using SharpNav.Geometry;

namespace SharpNav
{
	//TODO right now this is basically an alias for TiledNavMesh. Fix this in the future.

	/// <summary>
	/// A TiledNavMesh generated from a collection of triangles and some settings
	/// </summary>
	public class NavMesh : TiledNavMesh
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="NavMesh" /> class.
		/// </summary>
		/// <param name="builder">The NavMeshBuilder data</param>
		public NavMesh(NavMeshBuilder builder)
			: base(builder)
		{
		}

		/// <summary>
		/// Generates a <see cref="NavMesh"/> given a collection of triangles and some settings.
		/// </summary>
		/// <param name="triangles">The triangles that form the level.</param>
		/// <param name="settings">The settings to generate with.</param>
		/// <returns>A <see cref="NavMesh"/>.</returns>
		public static NavMesh Generate(IEnumerable<Triangle3> triangles, NavMeshGenerationSettings settings, out PolyMesh polyMesh, out PolyMeshDetail polyMeshDetail)
		{
			BBox3 bounds = triangles.GetBoundingBox(settings.CellSize);
			var hf = new Heightfield(bounds, settings);
			hf.RasterizeTriangles(triangles);
			hf.FilterLedgeSpans(settings.VoxelAgentHeight, settings.VoxelMaxClimb);
			hf.FilterLowHangingWalkableObstacles(settings.VoxelMaxClimb);
			hf.FilterWalkableLowHeightSpans(settings.VoxelAgentHeight);
			var chf = new CompactHeightfield(hf, settings);
			chf.Erode(settings.VoxelAgentRadius);
			chf.BuildDistanceField();
			chf.BuildRegions(2, settings.MinRegionSize, settings.MergedRegionSize);
			var cont = chf.BuildContourSet(settings);

			polyMesh = new PolyMesh(cont, settings);

			polyMeshDetail = new PolyMeshDetail(polyMesh, chf, settings);
			var buildData = new NavMeshBuilder(polyMesh, polyMeshDetail, new Pathfinding.OffMeshConnection[0], settings);

			var navMesh = new NavMesh(buildData);
			return navMesh;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\NavMeshBuilder.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

using SharpNav.Collections;
using SharpNav.Geometry;
using SharpNav.Pathfinding;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// The NavMeshBuilder class converst PolyMesh and PolyMeshDetail into a different data structure suited for 
	/// pathfinding. This class will create tiled data.
	/// </summary>
	public class NavMeshBuilder
	{
		private PathfindingCommon.NavMeshInfo header;
		private Vector3[] navVerts;
		private Poly[] navPolys;
		private PolyMeshDetail.MeshData[] navDMeshes;
		private Vector3[] navDVerts;
		private PolyMeshDetail.TriangleData[] navDTris;
		private BVTree navBvTree;
		private OffMeshConnection[] offMeshConnections;

		/// <summary>
		/// Initializes a new instance of the <see cref="NavMeshBuilder" /> class.
		/// Add all the PolyMesh and PolyMeshDetail attributes to the Navigation Mesh.
		/// Then, add Off-Mesh connection support.
		/// </summary>
		/// <param name="polyMesh">The PolyMesh</param>
		/// <param name="polyMeshDetail">The PolyMeshDetail</param>
		/// <param name="offMeshCons">Offmesh connection data</param>
		/// <param name="settings">The settings used to build.</param>
		public NavMeshBuilder(PolyMesh polyMesh, PolyMeshDetail polyMeshDetail, OffMeshConnection[] offMeshCons, NavMeshGenerationSettings settings)
		{
			if (settings.VertsPerPoly > PathfindingCommon.VERTS_PER_POLYGON)
				throw new InvalidOperationException("The number of vertices per polygon is above SharpNav's limit");
			if (polyMesh.VertCount == 0)
				throw new InvalidOperationException("The provided PolyMesh has no vertices.");
			if (polyMesh.PolyCount == 0)
				throw new InvalidOperationException("The provided PolyMesh has not polys.");

			int nvp = settings.VertsPerPoly;

			//classify off-mesh connection points
			BoundarySide[] offMeshSides = new BoundarySide[offMeshCons.Length * 2];
			int storedOffMeshConCount = 0;
			int offMeshConLinkCount = 0;

			if (offMeshCons.Length > 0)
			{
				//find height bounds
				float hmin = float.MaxValue;
				float hmax = -float.MaxValue;

				if (polyMeshDetail != null)
				{
					for (int i = 0; i < polyMeshDetail.VertCount; i++)
					{
						float h = polyMeshDetail.Verts[i].Y;
						hmin = Math.Min(hmin, h);
						hmax = Math.Max(hmax, h);
					}
				}
				else
				{
					for (int i = 0; i < polyMesh.VertCount; i++)
					{
						PolyVertex iv = polyMesh.Verts[i];
						float h = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;
						hmin = Math.Min(hmin, h);
						hmax = Math.Max(hmax, h);
					}
				}

				hmin -= settings.MaxClimb;
				hmax += settings.MaxClimb;
				BBox3 bounds = polyMesh.Bounds;
				bounds.Min.Y = hmin;
				bounds.Max.Y = hmax;

				for (int i = 0; i < offMeshCons.Length; i++)
				{
					Vector3 p0 = offMeshCons[i].Pos0;
					Vector3 p1 = offMeshCons[i].Pos1;

					offMeshSides[i * 2 + 0] = BoundarySideExtensions.FromPoint(p0, bounds);
					offMeshSides[i * 2 + 1] = BoundarySideExtensions.FromPoint(p1, bounds);

					//off-mesh start position isn't touching mesh
					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)
					{
						if (p0.Y < bounds.Min.Y || p0.Y > bounds.Max.Y)
							offMeshSides[i * 2 + 0] = 0;
					}

					//count number of links to allocate
					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)
						offMeshConLinkCount++;
					if (offMeshSides[i * 2 + 1] == BoundarySide.Internal)
						offMeshConLinkCount++;

					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)
						storedOffMeshConCount++;
				}
			}

			//off-mesh connections stored as polygons, adjust values
			int totPolyCount = polyMesh.PolyCount + storedOffMeshConCount;
			int totVertCount = polyMesh.VertCount + storedOffMeshConCount * 2;

			//find portal edges
			int edgeCount = 0;
			int portalCount = 0;
			for (int i = 0; i < polyMesh.PolyCount; i++)
			{
				PolyMesh.Polygon p = polyMesh.Polys[i];
				for (int j = 0; j < nvp; j++)
				{
					if (p.Vertices[j] == PolyMesh.NullId)
						break;

					edgeCount++;
					
					if (PolyMesh.IsBoundaryEdge(p.NeighborEdges[j]))
					{
						int dir = p.NeighborEdges[j] % 16;
						if (dir != 15)
							portalCount++;
					}
				}
			}

			int maxLinkCount = edgeCount + portalCount * 2 + offMeshConLinkCount * 2;

			//find unique detail vertices
			int uniqueDetailVertCount = 0;
			int detailTriCount = 0;
			if (polyMeshDetail != null)
			{
				detailTriCount = polyMeshDetail.TrisCount;
				for (int i = 0; i < polyMesh.PolyCount; i++)
				{
					int numDetailVerts = polyMeshDetail.Meshes[i].VertexCount;
					int numPolyVerts = polyMesh.Polys[i].VertexCount;
					uniqueDetailVertCount += numDetailVerts - numPolyVerts;
				}
			}
			else
			{
				uniqueDetailVertCount = 0;
				detailTriCount = 0;
				for (int i = 0; i < polyMesh.PolyCount; i++)
				{
					int numPolyVerts = polyMesh.Polys[i].VertexCount;
					uniqueDetailVertCount += numPolyVerts - 2;
				}
			}

			//allocate data
			header = new PathfindingCommon.NavMeshInfo();
			navVerts = new Vector3[totVertCount];
			navPolys = new Poly[totPolyCount];
			navDMeshes = new PolyMeshDetail.MeshData[polyMesh.PolyCount];
			navDVerts = new Vector3[uniqueDetailVertCount];
			navDTris = new PolyMeshDetail.TriangleData[detailTriCount];
			offMeshConnections = new OffMeshConnection[storedOffMeshConCount];

			//store header
			//HACK TiledNavMesh should figure out the X/Y/layer instead of the user maybe?
			header.X = 0;
			header.Y = 0;
			header.Layer = 0;
			header.PolyCount = totPolyCount;
			header.VertCount = totVertCount;
			header.MaxLinkCount = maxLinkCount;
			header.Bounds = polyMesh.Bounds;
			header.DetailMeshCount = polyMesh.PolyCount;
			header.DetailVertCount = uniqueDetailVertCount;
			header.DetailTriCount = detailTriCount;
			header.OffMeshBase = polyMesh.PolyCount;
			header.WalkableHeight = settings.AgentHeight;
			header.WalkableRadius = settings.AgentRadius;
			header.WalkableClimb = settings.MaxClimb;
			header.OffMeshConCount = storedOffMeshConCount;
			header.BvNodeCount = settings.BuildBoundingVolumeTree ? polyMesh.PolyCount * 2 : 0;
			header.BvQuantFactor = 1f / settings.CellSize;

			int offMeshVertsBase = polyMesh.VertCount;
			int offMeshPolyBase = polyMesh.PolyCount;

			//store vertices
			for (int i = 0; i < polyMesh.VertCount; i++)
			{
				PolyVertex iv = polyMesh.Verts[i];
				navVerts[i].X = polyMesh.Bounds.Min.X + iv.X * settings.CellSize;
				navVerts[i].Y = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;
				navVerts[i].Z = polyMesh.Bounds.Min.Z + iv.Z * settings.CellSize;
			}

			//off-mesh link vertices
			int n = 0;
			for (int i = 0; i < offMeshCons.Length; i++)
			{
				//only store connections which start from this tile
				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)
				{
					navVerts[offMeshVertsBase + (n * 2 + 0)] = offMeshCons[i].Pos0;
					navVerts[offMeshVertsBase + (n * 2 + 1)] = offMeshCons[i].Pos1;
					n++;
				}
			}

			//store polygons
			for (int i = 0; i < polyMesh.PolyCount; i++)
			{
				navPolys[i] = new Poly();
				navPolys[i].VertCount = 0;
				navPolys[i].Flags = polyMesh.Polys[i].Flags;
				navPolys[i].Area = polyMesh.Polys[i].Area;
				navPolys[i].PolyType = PolygonType.Ground;
				navPolys[i].Verts = new int[nvp];
				navPolys[i].Neis = new int[nvp];
				for (int j = 0; j < nvp; j++)
				{
					if (polyMesh.Polys[i].Vertices[j] == PolyMesh.NullId)
						break;

					navPolys[i].Verts[j] = polyMesh.Polys[i].Vertices[j];
					if (PolyMesh.IsBoundaryEdge(polyMesh.Polys[i].NeighborEdges[j]))
					{
						//border or portal edge
						int dir = polyMesh.Polys[i].NeighborEdges[j] % 16;
						if (dir == 0xf) //border
							navPolys[i].Neis[j] = 0;
						else if (dir == 0) //portal x-
							navPolys[i].Neis[j] = Link.External | 4;
						else if (dir == 1) //portal z+
							navPolys[i].Neis[j] = Link.External | 2;
						else if (dir == 2) //portal x+
							navPolys[i].Neis[j] = Link.External | 0;
						else if (dir == 3) //portal z-
							navPolys[i].Neis[j] = Link.External | 6;
					}
					else
					{
						//normal connection
						navPolys[i].Neis[j] = polyMesh.Polys[i].NeighborEdges[j] + 1;
					}

					navPolys[i].VertCount++;
				}
			}

			//off-mesh connection vertices
			n = 0;
			for (int i = 0; i < offMeshCons.Length; i++)
			{
				//only store connections which start from this tile
				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)
				{
					navPolys[offMeshPolyBase + n].VertCount = 2;
					navPolys[offMeshPolyBase + n].Verts = new int[nvp];
					navPolys[offMeshPolyBase + n].Verts[0] = offMeshVertsBase + (n * 2 + 0);
					navPolys[offMeshPolyBase + n].Verts[1] = offMeshVertsBase + (n * 2 + 1);
					navPolys[offMeshPolyBase + n].Flags = (int)offMeshCons[i].Flags;
					navPolys[offMeshPolyBase + n].Area = polyMesh.Polys[offMeshCons[i].Poly].Area; //HACK is this correct?
					navPolys[offMeshPolyBase + n].PolyType = PolygonType.OffMeshConnection;
					n++;
				}
			}
			
			//store detail meshes and vertices
			if (polyMeshDetail != null)
			{
				int vbase = 0;
				List<Vector3> storedDetailVerts = new List<Vector3>();
				for (int i = 0; i < polyMesh.PolyCount; i++)
				{
					int vb = polyMeshDetail.Meshes[i].VertexIndex;
					int numDetailVerts = polyMeshDetail.Meshes[i].VertexCount;
					int numPolyVerts = navPolys[i].VertCount;
					navDMeshes[i].VertexIndex = vbase;
					navDMeshes[i].VertexCount = numDetailVerts - numPolyVerts;
					navDMeshes[i].TriangleIndex = polyMeshDetail.Meshes[i].TriangleIndex;
					navDMeshes[i].TriangleCount = polyMeshDetail.Meshes[i].TriangleCount;
					
					//Copy detail vertices 
					//first 'nv' verts are equal to nav poly verts
					//the rest are detail verts
					for (int j = 0; j < navDMeshes[i].VertexCount; j++)
					{
						storedDetailVerts.Add(polyMeshDetail.Verts[vb + numPolyVerts + j]);
					}

					vbase += numDetailVerts - numPolyVerts;
				}

				navDVerts = storedDetailVerts.ToArray();

				//store triangles
				for (int j = 0; j < polyMeshDetail.TrisCount; j++)
					navDTris[j] = polyMeshDetail.Tris[j];
			}
			else
			{
				//create dummy detail mesh by triangulating polys
				int tbase = 0;
				for (int i = 0; i < polyMesh.PolyCount; i++)
				{
					int numPolyVerts = navPolys[i].VertCount;
					navDMeshes[i].VertexIndex = 0;
					navDMeshes[i].VertexCount = 0;
					navDMeshes[i].TriangleIndex = tbase;
					navDMeshes[i].TriangleCount = numPolyVerts - 2;

					//triangulate polygon
					for (int j = 2; j < numPolyVerts; j++)
					{
						navDTris[tbase].VertexHash0 = 0;
						navDTris[tbase].VertexHash1 = j - 1;
						navDTris[tbase].VertexHash2 = j;

						//bit for each edge that belongs to the poly boundary
						navDTris[tbase].Flags = 1 << 2;
						if (j == 2) 
							navDTris[tbase].Flags |= 1 << 0;
						if (j == numPolyVerts - 1)
							navDTris[tbase].Flags |= 1 << 4;
						
						tbase++;
					}
				}
			}
			
			//store and create BV tree
			if (settings.BuildBoundingVolumeTree)
			{
				//build tree
				navBvTree = new BVTree(polyMesh.Verts, polyMesh.Polys, nvp, settings.CellSize, settings.CellHeight);
			}

			//store off-mesh connections
			n = 0;
			for (int i = 0; i < offMeshConnections.Length; i++)
			{
				//only store connections which start from this tile
				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)
				{
					offMeshConnections[n].Poly = offMeshPolyBase + n;

					//copy connection end points
					offMeshConnections[n].Pos0 = offMeshCons[i].Pos0;
					offMeshConnections[n].Pos1 = offMeshCons[i].Pos1;

					offMeshConnections[n].Radius = offMeshCons[i].Radius;
					offMeshConnections[n].Flags = offMeshCons[i].Flags;
					offMeshConnections[n].Side = offMeshSides[i * 2 + 1];
					offMeshConnections[n].Tag = offMeshCons[i].Tag;

					n++;
				}
			}
		}

		/// <summary>
		/// Gets the file header
		/// </summary>
		public PathfindingCommon.NavMeshInfo Header 
		{ 
			get 
			{ 
				return header; 
			} 
		}

		/// <summary>
		/// Gets the PolyMesh vertices
		/// </summary>
		public Vector3[] NavVerts 
		{ 
			get 
			{ 
				return navVerts; 
			} 
		}

		/// <summary>
		/// Gets the PolyMesh polygons
		/// </summary>
		public Poly[] NavPolys 
		{ 
			get 
			{
				return navPolys; 
			} 
		}

		/// <summary>
		/// Gets the PolyMeshDetail mesh data (the indices of the vertices and triagles)
		/// </summary>
		public PolyMeshDetail.MeshData[] NavDMeshes 
		{ 
			get 
			{ 
				return navDMeshes; 
			} 
		}

		/// <summary>
		/// Gets the PolyMeshDetail vertices
		/// </summary>
		public Vector3[] NavDVerts 
		{ 
			get 
			{ 
				return navDVerts; 
			} 
		}

		/// <summary>
		/// Gets the PolyMeshDetail triangles
		/// </summary>
		public PolyMeshDetail.TriangleData[] NavDTris 
		{ 
			get 
			{ 
				return navDTris; 
			} 
		}

		/// <summary>
		/// Gets the bounding volume tree
		/// </summary>
		public BVTree NavBvTree 
		{ 
			get 
			{ 
				return navBvTree; 
			} 
		}

		/// <summary>
		/// Gets the offmesh connection data
		/// </summary>
		public OffMeshConnection[] OffMeshCons 
		{ 
			get
			{ 
				return offMeshConnections; 
			} 
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\NavMeshGenerationSettings.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

namespace SharpNav
{
	/// <summary>
	/// Contains all the settings necessary to convert a mesh to a navmesh.
	/// </summary>
	public class NavMeshGenerationSettings
	{
		/// <summary>
		/// Prevents a default instance of the <see cref="NavMeshGenerationSettings"/> class from being created.
		/// Use <see cref="Default"/> instead.
		/// </summary>
		public NavMeshGenerationSettings()
		{
			//TODO now that this is public set reasonable defaults.
		}

		/// <summary>
		/// Gets the "default" generation settings for a model where 1 unit represents 1 meter.
		/// </summary>
		public static NavMeshGenerationSettings Default
		{
			get
			{
				//TODO rename this property to something more descriptive.
				var settings = new NavMeshGenerationSettings();

				settings.CellSize = 0.3f;
				settings.CellHeight = 0.2f;
				settings.MaxClimb = 0.9f;
				settings.AgentHeight = 2.0f;
				settings.AgentRadius = 0.6f;
				settings.MinRegionSize = 8;
				settings.MergedRegionSize = 20;
				settings.MaxEdgeLength = 12;
				settings.MaxEdgeError = 1.8f;
				settings.VertsPerPoly = 6;
				settings.SampleDistance = 6;
				settings.MaxSampleError = 1;

				settings.BuildBoundingVolumeTree = true;

				return settings;
			}
		}

		/// <summary>
		/// Gets or sets the size of a cell in the X and Z axes in world units.
		/// </summary>
		public float CellSize { get; set; }

		/// <summary>
		/// Gets or sets the height of a cell in world units.
		/// </summary>
		public float CellHeight { get; set; }

		/// <summary>
		/// Gets or sets the maximum climb height.
		/// </summary>
		public float MaxClimb { get; set; }

		/// <summary>
		/// Gets or sets the height of the agents traversing the <see cref="NavMesh"/>.
		/// </summary>
		public float AgentHeight { get; set; }

		/// <summary>
		/// Gets or sets the radius of the agents traversing the <see cref="NavMesh"/>.
		/// </summary>
		public float AgentRadius { get; set; }

		/// <summary>
		/// Gets or sets the minimum number of spans that can form a region. Any less than this, and they will be
		/// merged with another region.
		/// </summary>
		public int MinRegionSize { get; set; }

		/// <summary>
		/// Gets or sets the size of the merged regions
		/// </summary>
		public int MergedRegionSize { get; set; }

		/// <summary>
		/// Gets or sets the maximum edge length allowed
		/// </summary>
		public int MaxEdgeLength { get; set; }

		/// <summary>
		/// Gets or sets the maximum error allowed
		/// </summary>
		public float MaxEdgeError { get; set; }

		/// <summary>
		/// Gets or sets the flags that determine how the <see cref="ContourSet"/> is generated.
		/// </summary>
		public ContourBuildFlags ContourFlags { get; set; }

		/// <summary>
		/// Gets or sets the number of vertices a polygon can have.
		/// </summary>
		public int VertsPerPoly { get; set; }

		/// <summary>
		/// Gets or sets the sampling distance for the PolyMeshDetail
		/// </summary>
		public int SampleDistance { get; set; }

		/// <summary>
		/// Gets or sets the maximium error allowed in sampling for the PolyMeshDetail
		/// </summary>
		public int MaxSampleError { get; set; }

		/// <summary>
		/// Gets or sets a value indicating whether a bounding volume tree is generated for the mesh.
		/// </summary>
		public bool BuildBoundingVolumeTree { get; set; }

		/// <summary>
		/// Gets the height of the agents traversing the <see cref="NavMesh"/> in voxel (cell) units.
		/// </summary>
		public int VoxelAgentHeight
		{
			get
			{
				return (int)(AgentHeight / CellHeight);
			}
		}

		/// <summary>
		/// Gets the maximum clim height in voxel (cell) units.
		/// </summary>
		public int VoxelMaxClimb
		{
			get
			{
				return (int)(MaxClimb / CellHeight);
			}
		}

		/// <summary>
		/// Gets the radius of the agents traversing the <see cref="NavMesh"/> in voxel (cell) units.
		/// </summary>
		public int VoxelAgentRadius
		{
			get
			{
				return (int)(AgentRadius / CellHeight);
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\NavMeshQuery.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

using SharpNav.Collections.Generic;
using SharpNav.Geometry;
using SharpNav.Pathfinding;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// Do pathfinding calculations on the TiledNavMesh
	/// </summary>
	public class NavMeshQuery
	{
		private const float H_SCALE = 0.999f;

		private TiledNavMesh nav;
		private float[] areaCost; 
		private NodePool tinyNodePool;
		private NodePool nodePool;
		private PriorityQueue<Node> openList;
		private QueryData query;
		private Random rand;

		/// <summary>
		/// Initializes a new instance of the <see cref="NavMeshQuery"/> class.
		/// </summary>
		/// <param name="nav">The navigation mesh to query.</param>
		/// <param name="maxNodes">The maximum number of nodes that can be queued in a query.</param>
		public NavMeshQuery(TiledNavMesh nav, int maxNodes)
			: this(nav, maxNodes, new Random())
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="NavMeshQuery"/> class.
		/// </summary>
		/// <param name="nav">The navigation mesh to query.</param>
		/// <param name="maxNodes">The maximum number of nodes that can be queued in a query.</param>
		/// <param name="rand">A random number generator for use in methods like <see cref="NavMeshQuery.FindRandomPoint()"/></param>
		public NavMeshQuery(TiledNavMesh nav, int maxNodes, Random rand)
		{
			this.nav = nav;

			areaCost = new float[byte.MaxValue + 1];
			for (int i = 0; i < areaCost.Length; i++)
				areaCost[i] = 1.0f;

			nodePool = new NodePool(maxNodes, MathHelper.NextPowerOfTwo(maxNodes / 4));
			tinyNodePool = new NodePool(64, 32);
			openList = new PriorityQueue<Node>(maxNodes);

			this.rand = rand;
		}

		/// <summary>
		/// The cost between two points may vary depending on the type of polygon.
		/// </summary>
		/// <param name="pa">Point A</param>
		/// <param name="pb">Point B</param>
		/// <param name="curPoly">Current polygon</param>
		/// <returns>Cost</returns>
		public float GetCost(Vector3 pa, Vector3 pb, Poly curPoly)
		{
			return (pa - pb).Length() * areaCost[(int)curPoly.Area.Id];
		}

		public TiledNavMesh NavMesh
		{
			get
			{
				return nav;
			}
		}

		/// <summary>
		/// Finds a random point on a polygon.
		/// </summary>
		/// <param name="tile">The current mesh tile</param>
		/// <param name="poly">The current polygon</param>
		/// <param name="polyRef">Polygon reference</param>
		/// <returns>Resulting random point</returns>
		public Vector3 FindRandomPointOnPoly(MeshTile tile, Poly poly, int polyRef)
		{
			Vector3 result;
			this.FindRandomPointOnPoly(tile, poly, polyRef, out result);
			return result;
		}

		/// <summary>
		/// Finds a random point on a polygon.
		/// </summary>
		/// <param name="tile">The current mesh tile</param>
		/// <param name="poly">The current polygon</param>
		/// <param name="polyRef">Polygon reference</param>
		/// <param name="randomPt">Resulting random point</param>
		public void FindRandomPointOnPoly(MeshTile tile, Poly poly, int polyRef, out Vector3 randomPt)
		{
			Vector3[] verts = new Vector3[PathfindingCommon.VERTS_PER_POLYGON];
			float[] areas = new float[PathfindingCommon.VERTS_PER_POLYGON];
			for (int j = 0; j < poly.VertCount; j++)
				verts[j] = tile.Verts[poly.Verts[j]];

			float s = (float)rand.NextDouble();
			float t = (float)rand.NextDouble();

			PathfindingCommon.RandomPointInConvexPoly(verts, poly.VertCount, areas, s, t, out randomPt);

			//TODO bad state again.
			float h = 0.0f;
			if (!GetPolyHeight(polyRef, randomPt, ref h))
				throw new InvalidOperationException("Outside bounds?");

			randomPt.Y = h;
		}

		/// <summary>
		/// Finds a random point somewhere in the navigation mesh.
		/// </summary>
		/// <returns>Resulting random point.</returns>
		public NavPoint FindRandomPoint()
		{
			NavPoint result;
			this.FindRandomPoint(out result);
			return result;
		}

		/// <summary>
		/// Finds a random point somewhere in the navigation mesh.
		/// </summary>
		/// <param name="randomPoint">Resulting random point.</param>
		public void FindRandomPoint(out NavPoint randomPoint)
		{
			//TODO we're object-oriented, can prevent this state from ever happening.
			if (nav == null)
				throw new InvalidOperationException("TODO prevent this state from ever occuring");

			//randomly pick one tile
			//assume all tiles cover roughly the same area
			MeshTile tile = null;
			float tsum = 0.0f;
			
			for (int i = 0; i < nav.TileCount; i++)
			{
				MeshTile t = nav[i];
				
				if (t == null || t.Header == null)
					continue;

				//choose random tile using reservoir sampling
				float area = 1.0f;
				tsum += area;
				float u = (float)rand.NextDouble();
				if (u * tsum <= area)
					tile = t;
			}

			//TODO why?
			if (tile == null)
				throw new InvalidOperationException("No tiles?");

			//randomly pick one polygon weighted by polygon area
			Poly poly = null;
			int polyRef = 0;
			int polyBase = nav.GetPolyRefBase(tile);

			float areaSum = 0.0f;
			for (int i = 0; i < tile.Header.PolyCount; i++)
			{
				Poly p = tile.Polys[i];

				//don't return off-mesh connection polygons
				if (p.PolyType != PolygonType.Ground)
					continue;

				int reference = polyBase | i;

				//calculate area of polygon
				float polyArea = 0.0f;
				float area;
				for (int j = 2; j < p.VertCount; j++)
				{
					Triangle3.Area2D(ref tile.Verts[p.Verts[0]], ref tile.Verts[p.Verts[j - 1]], ref tile.Verts[p.Verts[j]], out area);
					polyArea += area;
				}

				//choose random polygon weighted by area, usig resevoir sampling
				areaSum += polyArea;
				float u = (float)rand.NextDouble();
				if (u * areaSum <= polyArea)
				{
					poly = p;
					polyRef = reference;
				}
			}

			//TODO why?
			if (poly == null)
				throw new InvalidOperationException("No polys?");

			//randomRef = polyRef;
			Vector3 randomPt;
			FindRandomPointOnPoly(tile, poly, polyRef, out randomPt);

			randomPoint = new NavPoint(polyRef, randomPt);
		}

		/// <summary>
		/// Finds a random point in a NavMesh within a specified circle.
		/// </summary>
		/// <param name="center">The center point.</param>
		/// <param name="radius">The maximum distance away from the center that the random point can be.</param>
		/// <returns>A random point within the specified circle.</returns>
		public NavPoint FindRandomPointAroundCircle(NavPoint center, float radius)
		{
			NavPoint result;
			this.FindRandomPointAroundCircle(center, radius, out result);
			return result;
		}

		/// <summary>
		/// Finds a random point in a NavMesh within a specified circle.
		/// </summary>
		/// <param name="center">The center point.</param>
		/// <param name="radius">The maximum distance away from the center that the random point can be.</param>
		/// <param name="randomPoint">A random point within the specified circle.</param>
		public void FindRandomPointAroundCircle(NavPoint center, float radius, out NavPoint randomPoint)
		{
			//TODO fix state
			if (nav == null || nodePool == null || openList == null)
				throw new InvalidOperationException("Something null");

			//validate input
			if (center.Polygon == 0)
				throw new ArgumentOutOfRangeException("startRef", "Null poly reference");

			if (!nav.IsValidPolyRef(center.Polygon))
				throw new ArgumentException("startRef", "Poly reference is not valid for this navmesh");

			MeshTile startTile;
			Poly startPoly;
			nav.TryGetTileAndPolyByRefUnsafe(center.Polygon, out startTile, out startPoly);

			nodePool.Clear();
			openList.Clear();

			Node startNode = nodePool.GetNode(center.Polygon);
			startNode.Pos = center.Position;
			startNode.ParentIdx = 0;
			startNode.cost = 0;
			startNode.total = 0;
			startNode.Id = center.Polygon;
			startNode.Flags = NodeFlags.Open;
			openList.Push(startNode);

			float radiusSqr = radius * radius;
			float areaSum = 0.0f;

			MeshTile randomTile = null;
			Poly randomPoly = null;
			int randomPolyRef = 0;

			while (openList.Count > 0)
			{
				Node bestNode = openList.Pop();
				SetNodeFlagClosed(ref bestNode);

				//get poly and tile
				int bestRef = bestNode.Id;
				MeshTile bestTile;
				Poly bestPoly;
				nav.TryGetTileAndPolyByRefUnsafe(bestRef, out bestTile, out bestPoly);

				//place random locations on ground
				if (bestPoly.PolyType == PolygonType.Ground)
				{
					//calculate area of polygon
					float polyArea = 0.0f;
					float area;
					for (int j = 2; j < bestPoly.VertCount; j++)
					{
						Triangle3.Area2D(ref bestTile.Verts[bestPoly.Verts[0]], ref bestTile.Verts[bestPoly.Verts[j - 1]], ref bestTile.Verts[bestPoly.Verts[j]], out area);
						polyArea += area;
					}

					//choose random polygon weighted by area using resevoir sampling
					areaSum += polyArea;
					float u = (float)rand.NextDouble();
					if (u * areaSum <= polyArea)
					{
						randomTile = bestTile;
						randomPoly = bestPoly;
						randomPolyRef = bestRef;
					}
				}

				//get parent poly and tile
				int parentRef = 0;
				MeshTile parentTile;
				Poly parentPoly;
				if (bestNode.ParentIdx != 0)
					parentRef = nodePool.GetNodeAtIdx(bestNode.ParentIdx).Id;
				if (parentRef != 0)
					nav.TryGetTileAndPolyByRefUnsafe(parentRef, out parentTile, out parentPoly);

				for (int i = bestPoly.FirstLink; i != Link.Null; i = bestTile.Links[i].Next)
				{
					Link link = bestTile.Links[i];
					int neighbourRef = link.Reference;

					//skip invalid neighbours and do not follor back to parent
					if (neighbourRef == 0 || neighbourRef == parentRef)
						continue;

					//expand to neighbour
					MeshTile neighbourTile;
					Poly neighbourPoly;
					nav.TryGetTileAndPolyByRefUnsafe(neighbourRef, out neighbourTile, out neighbourPoly);

					//find edge and calculate distance to edge
					Vector3 va = new Vector3();
					Vector3 vb = new Vector3();
					if (!GetPortalPoints(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, ref va, ref vb))
						continue;

					//if circle isn't touching next polygon, skip it
					float tseg;
					float distSqr = Distance.PointToSegment2DSquared(ref center.Position, ref va, ref vb, out tseg);
					if (distSqr > radiusSqr)
						continue;

					Node neighbourNode = nodePool.GetNode(neighbourRef);
					if (neighbourNode == null)
						continue;

					if (IsInClosedList(neighbourNode))
						continue;

					//cost
					if (neighbourNode.Flags == 0)
						neighbourNode.Pos = Vector3.Lerp(va, vb, 0.5f);

					float total = bestNode.total + (bestNode.Pos - neighbourNode.Pos).Length();

					//node is already in open list and new result is worse, so skip
					if (IsInOpenList(neighbourNode) && total >= neighbourNode.total)
						continue;

					neighbourNode.Id = neighbourRef;
					neighbourNode.Flags = RemoveNodeFlagClosed(neighbourNode);
					neighbourNode.ParentIdx = nodePool.GetNodeIdx(bestNode);
					neighbourNode.total = total;

					if (IsInOpenList(neighbourNode))
					{
						openList.Modify(neighbourNode);
					}
					else
					{
						neighbourNode.Flags = NodeFlags.Open;
						openList.Push(neighbourNode);
					}
				}
			}

			//TODO invalid state.
			if (randomPoly == null)
				throw new InvalidOperationException("Poly null?");

			Vector3 randomPt;
			FindRandomPointOnPoly(randomTile, randomPoly, randomPolyRef, out randomPt);

			randomPoint = new NavPoint(randomPolyRef, randomPt);
		}

		/// <summary>
		/// Find a path from the start polygon to the end polygon.
		/// -If the end polygon can't be reached, the last polygon will be nearest the end polygon
		/// -If the path array is too small, it will be filled as far as possible 
		/// -start and end positions are used to calculate traversal costs
		/// </summary>
		/// <param name="startPt">The start point.</param>
		/// <param name="endPt">The end point.</param>
		/// <param name="path">The path of polygon references</param>
		/// <returns>True, if path found. False, if otherwise.</returns>
		public bool FindPath(ref NavPoint startPt, ref NavPoint endPt, List<int> path)
		{
			//reset path of polygons
			path.Clear();

			int startRef = startPt.Polygon;
			Vector3 startPos = startPt.Position;
			int endRef = endPt.Polygon;
			Vector3 endPos = endPt.Position;

			if (startRef == 0 || endRef == 0)
				return false;

			//path can't store any elements
			if (path.Capacity == 0)
				return false;

			//validate input
			if (!nav.IsValidPolyRef(startRef) || !nav.IsValidPolyRef(endRef))
				return false;

			//special case: both start and end are in the same polygon
			if (startRef == endRef)
			{
				path.Add(startRef);
				return true;
			}

			nodePool.Clear();
			openList.Clear();

			//initial node is located at the starting position
			Node startNode = nodePool.GetNode(startRef);
			startNode.Pos = startPos;
			startNode.ParentIdx = 0;
			startNode.cost = 0;
			startNode.total = (startPos - endPos).Length() * H_SCALE;
			startNode.Id = startRef;
			startNode.Flags = NodeFlags.Open;
			openList.Push(startNode);

			Node lastBestNode = startNode;
			float lastBestTotalCost = startNode.total;

			while (openList.Count > 0)
			{
				//remove node from open list and put it in closed list
				Node bestNode = openList.Pop();
				SetNodeFlagClosed(ref bestNode);

				//reached the goal. stop searching
				if (bestNode.Id == endRef)
				{
					lastBestNode = bestNode;
					break;
				}

				//get current poly and tile
				int bestRef = bestNode.Id;
				MeshTile bestTile;
				Poly bestPoly;
				nav.TryGetTileAndPolyByRefUnsafe(bestRef, out bestTile, out bestPoly);

				//get parent poly and tile
				int parentRef = 0;
				MeshTile parentTile;
				Poly parentPoly;
				if (bestNode.ParentIdx != 0)
					parentRef = nodePool.GetNodeAtIdx(bestNode.ParentIdx).Id;
				if (parentRef != 0)
					nav.TryGetTileAndPolyByRefUnsafe(parentRef, out parentTile, out parentPoly);

				//examine neighbors
				for (int i = bestPoly.FirstLink; i != Link.Null; i = bestTile.Links[i].Next)
				{
					int neighbourRef = bestTile.Links[i].Reference;

					//skip invalid ids and do not expand back to where we came from
					if (neighbourRef == 0 || neighbourRef == parentRef)
						continue;

					//get neighbour poly and tile
					MeshTile neighbourTile;
					Poly neighbourPoly;
					nav.TryGetTileAndPolyByRefUnsafe(neighbourRef, out neighbourTile, out neighbourPoly);

					Node neighbourNode = nodePool.GetNode(neighbourRef);
					if (neighbourNode == null)
						continue;

					//if node is visited the first time, calculate node position
					if (neighbourNode.Flags == 0)
					{
						GetEdgeMidPoint(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, ref neighbourNode.Pos);
					}

					//calculate cost and heuristic
					float cost = 0;
					float heuristic = 0;

					//special case for last node
					if (neighbourRef == endRef)
					{
						//cost
						float curCost = GetCost(bestNode.Pos, neighbourNode.Pos, bestPoly);
						float endCost = GetCost(neighbourNode.Pos, endPos, neighbourPoly);

						cost = bestNode.cost + curCost + endCost;
						heuristic = 0;
					}
					else
					{
						//cost
						float curCost = GetCost(bestNode.Pos, neighbourNode.Pos, bestPoly);
						
						cost = bestNode.cost + curCost;
						heuristic = (neighbourNode.Pos - endPos).Length() * H_SCALE; 
					}

					float total = cost + heuristic;

					//the node is already in open list and new result is worse, skip
					if (IsInOpenList(neighbourNode) && total >= neighbourNode.total)
						continue;

					//the node is already visited and processesd, and the new result is worse, skip
					if (IsInClosedList(neighbourNode) && total >= neighbourNode.total)
						continue;

					//add or update the node
					neighbourNode.ParentIdx = nodePool.GetNodeIdx(bestNode);
					neighbourNode.Id = neighbourRef;
					neighbourNode.Flags = RemoveNodeFlagClosed(neighbourNode);
					neighbourNode.cost = cost;
					neighbourNode.total = total;

					if (IsInOpenList(neighbourNode))
					{
						//already in open, update node location
						openList.Modify(neighbourNode);
					}
					else
					{
						//put the node in the open list
						SetNodeFlagOpen(ref neighbourNode);
						openList.Push(neighbourNode);
					}

					//update nearest node to target so far
					if (heuristic < lastBestTotalCost)
					{
						lastBestTotalCost = heuristic;
						lastBestNode = neighbourNode;
					}
				}
			}

			//save path
			Node node = lastBestNode;
			do
			{
				path.Add(node.Id);
				if (path.Count >= path.Capacity)
					break;
		
				node = nodePool.GetNodeAtIdx(node.ParentIdx);
			}
			while (node != null);
			
			//reverse the path since it's backwards
			path.Reverse();

			return true;
		}

		/// <summary>
		/// Add vertices and portals to a regular path computed from the method FindPath().
		/// </summary>
		/// <param name="startPos">Starting position</param>
		/// <param name="endPos">Ending position</param>
		/// <param name="path">Path of polygon references</param>
		/// <param name="pathSize">Length of path</param>
		/// <param name="straightPath">An array of points on the straight path</param>
		/// <param name="straightPathFlags">An array of flags</param>
		/// <param name="straightPathRefs">An array of polygon references</param>
		/// <param name="straightPathCount">The number of points on the path</param>
		/// <param name="maxStraightPath">The maximum length allowed for the straight path</param>
		/// <param name="options">Options flag</param>
		/// <returns>True, if path found. False, if otherwise.</returns>
		public bool FindStraightPath(Vector3 startPos, Vector3 endPos, int[] path, int pathSize, Vector3[] straightPath, int[] straightPathFlags, int[] straightPathRefs, ref int straightPathCount, int maxStraightPath, PathBuildFlags options)
		{
			straightPathCount = 0;

			if (path.Length == 0)
				return false;

			bool stat = false;

			Vector3 closestStartPos = new Vector3();
			ClosestPointOnPolyBoundary(path[0], startPos, ref closestStartPos);

			Vector3 closestEndPos = new Vector3();
			ClosestPointOnPolyBoundary(path[pathSize - 1], endPos, ref closestEndPos);

			stat = AppendVertex(closestStartPos, PathfindingCommon.STRAIGHTPATH_START, path[0], straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath);

			if (!stat)
				return true;

			if (pathSize > 1)
			{
				Vector3 portalApex = closestStartPos;
				Vector3 portalLeft = portalApex;
				Vector3 portalRight = portalApex;
				int apexIndex = 0;
				int leftIndex = 0;
				int rightIndex = 0;

				PolygonType leftPolyType = 0;
				PolygonType rightPolyType = 0;

				int leftPolyRef = path[0];
				int rightPolyRef = path[0];

				for (int i = 0; i < pathSize; i++)
				{
					Vector3 left = new Vector3();
					Vector3 right = new Vector3();
					PolygonType fromType = 0, toType = 0;

					if (i + 1 < pathSize)
					{
						//next portal
						if (GetPortalPoints(path[i], path[i + 1], ref left, ref right, ref fromType, ref toType) == false)
						{
							//failed to get portal points means path[i + 1] is an invalid polygon
							//clamp end point to path[i] and return path so far
							if (ClosestPointOnPolyBoundary(path[i], endPos, ref closestEndPos) == false)
							{
								//first polygon is invalid
								return false;
							}

							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)
							{
								//append portals
								stat = AppendPortals(apexIndex, i, closestEndPos, path, straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath, options);
							}

							stat = AppendVertex(closestEndPos, 0, path[i], straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath);

							return true;
						}

						//if starting really close to the portal, advance
						if (i == 0)
						{
							float t;
							if (Distance.PointToSegment2DSquared(ref portalApex, ref left, ref right, out t) < 0.001 * 0.001)
								continue;
						}
					}
					else
					{
						//end of the path
						left = closestEndPos;
						right = closestEndPos;

						fromType = toType = PolygonType.Ground;
					}

					//right vertex
					float triArea2D;
					Triangle3.Area2D(ref portalApex, ref portalRight, ref right, out triArea2D);
					if (triArea2D <= 0.0)
					{
						Triangle3.Area2D(ref portalApex, ref portalLeft, ref right, out triArea2D);
						if (portalApex == portalRight || triArea2D > 0.0)
						{
							portalRight = right;
							rightPolyRef = (i + 1 < pathSize) ? path[i + 1] : 0;
							rightPolyType = toType;
							rightIndex = i;
						}
						else
						{
							//append portals along current straight path segment
							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)
							{
								stat = AppendPortals(apexIndex, leftIndex, portalLeft, path, straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath, options);

								if (stat != true)
									return true;
							}

							portalApex = portalLeft;
							apexIndex = leftIndex;

							int flags = 0;
							if (leftPolyRef == 0)
								flags = PathfindingCommon.STRAIGHTPATH_END;
							else if (leftPolyType == PolygonType.OffMeshConnection)
								flags = PathfindingCommon.STRAIGHTPATH_OFFMESH_CONNECTION;

							int reference = leftPolyRef;

							//append or update vertex
							stat = AppendVertex(portalApex, flags, reference, straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath);

							if (stat != true)
								return true;

							portalLeft = portalApex;
							portalRight = portalApex;
							leftIndex = apexIndex;
							rightIndex = apexIndex;

							//restart
							i = apexIndex;

							continue;
						}
					}

					//left vertex
					Triangle3.Area2D(ref portalApex, ref portalLeft, ref left, out triArea2D);
					if (triArea2D >= 0.0)
					{
						Triangle3.Area2D(ref portalApex, ref portalRight, ref left, out triArea2D);
						if (portalApex == portalLeft || triArea2D < 0.0f)
						{
							portalLeft = left;
							leftPolyRef = (i + 1 < pathSize) ? path[i + 1] : 0;
							leftPolyType = toType;
							leftIndex = i;
						}
						else
						{
							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)
							{
								stat = AppendPortals(apexIndex, rightIndex, portalRight, path, straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath, options);

								if (stat != true)
									return true;
							}

							portalApex = portalRight;
							apexIndex = rightIndex;

							int flags = 0;
							if (rightPolyRef == 0)
								flags = PathfindingCommon.STRAIGHTPATH_END;
							else if (rightPolyType == PolygonType.OffMeshConnection)
								flags = PathfindingCommon.STRAIGHTPATH_OFFMESH_CONNECTION;

							int reference = rightPolyRef;

							//append or update vertex
							stat = AppendVertex(portalApex, flags, reference, straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath);

							if (stat != true)
								return true;

							portalLeft = portalApex;
							portalRight = portalApex;
							leftIndex = apexIndex;
							rightIndex = apexIndex;

							//restart 
							i = apexIndex;

							continue;
						}
					}
				}

				//append portals along the current straight line segment
				if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)
				{
					stat = AppendPortals(apexIndex, pathSize - 1, closestEndPos, path, straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath, options);

					if (stat != true)
						return true;
				}
			}

			stat = AppendVertex(closestEndPos, PathfindingCommon.STRAIGHTPATH_END, 0, straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath);

			return true;
		}

		/// <summary>
		/// This method is optimized for small delta movement and a small number of polygons.
		/// If movement distance is too large, the result will form an incomplete path.
		/// </summary>
		/// <param name="startPoint">The start point.</param>
		/// <param name="endPos">End position</param>
		/// <param name="resultPos">Intermediate point</param>
		/// <param name="visited">Visited polygon references</param>
		/// <returns>True, if point found. False, if otherwise.</returns>
		public bool MoveAlongSurface(NavPoint startPoint, Vector3 endPos, ref Vector3 resultPos, List<int> visited)
		{
			if (nav == null)
				return false;
			if (tinyNodePool == null)
				return false;

			visited.Clear();

			//validate input
			if (startPoint.Polygon == 0)
				return false;
			if (!nav.IsValidPolyRef(startPoint.Polygon))
				return false;

			int MAX_STACK = 48;
			Queue<Node> nodeQueue = new Queue<Node>(MAX_STACK);

			tinyNodePool.Clear();

			Node startNode = tinyNodePool.GetNode(startPoint.Polygon);
			startNode.ParentIdx = 0;
			startNode.cost = 0;
			startNode.total = 0;
			startNode.Id = startPoint.Polygon;
			startNode.Flags = NodeFlags.Closed;
			nodeQueue.Enqueue(startNode);

			Vector3 bestPos = startPoint.Position;
			float bestDist = float.MaxValue;
			Node bestNode = null;

			//search constraints
			Vector3 searchPos = Vector3.Lerp(startPoint.Position, endPos, 0.5f);
			float searchRad = (startPoint.Position - endPos).Length() / 2.0f + 0.001f;
			float searchRadSqr = searchRad * searchRad;

			Vector3[] verts = new Vector3[PathfindingCommon.VERTS_PER_POLYGON];
			
			while (nodeQueue.Count > 0)
			{
				//pop front
				Node curNode = nodeQueue.Dequeue();

				//get poly and tile
				int curRef = curNode.Id;
				MeshTile curTile;
				Poly curPoly;
				nav.TryGetTileAndPolyByRefUnsafe(curRef, out curTile, out curPoly);

				//collect vertices
				int nverts = curPoly.VertCount;
				for (int i = 0; i < nverts; i++)
					verts[i] = curTile.Verts[curPoly.Verts[i]];

				//if target is inside poly, stop search
				if (Containment.PointInPoly(endPos, verts, nverts))
				{
					bestNode = curNode;
					bestPos = endPos;
					break;
				}

				//find wall edges and find nearest point inside walls
				for (int i = 0, j = curPoly.VertCount - 1; i < curPoly.VertCount; j = i++)
				{
					//find links to neighbors
					List<int> neis = new List<int>(8);

					if ((curPoly.Neis[j] & Link.External) != 0)
					{
						//tile border
						for (int k = curPoly.FirstLink; k != Link.Null; k = curTile.Links[k].Next)
						{
							Link link = curTile.Links[k];
							if (link.Edge == j)
							{
								if (link.Reference != 0)
								{
									MeshTile neiTile;
									Poly neiPoly;
									nav.TryGetTileAndPolyByRefUnsafe(link.Reference, out neiTile, out neiPoly);
									
									if (neis.Count < neis.Capacity)
										neis.Add(link.Reference);
								}
							}
						}
					}
					else if (curPoly.Neis[j] != 0)
					{
						int idx = curPoly.Neis[j] - 1;
						int reference = nav.GetPolyRefBase(curTile) | idx;
						neis.Add(reference); //internal edge, encode id
					}

					if (neis.Count == 0)
					{
						//wall edge, calculate distance
						float tseg = 0;
						float distSqr = Distance.PointToSegment2DSquared(ref endPos, ref verts[j], ref verts[i], out tseg);
						if (distSqr < bestDist)
						{
							//update nearest distance
							bestPos = Vector3.Lerp(verts[j], verts[i], tseg);
							bestDist = distSqr;
							bestNode = curNode;
						}
					}
					else
					{
						for (int k = 0; k < neis.Count; k++)
						{
							//skip if no node can be allocated
							Node neighbourNode = tinyNodePool.GetNode(neis[k]);
							if (neighbourNode == null)
								continue;
							
							//skip if already visited
							if ((neighbourNode.Flags & NodeFlags.Closed) != 0)
								continue;

							//skip the link if too far from search constraint
							float distSqr = Distance.PointToSegment2DSquared(ref searchPos, ref verts[j], ref verts[i]);
							if (distSqr > searchRadSqr)
								continue;

							//mark the node as visited and push to queue
							if (nodeQueue.Count < MAX_STACK)
							{
								neighbourNode.ParentIdx = tinyNodePool.GetNodeIdx(curNode);
								neighbourNode.Flags |= NodeFlags.Closed;
								nodeQueue.Enqueue(neighbourNode);
							}
						}
					}
				}
			}

			if ((endPos - bestPos).Length() > 1f)
				return false;

			if (bestNode != null)
			{
				//save the path
				Node node = bestNode;
				do
				{
					visited.Add(node.Id);
					if (visited.Count >= visited.Capacity)
						break;

					node = tinyNodePool.GetNodeAtIdx(node.ParentIdx);
				}
				while (node != null);

				//reverse the path since it's backwards
				visited.Reverse();
			}

			resultPos = bestPos;
			
			return true;
		}

		/// <summary>
		/// Initialize a sliced path, which is used mostly for crowd pathfinding.
		/// </summary>
		/// <param name="startPoint">The start point.</param>
		/// <param name="endPoint">The end point.</param>
		/// <returns>True if path initialized, false otherwise</returns>
		public bool InitSlicedFindPath(NavPoint startPoint, NavPoint endPoint)
		{
			//init path state
			query = new QueryData();
			query.Status = false;
			query.StartRef = startPoint.Polygon;
			query.EndRef = endPoint.Polygon;
			query.StartPos = startPoint.Position;
			query.EndPos = endPoint.Position;

			if (query.StartRef == 0 || query.EndRef == 0)
				return false;

			//validate input
			if (!nav.IsValidPolyRef(startPoint.Polygon) || !nav.IsValidPolyRef(endPoint.Polygon))
				return false;

			if (startPoint.Polygon == endPoint.Polygon)
			{
				query.Status = true;
				return true;
			}

			nodePool.Clear();
			openList.Clear();

			Node startNode = nodePool.GetNode(startPoint.Polygon);
			startNode.Pos = startPoint.Position;
			startNode.ParentIdx = 0;
			startNode.cost = 0;
			startNode.total = (endPoint.Position - startPoint.Position).Length() * H_SCALE;
			startNode.Id = startPoint.Polygon;
			startNode.Flags = NodeFlags.Open;
			openList.Push(startNode);

			query.Status = true;
			query.LastBestNode = startNode;
			query.LastBestNodeCost = startNode.total;

			return query.Status;
		}

		/// <summary>
		/// Update the sliced path as agents move across the path.
		/// </summary>
		/// <param name="maxIter">Maximum iterations</param>
		/// <param name="doneIters">Number of times iterated through</param>
		/// <returns>True if updated, false if not</returns>
		public bool UpdateSlicedFindPath(int maxIter, ref int doneIters)
		{
			if (query.Status != true)
				return query.Status;

			//make sure the request is still valid
			if (!nav.IsValidPolyRef(query.StartRef) || !nav.IsValidPolyRef(query.EndRef))
			{
				query.Status = false;
				return false;
			}

			int iter = 0;
			while (iter < maxIter && !openList.Empty())
			{
				iter++;

				//remove node from open list and put it in closed list
				Node bestNode = openList.Pop();
				SetNodeFlagClosed(ref bestNode);

				//reached the goal, stop searching
				if (bestNode.Id == query.EndRef)
				{
					query.LastBestNode = bestNode;
					query.Status = true;
					doneIters = iter;
					return query.Status;
				}

				//get current poly and tile
				int bestRef = bestNode.Id;
				MeshTile bestTile;
				Poly bestPoly;
				if (nav.TryGetTileAndPolyByRef(bestRef, out bestTile, out bestPoly) == false)
				{
					//the polygon has disappeared during the sliced query, fail
					query.Status = false;
					doneIters = iter;
					return query.Status;
				}

				//get parent poly and tile
				int parentRef = 0;
				MeshTile parentTile;
				Poly parentPoly;
				if (bestNode.ParentIdx != 0)
					parentRef = nodePool.GetNodeAtIdx(bestNode.ParentIdx).Id;
				if (parentRef != 0)
				{
					if (nav.TryGetTileAndPolyByRef(parentRef, out parentTile, out parentPoly) == false)
					{
						//the polygon has disappeared during the sliced query, fail
						query.Status = false;
						doneIters = iter;
						return query.Status;
					}
				}

				for (int i = bestPoly.FirstLink; i != Link.Null; i = bestTile.Links[i].Next)
				{
					int neighbourRef = bestTile.Links[i].Reference;

					//skip invalid ids and do not expand back to where we came from
					if (neighbourRef == 0 || neighbourRef == parentRef)
						continue;

					//get neighbour poly and tile
					MeshTile neighbourTile;
					Poly neighbourPoly;
					nav.TryGetTileAndPolyByRefUnsafe(neighbourRef, out neighbourTile, out neighbourPoly);

					Node neighbourNode = nodePool.GetNode(neighbourRef);
					if (neighbourNode == null)
						continue;

					if (neighbourNode.Flags == 0)
					{
						GetEdgeMidPoint(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, ref neighbourNode.Pos);
					}

					//calculate cost and heuristic
					float cost = 0;
					float heuristic = 0;

					//special case for last node
					if (neighbourRef == query.EndRef)
					{
						//cost
						float curCost = GetCost(bestNode.Pos, neighbourNode.Pos, bestPoly);
						float endCost = GetCost(neighbourNode.Pos, query.EndPos, neighbourPoly);

						cost = bestNode.cost + curCost + endCost;
						heuristic = 0;
					}
					else
					{
						//cost
						float curCost = GetCost(bestNode.Pos, neighbourNode.Pos, bestPoly);

						cost = bestNode.cost + curCost;
						heuristic = (neighbourNode.Pos - query.EndPos).Length() * H_SCALE;
					}

					float total = cost + heuristic;

					//the node is already in open list and new result is worse, skip
					if (IsInOpenList(neighbourNode) && total >= neighbourNode.total)
						continue;

					//the node is already visited and processesd, and the new result is worse, skip
					if (IsInClosedList(neighbourNode) && total >= neighbourNode.total)
						continue;

					//add or update the node
					neighbourNode.ParentIdx = nodePool.GetNodeIdx(bestNode);
					neighbourNode.Id = neighbourRef;
					neighbourNode.Flags = RemoveNodeFlagClosed(neighbourNode);
					neighbourNode.cost = cost;
					neighbourNode.total = total;

					if (IsInOpenList(neighbourNode))
					{
						//already in open, update node location
						openList.Modify(neighbourNode);
					}
					else
					{
						//put the node in the open list
						SetNodeFlagOpen(ref neighbourNode);
						openList.Push(neighbourNode);
					}

					//update nearest node to target so far
					if (heuristic < query.LastBestNodeCost)
					{
						query.LastBestNodeCost = heuristic;
						query.LastBestNode = neighbourNode;
					}
				}
			}

			//exhausted all nodes, but could not find path
			if (openList.Empty())
			{
				query.Status = true;
			}

			doneIters = iter;

			return query.Status;
		}

		/// <summary>
		/// Save the sliced path 
		/// </summary>
		/// <param name="path">The path in terms of polygon references</param>
		/// <param name="pathCount">The path length</param>
		/// <param name="maxPath">The maximum path length allowed</param>
		/// <returns>True if the path is saved, false if not</returns>
		public bool FinalizeSlicedFindPath(int[] path, ref int pathCount, int maxPath)
		{
			pathCount = 0;

			if (query.Status == false)
			{
				query = new QueryData();
				return false;
			}

			int n = 0;

			if (query.StartRef == query.EndRef)
			{
				//special case: the search starts and ends at the same poly
				path[n++] = query.StartRef;
			}
			else
			{
				//reverse the path
				Node prev = null;
				Node node = query.LastBestNode;
				do
				{
					Node next = nodePool.GetNodeAtIdx(node.ParentIdx);
					node.ParentIdx = nodePool.GetNodeIdx(prev);
					prev = node;
					node = next;
				}
				while (node != null);

				//store path
				node = prev;
				do
				{
					path[n++] = node.Id;
					if (n >= maxPath)
						break;

					node = nodePool.GetNodeAtIdx(node.ParentIdx);
				}
				while (node != null);
			}

			//reset query
			query = new QueryData();

			//remember to update the path length
			pathCount = n;

			return true;
		}

		/// <summary>
		/// Save a partial path
		/// </summary>
		/// <param name="existing">Existing path</param>
		/// <param name="existingSize">Existing path's length</param>
		/// <param name="path">New path</param>
		/// <param name="pathCount">New path's length</param>
		/// <param name="maxPath">Maximum path length allowed</param>
		/// <returns>True if path saved, false if not</returns>
		public bool FinalizedSlicedPathPartial(int[] existing, int existingSize, int[] path, ref int pathCount, int maxPath)
		{
			pathCount = 0;

			if (existingSize == 0)
			{
				return false;
			}

			if (query.Status == false)
			{
				query = new QueryData();
				return false;
			}

			int n = 0;

			if (query.StartRef == query.EndRef)
			{
				//special case: the search starts and ends at the same poly
				path[n++] = query.StartRef;
			}
			else
			{
				//find furthest existing node that was visited
				Node prev = null;
				Node node = null;
				for (int i = existingSize - 1; i >= 0; i--)
				{
					node = nodePool.FindNode(existing[i]);
					if (node != null)
						break;
				}

				if (node == null)
				{
					node = query.LastBestNode;
				}

				//reverse the path
				do
				{
					Node next = nodePool.GetNodeAtIdx(node.ParentIdx);
					node.ParentIdx = nodePool.GetNodeIdx(prev);
					prev = node;
					node = next;
				}
				while (node != null);

				//store path
				node = prev;
				do
				{
					path[n++] = node.Id;
					if (n >= maxPath)
					{
						break;
					}

					node = nodePool.GetNodeAtIdx(node.ParentIdx);
				}
				while (node != null);
			}

			//reset query
			query = new QueryData();

			//remember to update the path length
			pathCount = n;

			return true;
		}

		public bool Raycast(NavPoint startPoint, Vector3 endPos, ref float t, ref Vector3 hitNormal, int[] path, ref int pathCount, int maxPath)
		{
			t = 0;
			pathCount = 0;

			//validate input
			if (startPoint.Polygon == 0 || !nav.IsValidPolyRef(startPoint.Polygon))
				return false;

			int curRef = startPoint.Polygon;
			Vector3[] verts = new Vector3[PathfindingCommon.VERTS_PER_POLYGON];
			int n = 0;

			hitNormal = new Vector3(0, 0, 0);

			while (curRef != 0)
			{
				//cast ray against current polygon
				MeshTile tile;
				Poly poly;
				nav.TryGetTileAndPolyByRefUnsafe(curRef, out tile, out poly);

				//collect vertices
				int nv = 0;
				for (int i = 0; i < poly.VertCount; i++)
				{
					verts[nv] = tile.Verts[poly.Verts[i]];
					nv++;
				}

				float tmin, tmax;
				int segMin, segMax;
				if (!Intersection.SegmentPoly2D(startPoint.Position, endPos, verts, nv, out tmin, out tmax, out segMin, out segMax))
				{
					//could not hit the polygon, keep the old t and report hit
					pathCount = n;
					return true;
				}

				//keep track of furthest t so far
				if (tmax > t)
					t = tmax;

				//store visited polygons
				if (n < maxPath)
					path[n++] = curRef;

				//ray end is completely inside the polygon
				if (segMax == -1)
				{
					t = float.MaxValue;
					pathCount = n;
					return true;
				}

				//follow neighbours
				int nextRef = 0;

				for (int i = poly.FirstLink; i != Link.Null; i = tile.Links[i].Next)
				{
					Link link = tile.Links[i];

					//find link which contains the edge
					if (link.Edge != segMax)
						continue;

					//get pointer to the next polygon
					MeshTile nextTile;
					Poly nextPoly;
					nav.TryGetTileAndPolyByRefUnsafe(link.Reference, out nextTile, out nextPoly);

					//skip off-mesh connection
					if (nextPoly.PolyType == PolygonType.OffMeshConnection)
						continue;

					//if the link is internal, just return the ref
					if (link.Side == BoundarySide.Internal)
					{
						nextRef = link.Reference;
						break;
					}

					//if the link is at the tile boundary

					//check if the link spans the whole edge and accept
					if (link.BMin == 0 && link.BMax == 255)
					{
						nextRef = link.Reference;
						break;
					}

					//check for partial edge links
					int v0 = poly.Verts[link.Edge];
					int v1 = poly.Verts[(link.Edge + 1) % poly.VertCount];
					Vector3 left = tile.Verts[v0];
					Vector3 right = tile.Verts[v1];

					//check that the intersection lies inside the link portal
					if (link.Side == BoundarySide.PlusX || link.Side == BoundarySide.MinusX)
					{
						//calculate link size
						float s = 1.0f / 255.0f;
						float lmin = left.Z + (right.Z - left.Z) * (link.BMin * s);
						float lmax = left.Z + (right.Z - left.Z) * (link.BMax * s);
						if (lmin > lmax)
						{
							//swap
							float temp = lmin;
							lmin = lmax;
							lmax = temp;
						}

						//find z intersection
						float z = startPoint.Position.Z + (endPos.Z - startPoint.Position.Z) * tmax;
						if (z >= lmin && z <= lmax)
						{
							nextRef = link.Reference;
							break;
						}
					}
					else if (link.Side == BoundarySide.PlusZ || link.Side == BoundarySide.MinusZ)
					{
						//calculate link size
						float s = 1.0f / 255.0f;
						float lmin = left.X + (right.X - left.X) * (link.BMin * s);
						float lmax = left.X + (right.X - left.X) * (link.BMax * s);
						if (lmin > lmax)
						{
							//swap
							float temp = lmin;
							lmin = lmax;
							lmax = temp;
						}

						//find x intersection
						float x = startPoint.Position.X + (endPos.X - startPoint.Position.X) * tmax;
						if (x >= lmin && x <= lmax)
						{
							nextRef = link.Reference;
							break;
						}
					}
				}

				if (nextRef == 0)
				{
					//no neighbour, we hit a wall

					//calculate hit normal
					int a = segMax;
					int b = (segMax + 1) < nv ? segMax + 1 : 0;
					Vector3 va = verts[a];
					Vector3 vb = verts[b];
					float dx = vb.X - va.X;
					float dz = vb.Z - va.Z;
					hitNormal.X = dz;
					hitNormal.Y = 0;
					hitNormal.Z = -dx;
					hitNormal.Normalize();

					pathCount = n;
					return true;
				}

				//no hit, advance to neighbour polygon
				curRef = nextRef;
			}

			pathCount = n;

			return true;
		}

		/// <summary>
		/// Store polygons that are within a certain range from the current polygon
		/// </summary>
		/// <param name="centerPoint">Starting position</param>
		/// <param name="radius">Range to search within</param>
		/// <param name="resultRef">All the polygons within range</param>
		/// <param name="resultParent">Polygon's parents</param>
		/// <param name="resultCount">Number of polygons stored</param>
		/// <param name="maxResult">Maximum number of polygons allowed</param>
		/// <returns>True, unless input is invalid</returns>
		public bool FindLocalNeighbourhood(NavPoint centerPoint, float radius, int[] resultRef, int[] resultParent, ref int resultCount, int maxResult)
		{
			resultCount = 0;

			//validate input
			if (centerPoint.Polygon == 0 || !nav.IsValidPolyRef(centerPoint.Polygon))
				return false;

			int MAX_STACK = 48;
			Node[] stack = new Node[MAX_STACK];
			int nstack = 0;

			tinyNodePool.Clear();

			Node startNode = tinyNodePool.GetNode(centerPoint.Polygon);
			startNode.ParentIdx = 0;
			startNode.Id = centerPoint.Polygon;
			startNode.Flags = NodeFlags.Closed;
			stack[nstack++] = startNode;

			float radiusSqr = radius * radius;

			Vector3[] pa = new Vector3[PathfindingCommon.VERTS_PER_POLYGON];
			Vector3[] pb = new Vector3[PathfindingCommon.VERTS_PER_POLYGON];

			int n = 0;
			if (n < maxResult)
			{
				resultRef[n] = startNode.Id;
				resultParent[n] = 0;
				++n;
			}

			while (nstack > 0)
			{
				//pop front
				Node curNode = stack[0];
				for (int i = 0; i < nstack - 1; i++)
					stack[i] = stack[i + 1];
				nstack--;

				//get poly and tile
				int curRef = curNode.Id;
				MeshTile curTile;
				Poly curPoly;
				nav.TryGetTileAndPolyByRefUnsafe(curRef, out curTile, out curPoly);

				for (int i = curPoly.FirstLink; i != Link.Null; i = curTile.Links[i].Next)
				{
					Link link = curTile.Links[i];
					int neighbourRef = link.Reference;

					//skip invalid neighbours
					if (neighbourRef == 0)
						continue;

					//skip if cannot allocate more nodes
					Node neighbourNode = tinyNodePool.GetNode(neighbourRef);
					if (neighbourNode == null)
						continue;

					//skip visited
					if ((neighbourNode.Flags & NodeFlags.Closed) != 0)
						continue;

					//expand to neighbour
					MeshTile neighbourTile;
					Poly neighbourPoly;
					nav.TryGetTileAndPolyByRefUnsafe(neighbourRef, out neighbourTile, out neighbourPoly);

					//skip off-mesh connections
					if (neighbourPoly.PolyType == PolygonType.OffMeshConnection)
						continue;

					//find edge and calculate distance to edge
					Vector3 va = new Vector3();
					Vector3 vb = new Vector3();
					if (!GetPortalPoints(curRef, curPoly, curTile, neighbourRef, neighbourPoly, neighbourTile, ref va, ref vb))
						continue;

					//if the circle is not touching the next polygon, skip it
					float tseg;
					float distSqr = Distance.PointToSegment2DSquared(ref centerPoint.Position, ref va, ref vb, out tseg);
					if (distSqr > radiusSqr)
						continue;

					//mark node visited
					neighbourNode.Flags |= NodeFlags.Closed;
					neighbourNode.ParentIdx = tinyNodePool.GetNodeIdx(curNode);

					//check that the polygon doesn't collide with existing polygons

					//collect vertices of the neighbour poly
					int npa = neighbourPoly.VertCount;
					for (int k = 0; k < npa; k++)
						pa[k] = neighbourTile.Verts[neighbourPoly.Verts[k]];

					bool overlap = false;
					for (int j = 0; j < n; j++)
					{
						int pastRef = resultRef[j];

						//connected polys do not overlap
						bool connected = false;
						for (int k = curPoly.FirstLink; k != Link.Null; k = curTile.Links[k].Next)
						{
							if (curTile.Links[k].Reference == pastRef)
							{
								connected = true;
								break;
							}
						}

						if (connected)
							continue;

						//potentially overlapping
						MeshTile pastTile;
						Poly pastPoly;
						nav.TryGetTileAndPolyByRefUnsafe(pastRef, out pastTile, out pastPoly);

						//get vertices and test overlap
						int npb = pastPoly.VertCount;
						for (int k = 0; k < npb; k++)
							pb[k] = pastTile.Verts[pastPoly.Verts[k]];

						if (Intersection.PolyPoly2D(pa, npa, pb, npb))
						{
							overlap = true;
							break;
						}
					}

					if (overlap)
						continue;

					//store poly
					if (n < maxResult)
					{
						resultRef[n] = neighbourRef;
						resultParent[n] = curRef;
						++n;
					}

					if (nstack < MAX_STACK)
					{
						stack[nstack++] = neighbourNode;
					}
				}
			}

			resultCount = n;

			return true;
		}

		/// <summary>
		/// Collect all the edges from a polygon.
		/// </summary>
		/// <param name="reference">The polygon reference</param>
		/// <param name="segmentVerts">Segment vertices</param>
		/// <param name="segmentRefs">The polygon reference containing the segment</param>
		/// <param name="segmentCount">The number of segments stored</param>
		/// <param name="maxSegments">The maximum number of segments allowed</param>
		/// <returns>True, unless the polygon reference is invalid</returns>
		public bool GetPolyWallSegments(int reference, Crowds.LocalBoundary.Segment[] segmentVerts, int[] segmentRefs, ref int segmentCount, int maxSegments)
		{
			segmentCount = 0;

			MeshTile tile;
			Poly poly;
			if (nav.TryGetTileAndPolyByRef(reference, out tile, out poly) == false)
				return false;

			int n = 0;
			int MAX_INTERVAL = 16;
			SegInterval[] ints = new SegInterval[MAX_INTERVAL];
			int nints;

			bool storePortals = segmentRefs.Length != 0;

			for (int i = 0, j = poly.VertCount - 1; i < poly.VertCount; j = i++)
			{
				//skip non-solid edges
				nints = 0;
				if ((poly.Neis[j] & Link.External) != 0)
				{
					//tile border
					for (int k = poly.FirstLink; k != Link.Null; k = tile.Links[k].Next)
					{
						Link link = tile.Links[k];
						if (link.Edge == j)
						{
							if (link.Reference != 0)
							{
								MeshTile neiTile;
								Poly neiPoly;
								nav.TryGetTileAndPolyByRefUnsafe(link.Reference, out neiTile, out neiPoly);
								InsertInterval(ints, ref nints, MAX_INTERVAL, link.BMin, link.BMax, link.Reference);
							}
						}
					}
				}
				else
				{
					//internal edge
					int neiRef = 0;
					if (poly.Neis[j] != 0)
					{
						int idx = poly.Neis[j] - 1;
						neiRef = nav.GetPolyRefBase(tile) | idx;
					}

					//if the edge leads to another polygon and portals are not stored, skip
					if (neiRef != 0 && !storePortals)
						continue;

					if (n < maxSegments)
					{
						Vector3 vj = tile.Verts[poly.Verts[j]];
						Vector3 vi = tile.Verts[poly.Verts[i]];
						segmentVerts[n].Start = vj;
						segmentVerts[n].End = vi;
						segmentRefs[n] = neiRef;
						n++; //could be n += 2, since segments have 2 vertices
					}

					continue;
				}

				//add sentinels
				InsertInterval(ints, ref nints, MAX_INTERVAL, -1, 0, 0);
				InsertInterval(ints, ref nints, MAX_INTERVAL, 255, 256, 0);

				//store segments
				Vector3 vj2 = tile.Verts[poly.Verts[j]];
				Vector3 vi2 = tile.Verts[poly.Verts[i]];
				for (int k = 1; k < nints; k++)
				{
					//portal segment
					if (storePortals && ints[k].Reference != 0)
					{
						float tmin = ints[k].TMin / 255.0f;
						float tmax = ints[k].TMax / 255.0f;
						if (n < maxSegments)
						{
							Vector3.Lerp(ref vj2, ref vi2, tmin, out segmentVerts[n].Start);
							Vector3.Lerp(ref vj2, ref vi2, tmax, out segmentVerts[n].End);
							segmentRefs[n] = ints[k].Reference;
							n++;
						}
					}

					//wall segment
					int imin = ints[k - 1].TMax;
					int imax = ints[k].TMin;
					if (imin != imax)
					{
						float tmin = imin / 255.0f;
						float tmax = imax / 255.0f;
						if (n < maxSegments)
						{
							Vector3.Lerp(ref vj2, ref vi2, tmin, out segmentVerts[n].Start);
							Vector3.Lerp(ref vj2, ref vi2, tmax, out segmentVerts[n].End);
							segmentRefs[n] = 0;
							n++; 
						}
					}
				}
			}

			segmentCount = n;

			return true;
		}

		/// <summary>
		/// Insert a segment into the array
		/// </summary>
		/// <param name="ints">The array of segments</param>
		/// <param name="nints">The number of segments</param>
		/// <param name="maxInts">The maximium number of segments allowed</param>
		/// <param name="tmin">Parameter t minimum</param>
		/// <param name="tmax">Parameter t maximum</param>
		/// <param name="reference">Polygon reference</param>
		public void InsertInterval(SegInterval[] ints, ref int nints, int maxInts, int tmin, int tmax, int reference)
		{
			if (nints + 1 > maxInts)
				return;

			//find insertion point
			int idx = 0;
			while (idx < nints)
			{
				if (tmax <= ints[idx].TMin)
					break;
				idx++;
			}

			//move current results
			if (nints - idx > 0)
			{
				for (int i = 0; i < nints - idx; i++)
					ints[idx + 1 + i] = ints[idx + i];
			}

			//store
			ints[idx].Reference = reference;
			ints[idx].TMin = tmin;
			ints[idx].TMax = tmax;
			nints++;
		}

		/// <summary>
		/// Get edge midpoint between two prolygons
		/// </summary>
		/// <param name="from">"From" polygon reference</param>
		/// <param name="fromPoly">"From" polygon data</param>
		/// <param name="fromTile">"From" mesh tile</param>
		/// <param name="to">"To" polygon reference</param>
		/// <param name="toPoly">"To" polygon data</param>
		/// <param name="toTile">"To" mesh tile</param>
		/// <param name="mid">Edge midpoint</param>
		/// <returns>True, if midpoint found. False, if otherwise.</returns>
		public bool GetEdgeMidPoint(int from, Poly fromPoly, MeshTile fromTile, int to, Poly toPoly, MeshTile toTile, ref Vector3 mid)
		{
			Vector3 left = new Vector3();
			Vector3 right = new Vector3();
			if (!GetPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, ref left, ref right))
				return false;

			mid = (left + right) * 0.5f;

			return true;
		}

		/// <summary>
		/// Find points on the left and right side.
		/// </summary>
		/// <param name="from">"From" polygon reference</param>
		/// <param name="to">"To" polygon reference</param>
		/// <param name="left">Point on the left side</param>
		/// <param name="right">Point on the right side</param>
		/// <param name="fromType">Polygon type of "From" polygon</param>
		/// <param name="toType">Polygon type of "To" polygon</param>
		/// <returns>True, if points found. False, if otherwise.</returns>
		public bool GetPortalPoints(int from, int to, ref Vector3 left, ref Vector3 right, ref PolygonType fromType, ref PolygonType toType)
		{
			MeshTile fromTile;
			Poly fromPoly;
			if (nav.TryGetTileAndPolyByRef(from, out fromTile, out fromPoly) == false)
				return false;
			fromType = fromPoly.PolyType;

			MeshTile toTile;
			Poly toPoly;
			if (nav.TryGetTileAndPolyByRef(to, out toTile, out toPoly) == false)
				return false;
			toType = toPoly.PolyType;

			return GetPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, ref left, ref right);
		}

		/// <summary>
		/// Find points on the left and right side.
		/// </summary>
		/// <param name="from">"From" polygon reference</param>
		/// <param name="fromPoly">"From" polygon data</param>
		/// <param name="fromTile">"From" mesh tile</param>
		/// <param name="to">"To" polygon reference</param>
		/// <param name="toPoly">"To" polygon data</param>
		/// <param name="toTile">"To" mesh tile</param>
		/// <param name="left">Resulting point on the left side</param>
		/// <param name="right">Resulting point on the right side</param>
		/// <returns>True, if points found. False, if otherwise.</returns>
		public bool GetPortalPoints(int from, Poly fromPoly, MeshTile fromTile, int to, Poly toPoly, MeshTile toTile, ref Vector3 left, ref Vector3 right)
		{
			//find the link that points to the 'to' polygon
			Link link = null;
			for (int i = fromPoly.FirstLink; i != Link.Null; i = fromTile.Links[i].Next)
			{
				if (fromTile.Links[i].Reference == to)
				{
					link = fromTile.Links[i];
					break;
				}
			}

			if (link == null)
				return false;

			//handle off-mesh connections
			if (fromPoly.PolyType == PolygonType.OffMeshConnection)
			{
				//find link that points to first vertex
				for (int i = fromPoly.FirstLink; i != Link.Null; i = fromTile.Links[i].Next)
				{
					if (fromTile.Links[i].Reference == to)
					{
						int v = fromTile.Links[i].Edge;
						left = fromTile.Verts[fromPoly.Verts[v]];
						right = fromTile.Verts[fromPoly.Verts[v]];
						return true;
					}
				}

				return false;
			}

			if (toPoly.PolyType == PolygonType.OffMeshConnection)
			{
				//find link that points to first vertex
				for (int i = toPoly.FirstLink; i != Link.Null; i = toTile.Links[i].Next)
				{
					if (toTile.Links[i].Reference == from)
					{
						int v = toTile.Links[i].Edge;
						left = toTile.Verts[toPoly.Verts[v]];
						right = toTile.Verts[toPoly.Verts[v]];
						return true;
					}
				}

				return false;
			}

			//find portal vertices
			int v0 = fromPoly.Verts[link.Edge];
			int v1 = fromPoly.Verts[(link.Edge + 1) % fromPoly.VertCount];
			left = fromTile.Verts[v0];
			right = fromTile.Verts[v1];

			//if the link is at the tile boundary, clamp the vertices to tile width
			if (link.Side != BoundarySide.Internal)
			{
				//unpack portal limits
				if (link.BMin != 0 || link.BMax != 255)
				{
					float s = 1.0f / 255.0f;
					float tmin = link.BMin * s;
					float tmax = link.BMax * s;
					left = Vector3.Lerp(fromTile.Verts[v0], fromTile.Verts[v1], tmin);
					right = Vector3.Lerp(fromTile.Verts[v0], fromTile.Verts[v1], tmax);
				}
			}

			return true;
		}

		/// <summary>
		/// Given a point on the polygon, find the closest point
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <param name="pos">Given point</param>
		/// <param name="closest">Resulting closest point</param>
		/// <returns>True, if point found. False, if otherwise.</returns>
		public bool ClosestPointOnPoly(int reference, Vector3 pos, ref Vector3 closest)
		{
			if (nav == null)
				return false;

			MeshTile tile;
			Poly poly;

			if (nav.TryGetTileAndPolyByRef(reference, out tile, out poly) == false)
				return false;

			if (tile == null)
				return false;

			tile.ClosestPointOnPoly(poly, pos, ref closest);
			return true;
		}

		/// <summary>
		/// Given a point on the polygon, find the closest point
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <param name="pos">Current position</param>
		/// <param name="closest">Resulting closest position</param>
		/// <param name="posOverPoly">Determines whether the position can be found on the polygon</param>
		/// <returns>True, if the closest point is found. False, if otherwise.</returns>
		public bool ClosestPointOnPoly(int reference, Vector3 pos, out Vector3 closest, out bool posOverPoly)
		{
			posOverPoly = false;
			closest = Vector3.Zero;

			MeshTile tile;
			Poly poly;
			if (!nav.TryGetTileAndPolyByRef(reference, out tile, out poly))
				return false;
			if (tile == null)
				return false;

			if (poly.PolyType == PolygonType.OffMeshConnection)
			{
				Vector3 v0 = tile.Verts[poly.Verts[0]];
				Vector3 v1 = tile.Verts[poly.Verts[1]];
				float d0 = (pos - v0).Length();
				float d1 = (pos - v1).Length();
				float u = d0 / (d0 + d1);
				closest = Vector3.Lerp(v0, v1, u);
				return true;
			}

			int indexPoly = 0;
			for (int i = 0; i < tile.Polys.Length; i++)
			{
				if (tile.Polys[i] == poly)
				{
					indexPoly = i;
					break;
				}
			}

			PolyMeshDetail.MeshData pd = tile.DetailMeshes[indexPoly];

			//Clamp point to be inside the polygon
			Vector3[] verts = new Vector3[PathfindingCommon.VERTS_PER_POLYGON];
			float[] edgeDistance = new float[PathfindingCommon.VERTS_PER_POLYGON];
			float[] edgeT = new float[PathfindingCommon.VERTS_PER_POLYGON];
			int numPolyVerts = poly.VertCount;
			for (int i = 0; i < numPolyVerts; i++)
				verts[i] = tile.Verts[poly.Verts[i]];

			closest = pos;
			if (!Distance.PointToPolygonEdgeSquared(pos, verts, numPolyVerts, edgeDistance, edgeT))
			{
				//Point is outside the polygon
				//Clamp to nearest edge
				float minDistance = float.MaxValue;
				int minIndex = -1;
				for (int i = 0; i < numPolyVerts; i++)
				{
					if (edgeDistance[i] < minDistance)
					{
						minDistance = edgeDistance[i];
						minIndex = i;
					}
				}

				Vector3 va = verts[minIndex];
				Vector3 vb = verts[(minIndex + 1) % numPolyVerts];
				closest = Vector3.Lerp(va, vb, edgeT[minIndex]);
			}
			else
			{
				posOverPoly = false;
			}

			//find height at the location
			for (int j = 0; j < tile.DetailMeshes[indexPoly].TriangleCount; j++)
			{
				PolyMeshDetail.TriangleData t = tile.DetailTris[pd.TriangleIndex + j];
				Vector3 va, vb, vc;

				if (t.VertexHash0 < poly.VertCount)
					va = tile.Verts[poly.Verts[t.VertexHash0]];
				else
					va = tile.DetailVerts[pd.VertexIndex + (t.VertexHash0 - poly.VertCount)];

				if (t.VertexHash1 < poly.VertCount)
					vb = tile.Verts[poly.Verts[t.VertexHash1]];
				else
					vb = tile.DetailVerts[pd.VertexIndex + (t.VertexHash1 - poly.VertCount)];

				if (t.VertexHash2 < poly.VertCount)
					vc = tile.Verts[poly.Verts[t.VertexHash2]];
				else
					vc = tile.DetailVerts[pd.VertexIndex + (t.VertexHash2 - poly.VertCount)];

				float h;
				if (Distance.PointToTriangle(pos, va, vb, vc, out h))
				{
					closest.Y = h;
					break;
				}
			}

			return true;
		}

		/// <summary>
		/// Given a point on a polygon, find the closest point which lies on the polygon boundary.
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <param name="pos">Current position</param>
		/// <param name="closest">Resulting closest point</param>
		/// <returns>True, if the closest point is found. False, if otherwise.</returns>
		public bool ClosestPointOnPolyBoundary(int reference, Vector3 pos, ref Vector3 closest)
		{
			MeshTile tile;
			Poly poly;
			if (nav.TryGetTileAndPolyByRef(reference, out tile, out poly) == false)
				return false;

			tile.ClosestPointOnPolyBoundary(poly, pos, out closest);
			return true;
		}

		/// <summary>
		/// Add a vertex to the straight path.
		/// </summary>
		/// <param name="pos"></param>
		/// <param name="flags"></param>
		/// <param name="reference"></param>
		/// <param name="straightPath">An array of points on the straight path</param>
		/// <param name="straightPathFlags">An array of flags</param>
		/// <param name="straightPathRefs">An array of polygon references</param>
		/// <param name="straightPathCount">The number of points on the path</param>
		/// <param name="maxStraightPath">The maximum length allowed for the straight path</param>
		/// <returns>True, if end of path hasn't been reached yet and path isn't full. False, if otherwise.</returns>
		public bool AppendVertex(Vector3 pos, int flags, int reference, Vector3[] straightPath, int[] straightPathFlags, int[] straightPathRefs, ref int straightPathCount, int maxStraightPath)
		{
			if (straightPathCount > 0 && straightPath[straightPathCount - 1] == pos)
			{
				//the vertices are equal
				//update flags and polys
				if (straightPathFlags.Length != 0)
					straightPathFlags[straightPathCount - 1] = flags;
				
				if (straightPathRefs.Length != 0)
					straightPathRefs[straightPathCount - 1] = reference;
			}
			else
			{
				//append new vertex
				straightPath[straightPathCount] = pos;
				
				if (straightPathFlags.Length != 0)
					straightPathFlags[straightPathCount] = flags;
				
				if (straightPathRefs.Length != 0)
					straightPathRefs[straightPathCount] = reference;
				
				straightPathCount++;

				if (flags == PathfindingCommon.STRAIGHTPATH_END || straightPathCount >= maxStraightPath)
				{
					return false;
				}
			}

			return true;
		}

		/// <summary>
		/// Update the vertices on the straight path
		/// </summary>
		/// <param name="startIdx">Original path's starting index</param>
		/// <param name="endIdx">Original path's end index</param>
		/// <param name="endPos">The end position</param>
		/// <param name="path">The original path of polygon references</param>
		/// <param name="straightPath">An array of points on the straight path</param>
		/// <param name="straightPathFlags">An array of flags</param>
		/// <param name="straightPathRefs">An array of polygon references</param>
		/// <param name="straightPathCount">The number of points on the path</param>
		/// <param name="maxStraightPath">The maximum length allowed for the straight path</param>
		/// <param name="options">Options flag</param>
		/// <returns></returns>
		public bool AppendPortals(int startIdx, int endIdx, Vector3 endPos, int[] path, Vector3[] straightPath, int[] straightPathFlags, int[] straightPathRefs, ref int straightPathCount, int maxStraightPath, PathBuildFlags options)
		{
			Vector3 startPos = straightPath[straightPathCount - 1];

			//append or update last vertex
			bool stat = false;
			for (int i = startIdx; i < endIdx; i++)
			{
				//calculate portal
				int from = path[i];
				MeshTile fromTile;
				Poly fromPoly;
				if (nav.TryGetTileAndPolyByRef(from, out fromTile, out fromPoly) == false)
					return false;

				int to = path[i + 1];
				MeshTile toTile;
				Poly toPoly;
				if (nav.TryGetTileAndPolyByRef(to, out toTile, out toPoly) == false)
					return false;

				Vector3 left = new Vector3();
				Vector3 right = new Vector3();
				if (GetPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, ref left, ref right) == false)
					break;

				if ((options & PathBuildFlags.AreaCrossingVertices) != 0)
				{
					//skip intersection if only area crossings are requested
					if (fromPoly.Area == toPoly.Area)
						continue;
				}

				//append intersection
				float s, t;
				if (Intersection.SegmentSegment2D(ref startPos, ref endPos, ref left, ref right, out s, out t))
				{
					Vector3 pt = Vector3.Lerp(left, right, t);

					stat = AppendVertex(pt, 0, path[i + 1], straightPath, straightPathFlags, straightPathRefs, ref straightPathCount, maxStraightPath);

					if (stat != true)
						return true;
				}
			}

			return true;
		}

		/// <summary>
		/// Return false if the provided position is outside the xz-bounds.
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <param name="pos">Current position</param>
		/// <param name="height">Resulting polygon height</param>
		/// <returns>True, if height found. False, if otherwise.</returns>
		public bool GetPolyHeight(int reference, Vector3 pos, ref float height)
		{
			if (nav == null)
				return false;

			MeshTile tile;
			Poly poly;
			if (!nav.TryGetTileAndPolyByRef(reference, out tile, out poly))
				return false;

			//off-mesh connections don't have detail polygons
			if (poly.PolyType == PolygonType.OffMeshConnection)
			{
				Vector3 closest;
				tile.ClosestPointOnPolyOffMeshConnection(poly, pos, out closest);
				height = closest.Y;
				return true;
			}
			else
			{
				int indexPoly = 0;
				for (int i = 0; i < tile.Polys.Length; i++)
				{
					if (tile.Polys[i] == poly)
					{
						indexPoly = i;
						break;
					}
				}

				float h = 0;
				if (tile.ClosestHeight(indexPoly, pos, out h))
				{
					height = h;
					return true;
				}
			}

			return false;
		}

		/// <summary>
		/// Find the nearest poly within a certain range.
		/// </summary>
		/// <param name="center">Center.</param>
		/// <param name="extents">Extents.</param>
		/// <returns>The neareast point.</returns>
		public NavPoint FindNearestPoly(Vector3 center, Vector3 extents)
		{
			NavPoint result;
			this.FindNearestPoly(ref center, ref extents, out result);
			return result;
		}

		/// <summary>
		/// Find the nearest poly within a certain range.
		/// </summary>
		/// <param name="center">Center.</param>
		/// <param name="extents">Extents.</param>
		/// <param name="nearestPt">The neareast point.</param>
		public void FindNearestPoly(ref Vector3 center, ref Vector3 extents, out NavPoint nearestPt)
		{
			nearestPt = NavPoint.Null;

			//TODO error state?

			// Get nearby polygons from proximity grid.
			List<int> polys = new List<int>(128);
			if (!QueryPolygons(ref center, ref extents, polys))
				throw new InvalidOperationException("no nearby polys?");

			float nearestDistanceSqr = float.MaxValue;
			for (int i = 0; i < polys.Count; i++) 
			{
				int reference = polys[i];
				Vector3 closestPtPoly;
				bool posOverPoly;
				ClosestPointOnPoly(reference, center, out closestPtPoly, out posOverPoly);

				// If a point is directly over a polygon and closer than
				// climb height, favor that instead of straight line nearest point.
				Vector3 diff = center - closestPtPoly;
				float d = 0;
				if (posOverPoly)
				{
					MeshTile tile;
					Poly poly;
					nav.TryGetTileAndPolyByRefUnsafe(polys[i], out tile, out poly);
					d = Math.Abs(diff.Y) - tile.Header.WalkableClimb;
					d = d > 0 ? d * d : 0;
				}
				else
				{
					d = diff.LengthSquared();
				}

				if (d < nearestDistanceSqr)
				{
					nearestDistanceSqr = d;
					nearestPt = new NavPoint(reference, closestPtPoly);
				}
			}
		}

		/// <summary>
		/// Finds nearby polygons within a certain range.
		/// </summary>
		/// <param name="center">The starting point</param>
		/// <param name="extent">The range to search within</param>
		/// <param name="polys">A list of polygons</param>
		/// <returns>True, if successful. False, if otherwise.</returns>
		public bool QueryPolygons(ref Vector3 center, ref Vector3 extent, List<int> polys)
		{
			Vector3 bmin = center - extent;
			Vector3 bmax = center + extent;

			int minx, miny, maxx, maxy;
			nav.CalcTileLoc(ref bmin, out minx, out miny);
			nav.CalcTileLoc(ref bmax, out maxx, out maxy);

			MeshTile[] neis = new MeshTile[32];
			
			BBox3 bounds = new BBox3(bmin, bmax);
			int n = 0;
			for (int y = miny; y <= maxy; y++)
			{
				for (int x = minx; x <= maxx; x++)
				{
					int nneis = nav.GetTilesAt(x, y, neis);
					for (int j = 0; j < nneis; j++)
					{
						n += nav.QueryPolygonsInTile(neis[j], bounds, polys);
						if (n >= polys.Capacity) 
						{
							return true;
						}
					}
				}
			}

			return polys.Count != 0;
		}

		public bool IsValidPolyRef(int reference)
		{
			MeshTile tile;
			Poly poly;
			bool status = nav.TryGetTileAndPolyByRef(reference, out tile, out poly);
			if (status == false)
				return false;
			return true;
		}

		public bool IsInOpenList(Node node)
		{
			return (node.Flags & NodeFlags.Open) != 0;
		}

		public bool IsInClosedList(Node node)
		{
			return (node.Flags & NodeFlags.Closed) != 0;
		}

		public void SetNodeFlagOpen(ref Node node)
		{
			node.Flags |= NodeFlags.Open;
		}

		public void SetNodeFlagClosed(ref Node node)
		{
			node.Flags &= ~NodeFlags.Open;
			node.Flags |= NodeFlags.Closed;
		}

		public NodeFlags RemoveNodeFlagClosed(Node node)
		{
			return node.Flags & ~NodeFlags.Closed;
		}

		private struct QueryData
		{
			public bool Status;
			public Node LastBestNode;
			public float LastBestNodeCost;
			public int StartRef, EndRef;
			public Vector3 StartPos, EndPos;
		}

		public struct SegInterval
		{
			public int Reference;
			public int TMin, TMax;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Node.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using SharpNav.Collections.Generic;
using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// Every polygon becomes a Node, which contains a position and cost.
	/// </summary>
	public class Node : IValueWithCost
	{
		public Vector3 Pos;
		public float cost;
		public float total;
		public int ParentIdx = 30; //index to parent node
		public NodeFlags Flags = 0; //node flags 0/open/closed
		public int Id; //polygon ref the node corresponds to

		public float Cost 
		{ 
			get 
			{ 
				return total; 
			} 
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\NodeFlags.cs:
 // Copyright (c) 2013 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav
{
	/// <summary>
	/// Determine which list the node is in.
	/// </summary>
	[Flags]
	public enum NodeFlags
	{
		/// <summary>
		/// Open list contains nodes to examine.
		/// </summary>
		Open = 0x01,

		/// <summary>
		/// Closed list stores path.
		/// </summary>
		Closed = 0x02
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\NodePool.cs:
 // Copyright (c) 2013-2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System.Collections.Generic;

namespace SharpNav
{
	/// <summary>
	/// Link all nodes together. Store indices in hash map.
	/// </summary>
	public class NodePool
	{
		//private int hashSize;
		private List<Node> nodes;
		private Dictionary<int, Node> nodeDict;
		private int maxNodes;

		/// <summary>
		/// Initializes a new instance of the <see cref="NodePool"/> class.
		/// </summary>
		/// <param name="maxNodes">The maximum number of nodes that can be stored</param>
		/// <param name="hashSize">The maximum number of elements in the hash table</param>
		public NodePool(int maxNodes, int hashSize)
		{
			this.maxNodes = maxNodes;
			//this.hashSize = hashSize;

			nodes = new List<Node>(maxNodes);
			nodeDict = new Dictionary<int, Node>(new IntNodeIdComparer(hashSize));
		}

		/// <summary>
		/// Reset all the data.
		/// </summary>
		public void Clear()
		{
			nodes.Clear();
			nodeDict.Clear();
		}

		/// <summary>
		/// Try to find a node.
		/// </summary>
		/// <param name="id">Node's id</param>
		/// <returns>The node, if found. Null, if otherwise.</returns>
		public Node FindNode(int id)
		{
			Node node;
			if (nodeDict.TryGetValue(id, out node))
			{
				return node;
			}

			return null;
		}

		/// <summary>
		/// Try to find the node. If it doesn't exist, create a new node.
		/// </summary>
		/// <param name="id">Node's id</param>
		/// <returns>The node</returns>
		public Node GetNode(int id)
		{
			Node node;
			if (nodeDict.TryGetValue(id, out node))
			{
				return node;
			}

			if (nodes.Count >= maxNodes)
				return null;

			Node newNode = new Node();
			newNode.ParentIdx = 0;
			newNode.cost = 0;
			newNode.total = 0;
			newNode.Id = id;
			newNode.Flags = 0;
			
			nodes.Add(newNode);
			nodeDict.Add(id, newNode);

			return newNode;
		}

		/// <summary>
		/// Gets the id of the node.
		/// </summary>
		/// <param name="node">The node</param>
		/// <returns>The id</returns>
		public int GetNodeIdx(Node node)
		{
			if (node == null)
				return 0;

			for (int i = 0; i < nodes.Count; i++)
			{
				if (nodes[i] == node)
					return i + 1;
			}

			return 0;
		}

		/// <summary>
		/// Return a node at a certain index. If index is out-of-bounds, return null.
		/// </summary>
		/// <param name="idx">Node index</param>
		/// <returns></returns>
		public Node GetNodeAtIdx(int idx)
		{
			if (idx <= 0 || idx > nodes.Count)
				return null;

			return nodes[idx - 1]; 
		}

		/// <summary>
		/// Determine whether two nodes are equal
		/// </summary>
		private class IntNodeIdComparer : IEqualityComparer<int>
		{
			private int hashSize;

			/// <summary>
			/// Initializes a new instance of the <see cref="IntNodeIdComparer" /> class.
			/// </summary>
			/// <param name="hashSize">The maximum number of elements in the hash table</param>
			public IntNodeIdComparer(int hashSize)
			{
				this.hashSize = hashSize;
			}

			/// <summary>
			/// Determines whether two objects or equal or now
			/// </summary>
			/// <param name="left">The first object</param>
			/// <param name="right">The second object</param>
			/// <returns>True if equal, false if not equal</returns>
			public bool Equals(int left, int right)
			{
				return left == right;
			}

			/// <summary>
			/// Gets the hash code for this object
			/// </summary>
			/// <param name="obj">The object</param>
			/// <returns>The hash code</returns>
			public int GetHashCode(int obj)
			{
				obj += ~(obj << 15);
				obj ^= obj >> 10;
				obj += obj << 3;
				obj ^= obj >> 6;
				obj += ~(obj << 11);
				obj ^= obj >> 16;

				return obj & (hashSize - 1);
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\PolyBounds.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Runtime.InteropServices;

namespace SharpNav
{
	/// <summary>
	/// A bounding box for vertices in a <see cref="PolyMesh"/>.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct PolyBounds : IEquatable<PolyBounds>
	{
		/// <summary>
		/// The lower bound of the bounding box.
		/// </summary>
		public PolyVertex Min;

		/// <summary>
		/// The upper bound of the bounding box.
		/// </summary>
		public PolyVertex Max;

		/// <summary>
		/// Initializes a new instance of the <see cref="PolyBounds"/> struct.
		/// </summary>
		/// <param name="min">The lower bound of the bounding box.</param>
		/// <param name="max">The upper bound of the bounding box.</param>
		public PolyBounds(PolyVertex min, PolyVertex max)
		{
			Min = min;
			Max = max;
		}

		/// <summary>
		/// Checks whether two boudning boxes are intersecting.
		/// </summary>
		/// <param name="a">The first bounding box.</param>
		/// <param name="b">The second bounding box.</param>
		/// <returns>A value indicating whether the two bounding boxes are overlapping.</returns>
		public static bool Overlapping(ref PolyBounds a, ref PolyBounds b)
		{
			return !(a.Min.X > b.Max.X || a.Max.X < b.Min.X
				|| a.Min.Y > b.Max.Y || a.Max.Y < b.Min.Y
				|| a.Min.Z > b.Max.Z || a.Max.Z < b.Min.Z);
		}

		/// <summary>
		/// Compares two <see cref="PolyBounds"/> instances for equality.
		/// </summary>
		/// <param name="left">A bounding box.</param>
		/// <param name="right">Another bounding box.</param>
		/// <returns>A value indicating whether the two bounding boxes are equal.</returns>
		public static bool operator ==(PolyBounds left, PolyBounds right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two <see cref="PolyBounds"/> instances for inequality.
		/// </summary>
		/// <param name="left">A bounding box.</param>
		/// <param name="right">Another bounding box.</param>
		/// <returns>A value indicating whether the two bounding boxes are not equal.</returns>
		public static bool operator !=(PolyBounds left, PolyBounds right)
		{
			return !(left == right);
		}

		/// <summary>
		/// Compares another <see cref="PolyBounds"/> instance with this instance for equality.
		/// </summary>
		/// <param name="other">A bounding box.</param>
		/// <returns>A value indicating whether the bounding box is equal to this instance.</returns>
		public bool Equals(PolyBounds other)
		{
			return Min == other.Min && Max == other.Max;
		}

		/// <summary>
		/// Compares another object with this instance for equality.
		/// </summary>
		/// <param name="obj">An object.</param>
		/// <returns>A value indicating whether the object is equal to this instance.</returns>
		public override bool Equals(object obj)
		{
			PolyBounds? b = obj as PolyBounds?;
			if (b.HasValue)
				return this.Equals(b.Value);

			return false;
		}

		/// <summary>
		/// Calculates a hash code unique to the contents of this instance.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			//TODO write a better hash code
			return Min.GetHashCode() ^ Max.GetHashCode();
		}

		/// <summary>
		/// Creates a human-readable string with the contents of this instance.
		/// </summary>
		/// <returns>A human-readable string.</returns>
		public override string ToString()
		{
			return "[" + Min.ToString() + ", " + Max.ToString() + "]";
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\PolyMesh.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// The class of Poly mesh.
	/// </summary>
	public class PolyMesh
	{
		public const int NullId = -1;
		
		private const int DiagonalFlag = unchecked((int)0x80000000);
		private const int NeighborEdgeFlag = unchecked((int)0x80000000);

		private PolyVertex[] vertices;
		private Polygon[] polygons;

		private int numVertsPerPoly;

		//copied data from CompactHeightfield
		private BBox3 bounds;
		private float cellSize;
		private float cellHeight;
		private int borderSize;

		//HACK borderSize is 0 here. Fix with borderSize.

		/// <summary>
		/// Initializes a new instance of the <see cref="PolyMesh"/> class.
		/// </summary>
		/// <param name="contSet">The <see cref="ContourSet"/> to generate polygons from.</param>
		/// <param name="settings">The settings to build with.</param>
		public PolyMesh(ContourSet contSet, NavMeshGenerationSettings settings)
			: this(contSet, settings.CellSize, settings.CellHeight, 0, settings.VertsPerPoly)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="PolyMesh"/> class by creating polygons from contours.
		/// </summary>
		/// <param name="contSet">The <see cref="ContourSet"/> to generate polygons from.</param>
		/// <param name="cellSize">The size of one voxel/cell.</param>
		/// <param name="cellHeight">The height of one voxel/cell.</param>
		/// <param name="borderSize">The size of the border around the mesh.</param>
		/// <param name="numVertsPerPoly">The maximum number of vertices per polygon.</param>
		public PolyMesh(ContourSet contSet, float cellSize, float cellHeight, int borderSize, int numVertsPerPoly)
		{
			//copy contour data
			this.bounds = contSet.Bounds;
			this.cellSize = cellSize;
			this.cellHeight = cellHeight;
			this.borderSize = borderSize;

			//get maximum limits
			//TODO move to ContourSet?
			int maxVertices = 0;
			int maxTris = 0;
			int maxVertsPerCont = 0;
			foreach (var cont in contSet)
			{
				int vertCount = cont.Vertices.Length;

				//skip null contours
				if (vertCount < 3) 
					continue;

				maxVertices += vertCount;
				maxTris += vertCount - 2;
				maxVertsPerCont = Math.Max(maxVertsPerCont, vertCount);
			}

			//initialize the mesh members
			var verts = new List<PolyVertex>(maxVertices);
			var polys = new List<Polygon>(maxTris);

			Queue<int> vertRemoveQueue = new Queue<int>(maxVertices);

			this.numVertsPerPoly = numVertsPerPoly;

			var vertDict = new Dictionary<PolyVertex, int>(new PolyVertex.RoughYEqualityComparer(2));

			int[] indices = new int[maxVertsPerCont]; //keep track of vertex hash codes
			Triangle[] tris = new Triangle[maxVertsPerCont];
			List<Polygon> contPolys = new List<Polygon>(maxVertsPerCont + 1);

			//extract contour data
			foreach (Contour cont in contSet)
			{
				//skip null contours
				if (cont.IsNull)
					continue;

				PolyVertex[] vertices = new PolyVertex[cont.Vertices.Length];

				//triangulate contours
				for (int i = 0; i < cont.Vertices.Length; i++)
				{
					var cv = cont.Vertices[i];
					vertices[i] = new PolyVertex(cv.X, cv.Y, cv.Z);
					indices[i] = i;
				}

				//Form triangles inside the area bounded by the contours
				int ntris = Triangulate(vertices, indices, tris);
				if (ntris <= 0) //TODO notify user when this happens. Logging?
					ntris = -ntris;

				//add and merge vertices
				for (int i = 0; i < cont.Vertices.Length; i++)
				{
					var cv = cont.Vertices[i];
					var pv = vertices[i];

					//save the hash code for each vertex
					indices[i] = AddVertex(vertDict, pv, verts);

					if (RegionId.HasFlags(cv.RegionId, RegionFlags.VertexBorder))
					{
						//the vertex should be removed
						vertRemoveQueue.Enqueue(indices[i]);
					}
				}

				contPolys.Clear();

				//iterate through all the triangles
				for (int i = 0; i < ntris; i++)
				{
					Triangle ti = tris[i];

					//make sure there are three distinct vertices. anything less can't be a polygon.
					if (ti.Index0 == ti.Index1
						|| ti.Index0 == ti.Index2
						|| ti.Index1 == ti.Index2)
						continue;

					//each polygon has numVertsPerPoly
					//index 0, 1, 2 store triangle vertices
					//other polygon indexes (3 to numVertsPerPoly - 1) should be used for storing extra vertices when two polygons merge together
					Polygon p = new Polygon(numVertsPerPoly, Area.Null, RegionId.Null, 0);
					p.Vertices[0] = RemoveDiagonalFlag(indices[ti.Index0]);
					p.Vertices[1] = RemoveDiagonalFlag(indices[ti.Index1]);
					p.Vertices[2] = RemoveDiagonalFlag(indices[ti.Index2]);
					contPolys.Add(p);
				}
				
				//no polygons generated, so skip
				if (contPolys.Count == 0)
					continue;

				//merge polygons
				if (numVertsPerPoly > 3)
				{
					while (true)
					{
						//find best polygons
						int bestMergeVal = 0;
						int bestPolyA = 0, bestPolyB = 0, bestEdgeA = 0, bestEdgeB = 0;

						for (int i = 0; i < contPolys.Count - 1; i++)
						{
							int pj = i;

							for (int j = i + 1; j < contPolys.Count; j++)
							{
								int pk = j;
								int ea = 0, eb = 0;
								int v = GetPolyMergeValue(contPolys, pj, pk, verts, out ea, out eb);
								if (v > bestMergeVal)
								{
									bestMergeVal = v;
									bestPolyA = i;
									bestPolyB = j;
									bestEdgeA = ea;
									bestEdgeB = eb;
								}
							}
						}

						if (bestMergeVal > 0)
						{
							int pa = bestPolyA;
							int pb = bestPolyB;
							MergePolys(contPolys, pa, pb, bestEdgeA, bestEdgeB);
							contPolys[pb] = contPolys[contPolys.Count - 1];
							contPolys.RemoveAt(contPolys.Count - 1);
						}
						else
						{
							//no more merging
							break;
						}
					}
				}

				//store polygons
				for (int i = 0; i < contPolys.Count; i++)
				{
					Polygon p = contPolys[i];
					Polygon p2 = new Polygon(numVertsPerPoly, cont.Area, cont.RegionId, 0);

					Buffer.BlockCopy(p.Vertices, 0, p2.Vertices, 0, numVertsPerPoly * sizeof(int));

					polys.Add(p2);
				}
			}

			//remove edge vertices
			while (vertRemoveQueue.Count > 0)
			{
				int i = vertRemoveQueue.Dequeue();

				if (CanRemoveVertex(polys, i))
					RemoveVertex(verts, polys, i);
			}

			//calculate adjacency (edges)
			BuildMeshAdjacency(verts, polys, numVertsPerPoly);
			
			//find portal edges
			if (this.borderSize > 0)
			{
				//iterate through all the polygons
				for (int i = 0; i < polys.Count; i++)
				{
					Polygon p = polys[i];

					//iterate through all the vertices
					for (int j = 0; j < numVertsPerPoly; j++)
					{
						if (p.Vertices[j] == NullId)
							break;

						//skip connected edges
						if (p.NeighborEdges[j] != NullId)
							continue;

						int nj = j + 1;
						if (nj >= numVertsPerPoly || p.Vertices[nj] == NullId)
							nj = 0;

						//grab two consecutive vertices
						int va = p.Vertices[j];
						int vb = p.Vertices[nj];

						//set some flags
						if (verts[va].X == 0 && verts[vb].X == 0)
							p.NeighborEdges[j] = NeighborEdgeFlag | 0;
						else if (verts[va].Z == contSet.Height && verts[vb].Z == contSet.Height)
							p.NeighborEdges[j] = NeighborEdgeFlag | 1;
						else if (verts[va].X == contSet.Width && verts[vb].X == contSet.Width)
							p.NeighborEdges[j] = NeighborEdgeFlag | 2;
						else if (verts[va].Z == 0 && verts[vb].Z == 0)
							p.NeighborEdges[j] = NeighborEdgeFlag | 3;
					}
				}
			}

			this.vertices = verts.ToArray();
			this.polygons = polys.ToArray();
		}

		/// <summary>
		/// Gets the number of vertices
		/// </summary>
		public int VertCount
		{
			get
			{
				return vertices.Length;
			}
		}

		/// <summary>
		/// Gets the number of polygons
		/// </summary>
		public int PolyCount
		{
			get
			{
				return polygons.Length;
			}
		}

		/// <summary>
		/// Gets the number of vertices per polygon
		/// </summary>
		public int NumVertsPerPoly
		{
			get
			{
				return numVertsPerPoly;
			}
		}

		/// <summary>
		/// Gets the vertex data
		/// </summary>
		public PolyVertex[] Verts
		{
			get
			{
				return vertices;
			}
		}

		/// <summary>
		/// Gets the polygon data
		/// </summary>
		public Polygon[] Polys
		{
			get
			{
				return polygons;
			}
		}

		/// <summary>
		/// Gets the bounds.
		/// </summary>
		/// <value>The bounds.</value>
		public BBox3 Bounds
		{
			get
			{
				return bounds;
			}
		}

		/// <summary>
		/// Gets the cell size
		/// </summary>
		public float CellSize
		{
			get
			{
				return cellSize;
			}
		}

		/// <summary>
		/// Gets the cell height
		/// </summary>
		public float CellHeight
		{
			get
			{
				return cellHeight;
			}
		}

		/// <summary>
		/// Gets the border size
		/// </summary>
		public int BorderSize
		{
			get
			{
				return borderSize;
			}
		}

		/// <summary>
		/// Determines if it is a boundary edge with the specified flag.
		/// </summary>
		/// <returns><c>true</c> if is boundary edge the specified flag; otherwise, <c>false</c>.</returns>
		/// <param name="flag">The flag.</param>
		public static bool IsBoundaryEdge(int flag)
		{
			return (flag & NeighborEdgeFlag) != 0;
		}

		/// <summary>
		/// Determines if it is an interior edge with the specified flag.
		/// </summary>
		/// <returns><c>true</c> if is interior edge the specified flag; otherwise, <c>false</c>.</returns>
		/// <param name="flag">The flag.</param>
		public static bool IsInteriorEdge(int flag)
		{
			return (flag & NeighborEdgeFlag) == 0;
		}

		/// <summary>
		/// Determines if it is a diagonal flag on the specified index.
		/// </summary>
		/// <param name="index">The index</param>
		/// <returns><c>true</c> if it is a diagonal flag on the specified index; otherwise, <c>false</c>.</returns>
		public static bool HasDiagonalFlag(int index)
		{
			return (index & DiagonalFlag) != 0;
		}

		/// <summary>
		/// True if and only if (v[i], v[j]) is a proper internal diagonal of polygon.
		/// </summary>
		/// <param name="i">Vertex index i</param>
		/// <param name="j">Vertex index j</param>
		/// <param name="verts">Contour vertices</param>
		/// <param name="indices">PolyMesh indices</param>
		/// <returns>True, if internal diagonal. False, if otherwise.</returns>
		public static bool Diagonal(int i, int j, PolyVertex[] verts, int[] indices)
		{
			return InCone(i, j, verts, indices) && Diagonalie(i, j, verts, indices);
		}

		/// <summary>
		/// True if and only if diagonal (i, j) is strictly internal to polygon 
		/// in neighborhood of i endpoint.
		/// </summary>
		/// <param name="i">Vertex index i</param>
		/// <param name="j">Vertex index j</param>
		/// <param name="verts">Contour vertices</param>
		/// <param name="indices">PolyMesh indices</param>
		/// <returns>True, if internal. False, if otherwise.</returns>
		public static bool InCone(int i, int j, PolyVertex[] verts, int[] indices)
		{
			int pi = RemoveDiagonalFlag(indices[i]);
			int pj = RemoveDiagonalFlag(indices[j]);
			int pi1 = RemoveDiagonalFlag(indices[Next(i, verts.Length)]);
			int pin1 = RemoveDiagonalFlag(indices[Prev(i, verts.Length)]);

			//if P[i] is convex vertex (i + 1 left or on (i - 1, i))
			if (PolyVertex.IsLeftOn(ref verts[pin1], ref verts[pi], ref verts[pi1]))
				return PolyVertex.IsLeft(ref verts[pi], ref verts[pj], ref verts[pin1]) && PolyVertex.IsLeft(ref verts[pj], ref verts[pi], ref verts[pi1]);

			//assume (i - 1, i, i + 1) not collinear
			return !(PolyVertex.IsLeftOn(ref verts[pi], ref verts[pj], ref verts[pi1]) && PolyVertex.IsLeftOn(ref verts[pj], ref verts[pi], ref verts[pin1]));
		}

		/// <summary>
		/// True if and only if (v[i], v[j]) is internal or external diagonal
		/// ignoring edges incident to v[i] or v[j].
		/// </summary>
		/// <param name="i">Vertex index i</param>
		/// <param name="j">Vertex index j</param>
		/// <param name="verts">Contour vertices</param>
		/// <param name="indices">PolyMesh indices</param>
		/// <returns>True, if internal or external diagonal. False, if otherwise.</returns>
		public static bool Diagonalie(int i, int j, PolyVertex[] verts, int[] indices)
		{
			int d0 = RemoveDiagonalFlag(indices[i]);
			int d1 = RemoveDiagonalFlag(indices[j]);

			//for each edge (k, k + 1)
			for (int k = 0; k < verts.Length; k++)
			{
				int k1 = Next(k, verts.Length);

				//skip edges incident to i or j
				if (!((k == i) || (k1 == i) || (k == j) || (k1 == j)))
				{
					int p0 = RemoveDiagonalFlag(indices[k]);
					int p1 = RemoveDiagonalFlag(indices[k1]);

					if (PolyVertex.Equal2D(ref verts[d0], ref verts[p0]) ||
						PolyVertex.Equal2D(ref verts[d1], ref verts[p0]) ||
						PolyVertex.Equal2D(ref verts[d0], ref verts[p1]) ||
						PolyVertex.Equal2D(ref verts[d1], ref verts[p1]))
						continue;

					if (PolyVertex.Intersect(ref verts[d0], ref verts[d1], ref verts[p0], ref verts[p1]))
						return false;
				}
			}

			return true;
		}

		/// <summary>
		/// Gets the previous vertex index
		/// </summary>
		/// <param name="i">The current index</param>
		/// <param name="n">The max number of vertices</param>
		/// <returns>The previous index</returns>
		private static int Prev(int i, int n)
		{
			return i - 1 >= 0 ? i - 1 : n - 1;
		}

		/// <summary>
		/// Gets the next vertex index
		/// </summary>
		/// <param name="i">The current index</param>
		/// <param name="n">The max number of vertices</param>
		/// <returns>The next index</returns>
		private static int Next(int i, int n)
		{
			return i + 1 < n ? i + 1 : 0;
		}

		/// <summary>
		/// Determines whether the vertices follow a certain order
		/// </summary>
		/// <param name="a">Vertex A</param>
		/// <param name="b">Vertex B</param>
		/// <param name="c">Vertex C</param>
		/// <returns>True if conditions met, false if not</returns>
		private static bool ULeft(PolyVertex a, PolyVertex b, PolyVertex c)
		{
			return (b.X - a.X) * (c.Z - a.Z) -
				(c.X - a.X) * (b.Z - a.Z) < 0;
		}

		/// <summary>
		/// Sets the diagonal flag for a vertex
		/// </summary>
		/// <param name="index">The vertex index</param>
		private static void SetDiagonalFlag(ref int index)
		{
			index |= DiagonalFlag;
		}

		/// <summary>
		/// Remove the diagonal flag for a vertex
		/// </summary>
		/// <param name="index">The vertex index</param>
		/// <returns>The new index</returns>
		private static int RemoveDiagonalFlag(int index)
		{
			return index & ~DiagonalFlag;
		}

		/// <summary>
		/// Remove the diagonal flag for a vertex
		/// </summary>
		/// <param name="index">The vertex index</param>
		private static void RemoveDiagonalFlag(ref int index)
		{
			index &= ~DiagonalFlag;
		}

		/// <summary>
		/// Walk the edges of a contour to determine whether a triangle can be formed.
		/// Form as many triangles as possible.
		/// </summary>
		/// <param name="verts">Vertices array</param>
		/// <param name="indices">Indices array</param>
		/// <param name="tris">Triangles array</param>
		/// <returns>The number of triangles.</returns>
		private static int Triangulate(PolyVertex[] verts, int[] indices, Triangle[] tris)
		{
			int ntris = 0;
			int n = verts.Length;

			//last bit of index determines whether vertex can be removed
			for (int i = 0; i < n; i++)
			{
				int i1 = Next(i, n);
				int i2 = Next(i1, n);
				if (Diagonal(i, i2, verts, indices))
				{
					SetDiagonalFlag(ref indices[i1]);
				}
			}

			//need 3 verts minimum for a polygon 
			while (n > 3)
			{
				//find the minimum distance betwee two vertices. 
				//also, save their index
				int minLen = -1;
				int minIndex = -1;
				for (int i = 0; i < n; i++)
				{
					int i1 = Next(i, n);
					
					if (HasDiagonalFlag(indices[i1]))
					{
						int p0 = RemoveDiagonalFlag(indices[i]);
						int p2 = RemoveDiagonalFlag(indices[Next(i1, n)]);

						int dx = verts[p2].X - verts[p0].X;
						int dy = verts[p2].Z - verts[p0].Z;
						int len = dx * dx + dy * dy;

						if (minLen < 0 || len < minLen)
						{
							minLen = len;
							minIndex = i;
						}
					}
				}
				
				if (minIndex == -1)
				{
					minLen = -1;
					minIndex = -1;
					
					
					for (int i = 0; i < n; i++)
					{
						int i1 = Next(i, n);
						int i2 = Next(i1, n);
						
						if (IsDiagonalLoose(i, i2, verts, indices))
						{
							var p0 = verts[RemoveDiagonalFlag(indices[i])];
							var p2 = verts[RemoveDiagonalFlag(indices[Next(i2, n)])];
							var dx = p2.X - p0.X;
							var dy = p2.Z - p0.Z;
							var len = dx * dx + dy * dy;
							if (minLen < 0 || len < minLen)
							{
								minLen = len;
								minIndex = i;
							}
						}
					}
					
					
					if (minIndex == -1)
					{
						return -ntris;
					}
				}


				int mi = minIndex;
				int mi1 = Next(mi, n);
				int mi2 = Next(mi1, n);

				tris[ntris] = new Triangle();
				tris[ntris].Index0 = RemoveDiagonalFlag(indices[mi]);
				tris[ntris].Index1 = RemoveDiagonalFlag(indices[mi1]);
				tris[ntris].Index2 = RemoveDiagonalFlag(indices[mi2]);
				ntris++;

				//remove P[i1]
				n--;
				for (int k = mi1; k < n; k++)
					indices[k] = indices[k + 1];

				if (mi1 >= n) mi1 = 0;
				mi = Prev(mi1, n);

				//update diagonal flags
				if (Diagonal(Prev(mi, n), mi1, verts, indices))
				{
					SetDiagonalFlag(ref indices[mi]);
				}
				else
				{
					RemoveDiagonalFlag(ref indices[mi]);
				}

				if (Diagonal(mi, Next(mi1, n), verts, indices))
				{
					SetDiagonalFlag(ref indices[mi1]);
				}
				else
				{
					RemoveDiagonalFlag(ref indices[mi1]);
				}
			}

			//append remaining triangle
			tris[ntris] = new Triangle();
			tris[ntris].Index0 = RemoveDiagonalFlag(indices[0]);
			tris[ntris].Index1 = RemoveDiagonalFlag(indices[1]);
			tris[ntris].Index2 = RemoveDiagonalFlag(indices[2]);
			ntris++;

			return ntris;
		}
		
		static bool	IsInConeLoose(int i, int j, PolyVertex[] verts, int[] indices)
		{
			var n = verts.Length;
			// int p2 = RemoveDiagonalFlag(indices[Next(i1, n)]);
			
			//const int* pi = &verts[(indices[i] & 0x0fffffff) * 4];
			//const int* pj = &verts[(indices[j] & 0x0fffffff) * 4];
			//const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];
			//const int* pin1 = &verts[(indices[prev(i, n)] & 0x0fffffff) * 4];
			var pi = verts[RemoveDiagonalFlag(indices[i])];
			var pj = verts[RemoveDiagonalFlag(indices[j])];
			var pi1 = verts[RemoveDiagonalFlag(indices[Next(i, n)])];
			var pin1 = verts[RemoveDiagonalFlag(indices[Prev(i, n)])];
			
			// If P[i] is a convex vertex [ i+1 left or on (i-1,i) ].
			
			if (PolyVertex.IsLeftOn(ref pin1, ref pi, ref pi1))
				return PolyVertex.IsLeftOn(ref pi, ref pj, ref pin1) && PolyVertex.IsLeftOn(ref pj, ref pi, ref pi1);
			// Assume (i-1,i,i+1) not collinear.
			// else P[i] is reflex.
			return !(PolyVertex.IsLeftOn(ref pi, ref pj, ref pi1) && PolyVertex.IsLeftOn(ref pj, ref pi, ref pin1));
		}
		
		static bool IsDiagonalLoose(int i, int j, PolyVertex[] verts, int[] indices)
		{
			//var n = verts.Length;
			return IsInConeLoose(i, j, verts, indices) && IsDiagonalieLoose(i, j, verts, indices);
		}
		
		static bool IsDiagonalieLoose(int i, int j, PolyVertex[] verts, int[] indices)
		{
			//const int* d0 = &verts[(indices[i] & 0x0fffffff) * 4];
			//const int* d1 = &verts[(indices[j] & 0x0fffffff) * 4];
			var n = verts.Length;
			var d0 = verts[RemoveDiagonalFlag(indices[i])];
			var d1 = verts[RemoveDiagonalFlag(indices[j])];
			
			// For each edge (k,k+1) of P
			for (int k = 0; k < n; k++)
			{
				int k1 = Next(k, n);
				// Skip edges incident to i or j
				if (!((k == i) || (k1 == i) || (k == j) || (k1 == j)))
				{
					//const int* p0 = &verts[(indices[k] & 0x0fffffff) * 4];
					//const int* p1 = &verts[(indices[k1] & 0x0fffffff) * 4];
					var p0 = verts[RemoveDiagonalFlag(indices[k])];
					var p1 = verts[RemoveDiagonalFlag(indices[k1])];
					
					
					if (PolyVertex.Equal2D(ref d0, ref p0) ||
					    PolyVertex.Equal2D(ref d1, ref p0) ||
					    PolyVertex.Equal2D(ref d0, ref p1) ||
					    PolyVertex.Equal2D(ref d1, ref p1))
						continue;
					
					if (IsIntersectProp(ref d0, ref d1, ref p0, ref p1))
						return false;
				}
			}
			return true;
		}
		
		static bool xorb(bool x, bool y)
		{
			return !x ^ !y;
		}
		
		//	Returns true iff ab properly intersects cd: they share
		//	a point interior to both segments.  The properness of the
		//	intersection is ensured by using strict leftness.
		static bool IsIntersectProp(ref PolyVertex a, ref PolyVertex b, ref PolyVertex c, ref PolyVertex d)
		{
			// Eliminate improper cases.
			if (PolyVertex.IsCollinear(ref a, ref b, ref c) || PolyVertex.IsCollinear(ref a, ref b, ref d) ||
			    PolyVertex.IsCollinear(ref c, ref d, ref a) || PolyVertex.IsCollinear(ref c, ref d, ref b))
				return false;
			
			
			return xorb(PolyVertex.IsLeft(ref a, ref b, ref c), PolyVertex.IsLeft(ref a, ref b, ref d)) &&
				xorb(PolyVertex.IsLeft(ref c, ref d, ref a), PolyVertex.IsLeft(ref c, ref d, ref b));
		}

		/// <summary>
		/// Generate a new vertices with (x, y, z) coordiates and return the hash code index 
		/// </summary>
		/// <param name="vertDict">Vertex dictionary that maps coordinates to index</param>
		/// <param name="v">A vertex.</param>
		/// <param name="verts">The list of vertices</param>
		/// <returns>The vertex index</returns>
		private static int AddVertex(Dictionary<PolyVertex, int> vertDict, PolyVertex v, List<PolyVertex> verts)
		{
			int index;
			if (vertDict.TryGetValue(v, out index))
			{
				return index;
			}

			index = verts.Count;
			verts.Add(v);
			vertDict.Add(v, index);
			return index;
		}

		/// <summary>
		/// Try to merge two polygons. If possible, return the distance squared between two vertices.
		/// </summary>
		/// <param name="polys">Polygon list</param>
		/// <param name="polyA">Polygon A</param>
		/// <param name="polyB">Polygon B</param>
		/// <param name="verts">Vertex list</param>
		/// <param name="edgeA">Shared edge's endpoint A</param>
		/// <param name="edgeB">Shared edge's endpoint B</param>
		/// <returns>The distance between two vertices</returns>
		private static int GetPolyMergeValue(List<Polygon> polys, int polyA, int polyB, List<PolyVertex> verts, out int edgeA, out int edgeB)
		{
			int numVertsA = polys[polyA].VertexCount;
			int numVertsB = polys[polyB].VertexCount;

			//check if polygons share an edge
			edgeA = -1;
			edgeB = -1;

			//don't merge if result is too big
			if (numVertsA + numVertsB - 2 > polys[polyA].Vertices.Length)
				return -1;

			//iterate through all the vertices of polygonA
			for (int i = 0; i < numVertsA; i++)
			{
				//take two nearby vertices
				int va0 = polys[polyA].Vertices[i];
				int va1 = polys[polyA].Vertices[(i + 1) % numVertsA];
				
				//make sure va0 < va1
				if (va0 > va1)
				{
					int temp = va0;
					va0 = va1;
					va1 = temp;
				}

				//iterate through all the vertices of polygon B
				for (int j = 0; j < numVertsB; j++)
				{
					//take two nearby vertices
					int vb0 = polys[polyB].Vertices[j];
					int vb1 = polys[polyB].Vertices[(j + 1) % numVertsB];
					
					//make sure vb0 < vb1
					if (vb0 > vb1)
					{
						int temp = vb0;
						vb0 = vb1;
						vb1 = temp;
					}

					//edge shared, since vertices are equal
					if (va0 == vb0 && va1 == vb1)
					{
						edgeA = i;
						edgeB = j;
						break;
					}
				}
			}

			//no common edge
			if (edgeA == -1 || edgeB == -1)
				return -1;

			//check if merged polygon would be convex
			int vertA, vertB, vertC;

			vertA = polys[polyA].Vertices[(edgeA + numVertsA - 1) % numVertsA];
			vertB = polys[polyA].Vertices[edgeA];
			vertC = polys[polyB].Vertices[(edgeB + 2) % numVertsB];
			if (!ULeft(verts[vertA], verts[vertB], verts[vertC]))
				return -1;

			vertA = polys[polyB].Vertices[(edgeB + numVertsB - 1) % numVertsB];
			vertB = polys[polyB].Vertices[edgeB];
			vertC = polys[polyA].Vertices[(edgeA + 2) % numVertsA];
			if (!ULeft(verts[vertA], verts[vertB], verts[vertC]))
				return -1;

			vertA = polys[polyA].Vertices[edgeA];
			vertB = polys[polyA].Vertices[(edgeA + 1) % numVertsA];

			int dx = (int)(verts[vertA].X - verts[vertB].X);
			int dy = (int)(verts[vertA].Z - verts[vertB].Z);
			return dx * dx + dy * dy;
		}

		/// <summary>
		/// If vertex can't be removed, there is no need to spend time deleting it.
		/// </summary>
		/// <param name="polys">The polygon list</param>
		/// <param name="remove">The vertex index</param>
		/// <returns>True, if vertex can be removed. False, if otherwise.</returns>
		private static bool CanRemoveVertex(List<Polygon> polys, int remove)
		{
			//count number of polygons to remove
			int numRemovedVerts = 0;
			int numTouchedVerts = 0;
			int numRemainingEdges = 0;

			for (int i = 0; i < polys.Count; i++)
			{
				Polygon p = polys[i];
				int nv = p.VertexCount;
				int numRemoved = 0;
				int numVerts = 0;

				for (int j = 0; j < nv; j++)
				{
					if (p.Vertices[j] == remove)
					{
						numTouchedVerts++;
						numRemoved++;
					}

					numVerts++;
				}

				if (numRemoved > 0)
				{
					numRemovedVerts += numRemoved;
					numRemainingEdges += numVerts - (numRemoved + 1);
				}
			}

			//don't remove a vertex from a triangle since you need at least three vertices to make a polygon
			if (numRemainingEdges <= 2)
				return false;

			//find edges which share removed vertex
			int maxEdges = numTouchedVerts * 2;
			int nedges = 0;
			int[] edges = new int[maxEdges * 3];

			for (int i = 0; i < polys.Count; i++)
			{
				Polygon p = polys[i];
				int nv = p.VertexCount;

				//collect edges which touch removed vertex
				for (int j = 0, k = nv - 1; j < nv; k = j++)
				{
					if (p.Vertices[j] == remove || p.Vertices[k] == remove)
					{
						//arrange edge so that a has the removed value
						int a = p.Vertices[j], b = p.Vertices[k];
						if (b == remove)
						{
							int temp = a;
							a = b;
							b = temp;
						}

						//check if edge exists
						bool exists = false;
						for (int m = 0; m < nedges; m++)
						{
							int e = m * 3;
							if (edges[e + 1] == b)
							{
								//increment vertex share count
								edges[e + 2]++;
								exists = true;
							}
						}

						//add new edge
						if (!exists)
						{
							int e = nedges * 3;
							edges[e + 0] = a;
							edges[e + 1] = b;
							edges[e + 2] = 1;
							nedges++;
						}
					}
				}
			}

			//make sure there can't be more than two open edges
			//since there could be two non-adjacent polygons which share the same vertex, which shouldn't be removed
			int numOpenEdges = 0;
			for (int i = 0; i < nedges; i++)
			{
				if (edges[i * 3 + 2] < 2)
					numOpenEdges++;
			}

			if (numOpenEdges > 2)
				return false;

			return true;
		}

		/// <summary>
		/// Connect two adjacent vertices with edges.
		/// </summary>
		/// <param name="vertices">The vertex list</param>
		/// <param name="polys">The polygon list</param>
		/// <param name="numVertsPerPoly">Number of vertices per polygon</param>
		private static void BuildMeshAdjacency(List<PolyVertex> vertices, List<Polygon> polys, int numVertsPerPoly)
		{
			int maxEdgeCount = polys.Count * numVertsPerPoly;
			int[] firstEdge = new int[vertices.Count + maxEdgeCount];
			int nextEdge = vertices.Count;
			List<AdjacencyEdge> edges = new List<AdjacencyEdge>(maxEdgeCount);

			for (int i = 0; i < vertices.Count; i++)
				firstEdge[i] = NullId;

			//Iterate through all the polygons
			for (int i = 0; i < polys.Count; i++)
			{
				Polygon p = polys[i];

				//Iterate through all the vertices
				for (int j = 0; j < numVertsPerPoly; j++)
				{
					if (p.Vertices[j] == NullId)
						break;

					//get closest two verts
					int v0 = p.Vertices[j];
					int v1 = (j + 1 >= numVertsPerPoly || p.Vertices[j + 1] == NullId) ? p.Vertices[0] : p.Vertices[j + 1];

					if (v0 < v1)
					{
						AdjacencyEdge edge;

						//store vertices
						edge.Vert0 = v0;
						edge.Vert1 = v1;

						//poly array stores index of polygon
						//polyEdge stores the vertex
						edge.Poly0 = i;
						edge.PolyEdge0 = j;
						edge.Poly1 = i;
						edge.PolyEdge1 = 0;

						//insert edge
						firstEdge[nextEdge + edges.Count] = firstEdge[v0];
						firstEdge[v0] = edges.Count;

						edges.Add(edge);
					}
				}
			}

			//Iterate through all the polygons again
			for (int i = 0; i < polys.Count; i++)
			{
				Polygon p = polys[i];
				for (int j = 0; j < numVertsPerPoly; j++)
				{
					if (p.Vertices[j] == NullId)
						break;

					//get adjacent vertices
					int v0 = p.Vertices[j];
					int v1 = (j + 1 >= numVertsPerPoly || p.Vertices[j + 1] == NullId) ? p.Vertices[0] : p.Vertices[j + 1];

					if (v0 > v1)
					{
						//Iterate through all the edges
						for (int e = firstEdge[v1]; e != NullId; e = firstEdge[nextEdge + e])
						{
							AdjacencyEdge edge = edges[e];
							if (edge.Vert1 == v0 && edge.Poly0 == edge.Poly1)
							{
								edge.Poly1 = i;
								edge.PolyEdge1 = j;
								edges[e] = edge;
								break;
							}
						}
					}
				}
			}

			//store adjacency
			for (int i = 0; i < edges.Count; i++)
			{
				AdjacencyEdge e = edges[i];

				//the endpoints belong to different polygons
				if (e.Poly0 != e.Poly1)
				{
					//store other polygon number as part of extra info
					polys[e.Poly0].NeighborEdges[e.PolyEdge0] = e.Poly1;
					polys[e.Poly1].NeighborEdges[e.PolyEdge1] = e.Poly0;
				}
			}
		}

		/// <summary>
		/// The two polygon arrrays are merged into a single array
		/// </summary>
		/// <param name="polys">The polygon list</param>
		/// <param name="polyA">Polygon A</param>
		/// <param name="polyB">Polygon B</param>
		/// <param name="edgeA">Starting edge for polygon A</param>
		/// <param name="edgeB">Starting edge for polygon B</param>
		private void MergePolys(List<Polygon> polys, int polyA, int polyB, int edgeA, int edgeB)
		{
			//TODO replace with Polygon.Merge()
			int numA = polys[polyA].VertexCount;
			int numB = polys[polyB].VertexCount;
			int[] temp = new int[numA + numB];

			//merge
			for (int i = 0; i < numVertsPerPoly; i++)
				temp[i] = NullId;

			int n = 0;

			//add polygon A
			for (int i = 0; i < numA - 1; i++)
				temp[n++] = polys[polyA].Vertices[(edgeA + 1 + i) % numA];

			//add polygon B
			for (int i = 0; i < numB - 1; i++)
				temp[n++] = polys[polyB].Vertices[(edgeB + 1 + i) % numB];

			//save merged data to new polygon
			for (int i = 0; i < numVertsPerPoly; i++)
				polys[polyA].Vertices[i] = temp[i];
		}

		/// <summary>
		/// Removing vertices will leave holes that have to be triangulated again.
		/// </summary>
		/// <param name="verts">A list of vertices</param>
		/// <param name="polys">A list of polygons</param>
		/// <param name="vertex">The vertex to remove</param>
		private void RemoveVertex(List<PolyVertex> verts, List<Polygon> polys, int vertex)
		{
			int numVertsPerPoly = this.numVertsPerPoly;

			//count number of polygons to remove
			int numRemovedVerts = 0;
			for (int i = 0; i < polys.Count; i++)
			{
				Polygon p = polys[i];

				for (int j = 0; j < p.VertexCount; j++)
				{
					if (p.Vertices[j] == vertex)
						numRemovedVerts++;
				}
			}

			List<Edge> edges = new List<Edge>(numRemovedVerts * numVertsPerPoly);
			List<int> hole = new List<int>(numRemovedVerts * numVertsPerPoly);
			List<RegionId> regions = new List<RegionId>(numRemovedVerts * numVertsPerPoly);
			List<Area> areas = new List<Area>(numRemovedVerts * numVertsPerPoly);

			//Iterate through all the polygons
			for (int i = 0; i < polys.Count; i++)
			{
				Polygon p = polys[i];

				if (p.ContainsVertex(vertex))
				{
					int nv = p.VertexCount;

					//collect edges which don't touch removed vertex
					for (int j = 0, k = nv - 1; j < nv; k = j++)
						if (p.Vertices[j] != vertex && p.Vertices[k] != vertex)
							edges.Add(new Edge(p.Vertices[k], p.Vertices[j], p.RegionId, p.Area));

					polys[i] = polys[polys.Count - 1];
					polys.RemoveAt(polys.Count - 1);
					i--;
				}
			}

			//remove vertex
			verts.RemoveAt(vertex);

			//adjust indices
			for (int i = 0; i < polys.Count; i++)
			{
				Polygon p = polys[i];

				for (int j = 0; j < p.VertexCount; j++)
				{
					if (p.Vertices[j] > vertex)
						p.Vertices[j]--;
				}
			}

			for (int i = 0; i < edges.Count; i++)
			{
				Edge edge = edges[i];
				if (edge.Vert0 > vertex)
					edge.Vert0--;

				if (edge.Vert1 > vertex)
					edge.Vert1--;

				edges[i] = edge;
			}

			if (edges.Count == 0)
				return;

			//Find edges surrounding the holes
			hole.Add(edges[0].Vert0);
			regions.Add(edges[0].Region);
			areas.Add(edges[0].Area);

			while (edges.Count > 0)
			{
				bool match = false;

				for (int i = 0; i < edges.Count; i++)
				{
					Edge edge = edges[i];
					bool add = false;

					if (hole[0] == edge.Vert1)
					{
						//segment matches beginning of hole boundary
						hole.Insert(0, edge.Vert0);
						regions.Insert(0, edge.Region);
						areas.Insert(0, edge.Area);
						add = true;
					}
					else if (hole[hole.Count - 1] == edge.Vert0)
					{
						//segment matches end of hole boundary
						hole.Add(edge.Vert1);
						regions.Add(edge.Region);
						areas.Add(edge.Area);
						add = true;
					}

					if (add)
					{
						//edge segment was added so remove it
						edges[i] = edges[edges.Count - 1];
						edges.RemoveAt(edges.Count - 1);
						match = true;
						i--;
					}
				}

				if (!match)
					break;
			}

			var tris = new Triangle[hole.Count];
			var tverts = new PolyVertex[hole.Count];
			var thole = new int[hole.Count];

			//generate temp vertex array for triangulation
			for (int i = 0; i < hole.Count; i++)
			{
				int polyIndex = hole[i];
				tverts[i] = verts[polyIndex];
				thole[i] = i;
			}

			//triangulate the hole
			int ntris = Triangulate(tverts, thole, tris);
			if (ntris < 0)
				ntris = -ntris;

			//merge hole triangles back to polygons
			List<Polygon> mergePolys = new List<Polygon>(ntris + 1);

			for (int j = 0; j < ntris; j++)
			{
				Triangle t = tris[j];
				if (t.Index0 != t.Index1 && t.Index0 != t.Index2 && t.Index1 != t.Index2)
				{
					Polygon p = new Polygon(numVertsPerPoly, areas[t.Index0], regions[t.Index0], 0);
					p.Vertices[0] = hole[t.Index0];
					p.Vertices[1] = hole[t.Index1];
					p.Vertices[2] = hole[t.Index2];
					mergePolys.Add(p);
				}
			}

			if (mergePolys.Count == 0)
				return;

			//merge polygons
			if (numVertsPerPoly > 3)
			{
				while (true)
				{
					//find best polygons
					int bestMergeVal = 0;
					int bestPolyA = 0, bestPolyB = 0, bestEa = 0, bestEb = 0;

					for (int j = 0; j < mergePolys.Count - 1; j++)
					{
						int pj = j;
						for (int k = j + 1; k < mergePolys.Count; k++)
						{
							int pk = k;
							int edgeA, edgeB;
							int v = GetPolyMergeValue(mergePolys, pj, pk, verts, out edgeA, out edgeB);
							if (v > bestMergeVal)
							{
								bestMergeVal = v;
								bestPolyA = j;
								bestPolyB = k;
								bestEa = edgeA;
								bestEb = edgeB;
							}
						}
					}

					if (bestMergeVal > 0)
					{
						int polyA = bestPolyA;
						int polyB = bestPolyB;
						MergePolys(mergePolys, polyA, polyB, bestEa, bestEb);
						mergePolys[polyB] = mergePolys[mergePolys.Count - 1];
						mergePolys.RemoveAt(mergePolys.Count - 1);
					}
					else
					{
						//no more merging
						break;
					}
				}
			}

			//add merged polys back to the list.
			polys.AddRange(mergePolys);
		}

		/// <summary>
		/// A triangle contains three indices.
		/// </summary>
		private struct Triangle
		{
			public int Index0;
			public int Index1;
			public int Index2;
		}

		/// <summary>
		/// Two adjacent vertices form an edge.
		/// </summary>
		private struct AdjacencyEdge
		{
			public int Vert0;
			public int Vert1;

			public int PolyEdge0;
			public int PolyEdge1;

			public int Poly0;
			public int Poly1;
		}

		/// <summary>
		/// Another edge structure, but this one contains the RegionId and AreaId.
		/// </summary>
		private struct Edge
		{
			public int Vert0;
			public int Vert1;
			public RegionId Region;
			public Area Area;

			/// <summary>
			/// Initializes a new instance of the <see cref="Edge"/> struct.
			/// </summary>
			/// <param name="vert0">Vertex A</param>
			/// <param name="vert1">Vertex B</param>
			/// <param name="region">Region id</param>
			/// <param name="area">Area id</param>
			public Edge(int vert0, int vert1, RegionId region, Area area)
			{
				Vert0 = vert0;
				Vert1 = vert1;
				Region = region;
				Area = area;
			}
		}
			
		/// <summary>
		/// Each polygon is a collection of vertices. It is the basic unit of the PolyMesh
		/// </summary>
		public class Polygon
		{
			private int[] vertices; //"numVertsPerPoly" elements
			private int[] neighborEdges; //"numVertsPerPoly" elements
			private Area area;
			private RegionId regionId;
			private int flags;

			/// <summary>
			/// Initializes a new instance of the <see cref="Polygon" /> class.
			/// </summary>
			/// <param name="numVertsPerPoly">The number of vertices per polygon.</param>
			/// <param name="area">The AreaId</param>
			/// <param name="regionId">The RegionId</param>
			/// <param name="flags">Polygon flags</param>
			public Polygon(int numVertsPerPoly, Area area, RegionId regionId, int flags)
			{
				vertices = new int[numVertsPerPoly];
				neighborEdges = new int[numVertsPerPoly];
				this.area = area;
				this.regionId = regionId;
				this.flags = flags;

				for (int i = 0; i < numVertsPerPoly; i++)
				{
					vertices[i] = NullId;
					neighborEdges[i] = NullId;
				}
			}

			/// <summary>
			/// Gets the indices for the vertices.
			/// </summary>
			/// <value>The vertices.</value>
			public int[] Vertices
			{
				get
				{
					return vertices;
				}
			}

			/// <summary>
			/// Gets the neighbor edges.
			/// </summary>
			/// <value>The neighbor edges.</value>
			public int[] NeighborEdges
			{
				get
				{
					return neighborEdges;
				}
			}

			/// <summary>
			/// Gets or sets the area id
			/// </summary>
			public Area Area
			{
				get
				{
					return area;
				}

				set
				{
					area = value;
				}
			}

			/// <summary>
			/// Gets or sets the region identifier.
			/// </summary>
			/// <value>The region identifier.</value>
			public RegionId RegionId
			{
				get
				{
					return regionId;
				}

				set
				{
					regionId = value;
				}
			}

			/// <summary>
			/// Gets or sets the flags.
			/// </summary>
			/// <value>The flags.</value>
			public int Flags
			{
				get
				{
					return flags;
				}

				set
				{
					flags = value;
				}
			}

			/// <summary>
			/// Gets the the number of vertex.
			/// </summary>
			/// <value>The vertex count.</value>
			public int VertexCount
			{
				get
				{
					for (int i = 0; i < vertices.Length; i++)
						if (vertices[i] == NullId)
							return i;

					return vertices.Length;
				}
			}

			/// <summary>
			/// Determine if the vertex is in polygon.
			/// </summary>
			/// <returns><c>true</c>, if vertex was containsed, <c>false</c> otherwise.</returns>
			/// <param name="vertex">The Vertex.</param>
			public bool ContainsVertex(int vertex)
			{
				//iterate through all the vertices
				for (int i = 0; i < vertices.Length; i++)
				{
					//find the vertex, return false if at end of defined polygon.
					int v = vertices[i];
					if (v == vertex)
						return true;
					else if (v == NullId)
						return false;
				}

				return false;
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\PolyMeshDetail.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// The PolyMeshDetail class is a combination of a PolyMesh and a CompactHeightfield merged together
	/// </summary>
	public class PolyMeshDetail
	{
		//9 x 2
		private static readonly int[] VertexOffset =
		{
			0, 0,
			-1, -1,
			0, -1,
			1, -1,
			1, 0,
			1, 1,
			0, 1,
			-1, 1,
			-1, 0
		};
		
		private MeshData[] meshes;
		private Vector3[] verts;
		private TriangleData[] tris;

		/// <summary>
		/// Initializes a new instance of the <see cref="PolyMeshDetail"/> class.
		/// </summary>
		/// <param name="mesh">The <see cref="PolyMesh"/>.</param>
		/// <param name="compactField">The <see cref="CompactHeightfield"/> used to add height detail.</param>
		/// <param name="settings">The settings to build with.</param>
		public PolyMeshDetail(PolyMesh mesh, CompactHeightfield compactField, NavMeshGenerationSettings settings)
			: this(mesh, compactField, settings.SampleDistance, settings.MaxSampleError)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="PolyMeshDetail"/> class.
		/// </summary>
		/// <remarks>
		/// <see cref="PolyMeshDetail"/> uses a <see cref="CompactHeightfield"/> to add in details to a
		/// <see cref="PolyMesh"/>. This detail is triangulated into a new mesh and can be used to approximate height in the walkable
		/// areas of a scene.
		/// </remarks>
		/// <param name="mesh">The <see cref="PolyMesh"/>.</param>
		/// <param name="compactField">The <see cref="CompactHeightfield"/> used to add height detail.</param>
		/// <param name="sampleDist">The sampling distance.</param>
		/// <param name="sampleMaxError">The maximum sampling error allowed.</param>
		public PolyMeshDetail(PolyMesh mesh, CompactHeightfield compactField, float sampleDist, float sampleMaxError)
		{
			if (mesh.VertCount == 0 || mesh.PolyCount == 0)
				return;

			Vector3 origin = mesh.Bounds.Min;

			int maxhw = 0, maxhh = 0;

			BBox2i[] bounds = new BBox2i[mesh.PolyCount];
			Vector3[] poly = new Vector3[mesh.NumVertsPerPoly];

			var storedVertices = new List<Vector3>();
			var storedTriangles = new List<TriangleData>();

			//find max size for polygon area
			for (int i = 0; i < mesh.PolyCount; i++)
			{
				var p = mesh.Polys[i];

				int xmin = compactField.Width;
				int xmax = 0;
				int zmin = compactField.Length;
				int zmax = 0;

				for (int j = 0; j < mesh.NumVertsPerPoly; j++)
				{
					var pj = p.Vertices[j];
					if (pj == PolyMesh.NullId)
						break;

					var v = mesh.Verts[pj];

					xmin = Math.Min(xmin, v.X);
					xmax = Math.Max(xmax, v.X);
					zmin = Math.Min(zmin, v.Z);
					zmax = Math.Max(zmax, v.Z);
				}

				xmin = Math.Max(0, xmin - 1);
				xmax = Math.Min(compactField.Width, xmax + 1);
				zmin = Math.Max(0, zmin - 1);
				zmax = Math.Min(compactField.Length, zmax + 1);

				if (xmin >= xmax || zmin >= zmax)
					continue;

				maxhw = Math.Max(maxhw, xmax - xmin);
				maxhh = Math.Max(maxhh, zmax - zmin);

				bounds[i] = new BBox2i(xmin, zmin, xmax, zmax);
			}

			HeightPatch hp = new HeightPatch(0, 0, maxhw, maxhh);

			this.meshes = new MeshData[mesh.PolyCount];

			for (int i = 0; i < mesh.PolyCount; i++)
			{
				var p = mesh.Polys[i];

				//store polygon vertices for processing
				int npoly = 0;
				for (int j = 0; j < mesh.NumVertsPerPoly; j++)
				{
					int pvi = p.Vertices[j];
					if (pvi == PolyMesh.NullId)
						break;

					PolyVertex pv = mesh.Verts[pvi];
					Vector3 v = new Vector3(pv.X, pv.Y, pv.Z);
					v.X *= mesh.CellSize;
					v.Y *= mesh.CellHeight;
					v.Z *= mesh.CellSize;
					poly[j] = v;
					npoly++;
				}

				//get height data from area of polygon
				BBox2i bound = bounds[i];
				hp.Resize(bound.Min.X, bound.Min.Y, bound.Max.X - bound.Min.X, bound.Max.Y - bound.Min.Y);
				GetHeightData(compactField, p, npoly, mesh.Verts, mesh.BorderSize, hp);

				List<Vector3> tempVerts = new List<Vector3>();
				List<TriangleData> tempTris = new List<TriangleData>(128);
				List<EdgeInfo> edges = new List<EdgeInfo>(16);
				List<SamplingData> samples = new List<SamplingData>(128);
				BuildPolyDetail(poly, npoly, sampleDist, sampleMaxError, compactField, hp, tempVerts, tempTris, edges, samples);

				//more detail verts
				for (int j = 0; j < tempVerts.Count; j++)
				{
					Vector3 tv = tempVerts[j];

					Vector3 v;
					v.X = tv.X + origin.X;
					v.Y = tv.Y + origin.Y + compactField.CellHeight;
					v.Z = tv.Z + origin.Z;

					tempVerts[j] = v;
				}

				for (int j = 0; j < npoly; j++)
				{
					Vector3 po = poly[j];

					po.X += origin.X;
					po.Y += origin.Y;
					po.Z += origin.Z;

					poly[j] = po;
				}

				//save data
				this.meshes[i].VertexIndex = storedVertices.Count;
				this.meshes[i].VertexCount = tempVerts.Count;
				this.meshes[i].TriangleIndex = storedTriangles.Count;
				this.meshes[i].TriangleCount = tempTris.Count;

				//store vertices
				storedVertices.AddRange(tempVerts);
				
				//store triangles
				for (int j = 0; j < tempTris.Count; j++)
				{
					storedTriangles.Add(new TriangleData(tempTris[j], tempVerts, poly, npoly));
				}
			}

			this.verts = storedVertices.ToArray();
			this.tris = storedTriangles.ToArray();
		}

		/// <summary>
		/// Determines whether an edge has been created or not.
		/// </summary>
		private enum EdgeValues
		{
			/// <summary>
			/// Edge has not been initialized
			/// </summary>
			Undefined = -1,

			/// <summary>
			/// Edge is hull
			/// </summary>
			Hull = -2
		}
		
		/// <summary>
		/// Gets the number of meshes (MeshData)
		/// </summary>
		public int MeshCount
		{
			get
			{
				if (meshes == null)
					return 0;

				return meshes.Length;
			}
		}

		/// <summary>
		/// Gets the number of vertices
		/// </summary>
		public int VertCount
		{
			get
			{
				if (verts == null)
					return 0;

				return verts.Length;
			}
		}

		/// <summary>
		/// Gets the number of triangles
		/// </summary>
		public int TrisCount
		{
			get
			{
				if (tris == null)
					return 0;

				return tris.Length;
			}
		}

		/// <summary>
		/// Gets the mesh data		
		/// </summary>
		public MeshData[] Meshes
		{
			get
			{
				return meshes;
			}
		}

		/// <summary>
		/// Gets the vertex data
		/// </summary>
		public Vector3[] Verts
		{
			get
			{
				return verts;
			}
		}

		/// <summary>
		/// Gets the triangle data
		/// </summary>
		public TriangleData[] Tris
		{
			get
			{
				return tris;
			}
		}

		#region Black Magic

		/// <summary>
		/// Offset for the x-coordinate
		/// </summary>
		/// <param name="i">Starting number</param>
		/// <returns>A new offset</returns>
		private static float GetJitterX(int i)
		{
			return (((i * 0x8da6b343) & 0xffff) / 65535.0f * 2.0f) - 1.0f;
		}

		/// <summary>
		/// Offset for the y-coordinate
		/// </summary>
		/// <param name="i">Starting number</param>
		/// <returns>A new offset</returns>
		private static float GetJitterY(int i)
		{
			return (((i * 0xd8163841) & 0xffff) / 65535.0f * 2.0f) - 1.0f;
		}

		#endregion

		/// <summary>
		/// Determine whether an edge of the triangle is part of the polygon (1 if true, 0 if false)
		/// </summary>
		/// <param name="va">Triangle vertex A</param>
		/// <param name="vb">Triangle vertex B</param>
		/// <param name="vpoly">Polygon vertex data</param>
		/// <returns>1 if the vertices are close, 0 if otherwise</returns>
		private static int GetEdgeFlags(Vector3 va, Vector3 vb, Vector3[] vpoly, int npoly)
		{
			//true if edge is part of polygon
			float thrSqr = 0.001f * 0.001f;

			for (int i = 0, j = npoly - 1; i < npoly; j = i++)
			{
				Vector3 pt1 = va;
				Vector3 pt2 = vb;

				//the vertices pt1 (va) and pt2 (vb) are extremely close to the polygon edge
				if (Distance.PointToSegment2DSquared(ref pt1, ref vpoly[j], ref vpoly[i]) < thrSqr 
					&& Distance.PointToSegment2DSquared(ref pt2, ref vpoly[j], ref vpoly[i]) < thrSqr)
					return 1;
			}

			return 0;
		}

		private void GetHeightData(CompactHeightfield compactField, PolyMesh.Polygon poly, int polyCount, PolyVertex[] verts, int borderSize, HeightPatch hp)
		{
			var stack = new List<CompactSpanReference>();
			bool empty = true;
			hp.Clear();

			for (int y = 0; y < hp.Length; y++)
			{
				int hy = hp.Y + y + borderSize;
				for (int x = 0; x < hp.Width; x++)
				{
					int hx = hp.X + x + borderSize;
					var cells = compactField.Cells[hy * compactField.Width + hx];
					for (int i = cells.StartIndex, end = cells.StartIndex + cells.Count; i < end; i++)
					{
						var span = compactField.Spans[i];

						if (span.Region == poly.RegionId)
						{
							hp[x, y] = span.Minimum;
							empty = false;

							bool border = false;
							for (var dir = Direction.West; dir <= Direction.South; dir++)
							{
								if (span.IsConnected(dir))
								{
									int ax = hx + dir.GetHorizontalOffset();
									int ay = hy + dir.GetVerticalOffset();
									int ai = compactField.Cells[ay * compactField.Width + ax].StartIndex + CompactSpan.GetConnection(ref span, dir);

									if (compactField.Spans[ai].Region != poly.RegionId)
									{
										border = true;
										break;
									}
								}
							}

							if (border)
								stack.Add(new CompactSpanReference(hx, hy, i));

							break;
						}
					}
				}
			}

			if (empty)
				GetHeightDataSeedsFromVertices(compactField, poly, polyCount, verts, borderSize, hp, stack);

			const int RetractSize = 256;
			int head = 0;

			while (head < stack.Count)
			{
				var cell = stack[head++];
				var cs = compactField[cell];

				if (head >= RetractSize)
				{
					head = 0;
					if (stack.Count > RetractSize)
					{
						for (int i = 0; i < stack.Count - RetractSize; i++)
							stack[i] = stack[i + RetractSize];
					}

					int targetSize = stack.Count % RetractSize;
					while (stack.Count > targetSize)
						stack.RemoveAt(stack.Count - 1);
				}

				//loop in all four directions
				for (var dir = Direction.West; dir <= Direction.South; dir++)
				{
					//skip
					if (!cs.IsConnected(dir))
						continue;

					int ax = cell.X + dir.GetHorizontalOffset();
					int ay = cell.Y + dir.GetVerticalOffset();
					int hx = ax - hp.X - borderSize;
					int hy = ay - hp.Y - borderSize;

					if (hx < 0 || hx >= hp.Width || hy < 0 || hy >= hp.Length)
						continue;

					//only continue if height is unset
					if (hp.IsSet(hy * hp.Width + hx))
						continue;

					//get new span
					int ai = compactField.Cells[ay * compactField.Width + ax].StartIndex + CompactSpan.GetConnection(ref cs, dir);
					CompactSpan ds = compactField.Spans[ai];

					hp[hx, hy] = ds.Minimum;

					stack.Add(new CompactSpanReference(ax, ay, ai));
				}
			}
		}

		/// <summary>
		/// Floodfill heightfield to get 2D height data, starting at vertex locations
		/// </summary>
		/// <param name="compactField">Original heightfield data</param>
		/// <param name="poly">Polygon in PolyMesh</param>
		/// <param name="polyCount">Number of vertices per polygon</param>
		/// <param name="verts">PolyMesh Vertices</param>
		/// <param name="borderSize">Heightfield border size</param>
		/// <param name="hp">HeightPatch which extracts heightfield data</param>
		/// <param name="stack">Temporary stack of CompactSpanReferences</param>
		private void GetHeightDataSeedsFromVertices(CompactHeightfield compactField, PolyMesh.Polygon poly, int polyCount, PolyVertex[] verts, int borderSize, HeightPatch hp, List<CompactSpanReference> stack)
		{
			hp.SetAll(0);

			//use poly vertices as seed points
			for (int j = 0; j < polyCount; j++)
			{
				var csr = new CompactSpanReference(0, 0, -1);
				int dmin = int.MaxValue;

				var v = verts[poly.Vertices[j]];

				for (int k = 0; k < 9; k++)
				{
					//get vertices and offset x and z coordinates depending on current drection
					int ax = v.X + VertexOffset[k * 2 + 0];
					int ay = v.Y;
					int az = v.Z + VertexOffset[k * 2 + 1];

					//skip if out of bounds
					if (ax < hp.X || ax >= hp.X + hp.Width || az < hp.Y || az >= hp.Y + hp.Length)
						continue;

					//get new cell
					CompactCell c = compactField.Cells[(az + borderSize) * compactField.Width + (ax + borderSize)];
					
					//loop through all the spans
					for (int i = c.StartIndex, end = c.StartIndex + c.Count; i < end; i++)
					{
						CompactSpan s = compactField.Spans[i];
						
						//find minimum y-distance
						int d = Math.Abs(ay - s.Minimum);
						if (d < dmin)
						{
							csr = new CompactSpanReference(ax, az, i);
							dmin = d;
						}
					}
				}

				//only add if something new found
				if (csr.Index != -1)
				{
					stack.Add(csr);
				}
			}

			//find center of polygon using flood fill
			int pcx = 0, pcz = 0;
			for (int j = 0; j < polyCount; j++)
			{
				var v = verts[poly.Vertices[j]];
				pcx += v.X;
				pcz += v.Z;
			}

			pcx /= polyCount;
			pcz /= polyCount;

			//stack groups 3 elements as one part
			foreach (var cell in stack)
			{
				int idx = (cell.Y - hp.Y) * hp.Width + (cell.X - hp.X);
				hp[idx] = 1;
			}

			//process the entire stack
			while (stack.Count > 0)
			{
				var cell = stack[stack.Count - 1];
				stack.RemoveAt(stack.Count - 1);

				//check if close to center of polygon
				if (Math.Abs(cell.X - pcx) <= 1 && Math.Abs(cell.Y - pcz) <= 1)
				{
					//clear the stack and add a new group
					stack.Clear();

					stack.Add(cell);
					break;
				}

				CompactSpan cs = compactField[cell];

				//check all four directions
				for (var dir = Direction.West; dir <= Direction.South; dir++)
				{
					//skip if disconnected
					if (!cs.IsConnected(dir))
						continue;

					//get neighbor
					int ax = cell.X + dir.GetHorizontalOffset();
					int ay = cell.Y + dir.GetVerticalOffset();

					//skip if out of bounds
					if (ax < hp.X || ax >= (hp.X + hp.Width) || ay < hp.Y || ay >= (hp.Y + hp.Length))
						continue;

					if (hp[(ay - hp.Y) * hp.Width + (ax - hp.X)] != 0)
						continue;

					//get the new index
					int ai = compactField.Cells[(ay + borderSize) * compactField.Width + (ax + borderSize)].StartIndex + CompactSpan.GetConnection(ref cs, dir);

					//save data
					int idx = (ay - hp.Y) * hp.Width + (ax - hp.X);
					hp[idx] = 1;

					//push to stack
					stack.Add(new CompactSpanReference(ax, ay, ai));
				}
			}

			//clear the heightpatch
			hp.Clear();

			//mark start locations
			for (int i = 0; i < stack.Count; i++)
			{
				var c = stack[i];

				//set new heightpatch data
				int idx = (c.Y - hp.Y) * hp.Width + (c.X - hp.X);
				CompactSpan cs = compactField.Spans[c.Index];
				hp[idx] = cs.Minimum;

				stack[i] = new CompactSpanReference(c.X + borderSize, c.Y + borderSize, c.Index);
			}
		}

		private static float PolyMinExtent(Vector3[] verts)
		{
			float minDist = float.MaxValue;
			for (int i = 0; i < verts.Length; i++)
			{
				int ni = (i + 1) % verts.Length;
				Vector3 p0 = verts[i];
				Vector3 p1 = verts[ni];

				float maxEdgeDist = 0;
				for (int j = 0; j < verts.Length; j++)
				{
					if (j == i || j == ni)
						continue;

					float d = Distance.PointToSegment2DSquared(ref verts[j], ref p0, ref p1);
					maxEdgeDist = Math.Max(maxEdgeDist, d);
				}

				minDist = Math.Min(minDist, maxEdgeDist);
			}

			return (float)Math.Sqrt(minDist);
		}

		/// <summary>
		/// Generate the PolyMeshDetail using the PolyMesh and HeightPatch
		/// </summary>
		/// <param name="polyMeshVerts">PolyMesh Vertex data</param>
		/// <param name="numMeshVerts">Number of PolyMesh vertices</param>
		/// <param name="sampleDist">Sampling distance</param>
		/// <param name="sampleMaxError">Maximum sampling error</param>
		/// <param name="compactField">THe compactHeightfield</param>
		/// <param name="hp">The heightPatch</param>
		/// <param name="verts">Detail verts</param>
		/// <param name="tris">Detail triangles</param>
		/// <param name="edges">The edge array</param>
		/// <param name="samples">The samples array</param>
		private void BuildPolyDetail(Vector3[] polyMeshVerts, int numMeshVerts, float sampleDist, float sampleMaxError, CompactHeightfield compactField, HeightPatch hp, List<Vector3> verts, List<TriangleData> tris, List<EdgeInfo> edges, List<SamplingData> samples)
		{
			const int MAX_VERTS = 127;
			const int MAX_TRIS = 255;
			const int MAX_VERTS_PER_EDGE = 32;
			Vector3[] edge = new Vector3[MAX_VERTS_PER_EDGE + 1];
			List<int> hull = new List<int>(MAX_VERTS);

			//fill up vertex array
			for (int i = 0; i < numMeshVerts; ++i)
				verts.Add(polyMeshVerts[i]);

			float cs = compactField.CellSize;
			float ics = 1.0f / cs;

			float minExtent = PolyMinExtent(polyMeshVerts);

			//tessellate outlines
			if (sampleDist > 0)
			{
				for (int i = 0, j = verts.Count - 1; i < verts.Count; j = i++)
				{
					Vector3 vi = verts[i];
					Vector3 vj = verts[j];
					bool swapped = false;

					//make sure order is correct, otherwise swap data
					if (Math.Abs(vj.X - vi.X) < 1E-06f)
					{
						if (vj.Z > vi.Z)
						{
							Vector3 temp = vj;
							vj = vi;
							vi = temp;
							swapped = true;
						}
					}
					else if (vj.X > vi.X)
					{
						Vector3 temp = vj;
						vj = vi;
						vi = temp;
						swapped = true;
					}

					//create samples along the edge
					Vector3 dv;
					Vector3.Subtract(ref vi, ref vj, out dv);
					float d = (float)Math.Sqrt(dv.X * dv.X + dv.Z * dv.Z);
					int nn = 1 + (int)Math.Floor(d / sampleDist);

					if (nn >= MAX_VERTS_PER_EDGE)
						nn = MAX_VERTS_PER_EDGE - 1;

					if (verts.Count + nn >= MAX_VERTS)
						nn = MAX_VERTS - 1 - verts.Count;

					for (int k = 0; k <= nn; k++)
					{
						float u = (float)k / (float)nn;
						Vector3 pos;

						Vector3 tmp;
						Vector3.Multiply(ref dv, u, out tmp);
						Vector3.Add(ref vj, ref tmp, out pos);

						pos.Y = GetHeight(pos, ics, compactField.CellHeight, hp) * compactField.CellHeight;

						edge[k] = pos;
					}

					//simplify samples
					int[] idx = new int[MAX_VERTS_PER_EDGE];
					idx[0] = 0;
					idx[1] = nn;
					int nidx = 2;

					for (int k = 0; k < nidx - 1;)
					{
						int a = idx[k];
						int b = idx[k + 1];
						Vector3 va = edge[a];
						Vector3 vb = edge[b];

						//find maximum deviation along segment
						float maxd = 0;
						int maxi = -1;
						for (int m = a + 1; m < b; m++)
						{
							float dev = Distance.PointToSegmentSquared(ref edge[m], ref va, ref vb);
							if (dev > maxd)
							{
								maxd = dev;
								maxi = m;
							}
						}

						if (maxi != -1 && maxd > (sampleMaxError * sampleMaxError))
						{
							//shift data to the right
							for (int m = nidx; m > k; m--)
								idx[m] = idx[m - 1];

							//set new value
							idx[k + 1] = maxi;
							nidx++;
						}
						else
						{
							k++;
						}
					}

					hull.Add(j);

					//add new vertices
					if (swapped)
					{
						for (int k = nidx - 2; k > 0; k--)
						{
							hull.Add(verts.Count);
							verts.Add(edge[idx[k]]);
						}
					}
					else
					{
						for (int k = 1; k < nidx - 1; k++)
						{
							hull.Add(verts.Count);
							verts.Add(edge[idx[k]]);
						}
					}
				}
			}

			//tesselate base mesh
			edges.Clear();
			tris.Clear();

			if (minExtent < sampleDist * 2)
			{
				TriangulateHull(verts, hull, tris);
				return;
			}

			TriangulateHull(verts, hull, tris);

			if (tris.Count == 0)
			{
				Console.WriteLine("Can't triangulate polygon, adding default data.");
				return;
			}

			if (sampleDist > 0)
			{
				//create sample locations
				BBox3 bounds = new BBox3();
				bounds.Min = polyMeshVerts[0];
				bounds.Max = polyMeshVerts[0];

				for (int i = 1; i < numMeshVerts; i++)
				{
					Vector3Extensions.ComponentMin(ref bounds.Min, ref polyMeshVerts[i], out bounds.Min);
					Vector3Extensions.ComponentMax(ref bounds.Max, ref polyMeshVerts[i], out bounds.Max); 
				}

				int x0 = (int)Math.Floor(bounds.Min.X / sampleDist);
				int x1 = (int)Math.Ceiling(bounds.Max.X / sampleDist);
				int z0 = (int)Math.Floor(bounds.Min.Z / sampleDist);
				int z1 = (int)Math.Ceiling(bounds.Max.Z / sampleDist);

				samples.Clear();

				for (int z = z0; z < z1; z++)
				{
					for (int x = x0; x < x1; x++)
					{
						Vector3 pt = new Vector3(x * sampleDist, (bounds.Max.Y + bounds.Min.Y) * 0.5f, z * sampleDist);

						//make sure samples aren't too close to edge
						if (Distance.PointToPolygonSquared(pt, polyMeshVerts, numMeshVerts) > -sampleDist * 0.5f)
							continue;

						SamplingData sd = new SamplingData(x, GetHeight(pt, ics, compactField.CellHeight, hp), z, false);
						samples.Add(sd);
					}
				}

				//added samples
				for (int iter = 0; iter < samples.Count; iter++)
				{
					if (verts.Count >= MAX_VERTS)
						break;

					//find sample with most error
					Vector3 bestPt = Vector3.Zero;
					float bestDistance = 0;
					int bestIndex = -1;

					for (int i = 0; i < samples.Count; i++)
					{
						SamplingData sd = samples[i];
						if (sd.IsSampled)
							continue;

						//jitter sample location to remove effects of bad triangulation
						Vector3 pt;
						pt.X = sd.X * sampleDist + GetJitterX(i) * compactField.CellSize * 0.1f;
						pt.Y = sd.Y * compactField.CellHeight;
						pt.Z = sd.Z * sampleDist + GetJitterY(i) * compactField.CellSize * 0.1f;
						float d = DistanceToTriMesh(pt, verts, tris);

						if (d < 0)
							continue;

						if (d > bestDistance)
						{
							bestDistance = d;
							bestIndex = i;
							bestPt = pt;
						}
					}

					if (bestDistance <= sampleMaxError || bestIndex == -1)
						break;

					SamplingData bsd = samples[bestIndex];
					bsd.IsSampled = true;
					samples[bestIndex] = bsd;

					verts.Add(bestPt);

					//create new triangulation
					edges.Clear();
					tris.Clear();
					DelaunayHull(verts, hull, tris, edges);
				}
			}

			int ntris = tris.Count;
			if (ntris > MAX_TRIS)
			{
				//TODO we're using lists... let the user have super detailed meshes?
				//Perhaps just a warning saying there's a lot of tris?
				//tris.RemoveRange(MAX_TRIS + 1, tris.Count - MAX_TRIS);
				//Console.WriteLine("WARNING: shrinking number of triangles.");
			}
		}

		/// <summary>
		/// Use the HeightPatch data to obtain a height for a certain location.
		/// </summary>
		/// <param name="loc">The location</param>
		/// <param name="invCellSize">Reciprocal of cell size</param>
		/// <param name="cellHeight">Cell height</param>
		/// <param name="hp">Height patch</param>
		/// <returns>The height</returns>
		private int GetHeight(Vector3 loc, float invCellSize, float cellHeight, HeightPatch hp)
		{
			int ix = (int)Math.Floor(loc.X * invCellSize + 0.01f);
			int iz = (int)Math.Floor(loc.Z * invCellSize + 0.01f);
			ix = MathHelper.Clamp(ix - hp.X, 0, hp.Width - 1);
			iz = MathHelper.Clamp(iz - hp.Y, 0, hp.Length - 1);
			int h;

			if (!hp.TryGetHeight(ix, iz, out h))
			{
				//go in counterclockwise direction starting from west, ending in northwest
				int[] off =
				{
					-1,  0,
					-1, -1,
					 0, -1,
					 1, -1,
					 1,  0,
					 1,  1,
					 0,  1,
					-1,  1
				};

				float dmin = float.MaxValue;

				for (int i = 0; i < 8; i++)
				{
					int nx = ix + off[i * 2 + 0];
					int nz = iz + off[i * 2 + 1];

					if (nx < 0 || nz < 0 || nx >= hp.Width || nz >= hp.Length)
						continue;

					int nh;
					if (!hp.TryGetHeight(nx, nz, out nh))
						continue;

					float d = Math.Abs(nh * cellHeight - loc.Y);
					if (d < dmin)
					{
						h = nh;
						dmin = d;
					}
				}
			}

			return h;
		}

		/// <summary>
		/// Gets the previous vertex index
		/// </summary>
		/// <param name="i">The current index</param>
		/// <param name="n">The max number of vertices</param>
		/// <returns>The previous index</returns>
		private static int Prev(int i, int n)
		{
			return i - 1 >= 0 ? i - 1 : n - 1;
		}

		/// <summary>
		/// Gets the next vertex index
		/// </summary>
		/// <param name="i">The current index</param>
		/// <param name="n">The max number of vertices</param>
		/// <returns>The next index</returns>
		private static int Next(int i, int n)
		{
			return i + 1 < n ? i + 1 : 0;
		}

		private void TriangulateHull(List<Vector3> pts, List<int> hull, List<TriangleData> tris)
		{
			int start = 0, left = 1, right = hull.Count - 1;

			float dmin = 0;
			for (int i = 0; i < hull.Count; i++)
			{
				int pi = Prev(i, hull.Count);
				int ni = Next(i, hull.Count);
				Vector3 pv = pts[hull[pi]];
				Vector3 cv = pts[hull[i]];
				Vector3 nv = pts[hull[ni]];
				float d = 0;
				float dtmp;
				Vector3Extensions.Distance2D(ref pv, ref cv, out dtmp);
				d += dtmp;
				Vector3Extensions.Distance2D(ref cv, ref nv, out dtmp);
				d += dtmp;
				Vector3Extensions.Distance2D(ref nv, ref pv, out dtmp);
				d += dtmp;

				if (d < dmin)
				{
					start = i;
					left = ni;
					right = pi;
					dmin = d;
				}
			}

			tris.Add(new TriangleData(hull[start], hull[left], hull[right], 0));

			while (Next(left, hull.Count) != right)
			{
				int nleft = Next(left, hull.Count);
				int nright = Prev(right, hull.Count);

				Vector3 cvleft = pts[hull[left]];
				Vector3 nvleft = pts[hull[nleft]];
				Vector3 cvright = pts[hull[right]];
				Vector3 nvright = pts[hull[nright]];

				float dleft = 0, dright = 0;
				float dtmp;
				Vector3Extensions.Distance2D(ref cvleft, ref nvleft, out dtmp);
				dleft += dtmp;
				Vector3Extensions.Distance2D(ref nvleft, ref cvright, out dtmp);
				dleft += dtmp;

				Vector3Extensions.Distance2D(ref cvright, ref nvright, out dtmp);
				dright += dtmp;
				Vector3Extensions.Distance2D(ref cvleft, ref nvright, out dtmp);
				dright += dtmp;

				if (dleft < dright)
				{
					tris.Add(new TriangleData(hull[left], hull[nleft], hull[right], 0));
					left = nleft;
				}
				else
				{
					tris.Add(new TriangleData(hull[left], hull[nright], hull[right], 0));
					right = nright;
				}
			}
		}

		/// <summary>
		/// Delaunay triangulation is used to triangulate the polygon after adding detail to the edges. The result is a mesh.
		/// </summary>
		/// <param name="pts">Vertex data (each vertex has 3 elements x,y,z)</param>
		/// <param name="hull">The hull (purpose?)</param>
		/// <param name="tris">The triangles formed.</param>
		/// <param name="edges">The edge connections formed.</param>
		private void DelaunayHull(List<Vector3> pts, List<int> hull, List<TriangleData> tris, List<EdgeInfo> edges)
		{
			int nfaces = 0;
			edges.Clear();

			for (int i = 0, j = hull.Count - 1; i < hull.Count; j = i++)
				AddEdge(edges, hull[j], hull[i], (int)EdgeValues.Hull, (int)EdgeValues.Undefined);

			for (int i = 0; i < edges.Count; i++)
			{
				if (edges[i].LeftFace == (int)EdgeValues.Undefined)
					CompleteFacet(pts, edges, ref nfaces, i);
				
				if (edges[i].RightFace == (int)EdgeValues.Undefined)
					CompleteFacet(pts, edges, ref nfaces, i);
			}

			/*int currentEdge = 0;
			while (currentEdge < edges.Count)
			{
				if (edges[currentEdge].LeftFace == (int)EdgeValues.Undefined)
					CompleteFacet(pts, edges, ref nfaces, currentEdge);
				if (edges[currentEdge].RightFace == (int)EdgeValues.Undefined)
					CompleteFacet(pts, edges, ref nfaces, currentEdge);

				currentEdge++;
			}*/

			//create triangles
			tris.Clear();
			for (int i = 0; i < nfaces; i++)
				tris.Add(new TriangleData(-1, -1, -1, -1));

			for (int i = 0; i < edges.Count; i++)
			{
				EdgeInfo e = edges[i];

				if (e.RightFace >= 0)
				{
					//left face
					var tri = tris[e.RightFace];
					
					if (tri.VertexHash0 == -1)
					{
						tri.VertexHash0 = e.EndPt0;
						tri.VertexHash1 = e.EndPt1;
					}
					else if (tri.VertexHash0 == e.EndPt1)
					{
						tri.VertexHash2 = e.EndPt0;
					}
					else if (tri.VertexHash1 == e.EndPt0)
					{
						tri.VertexHash2 = e.EndPt1;
					}

					tris[e.RightFace] = tri;
				}

				if (e.LeftFace >= 0)
				{
					//right
					var tri = tris[e.LeftFace];
					
					if (tri.VertexHash0 == -1)
					{
						tri.VertexHash0 = e.EndPt1;
						tri.VertexHash1 = e.EndPt0;
					}
					else if (tri.VertexHash0 == e.EndPt0)
					{
						tri.VertexHash2 = e.EndPt1;
					}
					else if (tri.VertexHash1 == e.EndPt1)
					{
						tri.VertexHash2 = e.EndPt0;
					}

					tris[e.LeftFace] = tri;
				}
			}

			for (int i = 0; i < tris.Count; i++)
			{
				var t = tris[i];
				if (t.VertexHash0 == -1 || t.VertexHash1 == -1 || t.VertexHash2 == -1)
				{
					//remove dangling face
					Console.WriteLine("WARNING: removing dangling face.");
					tris[i] = tris[tris.Count - 1];
					tris.RemoveAt(tris.Count - 1);
					i--;
				}
			}
		}

		/// <summary>
		/// If a face has missing edges, then fill in those edges
		/// </summary>
		/// <param name="pts">List of points</param>
		/// <param name="edges">List of edges</param>
		/// <param name="nfaces">The total number of faces</param>
		/// <param name="curEdge">The current index in the edge list</param>
		private void CompleteFacet(List<Vector3> pts, List<EdgeInfo> edges, ref int nfaces, int curEdge)
		{
			const float EPS = 1e-5f;

			EdgeInfo e = edges[curEdge];

			//cache s and t
			int s, t;
			if (e.LeftFace == (int)EdgeValues.Undefined)
			{
				s = e.EndPt0;
				t = e.EndPt1;
			}
			else if (e.RightFace == (int)EdgeValues.Undefined)
			{
				s = e.EndPt1;
				t = e.EndPt0;
			}
			else
			{
				//edge already completed
				return;
			}

			//find best point on left edge
			int pt = pts.Count;
			Vector3 c = Vector3.Zero;
			float r = -1;
			float cross;
			for (int u = 0; u < pts.Count; u++)
			{
				if (u == s || u == t)
					continue;

				cross = Vector3Extensions.Cross2D(pts[s], pts[t], pts[u]);
				if (cross > EPS)
				{
					if (r < 0)
					{
						//update circle now
						pt = u;
						CircumCircle(pts[s], pts[t], pts[u], ref c, out r);
						continue;
					}

					float d = Vector3Extensions.Distance2D(c, pts[u]);
					float tol = 0.001f;

					if (d > r * (1 + tol))
					{
						//outside circumcircle
						continue;
					}
					else if (d < r * (1 - tol))
					{
						//inside circumcircle, update
						pt = u;
						CircumCircle(pts[s], pts[t], pts[u], ref c, out r);
					}
					else
					{
						//inside epsilon circumcircle
						if (OverlapEdges(pts, edges, s, u))
							continue;

						if (OverlapEdges(pts, edges, t, u))
							continue;

						//edge is valid
						pt = u;
						CircumCircle(pts[s], pts[t], pts[u], ref c, out r);
					}
				}
			}

			//add new triangle or update edge if s-t on hull
			if (pt < pts.Count)
			{
				EdgeInfo.UpdateLeftFace(ref e, s, t, nfaces);
				edges[curEdge] = e;

				curEdge = AddEdge(edges, pt, s, nfaces, (int)EdgeValues.Undefined);
				if (curEdge != (int)EdgeValues.Undefined)
				{
					e = edges[curEdge];
					EdgeInfo.UpdateLeftFace(ref e, pt, s, nfaces);
					edges[curEdge] = e;
				}

				curEdge = AddEdge(edges, t, pt, nfaces, (int)EdgeValues.Undefined);
				if (curEdge != (int)EdgeValues.Undefined)
				{
					e = edges[curEdge];
					EdgeInfo.UpdateLeftFace(ref e, t, pt, nfaces);
					edges[curEdge] = e;
				}

				nfaces++;
			}
			else
			{
				e = edges[curEdge];
				EdgeInfo.UpdateLeftFace(ref e, s, t, (int)EdgeValues.Hull);
				edges[curEdge] = e;
			}
		}

		/// <summary>
		/// Add an edge to the edge list if it hasn't been done so already
		/// </summary>
		/// <param name="edges">Edge list</param>
		/// <param name="s">Endpt 0</param>
		/// <param name="t">Endpt 1</param>
		/// <param name="leftFace">Left face value</param>
		/// <param name="rightFace">Right face value</param>
		/// <returns>The index of the edge (edge can already exist in the list).</returns>
		private int AddEdge(List<EdgeInfo> edges, int s, int t, int leftFace, int rightFace)
		{
			//add edge
			int e = FindEdge(edges, s, t);
			if (e == -1)
			{
				EdgeInfo edge = new EdgeInfo(s, t, rightFace, leftFace);
				edges.Add(edge);

				return edges.Count - 1;
			}
			else
				return e;
		}

		/// <summary>
		/// Search for an edge within the edge list
		/// </summary>
		/// <param name="edges">Edge list</param>
		/// <param name="s">Endpt 0</param>
		/// <param name="t">Endpt 1</param>
		/// <returns>If found, return the edge's index. Otherwise, return -1.</returns>
		private int FindEdge(List<EdgeInfo> edges, int s, int t)
		{
			for (int i = 0; i < edges.Count; i++)
			{
				EdgeInfo e = edges[i];
				if ((e.EndPt0 == s && e.EndPt1 == t) || (e.EndPt0 == t && e.EndPt1 == s))
					return i;
			}

			return -1;
		}

		/// <summary>
		/// Determine whether edges overlap with the points
		/// </summary>
		/// <param name="pts">Individual points</param>
		/// <param name="edges">Edge list</param>
		/// <param name="s1">An edge's endpt 0</param>
		/// <param name="t1">An edge's endpt1</param>
		/// <returns>True if there is overlap, false if not</returns>
		private bool OverlapEdges(List<Vector3> pts, List<EdgeInfo> edges, int s1, int t1)
		{
			Vector3 ps1 = pts[s1], pt1 = pts[t1];

			for (int i = 0; i < edges.Count; i++)
			{
				int s0 = edges[i].EndPt0;
				int t0 = edges[i].EndPt1;

				//same or connected edges do not overlap
				if (s0 == s1 || s0 == t1 || t0 == s1 || t0 == t1)
					continue;

				Vector3 ps0 = pts[s0], pt0 = pts[t0];
				if (Intersection.SegmentSegment2D(ref ps0, ref pt0, ref ps1, ref pt1))
					return true;
			}

			return false;
		}

		/// <summary>
		/// Form a triangle ABC out of the three vectors and calculate the center and radius 
		/// of the resulting circumcircle
		/// </summary>
		/// <param name="p1">Point A</param>
		/// <param name="p2">Point B</param>
		/// <param name="p3">point C</param>
		/// <param name="c">Circumcirlce center</param>
		/// <param name="r">Circumcircle radius</param>
		/// <returns>True, if a circumcirle can be found. False, if otherwise.</returns>
		private bool CircumCircle(Vector3 p1, Vector3 p2, Vector3 p3, ref Vector3 c, out float r)
		{
			const float EPS = 1e-6f;
			float cp;
			Vector3Extensions.Cross2D(ref p1, ref p2, ref p3, out cp);

			if (Math.Abs(cp) > EPS)
			{
				//find magnitude of each point
				float p1sq, p2sq, p3sq;

				Vector3Extensions.Dot2D(ref p1, ref p1, out p1sq);
				Vector3Extensions.Dot2D(ref p2, ref p2, out p2sq);
				Vector3Extensions.Dot2D(ref p3, ref p3, out p3sq);

				c.X = (p1sq * (p2.Z - p3.Z) + p2sq * (p3.Z - p1.Z) + p3sq * (p1.Z - p2.Z)) / (2 * cp);
				c.Z = (p1sq * (p3.X - p2.X) + p2sq * (p1.X - p3.X) + p3sq * (p2.X - p1.X)) / (2 * cp);

				float dx = p1.X - c.X;
				float dy = p1.Z - c.Z;
				r = (float)Math.Sqrt(dx * dx + dy * dy);
				return true;
			}

			c.X = p1.X;
			c.Z = p1.Z;
			r = 0;
			return false;
		}

		/// <summary>
		/// Find the distance from a point to a triangle mesh.
		/// </summary>
		/// <param name="p">Individual point</param>
		/// <param name="verts">Vertex array</param>
		/// <param name="tris">Triange list</param>
		/// <returns>The distance</returns>
		private float DistanceToTriMesh(Vector3 p, List<Vector3> verts, List<TriangleData> tris)
		{
			float dmin = float.MaxValue;

			for (int i = 0; i < tris.Count; i++)
			{
				Vector3 va = verts[tris[i].VertexHash0];
				Vector3 vb = verts[tris[i].VertexHash1];
				Vector3 vc = verts[tris[i].VertexHash2];
				float d = Distance.PointToTriangle(p, va, vb, vc);
				if (d < dmin)
					dmin = d;
			}

			if (dmin == float.MaxValue)
				return -1;

			return dmin;
		}

		/// <summary>
		/// The MeshData struct contains information about vertex and triangle base and offset values for array indices
		/// </summary>
		public struct MeshData
		{
			public int VertexIndex;
			public int VertexCount;
			public int TriangleIndex;
			public int TriangleCount;
		}

		/// <summary>
		/// The triangle info contains three vertex hashes and a flag
		/// </summary>
		public struct TriangleData
		{
			public int VertexHash0;
			public int VertexHash1;
			public int VertexHash2;
			public int Flags; //indicates which 3 vertices are part of the polygon

			/// <summary>
			/// Initializes a new instance of the <see cref="TriangleData" /> struct.
			/// </summary>
			/// <param name="hash0">Vertex A</param>
			/// <param name="hash1">Vertex B</param>
			/// <param name="hash2">Vertex C</param>
			public TriangleData(int hash0, int hash1, int hash2)
			{
				VertexHash0 = hash0;
				VertexHash1 = hash1;
				VertexHash2 = hash2;
				Flags = 0;
			}

			/// <summary>
			/// Initializes a new instance of the <see cref="TriangleData" /> struct.
			/// </summary>
			/// <param name="hash0">Vertex A</param>
			/// <param name="hash1">Vertex B</param>
			/// <param name="hash2">Vertex C</param>
			/// <param name="flags">The triangle flags</param>
			public TriangleData(int hash0, int hash1, int hash2, int flags)
			{
				VertexHash0 = hash0;
				VertexHash1 = hash1;
				VertexHash2 = hash2;
				Flags = flags;
			}

			/// <summary>
			/// Initializes a new instance of the <see cref="TriangleData" /> struct.
			/// </summary>
			/// <param name="data">The triangle itself</param>
			/// <param name="verts">The list of all the vertices</param>
			/// <param name="vpoly">The list of the polygon's vertices</param>
			public TriangleData(TriangleData data, List<Vector3> verts, Vector3[] vpoly, int npoly)
			{
				VertexHash0 = data.VertexHash0;
				VertexHash1 = data.VertexHash1;
				VertexHash2 = data.VertexHash2;
				Flags = GetTriFlags(ref data, verts, vpoly, npoly);
			}

			/// <summary>
			/// Gets a triangle's particular vertex
			/// </summary>
			/// <param name="index">Vertex index</param>
			/// <returns>Triangle vertex hash</returns>
			public int this[int index]
			{
				get
				{
					switch (index)
					{
						case 0:
							return VertexHash0;
						case 1:
							return VertexHash1;
						case 2:
						default:
							return VertexHash2;
					}
				}
			}

			/// <summary>
			/// Determine which edges of the triangle are part of the polygon
			/// </summary>
			/// <param name="t">A triangle.</param>
			/// <param name="verts">The vertex buffer that the triangle is referencing.</param>
			/// <param name="vpoly">Polygon vertex data.</param>
			/// <returns>The triangle's flags.</returns>
			public static int GetTriFlags(ref TriangleData t, List<Vector3> verts, Vector3[] vpoly, int npoly)
			{
				int flags = 0;

				//the triangle flags store five bits ?0?0? (like 10001, 10101, etc..)
				//each bit stores whether two vertices are close enough to a polygon edge 
				//since triangle has three vertices, there are three distinct pairs of vertices (va,vb), (vb,vc) and (vc,va)
				flags |= GetEdgeFlags(verts[t.VertexHash0], verts[t.VertexHash1], vpoly, npoly) << 0;
				flags |= GetEdgeFlags(verts[t.VertexHash1], verts[t.VertexHash2], vpoly, npoly) << 2;
				flags |= GetEdgeFlags(verts[t.VertexHash2], verts[t.VertexHash0], vpoly, npoly) << 4;

				return flags;
			}
		}

		/// <summary>
		/// The EdgeInfo struct contains two enpoints and the faces/polygons to the left and right of that edge.
		/// </summary>
		private struct EdgeInfo
		{
			public int EndPt0;
			public int EndPt1;
			public int RightFace;
			public int LeftFace;

			/// <summary>
			/// Initializes a new instance of the <see cref="EdgeInfo"/> struct.
			/// </summary>
			/// <param name="endPt0">Point A</param>
			/// <param name="endPt1">Point B</param>
			/// <param name="rightFace">The face to the left of the edge</param>
			/// <param name="leftFace">The face to the right of the edge</param>
			public EdgeInfo(int endPt0, int endPt1, int rightFace, int leftFace)
			{
				this.EndPt0 = endPt0;
				this.EndPt1 = endPt1;
				this.RightFace = rightFace;
				this.LeftFace = leftFace;
			}

			/// <summary>
			/// If the left face is undefined, assign it a value
			/// </summary>
			/// <param name="e">The current edge</param>
			/// <param name="s">Endpoint A</param>
			/// <param name="t">Endpoint B</param>
			/// <param name="f">The face value</param>
			public static void UpdateLeftFace(ref EdgeInfo e, int s, int t, int f)
			{
				if (e.EndPt0 == s && e.EndPt1 == t && e.LeftFace == (int)EdgeValues.Undefined)
					e.LeftFace = f;
				else if (e.EndPt1 == s && e.EndPt0 == t && e.RightFace == (int)EdgeValues.Undefined)
					e.RightFace = f;
			}
		}

		/// <summary>
		/// The SamplingData struct contains information about sampled vertices from the PolyMesh
		/// </summary>
		private struct SamplingData
		{
			public int X;
			public int Y;
			public int Z;
			public bool IsSampled;

			/// <summary>
			/// Initializes a new instance of the <see cref="SamplingData"/> struct.
			/// </summary>
			/// <param name="x">The x-coordinate</param>
			/// <param name="y">The y-coordinate</param>
			/// <param name="z">The z-coordinate</param>
			/// <param name="isSampled">Whether or not the vertex has been sampled</param>
			public SamplingData(int x, int y, int z, bool isSampled)
			{
				this.X = x;
				this.Y = y;
				this.Z = z;
				this.IsSampled = isSampled;
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\PolyVertex.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace SharpNav
{
	/// <summary>
	/// A vertex inside a <see cref="PolyMesh"/>.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct PolyVertex : IEquatable<PolyVertex>
	{
		/// <summary>
		/// The X coordinate.
		/// </summary>
		public int X;

		/// <summary>
		/// The Y coordinate.
		/// </summary>
		public int Y;

		/// <summary>
		/// The Z coordinate.
		/// </summary>
		public int Z;

		/// <summary>
		/// Initializes a new instance of the <see cref="PolyVertex"/> struct.
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		/// <param name="z">The Z coordinate.</param>
		public PolyVertex(int x, int y, int z)
		{
			X = x;
			Y = y;
			Z = z;
		}

		/// <summary>
		/// Calculates the component-wise minimum of two vertices.
		/// </summary>
		/// <param name="a">A vertex.</param>
		/// <param name="b">Another vertex.</param>
		/// <returns>The component-wise minimum of the two vertices.</returns>
		public static PolyVertex ComponentMin(PolyVertex a, PolyVertex b)
		{
			PolyVertex v;
			ComponentMin(ref a, ref b, out v);
			return v;
		}

		/// <summary>
		/// Calculates the component-wise minimum of two vertices.
		/// </summary>
		/// <param name="a">A vertex.</param>
		/// <param name="b">Another vertex.</param>
		/// <param name="result">The component-wise minimum of the two vertices.</param>
		public static void ComponentMin(ref PolyVertex a, ref PolyVertex b, out PolyVertex result)
		{
			result.X = a.X < b.X ? a.X : b.X;
			result.Y = a.Y < b.Y ? a.Y : b.Y;
			result.Z = a.Z < b.Z ? a.Z : b.Z;
		}

		/// <summary>
		/// Calculates the component-wise maximum of two vertices.
		/// </summary>
		/// <param name="a">A vertex.</param>
		/// <param name="b">Another vertex.</param>
		/// <returns>The component-wise maximum of the two vertices.</returns>
		public static PolyVertex ComponentMax(PolyVertex a, PolyVertex b)
		{
			PolyVertex v;
			ComponentMax(ref a, ref b, out v);
			return v;
		}

		/// <summary>
		/// Calculates the component-wise maximum of two vertices.
		/// </summary>
		/// <param name="a">A vertex.</param>
		/// <param name="b">Another vertex.</param>
		/// <param name="result">The component-wise maximum of the two vertices.</param>
		public static void ComponentMax(ref PolyVertex a, ref PolyVertex b, out PolyVertex result)
		{
			result.X = a.X > b.X ? a.X : b.X;
			result.Y = a.Y > b.Y ? a.Y : b.Y;
			result.Z = a.Z > b.Z ? a.Z : b.Z;
		}

		/// <summary>
		/// Gets the leftness of a triangle formed from 3 contour vertices.
		/// </summary>
		/// <param name="a">The first vertex.</param>
		/// <param name="b">The second vertex.</param>
		/// <param name="c">The third vertex.</param>
		/// <returns>A value indicating the leftness of the triangle.</returns>
		public static bool IsLeft(ref PolyVertex a, ref PolyVertex b, ref PolyVertex c)
		{
			int area;
			Area2D(ref a, ref b, ref c, out area);
			return area < 0;
		}

		/// <summary>
		/// Gets the leftness (left or on) of a triangle formed from 3 contour vertices.
		/// </summary>
		/// <param name="a">The first vertex.</param>
		/// <param name="b">The second vertex.</param>
		/// <param name="c">The third vertex.</param>
		/// <returns>A value indicating whether the triangle is left or on.</returns>
		public static bool IsLeftOn(ref PolyVertex a, ref PolyVertex b, ref PolyVertex c)
		{
			int area;
			Area2D(ref a, ref b, ref c, out area);
			return area <= 0;
		}

		/// <summary>
		/// Compares vertex equality in 2D.
		/// </summary>
		/// <param name="a">A vertex.</param>
		/// <param name="b">Another vertex.</param>
		/// <returns>A value indicating whether the X and Z components of both vertices are equal.</returns>
		public static bool Equal2D(ref PolyVertex a, ref PolyVertex b)
		{
			return a.X == b.X && a.Z == b.Z;
		}

		/// <summary>
		/// True if and only if segments AB and CD intersect, properly or improperly.
		/// </summary>
		/// <param name="a">Point A of segment AB.</param>
		/// <param name="b">Point B of segment AB.</param>
		/// <param name="c">Point C of segment CD.</param>
		/// <param name="d">Point D of segment CD.</param>
		/// <returns>A value indicating whether segments AB and CD intersect.</returns>
		public static bool Intersect(ref PolyVertex a, ref PolyVertex b, ref PolyVertex c, ref PolyVertex d)
		{
			if (IntersectProp(ref a, ref b, ref c, ref d))
				return true;
			else if (IsBetween(ref a, ref b, ref c)
				|| IsBetween(ref a, ref b, ref d)
				|| IsBetween(ref c, ref d, ref a)
				|| IsBetween(ref c, ref d, ref b))
				return true;
			else
				return false;
		}

		/// <summary>
		/// True if and only if segments AB and CD intersect properly.
		/// </summary>
		/// <remarks>
		/// Proper intersection: A point interior to both segments is shared. Properness determined by strict leftness.
		/// </remarks>
		/// <param name="a">Point A of segment AB.</param>
		/// <param name="b">Point B of segment AB.</param>
		/// <param name="c">Point C of segment CD.</param>
		/// <param name="d">Point D of segment CD.</param>
		/// <returns>A value indicating whether segements AB and CD are intersecting properly.</returns>
		public static bool IntersectProp(ref PolyVertex a, ref PolyVertex b, ref PolyVertex c, ref PolyVertex d)
		{
			//eliminate improper cases
			if (IsCollinear(ref a, ref b, ref c)
				|| IsCollinear(ref a, ref b, ref d)
				|| IsCollinear(ref c, ref d, ref a)
				|| IsCollinear(ref c, ref d, ref b))
				return false;

			return (!IsLeft(ref a, ref b, ref c) ^ !IsLeft(ref a, ref b, ref d))
				&& (!IsLeft(ref c, ref d, ref a) ^ !IsLeft(ref c, ref d, ref b));
		}

		/// <summary>
		/// True if and only if A, B, and C are collinear and point C lies on closed segment AB
		/// </summary>
		/// <param name="a">Point A of segment AB.</param>
		/// <param name="b">Point B of segment AB.</param>
		/// <param name="c">Point C.</param>
		/// <returns>A value indicating whether the three points are collinear with C in the middle.</returns>
		public static bool IsBetween(ref PolyVertex a, ref PolyVertex b, ref PolyVertex c)
		{
			if (!IsCollinear(ref a, ref b, ref c))
				return false;

			if (a.X != b.X)
				return ((a.X <= c.X) && (c.X <= b.X)) || ((a.X >= c.X) && (c.X >= b.X));
			else
				return ((a.Z <= c.Z) && (c.Z <= b.Z)) || ((a.Z >= c.Z) && (c.Z >= b.Z));
		}

		/// <summary>
		/// True if and only if points A, B, and C are collinear.
		/// </summary>
		/// <param name="a">Point A.</param>
		/// <param name="b">Point B.</param>
		/// <param name="c">Point C.</param>
		/// <returns>A value indicating whether the points are collinear.</returns>
		public static bool IsCollinear(ref PolyVertex a, ref PolyVertex b, ref PolyVertex c)
		{
			int area;
			Area2D(ref a, ref b, ref c, out area);
			return area == 0;
		}

		/// <summary>
		/// Gets the 2D area of the triangle ABC.
		/// </summary>
		/// <param name="a">Point A of triangle ABC.</param>
		/// <param name="b">Point B of triangle ABC.</param>
		/// <param name="c">Point C of triangle ABC.</param>
		/// <param name="area">The 2D area of the triangle.</param>
		public static void Area2D(ref PolyVertex a, ref PolyVertex b, ref PolyVertex c, out int area)
		{
			area = (b.X - a.X) * (c.Z - a.Z) - (c.X - a.X) * (b.Z - a.Z);
		}

		/// <summary>
		/// Gets the 2D area of the triangle ABC.
		/// </summary>
		/// <param name="a">Point A of triangle ABC.</param>
		/// <param name="b">Point B of triangle ABC.</param>
		/// <param name="c">Point C of triangle ABC.</param>
		/// <param name="area">The 2D area of the triangle.</param>
		public static void Area2D(ref ContourVertex a, ref ContourVertex b, ref ContourVertex c, out int area)
		{
			area = (b.X - a.X) * (c.Z - a.Z) - (c.X - a.X) * (b.Z - a.Z);
		}

		/// <summary>
		/// Compares two vertices for equality.
		/// </summary>
		/// <param name="left">A vertex.</param>
		/// <param name="right">Another vertex.</param>
		/// <returns>A value indicating whether the two vertices are equal.</returns>
		public static bool operator ==(PolyVertex left, PolyVertex right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two vertices for inequality.
		/// </summary>
		/// <param name="left">A vertex.</param>
		/// <param name="right">Another vertex.</param>
		/// <returns>A value indicating whether the two vertices are not equal.</returns>
		public static bool operator !=(PolyVertex left, PolyVertex right)
		{
			return !(left == right);
		}

		/// <summary>
		/// Compares another <see cref="PolyVertex"/> with this instance for equality.
		/// </summary>
		/// <param name="other">The other instance.</param>
		/// <returns>A value indicating whether the two vertices are equal.</returns>
		public bool Equals(PolyVertex other)
		{
			return X == other.X && Y == other.Y && Z == other.Z;
		}

		/// <summary>
		/// Compares an object with this instance for equality.
		/// </summary>
		/// <param name="obj">An object.</param>
		/// <returns>A value indicating whether the object is equal to this instance.</returns>
		public override bool Equals(object obj)
		{
			PolyVertex? p = obj as PolyVertex?;
			if (p.HasValue)
				return this.Equals(p.Value);

			return false;
		}

		/// <summary>
		/// Gets a hash code unique to the contents of this instance.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			//TODO write a better hashcode
			return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode();
		}

		/// <summary>
		/// Gets a human-readable version of the vertex.
		/// </summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			return "(" + X + ", " + Y + ", " + Z + ")";
		}

		/// <summary>
		/// An implementation of <see cref="IEqualityComparer{T}"/> of <see cref="PolyVertex"/> that allows for the
		/// Y coordinates of two vertices to be within a specified range and still be considered equal.
		/// </summary>
		internal class RoughYEqualityComparer : IEqualityComparer<PolyVertex>
		{
			private const int HashConstX = unchecked((int)0x8da6b343);
			private const int HashConstZ = unchecked((int)0xcb1ab31f);

			private int epsilonY;

			/// <summary>
			/// Initializes a new instance of the <see cref="RoughYEqualityComparer"/> class.
			/// </summary>
			/// <param name="epsilonY">The range of Y values in which two vertices are considered equal.</param>
			public RoughYEqualityComparer(int epsilonY)
			{
				this.epsilonY = epsilonY;
			}

			/// <summary>
			/// Compares two vertices for equality.
			/// </summary>
			/// <param name="left">A vertex.</param>
			/// <param name="right">Another vertex.</param>
			/// <returns>A value indicating whether the two vertices are equal.</returns>
			public bool Equals(PolyVertex left, PolyVertex right)
			{
				return left.X == right.X && (Math.Abs(left.Y - right.Y) <= epsilonY) && left.Z == right.Z;
			}

			/// <summary>
			/// Gets a unique hash code for the contents of a <see cref="PolyVertex"/> instance.
			/// </summary>
			/// <param name="obj">A vertex.</param>
			/// <returns>A hash code.</returns>
			public int GetHashCode(PolyVertex obj)
			{
				return HashConstX * obj.X + HashConstZ * obj.Z;
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Region.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

namespace SharpNav
{
	/// <summary>
	/// Flags that can be applied to a region.
	/// </summary>
	[Flags]
	public enum RegionFlags
	{
		/// <summary>
		/// The border flag
		/// </summary>
		Border = 0x20000000,

		/// <summary>
		/// The vertex border flag
		/// </summary>
		VertexBorder = 0x40000000,

		/// <summary>
		/// The area border flag
		/// </summary>
		AreaBorder = unchecked((int)0x80000000)
	}

	/// <summary>
	/// A <see cref="RegionId"/> is an identifier with flags marking borders.
	/// </summary>
	[Serializable]
	public struct RegionId : IEquatable<RegionId>, IEquatable<int>
	{
		/// <summary>
		/// A null region is one with an ID of 0.
		/// </summary>
		public static readonly RegionId Null = new RegionId(0, 0);

		/// <summary>
		/// A bitmask 
		/// </summary>
		public const int MaskId = 0x1fffffff;

		/// <summary>
		/// The internal storage of a <see cref="RegionId"/>. The <see cref="RegionFlags"/> portion are the most
		/// significant bits, the integer identifier are the least significant bits, marked by <see cref="MaskId"/>.
		/// </summary>
		private int bits;

		/// <summary>
		/// Initializes a new instance of the <see cref="RegionId"/> struct without any flags.
		/// </summary>
		/// <param name="id">The identifier.</param>
		public RegionId(int id)
			: this(id, 0)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="RegionId"/> struct.
		/// </summary>
		/// <param name="id"></param>
		/// <param name="flags"></param>
		public RegionId(int id, RegionFlags flags)
		{
			int masked = id & MaskId;

			if (masked != id)
				throw new ArgumentOutOfRangeException("id", "The provided id is outside of the valid range. The 3 most significant bits must be 0. Maybe you wanted RegionId.FromRawBits()?");

			if ((RegionFlags)((int)flags & ~MaskId) != flags)
				throw new ArgumentException("flags", "The provide region flags are invalid.");

			bits = masked | (int)flags;
		}

		/// <summary>
		/// Gets the ID of the region without any flags.
		/// </summary>
		public int Id
		{
			get
			{
				return bits & MaskId;
			}
		}

		/// <summary>
		/// Gets the flags set for this region.
		/// </summary>
		public RegionFlags Flags
		{
			get
			{
				return (RegionFlags)(bits & ~MaskId);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the region is the null region (ID == 0).
		/// </summary>
		public bool IsNull
		{
			get
			{
				return (bits & MaskId) == 0;
			}
		}

		/// <summary>
		/// Creates a new <see cref="RegionId"/> from a value that contains both the region ID and the flags.
		/// </summary>
		/// <param name="bits">The int containing <see cref="RegionId"/> data.</param>
		/// <returns>A new instance of the <see cref="RegionId"/> struct with the specified data.</returns>
		public static RegionId FromRawBits(int bits)
		{
			RegionId id;
			id.bits = bits;
			return id;
		}

		/// <summary>
		/// Creates a new <see cref="RegionId"/> with extra flags.
		/// </summary>
		/// <param name="region">The region to add flags to.</param>
		/// <param name="flags">The flags to add.</param>
		/// <returns>A new instance of the <see cref="RegionId"/> struct with extra flags.</returns>
		public static RegionId WithFlags(RegionId region, RegionFlags flags)
		{
			if ((RegionFlags)((int)flags & ~MaskId) != flags)
				throw new ArgumentException("flags", "The provide region flags are invalid.");

			RegionFlags newFlags = region.Flags | flags;
			return RegionId.FromRawBits((region.bits & MaskId) | (int)newFlags);
		}

		/// <summary>
		/// Creates a new instance of the <see cref="RegionId"/> class without any flags set.
		/// </summary>
		/// <param name="region">The region to use.</param>
		/// <returns>A new instance of the <see cref="RegionId"/> struct without any flags set.</returns>
		public static RegionId WithoutFlags(RegionId region)
		{
			return new RegionId(region.Id);
		}

		/// <summary>
		/// Creates a new instance of the <see cref="RegionId"/> class without certain flags set.
		/// </summary>
		/// <param name="region">The region to use.</param>
		/// <param name="flags">The flags to unset.</param>
		/// <returns>A new instnace of the <see cref="RegionId"/> struct without certain flags set.</returns>
		public static RegionId WithoutFlags(RegionId region, RegionFlags flags)
		{
			if ((RegionFlags)((int)flags & ~MaskId) != flags)
				throw new ArgumentException("flags", "The provide region flags are invalid.");

			RegionFlags newFlags = region.Flags & ~flags;
			return RegionId.FromRawBits((region.bits & MaskId) | (int)newFlags);
		}

		/// <summary>
		/// Checks if a region has certain flags.
		/// </summary>
		/// <param name="region">The region to check.</param>
		/// <param name="flags">The flags to check.</param>
		/// <returns>A value indicating whether the region has all of the specified flags.</returns>
		public static bool HasFlags(RegionId region, RegionFlags flags)
		{
			return (region.Flags & flags) != 0;
		}

		/// <summary>
		/// Compares an instance of <see cref="RegionId"/> with an integer for equality.
		/// </summary>
		/// <remarks>
		/// This checks for both the ID and flags set on the region. If you want to only compare the IDs, use the
		/// following code:
		/// <code>
		/// RegionId left = ...;
		/// int right = ...;
		/// if (left.Id == right)
		/// {
		///    // ...
		/// }
		/// </code>
		/// </remarks>
		/// <param name="left">An instance of <see cref="RegionId"/>.</param>
		/// <param name="right">An integer.</param>
		/// <returns>A value indicating whether the two values are equal.</returns>
		public static bool operator ==(RegionId left, int right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares an instance of <see cref="RegionId"/> with an integer for inequality.
		/// </summary>
		/// <remarks>
		/// This checks for both the ID and flags set on the region. If you want to only compare the IDs, use the
		/// following code:
		/// <code>
		/// RegionId left = ...;
		/// int right = ...;
		/// if (left.Id != right)
		/// {
		///    // ...
		/// }
		/// </code>
		/// </remarks>
		/// <param name="left">An instance of <see cref="RegionId"/>.</param>
		/// <param name="right">An integer.</param>
		/// <returns>A value indicating whether the two values are unequal.</returns>
		public static bool operator !=(RegionId left, int right)
		{
			return !(left == right);
		}

		/// <summary>
		/// Compares two instances of <see cref="RegionId"/> for equality.
		/// </summary>
		/// <remarks>
		/// This checks for both the ID and flags set on the regions. If you want to only compare the IDs, use the
		/// following code:
		/// <code>
		/// RegionId left = ...;
		/// RegionId right = ...;
		/// if (left.Id == right.Id)
		/// {
		///    // ...
		/// }
		/// </code>
		/// </remarks>
		/// <param name="left">An instance of <see cref="RegionId"/>.</param>
		/// <param name="right">Another instance of <see cref="RegionId"/>.</param>
		/// <returns>A value indicating whether the two instances are equal.</returns>
		public static bool operator ==(RegionId left, RegionId right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two instances of <see cref="RegionId"/> for inequality.
		/// </summary>
		/// <remarks>
		/// This checks for both the ID and flags set on the regions. If you want to only compare the IDs, use the
		/// following code:
		/// <code>
		/// RegionId left = ...;
		/// RegionId right = ...;
		/// if (left.Id != right.Id)
		/// {
		///    // ...
		/// }
		/// </code>
		/// </remarks>
		/// <param name="left">An instance of <see cref="RegionId"/>.</param>
		/// <param name="right">Another instance of <see cref="RegionId"/>.</param>
		/// <returns>A value indicating whether the two instances are unequal.</returns>
		public static bool operator !=(RegionId left, RegionId right)
		{
			return !(left == right);
		}

		/// <summary>
		/// Converts an instance of <see cref="RegionId"/> to an integer containing both the ID and the flags.
		/// </summary>
		/// <param name="id">An instance of <see cref="RegionId"/>.</param>
		/// <returns>An integer.</returns>
		public static explicit operator int(RegionId id)
		{
			return id.bits;
		}

		/// <summary>
		/// Compares this instance with another instance of <see cref="RegionId"/> for equality, including flags.
		/// </summary>
		/// <param name="other">An instance of <see cref="RegionId"/>.</param>
		/// <returns>A value indicating whether the two instances are equal.</returns>
		public bool Equals(RegionId other)
		{
			bool thisNull = this.IsNull;
			bool otherNull = other.IsNull;

			if (thisNull && otherNull)
				return true;
			else if (thisNull ^ otherNull)
				return false;
			else
				return this.bits == other.bits;
		}

		/// <summary>
		/// Compares this instance with another an intenger for equality, including flags.
		/// </summary>
		/// <param name="other">An integer.</param>
		/// <returns>A value indicating whether the two instances are equal.</returns>
		public bool Equals(int other)
		{
			RegionId otherId;
			otherId.bits = other;

			return this.Equals(otherId);
		}

		/// <summary>
		/// Compares this instance with an object for equality.
		/// </summary>
		/// <param name="obj">An object</param>
		/// <returns>A value indicating whether the two instances are equal.</returns>
		public override bool Equals(object obj)
		{
			var regObj = obj as RegionId?;
			var intObj = obj as int?;

			if (regObj.HasValue)
				return this.Equals(regObj.Value);
			else if (intObj.HasValue)
				return this.Equals(intObj.Value);
			else
				return false;
		}

		/// <summary>
		/// Gets a unique hash code for this instance.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			if (IsNull)
				return 0;

			return bits.GetHashCode();
		}

		/// <summary>
		/// Gets a human-readable version of this instance.
		/// </summary>
		/// <returns>A string representing this instance.</returns>
		public override string ToString()
		{
			return "{ Id: " + Id + ", Flags: " + Flags + "}";
		}
	}

	/// <summary>
	/// A Region contains a group of adjacent spans.
	/// </summary>
	public class Region
	{
		private int spanCount;
		private RegionId id;
		private Area areaType;
		private bool remap;
		private bool visited;
		private List<RegionId> connections;
		private List<RegionId> floors;

		/// <summary>
		/// Initializes a new instance of the <see cref="Region" /> class.
		/// </summary>
		/// <param name="idNum">The id</param>
		public Region(int idNum)
		{
			spanCount = 0;
			id = new RegionId(idNum);
			areaType = 0;
			remap = false;
			visited = false;

			connections = new List<RegionId>();
			floors = new List<RegionId>();
		}

		/// <summary>
		/// Gets or sets the number of spans
		/// </summary>
		public int SpanCount
		{
			get
			{
				return spanCount;
			}

			set
			{
				this.spanCount = value;
			}
		}

		/// <summary>
		/// Gets or sets the region id 
		/// </summary>
		public RegionId Id 
		{
			get
			{
				return id;
			}

			set
			{
				this.id = value;
			}
		}

		/// <summary>
		/// Gets or sets the AreaType of this region
		/// </summary>
		public Area AreaType
		{
			get
			{
				return areaType;
			}

			set
			{
				this.areaType = value;
			}
		}

		/// <summary>
		/// Gets or sets a value indicating whether this region has been remapped or not
		/// </summary>
		public bool Remap 
		{
			get
			{
				return remap;
			}

			set
			{
				this.remap = value;
			}
		}

		/// <summary>
		/// Gets or sets a value indicating whether this region has been visited or not
		/// </summary>
		public bool Visited
		{
			get
			{
				return visited;
			}

			set
			{
				this.visited = value;
			}
		}

		/// <summary>
		/// Gets the list of floor regions
		/// </summary>
		public List<RegionId> FloorRegions
		{
			get
			{
				return floors;
			}
		}

		/// <summary>
		/// Gets the list of connected regions
		/// </summary>
		public List<RegionId> Connections
		{
			get
			{
				return connections;
			}
		}

		/// <summary>
		/// Gets a value indicating whether the region is a border region.
		/// </summary>
		public bool IsBorder
		{
			get
			{
				return RegionId.HasFlags(id, RegionFlags.Border);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the region is either a border region or the null region.
		/// </summary>
		public bool IsBorderOrNull
		{
			get
			{
				return id.IsNull || IsBorder;
			}
		}

		/// <summary>
		/// Remove adjacent connections if there is a duplicate
		/// </summary>
		public void RemoveAdjacentNeighbours()
		{
			if (connections.Count <= 1)
				return;

			// Remove adjacent duplicates.
			for (int i = 0; i < connections.Count; i++)
			{
				//get the next i
				int ni = (i + 1) % connections.Count;

				//remove duplicate if found
				if (connections[i] == connections[ni])
				{
					connections.RemoveAt(i);
					i--;
				}
			}
		}

		/// <summary>
		/// Replace all connection and floor values 
		/// </summary>
		/// <param name="oldId">The value you want to replace</param>
		/// <param name="newId">The new value that will be used</param>
		public void ReplaceNeighbour(RegionId oldId, RegionId newId)
		{
			//replace the connections
			bool neiChanged = false;
			for (int i = 0; i < connections.Count; ++i)
			{
				if (connections[i] == oldId)
				{
					connections[i] = newId;
					neiChanged = true;
				}
			}

			//replace the floors
			for (int i = 0; i < floors.Count; ++i)
			{
				if (floors[i] == oldId)
					floors[i] = newId;
			}

			//make sure to remove adjacent neighbors
			if (neiChanged)
				RemoveAdjacentNeighbours();
		}

		/// <summary>
		/// Determine whether this region can merge with another region.
		/// </summary>
		/// <param name="otherRegion">The other region to merge with</param>
		/// <returns>True if the two regions can be merged, false if otherwise</returns>
		public bool CanMergeWith(Region otherRegion)
		{
			//make sure areas are the same
			if (areaType != otherRegion.areaType)
				return false;
			
			//count the number of connections to the other region
			int n = 0;
			for (int i = 0; i < connections.Count; i++)
			{
				if (connections[i] == otherRegion.id)
						n++;
			}
		
			//make sure there's only one connection
			if (n > 1)
				return false;
		
			//make sure floors are separate
			if (floors.Contains(otherRegion.id))
				return false;

			return true;
		}

		/// <summary>
		/// Only add a floor if it hasn't been added already
		/// </summary>
		/// <param name="n">The value of the floor</param>
		public void AddUniqueFloorRegion(RegionId n)
		{
			if (!floors.Contains(n))
				floors.Add(n);
		}

		/// <summary>
		/// Merge two regions into one. Needs good testing
		/// </summary>
		/// <param name="otherRegion">The region to merge with</param>
		/// <returns>True if merged successfully, false if otherwise</returns>
		public bool MergeWithRegion(Region otherRegion)
		{
			RegionId thisId = id;
			RegionId otherId = otherRegion.id;

			// Duplicate current neighbourhood.
			List<RegionId> thisConnected = new List<RegionId>();
			for (int i = 0; i < connections.Count; ++i)
				thisConnected.Add(connections[i]);
			List<RegionId> otherConnected = otherRegion.connections;

			// Find insertion point on this region
			int insertInThis = -1;
			for (int i = 0; i < thisConnected.Count; ++i)
			{
				if (thisConnected[i] == otherId)
				{
					insertInThis = i;
					break;
				}
			}

			if (insertInThis == -1)
				return false;

			// Find insertion point on the other region
			int insertInOther = -1;
			for (int i = 0; i < otherConnected.Count; ++i)
			{
				if (otherConnected[i] == thisId)
				{
					insertInOther = i;
					break;
				}
			}

			if (insertInOther == -1)
				return false;

			// Merge neighbours.
			connections = new List<RegionId>();
			for (int i = 0, ni = thisConnected.Count; i < ni - 1; ++i)
				connections.Add(thisConnected[(insertInThis + 1 + i) % ni]);

			for (int i = 0, ni = otherConnected.Count; i < ni - 1; ++i)
				connections.Add(otherConnected[(insertInOther + 1 + i) % ni]);

			RemoveAdjacentNeighbours();

			for (int j = 0; j < otherRegion.floors.Count; ++j)
				AddUniqueFloorRegion(otherRegion.floors[j]);
			spanCount += otherRegion.spanCount;
			otherRegion.spanCount = 0;
			otherRegion.connections.Clear();

			return true;
		}

		/// <summary>
		/// Test if region is connected to a border
		/// </summary>
		/// <returns>True if connected, false if not</returns>
		public bool IsConnectedToBorder()
		{
			// Region is connected to border if
			// one of the neighbours is null id.
			for (int i = 0; i < connections.Count; ++i)
			{
				if (connections[i] == 0)
					return true;
			}

			return false;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Span.cs:
 // Copyright (c) 2013-2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System.Runtime.InteropServices;

namespace SharpNav
{
	/// <summary>
	/// A span is a range of integers which represents a range of voxels in a <see cref="Cell"/>.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct Span
	{
		/// <summary>
		/// The lowest value in the span.
		/// </summary>
		public int Minimum;

		/// <summary>
		/// The highest value in the span.
		/// </summary>
		public int Maximum;

		/// <summary>
		/// The span area id
		/// </summary>
		public Area Area;

		/// <summary>
		/// Initializes a new instance of the <see cref="Span"/> struct.
		/// </summary>
		/// <param name="min">The lowest value in the span.</param>
		/// <param name="max">The highest value in the span.</param>
		public Span(int min, int max)
		{
			Minimum = min;
			Maximum = max;
			Area = Area.Null;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="Span"/> struct.
		/// </summary>
		/// <param name="min">The lowest value in the span.</param>
		/// <param name="max">The highest value in the span.</param>
		/// <param name="area">The area flags for the span.</param>
		public Span(int min, int max, Area area)
		{
			Minimum = min;
			Maximum = max;
			Area = area;
		}

		/// <summary>
		/// Gets the height of the span.
		/// </summary>
		public int Height
		{
			get
			{
				return Maximum - Minimum;
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\SpanReference.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System.Runtime.InteropServices;

namespace SharpNav
{
	/// <summary>
	/// References a <see cref="Span"/> within a <see cref="Heightfield"/>.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct SpanReference
	{
		private int x;
		private int y;
		private int index;

		/// <summary>
		/// Initializes a new instance of the <see cref="SpanReference"/> struct.
		/// </summary>
		/// <param name="x">The X coordinate of the <see cref="Cell"/> the <see cref="Span"/> is contained in.</param>
		/// <param name="y">The Y coordinate of the <see cref="Cell"/> the <see cref="Span"/> is contained in.</param>
		/// <param name="i">The index of the <see cref="Span"/> within the specified <see cref="Cell"/>.</param>
		public SpanReference(int x, int y, int i)
		{
			this.x = x;
			this.y = y;
			this.index = i;
		}

		/// <summary>
		/// Gets the X coordinate of the <see cref="Cell"/> that contains the referenced <see cref="Span"/>.
		/// </summary>
		public int X
		{
			get
			{
				return x;
			}
		}

		/// <summary>
		/// Gets the Y coordinate of the <see cref="Cell"/> that contains the referenced <see cref="Span"/>.
		/// </summary>
		public int Y
		{
			get
			{
				return y;
			}
		}

		/// <summary>
		/// Gets the index of the <see cref="Span"/> within the <see cref="Cell"/> it is contained in.
		/// </summary>
		public int Index
		{
			get
			{
				return index;
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\TiledNavMesh.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

using SharpNav.Collections;
using SharpNav.Geometry;
using SharpNav.Pathfinding;

#if MONOGAME
using Vector2 = Microsoft.Xna.Framework.Vector2;
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector2 = OpenTK.Vector2;
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector2 = SharpDX.Vector2;
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav
{
	/// <summary>
	/// A TiledNavMesh is a continuous region, which is used for pathfinding. 
	/// </summary>
	public class TiledNavMesh
	{
		/// <summary>
		/// The settings for the TiledNavMesh
		/// </summary>
		public struct TiledNavMeshParams
		{
			public Vector3 Origin;
			public float TileWidth;
			public float TileHeight;
			public int MaxTiles;
			public int MaxPolys;
		}

		private TiledNavMeshParams parameters;
		private Vector3 origin;
		private float tileWidth, tileHeight;
		private int maxTiles;
		private int tileLookupTableSize; //tile hash lookup size
		private int tileLookupTableMask; //tile hash lookup mask

		private MeshTile[] posLookup; //tile hash lookup
		private MeshTile nextFree; //freelist of tiles
		private MeshTile[] tiles; //list of tiles

		private int saltBits; //number of salt bits in ID
		private int tileBits; //number of tile bits in ID
		private int polyBits; //number of poly bits in ID

		/// <summary>
		/// Initializes a new instance of the <see cref="TiledNavMesh"/> class.
		/// </summary>
		/// <param name="data">The Navigation Mesh data</param>
		public TiledNavMesh(NavMeshBuilder data)
		{
			TiledNavMeshParams parameters;
			parameters.Origin = data.Header.Bounds.Min;
			parameters.TileWidth = data.Header.Bounds.Max.X - data.Header.Bounds.Min.X;
			parameters.TileHeight = data.Header.Bounds.Max.Z - data.Header.Bounds.Min.Z;
			parameters.MaxTiles = 1;
			parameters.MaxPolys = data.Header.PolyCount;

			if (!InitTileNavMesh(parameters))
				return;

			int tileRef = 0;
			AddTile(data, 0, ref tileRef);
		}

		/// <summary>
		/// Gets the maximum number of tiles that can be stored
		/// </summary>
		public int TileCount
		{
			get
			{
				return maxTiles;
			}
		}

		/// <summary>
		/// Gets the mesh tile at a specified index.
		/// </summary>
		/// <param name="index">The index referencing a tile.</param>
		/// <returns>The tile at the index.</returns>
		public MeshTile this[int index]
		{
			get
			{
				return tiles[index];
			}
		}

		/// <summary>
		/// Gets or sets user data for this navmesh.
		/// </summary>
		public object Tag { get; set; }

		/// <summary>
		/// Initialize the Tiled Navigation Mesh variables and arrays.
		/// </summary>
		/// <param name="parameters">Tiled Navigation Mesh attributes</param>
		/// <returns>True if initialization is successful</returns>
		public bool InitTileNavMesh(TiledNavMeshParams parameters)
		{
			this.parameters = parameters;
			origin = this.parameters.Origin;
			tileWidth = parameters.TileWidth;
			tileHeight = parameters.TileHeight;

			//init tiles
			maxTiles = parameters.MaxTiles;
			tileLookupTableSize = MathHelper.NextPowerOfTwo(parameters.MaxTiles / 4);
			if (tileLookupTableSize == 0)
				tileLookupTableSize = 1;
			tileLookupTableMask = tileLookupTableSize - 1;

			tiles = new MeshTile[maxTiles];
			posLookup = new MeshTile[tileLookupTableSize];
			for (int i = 0; i < tiles.Length; i++)
				tiles[i] = new MeshTile();
			for (int i = 0; i < posLookup.Length; i++)
				posLookup[i] = null;

			//create a linked list of tiles
			nextFree = null;
			for (int i = maxTiles - 1; i >= 0; i--)
			{
				tiles[i].Salt = 1;
				tiles[i].Next = nextFree;
				nextFree = tiles[i];
			}
			
			//init ID generator values
			tileBits = MathHelper.Log2(MathHelper.NextPowerOfTwo(parameters.MaxTiles));
			polyBits = MathHelper.Log2(MathHelper.NextPowerOfTwo(parameters.MaxPolys));

			//only allow 31 salt bits, since salt mask is calculated using 32-bit int and it will overflow
			saltBits = Math.Min(31, 32 - tileBits - polyBits);
			if (saltBits < 10)
				return false;

			return true;
		}

		/// <summary>
		/// Build a tile and link all the polygons togther, both internally and externally.
		/// Make sure to link off-mesh connections as well.
		/// </summary>
		/// <param name="data">Navigation Mesh data</param>
		/// <param name="lastRef">Last polygon reference</param>
		/// <param name="result">Last tile reference</param>
		public void AddTile(NavMeshBuilder data, int lastRef, ref int result)
		{
			//make sure data is in right format
			PathfindingCommon.NavMeshInfo header = data.Header;

			//make sure location is free
			if (GetTileAt(header.X, header.Y, header.Layer) != null)
				return;

			//allocate a tile
			MeshTile tile = null;
			if (lastRef == 0)
			{
				if (nextFree != null)
				{
					tile = nextFree;
					nextFree = tile.Next;
					tile.Next = null;
				}
			}
			else
			{
				//try to relocate tile to specific index with the same salt
				int tileIndex = DecodePolyIdTile(lastRef);
				if (tileIndex >= maxTiles)
					return;

				//try to find specific tile id from free list
				MeshTile target = tiles[tileIndex];
				MeshTile prev = null;
				tile = nextFree;
				while (tile != null && tile != target)
				{
					prev = tile;
					tile = tile.Next;
				}

				//couldn't find correct location
				if (tile != target)
					return;

				//remove from freelist
				if (prev == null)
					nextFree = tile.Next;
				else
					prev.Next = tile.Next;

				//restore salt
				tile.Salt = DecodePolyIdSalt(lastRef);
			}

			//make sure we could allocate a tile
			if (tile == null)
				return;

			//insert tile into position LookUp Table (lut)
			int h = ComputeTileHash(header.X, header.Y, tileLookupTableMask);
			tile.Next = posLookup[h];
			posLookup[h] = tile;

			if (header.BvNodeCount == 0)
				tile.BVTree = null;

			//patch header
			tile.Verts = data.NavVerts;
			tile.Polys = data.NavPolys;
			tile.DetailMeshes = data.NavDMeshes;
			tile.DetailVerts = data.NavDVerts;
			tile.DetailTris = data.NavDTris;
			tile.BVTree = data.NavBvTree;
			tile.OffMeshConnections = data.OffMeshCons;

			//build links freelist
			tile.LinksFreeList = 0;
			tile.Links = new Link[header.MaxLinkCount];
			for (int i = 0; i < header.MaxLinkCount; i++)
				tile.Links[i] = new Link();

			tile.Links[header.MaxLinkCount - 1].Next = Link.Null;
			for (int i = 0; i < header.MaxLinkCount - 1; i++)
				tile.Links[i].Next = i + 1;

			//init tile
			tile.Header = header;
			tile.Data = data;

			ConnectIntLinks(ref tile);
			BaseOffMeshLinks(ref tile);

			//create connections with neighbor tiles
			MeshTile[] neis = new MeshTile[32];
			int nneis;

			//connect with layers in current tile
			nneis = GetTilesAt(header.X, header.Y, neis);
			for (int j = 0; j < nneis; j++)
			{
				if (neis[j] != tile)
				{
					ConnectExtLinks(ref tile, ref neis[j], BoundarySide.Internal);
					ConnectExtLinks(ref neis[j], ref tile, BoundarySide.Internal);
				}

				ConnectExtOffMeshLinks(ref tile, ref neis[j], BoundarySide.Internal);
				ConnectExtOffMeshLinks(ref neis[j], ref tile, BoundarySide.Internal);
			}

			//connect with neighbour tiles
			for (int i = 0; i < 8; i++)
			{
				BoundarySide b = (BoundarySide)i;
				BoundarySide bo = b.GetOpposite();
				nneis = GetNeighbourTilesAt(header.X, header.Y, b, neis);
				for (int j = 0; j < nneis; j++)
				{
					ConnectExtLinks(ref tile, ref neis[j], b);
					ConnectExtLinks(ref neis[j], ref tile, bo);
					ConnectExtOffMeshLinks(ref tile, ref neis[j], b);
					ConnectExtOffMeshLinks(ref neis[j], ref tile, bo);
				}
			}

			result = GetTileRef(tile);
		}

		/// <summary>
		/// Allocate links for each of the tile's polygons' vertices
		/// </summary>
		/// <param name="tile">A tile contains a set of polygons, which are linked to each other</param>
		public void ConnectIntLinks(ref MeshTile tile)
		{
			if (tile == null)
				return;

			int polyBase = GetPolyRefBase(tile);

			//Iterate through all the polygons
			for (int i = 0; i < tile.Header.PolyCount; i++)
			{
				//The polygon links will end in a null link
				tile.Polys[i].FirstLink = Link.Null;

				//Avoid Off-Mesh Connection polygons
				if (tile.Polys[i].PolyType == PolygonType.OffMeshConnection)
					continue;

				//Build edge links
				for (int j = tile.Polys[i].VertCount - 1; j >= 0; j--)
				{
					//Skip hard and non-internal edges
					if (tile.Polys[i].Neis[j] == 0 || IsExternalLink(tile.Polys[i].Neis[j]))
						continue;

					//Allocate a new link if possible
					int idx = AllocLink(tile);

					//Allocation of link should be successful
					if (IsLinkAllocated(idx))
					{
						//Initialize a new link
						tile.Links[idx].Reference = GetReference(polyBase, tile.Polys[i].Neis[j] - 1);
						tile.Links[idx].Edge = j;
						tile.Links[idx].Side = BoundarySide.Internal;
						tile.Links[idx].BMin = tile.Links[idx].BMax = 0;

						//Add to polygon's links list
						tile.Links[idx].Next = tile.Polys[i].FirstLink;
						tile.Polys[i].FirstLink = idx;
					}
				}
			}
		}

		/// <summary>
		/// Begin creating off-mesh links between the tile polygons.
		/// </summary>
		/// <param name="tile">Current Tile</param>
		public void BaseOffMeshLinks(ref MeshTile tile)
		{
			if (tile == null)
				return;

			int polyBase = GetPolyRefBase(tile);

			//Base off-mesh connection start points
			for (int i = 0; i < tile.Header.OffMeshConCount; i++)
			{
				int con = i;
				int poly = tile.OffMeshConnections[con].Poly;

				Vector3 extents = new Vector3(tile.OffMeshConnections[con].Radius, tile.Header.WalkableClimb, tile.OffMeshConnections[con].Radius);
				
				//Find polygon to connect to
				Vector3 p = tile.OffMeshConnections[con].Pos0;
				Vector3 nearestPt = new Vector3();
				int reference = FindNearestPolyInTile(tile, p, extents, ref nearestPt);
				if (reference == 0)
					continue;

				//Do extra checks
				if ((nearestPt.X - p.X) * (nearestPt.X - p.X) + (nearestPt.Z - p.Z) * (nearestPt.Z - p.Z) >
					tile.OffMeshConnections[con].Radius * tile.OffMeshConnections[con].Radius)
					continue;

				//Make sure location is on current mesh
				tile.Verts[tile.Polys[poly].Verts[0]] = nearestPt;

				//Link off-mesh connection to target poly
				int idx = AllocLink(tile);
				if (IsLinkAllocated(idx))
				{
					//Initialize a new link
					tile.Links[idx].Reference = reference;
					tile.Links[idx].Edge = 0;
					tile.Links[idx].Side = BoundarySide.Internal;
					tile.Links[idx].BMin = tile.Links[idx].BMax = 0;

					//Add to polygon's links list
					tile.Links[idx].Next = tile.Polys[poly].FirstLink;
					tile.Polys[poly].FirstLink = idx;
				}

				//Start end-point always conects back to off-mesh connection
				int tidx = AllocLink(tile);
				if (IsLinkAllocated(tidx))
				{
					//Initialize a new link
					int landPolyIdx = DecodePolyIdPoly(reference);
					tile.Links[idx].Reference = GetReference(polyBase, tile.OffMeshConnections[con].Poly);
					tile.Links[idx].Edge = 0xff;
					tile.Links[idx].Side = BoundarySide.Internal;
					tile.Links[idx].BMin = tile.Links[idx].BMax = 0;

					//Add to polygon's links list
					tile.Links[idx].Next = tile.Polys[landPolyIdx].FirstLink;
					tile.Polys[landPolyIdx].FirstLink = tidx;
				}
			}
		}

		/// <summary>
		/// Connect polygons from two different tiles.
		/// </summary>
		/// <param name="tile">Current Tile</param>
		/// <param name="target">Target Tile</param>
		/// <param name="side">Polygon edge</param>
		public void ConnectExtLinks(ref MeshTile tile, ref MeshTile target, BoundarySide side)
		{
			if (tile == null)
				return;

			//Connect border links
			for (int i = 0; i < tile.Header.PolyCount; i++)
			{
				int numPolyVerts = tile.Polys[i].VertCount;

				for (int j = 0; j < numPolyVerts; j++)
				{
					//Skip non-portal edges
					if ((tile.Polys[i].Neis[j] & Link.External) == 0)
						continue;

					BoundarySide dir = (BoundarySide)(tile.Polys[i].Neis[j] & 0xff);
					if (side != BoundarySide.Internal && dir != side)
						continue;

					//Create new links
					Vector3 va = tile.Verts[tile.Polys[i].Verts[j]];
					Vector3 vb = tile.Verts[tile.Polys[i].Verts[(j + 1) % numPolyVerts]];
					List<int> nei = new List<int>(4);
					List<float> neia = new List<float>(4 * 2);
					FindConnectingPolys(va, vb, target, dir.GetOpposite(), nei, neia);

					//Iterate through neighbors
					for (int k = 0; k < nei.Count; k++)
					{
						//Allocate a new link if possible
						int idx = AllocLink(tile);

						if (IsLinkAllocated(idx))
						{
							tile.Links[idx].Reference = nei[k];
							tile.Links[idx].Edge = j;
							tile.Links[idx].Side = dir;

							tile.Links[idx].Next = tile.Polys[i].FirstLink;
							tile.Polys[i].FirstLink = idx;

							//Compress portal limits to a value
							if (dir == BoundarySide.PlusX || dir == BoundarySide.MinusX)
							{
								float tmin = (neia[k * 2 + 0] - va.Z) / (vb.Z - va.Z);
								float tmax = (neia[k * 2 + 1] - va.Z) / (vb.Z - va.Z);

								if (tmin > tmax)
								{
									float temp = tmin;
									tmin = tmax;
									tmax = temp;
								}

								tile.Links[idx].BMin = (int)(MathHelper.Clamp(tmin, 0.0f, 1.0f) * 255.0f);
								tile.Links[idx].BMax = (int)(MathHelper.Clamp(tmax, 0.0f, 1.0f) * 255.0f);
							}
							else if (dir == BoundarySide.PlusZ || dir == BoundarySide.MinusZ)
							{
								float tmin = (neia[k * 2 + 0] - va.X) / (vb.X - va.X);
								float tmax = (neia[k * 2 + 1] - va.X) / (vb.X - va.X);

								if (tmin > tmax)
								{
									float temp = tmin;
									tmin = tmax;
									tmax = temp;
								}

								tile.Links[idx].BMin = (int)(MathHelper.Clamp(tmin, 0.0f, 1.0f) * 255.0f);
								tile.Links[idx].BMax = (int)(MathHelper.Clamp(tmax, 0.0f, 1.0f) * 255.0f);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Connect Off-Mesh links between polygons from two different tiles.
		/// </summary>
		/// <param name="tile">Current Tile</param>
		/// <param name="target">Target Tile</param>
		/// <param name="side">Polygon edge</param>
		public void ConnectExtOffMeshLinks(ref MeshTile tile, ref MeshTile target, BoundarySide side)
		{
			if (tile == null)
				return;

			//Connect off-mesh links, specifically links which land from target tile to this tile
			BoundarySide oppositeSide = side.GetOpposite();

			//Iterate through all the off-mesh connections of target tile
			for (int i = 0; i < target.Header.OffMeshConCount; i++)
			{
				OffMeshConnection targetCon = target.OffMeshConnections[i];
				if (targetCon.Side != oppositeSide)
					continue;

				Poly targetPoly = target.Polys[targetCon.Poly];

				//Skip off-mesh connections which start location could not be connected at all
				if (!IsLinkAllocated(targetPoly.FirstLink))
					continue;

				Vector3 extents = new Vector3(targetCon.Radius, target.Header.WalkableClimb, targetCon.Radius);

				//Find polygon to connect to
				Vector3 p = targetCon.Pos1;
				Vector3 nearestPt = new Vector3();
				int reference = FindNearestPolyInTile(tile, p, extents, ref nearestPt);
				if (reference == 0)
					continue;

				//Further checks
				if ((nearestPt.X - p.X) * (nearestPt.X - p.X) + (nearestPt.Z - p.Z) * (nearestPt.Z - p.Z) >
					(targetCon.Radius * targetCon.Radius))
					continue;

				//Make sure the location is on the current mesh
				target.Verts[targetPoly.Verts[1]] = nearestPt;

				//Link off-mesh connection to target poly
				int idx = AllocLink(target);
				if (IsLinkAllocated(idx))
				{
					target.Links[idx].Reference = reference;
					target.Links[idx].Edge = i;
					target.Links[idx].Side = oppositeSide;
					target.Links[idx].BMin = target.Links[idx].BMax = 0;

					//add to linked list
					target.Links[idx].Next = target.Polys[i].FirstLink;
					target.Polys[i].FirstLink = idx;
				}

				//link target poly to off-mesh connection
				if ((targetCon.Flags & OffMeshConnectionFlags.Bidirectional) != 0)
				{
					int tidx = AllocLink(tile);
					if (IsLinkAllocated(tidx))
					{
						int landPolyIdx = DecodePolyIdPoly(reference);
						tile.Links[tidx].Reference = GetReference(GetPolyRefBase(target), targetCon.Poly);
						tile.Links[tidx].Edge = 0xff;
						tile.Links[tidx].Side = side;
						tile.Links[tidx].BMin = tile.Links[tidx].BMax = 0;

						//add to linked list
						tile.Links[tidx].Next = tile.Polys[landPolyIdx].FirstLink;
						tile.Polys[landPolyIdx].FirstLink = tidx;
					}
				}
			}
		}

		/// <summary>
		/// Retrieve the endpoints of the offmesh connection at the specified polygon
		/// </summary>
		/// <param name="prevRef">The previous polygon reference</param>
		/// <param name="polyRef">The current polygon reference</param>
		/// <param name="startPos">The starting position</param>
		/// <param name="endPos">The ending position</param>
		/// <returns>True if endpoints found, false if not</returns>
		public bool GetOffMeshConnectionPolyEndPoints(int prevRef, int polyRef, ref Vector3 startPos, ref Vector3 endPos)
		{
			int salt = 0, indexTile = 0, indexPoly = 0;

			if (polyRef == 0)
				return false;

			//get current polygon
			DecodePolyId(polyRef, ref salt, ref indexTile, ref indexPoly);
			if (indexTile >= maxTiles)
				return false;
			if (tiles[indexTile].Salt != salt || tiles[indexTile].Header == null)
				return false;
			MeshTile tile = tiles[indexTile];
			if (indexPoly >= tile.Header.PolyCount)
				return false;
			Poly poly = tile.Polys[indexPoly];

			if (poly.PolyType != PolygonType.OffMeshConnection)
				return false;

			int idx0 = 0, idx1 = 1;

			//find the link that points to the first vertex
			for (int i = poly.FirstLink; i != Link.Null; i = tile.Links[i].Next)
			{
				if (tile.Links[i].Edge == 0)
				{
					if (tile.Links[i].Reference != prevRef)
					{
						idx0 = 1;
						idx1 = 0;
					}

					break;
				}
			}

			startPos = tile.Verts[poly.Verts[idx0]];
			endPos = tile.Verts[poly.Verts[idx1]];

			return true;
		}

		/// <summary>
		/// Search for neighbor polygons in the tile.
		/// </summary>
		/// <param name="va">Vertex A</param>
		/// <param name="vb">Vertex B</param>
		/// <param name="tile">Current tile</param>
		/// <param name="side">Polygon edge</param>
		/// <param name="con">Resulting Connection polygon</param>
		/// <param name="conarea">Resulting Connection area</param>
		public void FindConnectingPolys(Vector3 va, Vector3 vb, MeshTile tile, BoundarySide side, List<int> con, List<float> conarea)
		{
			if (tile == null)
				return;

			Vector2 amin = Vector2.Zero;
			Vector2 amax = Vector2.Zero;
			CalcSlabEndPoints(va, vb, amin, amax, side);
			float apos = GetSlabCoord(va, side);

			//Remove links pointing to 'side' and compact the links array
			Vector2 bmin = Vector2.Zero;
			Vector2 bmax = Vector2.Zero;

			int polyBase = GetPolyRefBase(tile);

			//Iterate through all the tile's polygons
			for (int i = 0; i < tile.Header.PolyCount; i++)
			{
				int numPolyVerts = tile.Polys[i].VertCount;

				//Iterate through all the vertices
				for (int j = 0; j < numPolyVerts; j++)
				{
					//Skip edges which do not point to the right side
					if (tile.Polys[i].Neis[j] != (Link.External | (int)side))
						continue;

					//Grab two adjacent vertices
					Vector3 vc = tile.Verts[tile.Polys[i].Verts[j]];
					Vector3 vd = tile.Verts[tile.Polys[i].Verts[(j + 1) % numPolyVerts]];
					float bpos = GetSlabCoord(vc, side);

					//Segments are not close enough
					if (Math.Abs(apos - bpos) > 0.01f)
						continue;

					//Check if the segments touch
					CalcSlabEndPoints(vc, vd, bmin, bmax, side);

					//Skip if slabs don't overlap
					if (!OverlapSlabs(amin, amax, bmin, bmax, 0.01f, tile.Header.WalkableClimb))
						continue;

					//Add return value
					if (con.Count < con.Capacity)
					{
						conarea.Add(Math.Max(amin.X, bmin.X));
						conarea.Add(Math.Min(amax.X, bmax.X));
						con.Add(GetReference(polyBase, i));
					}

					break;
				}
			}
		}

		/// <summary>
		/// Find the slab endpoints based off of the 'side' value.
		/// </summary>
		/// <param name="va">Vertex A</param>
		/// <param name="vb">Vertex B</param>
		/// <param name="bmin">Minimum bounds</param>
		/// <param name="bmax">Maximum bounds</param>
		/// <param name="side">The side</param>
		public void CalcSlabEndPoints(Vector3 va, Vector3 vb, Vector2 bmin, Vector2 bmax, BoundarySide side)
		{
			if (side == BoundarySide.PlusX || side == BoundarySide.MinusX)
			{
				if (va.Z < vb.Z)
				{
					bmin.X = va.Z;
					bmin.Y = va.Y;
					
					bmax.X = vb.Z;
					bmax.Y = vb.Y;
				}
				else
				{
					bmin.X = vb.Z;
					bmin.Y = vb.Y;
					
					bmax.X = va.Z;
					bmax.Y = va.Y;
				}
			}
			else if (side == BoundarySide.PlusZ || side == BoundarySide.MinusZ)
			{
				if (va.X < vb.X)
				{
					bmin.X = va.X;
					bmin.Y = va.Y;
					
					bmax.X = vb.X;
					bmax.Y = vb.Y;
				}
				else
				{
					bmin.X = vb.X;
					bmin.Y = vb.Y;
					
					bmax.X = va.X;
					bmax.Y = va.Y;
				}
			}
		}

		/// <summary>
		/// Return the proper slab coordinate value depending on the 'side' value.
		/// </summary>
		/// <param name="va">Vertex A</param>
		/// <param name="side">The side</param>
		/// <returns>Slab coordinate value</returns>
		public float GetSlabCoord(Vector3 va, BoundarySide side)
		{
			if (side == BoundarySide.PlusX || side == BoundarySide.MinusX)
				return va.X;
			else if (side == BoundarySide.PlusZ || side == BoundarySide.MinusZ)
				return va.Z;
			
			return 0;
		}

		/// <summary>
		/// Check if two slabs overlap.
		/// </summary>
		/// <param name="amin">Minimum bounds A</param>
		/// <param name="amax">Maximum bounds A</param>
		/// <param name="bmin">Minimum bounds B</param>
		/// <param name="bmax">Maximum bounds B</param>
		/// <param name="px">Point's x</param>
		/// <param name="py">Point's y</param>
		/// <returns>True if slabs overlap</returns>
		public bool OverlapSlabs(Vector2 amin, Vector2 amax, Vector2 bmin, Vector2 bmax, float px, float py)
		{
			//Check for horizontal overlap
			//Segment shrunk a little so that slabs which touch at endpoints aren't connected
			float minX = Math.Max(amin.X + px, bmin.X + px);
			float maxX = Math.Min(amax.X - px, bmax.X - px);
			if (minX > maxX)
				return false;

			//Check vertical overlap
			float leftSlope = (amax.Y - amin.Y) / (amax.X - amin.X);
			float leftConstant = amin.Y - leftSlope * amin.X;
			float rightSlope = (bmax.Y - bmin.Y) / (bmax.X - bmin.X);
			float rightConstant = bmin.Y - rightSlope * bmin.X;
			float leftMinY = leftSlope * minX + leftConstant;
			float leftMaxY = leftSlope * maxX + leftConstant;
			float rightMinY = rightSlope * minX + rightConstant;
			float rightMaxY = rightSlope * maxX + rightConstant;
			float dmin = rightMinY - leftMinY;
			float dmax = rightMaxY - leftMaxY;

			//Crossing segments always overlap
			if (dmin * dmax < 0)
				return true;

			//Check for overlap at endpoints
			float threshold = (py * 2) * (py * 2);
			if (dmin * dmin <= threshold || dmax * dmax <= threshold)
				return true;

			return false;
		}

		/// <summary>
		/// Find the closest polygon possible in the tile under certain constraints.
		/// </summary>
		/// <param name="tile">Current tile</param>
		/// <param name="center">Center starting point</param>
		/// <param name="extents">Range of search</param>
		/// <param name="nearestPt">Resulting nearest point</param>
		/// <returns>Polygon Reference which contains nearest point</returns>
		public int FindNearestPolyInTile(MeshTile tile, Vector3 center, Vector3 extents, ref Vector3 nearestPt)
		{
			BBox3 bounds;
			bounds.Min = center - extents;
			bounds.Max = center + extents;

			//Get nearby polygons from proximity grid
			List<int> polys = new List<int>(128);
			int polyCount = QueryPolygonsInTile(tile, bounds, polys);

			//Find nearest polygon amongst the nearby polygons
			int nearest = 0;
			float nearestDistanceSqr = float.MaxValue;

			//Iterate throuh all the polygons
			for (int i = 0; i < polyCount; i++)
			{
				int reference = polys[i];
				Vector3 closestPtPoly = new Vector3();
				tile.ClosestPointOnPoly(DecodePolyIdPoly(reference), center, ref closestPtPoly);
				float d = (center - closestPtPoly).LengthSquared();
				if (d < nearestDistanceSqr)
				{
					nearestPt = closestPtPoly;
					nearestDistanceSqr = d;
					nearest = reference;
				}
			}

			return nearest;
		}

		/// <summary>
		/// Find all the polygons within a certain bounding box.
		/// </summary>
		/// <param name="tile">Current tile</param>
		/// <param name="qbounds">The bounds</param>
		/// <param name="polys">List of polygons</param>
		/// <returns>Number of polygons found</returns>
		public int QueryPolygonsInTile(MeshTile tile, BBox3 qbounds, List<int> polys)
		{
			if (tile.BVTree.Count != 0)
			{
				int node = 0;
				int end = tile.Header.BvNodeCount;
				Vector3 tbmin = tile.Header.Bounds.Min;
				Vector3 tbmax = tile.Header.Bounds.Max;
				
				//Clamp query box to world box
				Vector3 qbmin = qbounds.Min;
				Vector3 qbmax = qbounds.Max;
				PolyBounds b;
				float bminx = MathHelper.Clamp(qbmin.X, tbmin.X, tbmax.X) - tbmin.X;
				float bminy = MathHelper.Clamp(qbmin.Y, tbmin.Y, tbmax.Y) - tbmin.Y;
				float bminz = MathHelper.Clamp(qbmin.Z, tbmin.Z, tbmax.Z) - tbmin.Z;
				float bmaxx = MathHelper.Clamp(qbmax.X, tbmin.X, tbmax.X) - tbmin.X;
				float bmaxy = MathHelper.Clamp(qbmax.Y, tbmin.Y, tbmax.Y) - tbmin.Y;
				float bmaxz = MathHelper.Clamp(qbmax.Z, tbmin.Z, tbmax.Z) - tbmin.Z;

				const int MinMask = unchecked((int)0xfffffffe);

				b.Min.X = (int)(bminx * tile.Header.BvQuantFactor) & MinMask;
				b.Min.Y = (int)(bminy * tile.Header.BvQuantFactor) & MinMask;
				b.Min.Z = (int)(bminz * tile.Header.BvQuantFactor) & MinMask;
				b.Max.X = (int)(bmaxx * tile.Header.BvQuantFactor + 1) | 1;
				b.Max.Y = (int)(bmaxy * tile.Header.BvQuantFactor + 1) | 1;
				b.Max.Z = (int)(bmaxz * tile.Header.BvQuantFactor + 1) | 1;

				//traverse tree
				int polyBase = GetPolyRefBase(tile);
				
				while (node < end)
				{
					BVTree.Node bvNode = tile.BVTree[node];
					bool overlap = PolyBounds.Overlapping(ref b, ref bvNode.Bounds);
					bool isLeafNode = bvNode.Index >= 0;

					if (isLeafNode && overlap)
					{
						if (polys.Count < polys.Capacity)
							polys.Add(GetReference(polyBase, bvNode.Index));
					}

					if (overlap || isLeafNode)
					{
						node++;
					}
					else
					{
						int escapeIndex = -bvNode.Index;
						node += escapeIndex;
					}
				}

				return polys.Count;
			}
			else
			{
				BBox3 b;
				int polyBase = GetPolyRefBase(tile);

				for (int i = 0; i < tile.Header.PolyCount; i++)
				{
					var poly = tile.Polys[i];

					//don't return off-mesh connection polygons
					if (poly.PolyType == PolygonType.OffMeshConnection)
						continue;

					//calculate polygon bounds
					b.Max = b.Min = tile.Verts[poly.Verts[0]];
					for (int j = 1; j < poly.VertCount; j++)
					{
						Vector3 v = tile.Verts[poly.Verts[j]];
						Vector3Extensions.ComponentMin(ref b.Min, ref v, out b.Min);
						Vector3Extensions.ComponentMax(ref b.Max, ref v, out b.Max);
					}

					if (BBox3.Overlapping(ref qbounds, ref b))
					{
						if (polys.Count < polys.Capacity)
							polys.Add(GetReference(polyBase, i));
					}
				}

				return polys.Count;
			}
		}

		/// <summary>
		/// Allocate a new link if possible.
		/// </summary>
		/// <param name="tile">Current tile</param>
		/// <returns>New link number</returns>
		public int AllocLink(MeshTile tile)
		{
			if (!IsLinkAllocated(tile.LinksFreeList))
				return Link.Null;

			int link = tile.LinksFreeList;
			tile.LinksFreeList = tile.Links[link].Next;
			return link;
		}

		/// <summary>
		/// Get the tile reference
		/// </summary>
		/// <param name="tile">Tile to look for</param>
		/// <returns>Tile reference</returns>
		public int GetTileRef(MeshTile tile)
		{
			if (tile == null)
				return 0;

			int it = 0;
			for (int i = 0; i < tiles.Length; i++)
			{
				if (tiles[i] == tile)
				{
					it = i;
					break;
				}
			}

			return EncodePolyId(tile.Salt, it, 0);
		}

		/// <summary>
		/// Find the tile at a specific location
		/// </summary>
		/// <param name="x">The x-coordinate</param>
		/// <param name="y">The y-coordinate</param>
		/// <param name="layer">The layer number</param>
		/// <returns>The MeshTile at that location</returns>
		public MeshTile GetTileAt(int x, int y, int layer)
		{
			//Find tile based off hash
			int h = ComputeTileHash(x, y, tileLookupTableMask);
			MeshTile tile = posLookup[h];
			
			while (tile != null)
			{
				//Found
				if (tile.Header != null && tile.Header.X == x && tile.Header.Y == y && tile.Header.Layer == layer)
					return tile;

				//Keep searching
				tile = tile.Next;
			}
			
			return null;
		}

		/// <summary>
		/// Find and add a tile if it is found
		/// </summary>
		/// <param name="x">The x-coordinate</param>
		/// <param name="y">The y-coordinate</param>
		/// <param name="tiles">Tile array</param>
		/// <returns>Number of tiles satisfying condition</returns>
		public int GetTilesAt(int x, int y, MeshTile[] tiles)
		{
			int n = 0;

			//Find tile based on hash
			int h = ComputeTileHash(x, y, tileLookupTableMask);
			MeshTile tile = posLookup[h];
			
			while (tile != null)
			{
				//Tile found. 
				//Add to tile array
				if (tile.Header != null && tile.Header.X == x && tile.Header.Y == y)
				{
					if (n < tiles.Length)
						tiles[n++] = tile;
				}

				//Keep searching
				tile = tile.Next;
			}

			return n;
		}

		/// <summary>
		/// Gets the neighboring tile at that position
		/// </summary>
		/// <param name="x">The x-coordinate</param>
		/// <param name="y">The y-coordinate</param>
		/// <param name="side">The side value</param>
		/// <param name="tiles">An array of MeshTiles</param>
		/// <returns>The number of tiles satisfying the condition</returns>
		public int GetNeighbourTilesAt(int x, int y, BoundarySide side, MeshTile[] tiles)
		{
			int nx = x, ny = y;
			switch (side)
			{
				case BoundarySide.PlusX:
					nx++;
					break;

				case BoundarySide.PlusXPlusZ:
					nx++;
					ny++;
					break;

				case BoundarySide.PlusZ:
					ny++;
					break;

				case BoundarySide.MinusXPlusZ:
					nx--;
					ny++;
					break;

				case BoundarySide.MinusX:
					nx--;
					break;

				case BoundarySide.MinusXMinusZ:
					nx--;
					ny--;
					break;

				case BoundarySide.MinusZ:
					ny--;
					break;

				case BoundarySide.PlusXMinusZ:
					nx++;
					ny--;
					break;
			}

			return GetTilesAt(nx, ny, tiles);
		}

		/// <summary>
		/// Computes the tile hash code, which can be used in a hash table for quick lookup.
		/// </summary>
		/// <param name="x">The x-coordinate</param>
		/// <param name="y">The y-coordinate</param>
		/// <param name="mask">The mask</param>
		/// <returns>Tile hash code</returns>
		public int ComputeTileHash(int x, int y, int mask)
		{
			//choose large multiplicative constants which are primes
			uint h1 = 0x8da6b343;
			uint h2 = 0xd8163841;
			uint n = (uint)(h1 * x + h2 * y);
			return (int)(n & mask);
		}

		/// <summary>
		/// Get the actual polygon reference
		/// </summary>
		/// <param name="polyBase">The base value</param>
		/// <param name="poly">The offset</param>
		/// <returns>The polygon reference</returns>
		public int GetReference(int polyBase, int poly)
		{
			return polyBase | poly;
		}

		/// <summary>
		/// Determines whether a link exists for that index
		/// </summary>
		/// <param name="index">The index</param>
		/// <returns>True if allocated, false if not</returns>
		public bool IsLinkAllocated(int index)
		{
			return index != Link.Null;
		}

		/// <summary>
		/// Determines whether the two polygons are externally linked or not
		/// </summary>
		/// <param name="neighbor">The neighboring polygon</param>
		/// <returns>True if externally linked, false if not</returns>
		public bool IsExternalLink(int neighbor)
		{
			return (neighbor & Link.External) != 0;
		}
		
		/// <summary>
		/// Get the base reference for the polygons in a tile.
		/// </summary>
		/// <param name="tile">Current Tile</param>
		/// <returns>Base poly reference</returns>
		public int GetPolyRefBase(MeshTile tile)
		{
			if (tile == null)
				return 0;

			int it = 0;
			for (int i = 0; i < tiles.Length; i++)
			{
				if (tiles[i] == tile)
				{
					it = i;
					break;
				}
			}

			return EncodePolyId(tile.Salt, it, 0);
		}

		/// <summary>
		/// Retrieve the tile and poly based off of a polygon reference
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <param name="tile">Resulting tile</param>
		/// <param name="poly">Resulting poly</param>
		/// <returns>True if tile and poly successfully retrieved</returns>
		public bool TryGetTileAndPolyByRef(int reference, out MeshTile tile, out Poly poly)
		{
			tile = null;
			poly = null;

			if (reference == 0)
				return false;

			//Get tile and poly indices
			int salt = 0, indexTile = 0, indexPoly = 0;
			DecodePolyId(reference, ref salt, ref indexTile, ref indexPoly);
			
			//Make sure indices are valid
			if (indexTile >= maxTiles)
				return false;

			if (tiles[indexTile].Salt != salt || tiles[indexTile].Header == null)
				return false;

			if (indexPoly >= tiles[indexTile].Header.PolyCount)
				return false;

			//Retrieve tile and poly
			tile = tiles[indexTile];
			poly = tiles[indexTile].Polys[indexPoly];
			return true;
		}

		/// <summary>
		/// Only use this function if it is known that the provided polygon reference is valid.
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <param name="tile">Resulting tile</param>
		/// <param name="poly">Resulting poly</param>
		public void TryGetTileAndPolyByRefUnsafe(int reference, out MeshTile tile, out Poly poly)
		{
			int salt = 0, indexTile = 0, indexPoly = 0;
			DecodePolyId(reference, ref salt, ref indexTile, ref indexPoly);
			tile = tiles[indexTile];
			poly = tiles[indexTile].Polys[indexPoly];
		}

		/// <summary>
		/// Check if polygon reference is valid.
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <returns>True if valid</returns>
		public bool IsValidPolyRef(int reference)
		{
			if (reference == 0)
				return false;

			int salt = 0, indexTile = 0, indexPoly = 0;
			DecodePolyId(reference, ref salt, ref indexTile, ref indexPoly);

			if (indexTile >= maxTiles)
				return false;

			if (tiles[indexTile].Salt != salt || tiles[indexTile].Header == null)
				return false;

			if (indexPoly >= tiles[indexTile].Header.PolyCount)
				return false;

			return true;
		}

		/// <summary>
		/// Decode a standard polygon reference 
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <param name="salt">Resulting salt value</param>
		/// <param name="indexTile">Resulting tile index</param>
		/// <param name="indexPoly">Resulting poly index</param>
		public void DecodePolyId(int reference, ref int salt, ref int indexTile, ref int indexPoly)
		{
			int saltMask = (1 << saltBits) - 1;
			int tileMask = (1 << tileBits) - 1;
			int polyMask = (1 << polyBits) - 1;
			salt = (reference >> (polyBits + tileBits)) & saltMask;
			indexTile = (reference >> polyBits) & tileMask;
			indexPoly = reference & polyMask;
		}

		/// <summary>
		/// Extract a tile's salt value from the specified polygon reference 
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <returns>Salt value</returns>
		public int DecodePolyIdSalt(int reference)
		{
			int saltMask = (1 << saltBits) - 1;
			return (reference >> (polyBits + tileBits)) & saltMask;
		}

		/// <summary>
		/// Extract a tile's index from the specified polygon reference
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <returns>Tile index</returns>
		public int DecodePolyIdTile(int reference)
		{
			int tileMask = (1 << tileBits) - 1;
			return (reference >> polyBits) & tileMask;
		}

		/// <summary>
		/// Extract a polygon's index (within its tile) from the specified polygon reference 
		/// </summary>
		/// <param name="reference">Polygon reference</param>
		/// <returns>Poly index</returns>
		public int DecodePolyIdPoly(int reference)
		{
			int polyMask = (1 << polyBits) - 1;
			return reference & polyMask;
		}

		/// <summary>
		/// Derive a standard polygon reference, which compresses salt, tile index, and poly index together
		/// </summary>
		/// <param name="salt">Salt value</param>
		/// <param name="indexTile">Tile index</param>
		/// <param name="indexPoly">Poly index</param>
		/// <returns>Polygon reference</returns>
		public int EncodePolyId(int salt, int indexTile, int indexPoly)
		{
			return (salt << (int)(polyBits + tileBits)) | (indexTile << (int)polyBits) | indexPoly;
		}

		/// <summary>
		/// Calculates the tile location.
		/// </summary>
		/// <param name="pos">The position</param>
		/// <param name="tx">The tile's x-coordinate</param>
		/// <param name="ty">The tile's y-coordinate</param>
		public void CalcTileLoc(ref Vector3 pos, out int tx, out int ty)
		{
			tx = (int)Math.Floor((pos.X - origin.X) / tileWidth);
			ty = (int)Math.Floor((pos.Z - origin.Z) / tileHeight);
		}

		/*/// <summary>
		/// Serializes the navigation mesh into a JSON format and writes the 
		/// serialized data to a file. 
		/// </summary>
		/// <param name="filename">Path to file to be written</param>
		/// <returns>True if JSON data read, false otherwise</returns>
		public bool SaveJson(string filename)
		{
			string data = this.JSONObject.ToString();
			File.WriteAllText(filename, data);
			return true;
		}

		/// <summary>
		/// Reads the JSON data from a file, deserializes it and updates the current
		/// TiledNavMesh instance to reflect the deserialized data. 
		/// </summary>
		/// <param name="filename">Path to file to be read</param>
		/// <returns>True if file exists and was read successfully, false otherwise</returns>
		public static TiledNavMesh LoadJson(string filename)
		{
			if (!File.Exists(filename))    
				return null; 

			string data = File.ReadAllText(filename); 
			return (TiledNavMesh) JsonConvert.DeserializeObject<TiledNavMesh>(data);
		}*/
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Tuple.cs:
 // ----------------------------------------------------------------------------
// Tuple structs for use in .NET Not-Quite-3.5 (e.g. Unity3D).
//
// Used Chapter 3 in http://functional-programming.net/ as a starting point.
//
// Note: .NET 4.0 Tuples are immutable classes so they're *slightly* different.
// ----------------------------------------------------------------------------

using System;

namespace SharpNav
{
	/// <summary>
	/// Represents a functional tuple that can be used to store
	/// two values of different types inside one object.
	/// </summary>
	/// <typeparam name="T1">The type of the first element</typeparam>
	/// <typeparam name="T2">The type of the second element</typeparam>
	public sealed class Tuple<T1, T2>
	{
		private readonly T1 item1;
		private readonly T2 item2;

		/// <summary>
		/// Retyurns the first element of the tuple
		/// </summary>
		public T1 Item1
		{
			get { return item1; }
		}
		
		/// <summary>
		/// Returns the second element of the tuple
		/// </summary>
		public T2 Item2
		{
			get { return item2; }
		}
		
		/// <summary>
		/// Create a new tuple value
		/// </summary>
		/// <param name="item1">First element of the tuple</param>
		/// <param name="second">Second element of the tuple</param>
		public Tuple(T1 item1, T2 item2)
		{
			this.item1 = item1;
			this.item2 = item2;
		}
		
		public override string ToString()
		{
			return string.Format("Tuple({0}, {1})", Item1, Item2);
		}
		
		public override int GetHashCode()
		{
			int hash = 17;
			hash = hash * 23 + (item1 == null ? 0 : item1.GetHashCode());
			hash = hash * 23 + (item2 == null ? 0 : item2.GetHashCode());
			return hash;
		}
		
		public override bool Equals(object o)
		{
			if (!(o is Tuple<T1, T2>)) {
				return false;
			}
			
			var other = (Tuple<T1, T2>) o;
			
			return this == other;
		}
		
		public bool Equals(Tuple<T1, T2> other)
		{
			return this == other;
		}
		
		public static bool operator==(Tuple<T1, T2> a, Tuple<T1, T2> b)
		{
			if (object.ReferenceEquals(a, null)) {
				return object.ReferenceEquals(b, null);
			}
			if (a.item1 == null && b.item1 != null) return false;
			if (a.item2 == null && b.item2 != null) return false;
			return
				a.item1.Equals(b.item1) &&
					a.item2.Equals(b.item2);
		}
		
		public static bool operator!=(Tuple<T1, T2> a, Tuple<T1, T2> b)
		{
			return !(a == b);
		}
		
		public void Unpack(Action<T1, T2> unpackerDelegate)
		{
			unpackerDelegate(Item1, Item2);
		}
	}
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_CircularCity\Scripts\CircularCityBuildingHeightModifier.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.CircularCity;

namespace DungeonArchitect.Samples.CircularCity
{
    public class CircularCityBuildingHeightModifier : DungeonEventListener
    {
        public AnimationCurve curve;
        public float maxScale = 2;
        public float minScale = 1;

        public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers) {
            var config = dungeon.Config as CircularCityDungeonConfig;
            if (config == null) return;

            foreach (var marker in markers)
            {
                var position = Matrix.GetTranslation(ref marker.Transform);
                var distanceFromCenter = position.magnitude;

                float t = (distanceFromCenter - config.startRadius) / (config.endRadius - config.startRadius);
                t = Mathf.Clamp01(t);
                t = 1 - t;

                if (curve != null)
                {
                    t = curve.Evaluate(t);
                }


                var scaleMultiplier = minScale + (maxScale - minScale) * t;
                var rotation = Matrix.GetRotation(ref marker.Transform);
                var scale = Matrix.GetScale(ref marker.Transform);
                scale = Vector3.Scale(scale, new Vector3(1, scaleMultiplier, 1));
                marker.Transform = Matrix4x4.TRS(position, rotation, scale);
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_FloorPlanner\Scripts\FloorPlanRoomMarkers.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.FloorPlan;

public class FloorPlanRoomMarkers : DungeonMarkerEmitter {

    public override void EmitMarkers(DungeonBuilder builder)
    {
        var floorModel = builder.Model as FloorPlanModel;
        if (floorModel == null)
        {
            return;
        }

        var roomChunks = new List<FloorChunk>();
        foreach (var chunk in floorModel.Chunks)
        {
            if (chunk.ChunkType == FloorChunkType.Room)
            {
                roomChunks.Add(chunk);
            }
        }

        var gridSize = floorModel.Config.GridSize;
        foreach (var roomChunk in roomChunks)
        {
            DecorateRoom(builder, roomChunk, gridSize);
        }
    }

    void DecorateRoom(DungeonBuilder builder, FloorChunk roomChunk, Vector3 gridSize)
    {
        var bounds = roomChunk.Bounds;
        var x0 = bounds.Location.x;
        var x1 = bounds.Location.x + bounds.Size.x;
        var y = bounds.Location.y;
        var z0 = bounds.Location.z;
        var z1 = bounds.Location.z + bounds.Size.z;

        EmitChunkMarker(builder, "RoomCorner", new Vector3(x0, y, z0), 0, gridSize, roomChunk.Id);
        EmitChunkMarker(builder, "RoomCorner", new Vector3(x1, y, z0), -90, gridSize, roomChunk.Id);
        EmitChunkMarker(builder, "RoomCorner", new Vector3(x1, y, z1), 180, gridSize, roomChunk.Id);
        EmitChunkMarker(builder, "RoomCorner", new Vector3(x0, y, z1), 90, gridSize, roomChunk.Id);

        EmitChunkMarker(builder, "RoomCenter", new Vector3(x0 + x1, y + y, z0 + z1) / 2.0f, 270, gridSize, roomChunk.Id);
    }

    void EmitChunkMarker(DungeonBuilder builder, string markerName, Vector3 gridPositionF, float angle, Vector3 gridSize, int cellId)
    {
        var worldPosition = Vector3.Scale(gridPositionF, gridSize);
        var matrix = Matrix4x4.TRS(worldPosition, Quaternion.Euler(0, angle, 0), Vector3.one);
        var gridPosition = new IntVector(gridPositionF);
        builder.EmitMarker(markerName, matrix, gridPosition, cellId);
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow_Navigation\Scripts\GFNavDemoController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Samples
{
    public class GFNavDemoController : MonoBehaviour
    {
        public Dungeon dungeon;
        void Start()
        {
            if (dungeon != null)
            {
                dungeon.Build();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow_Navigation\Scripts\GFNavNPCController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Samples.ShooterGame;
using UnityEngine;
using UnityEngine.AI;

namespace DungeonArchitect.Samples
{
    public class GFNavNPCController : MonoBehaviour
    {
        public Transform target;
        
        private NavMeshAgent agent;
        private CharacterController character;
        void Start()
        {
            agent = GetComponent<NavMeshAgent>();
            character = GetComponent<CharacterController>();
            InvokeRepeating(nameof(SeekToTarget), 0.5f, 1.0f);
        }

        void Update()
        {
            if (agent != null && agent.hasPath)
            {
                character.SimpleMove(agent.desiredVelocity);
            }
        }
        
        void SeekToTarget()
        {
            if (target == null)
            {
                FindTarget();
            }

            if (target != null)
            {
                agent.SetDestination(target.position);
            }
        }

        void FindTarget()
        {
            // Place your logic here.  For this sample, we search for the player in the entire map
            
            var player = GameObject.FindGameObjectWithTag(GameTags.Player);
            if (player != null)
            {
                target = player.transform;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow_Query\Example_QueryPathName\GridFlowPathSelector_AltPath.cs:
 using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Samples.GridFlow
{
    public class GridFlowPathSelector_AltPath : SelectorRule
    {
        public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
        {
            var gridFlowModel = model as GridFlowDungeonModel;
            if (gridFlowModel == null) return false;

            var query = gridFlowModel.Query;
            if (query == null) return false;

            var markerLocation = Matrix.GetTranslation(ref propTransform);
            var pathName = query.GetPathName(markerLocation);

            // Select nodes with the specified path (this was defined in the grid flow editor's `Create Path` node)
            return pathName == "alt";
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow_Query\Example_QueryPathName\GridFlowPathSelector_MainPath.cs:
 using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Samples.GridFlow
{
    public class GridFlowPathSelector_MainPath : SelectorRule
    {
        public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
        {
            var gridFlowModel = model as GridFlowDungeonModel;
            if (gridFlowModel == null) return false;

            var query = gridFlowModel.Query;
            if (query == null) return false;

            var markerLocation = Matrix.GetTranslation(ref propTransform);
            var pathName = query.GetPathName(markerLocation);

            // Select nodes with the specified path (this was defined in the grid flow editor's `Create Path` node)
            return pathName == "main"
                   || pathName == "main_start"
                   || pathName == "main";
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow_Query\Example_QueryPathName\GridFlowPathSelector_ShopPath.cs:
 using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Samples.GridFlow
{
    public class GridFlowPathSelector_ShopPath : SelectorRule
    {
        public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
        {
            var gridFlowModel = model as GridFlowDungeonModel;
            if (gridFlowModel == null) return false;

            var query = gridFlowModel.Query;
            if (query == null) return false;

            var markerLocation = Matrix.GetTranslation(ref propTransform);
            var pathName = query.GetPathName(markerLocation);

            // Select nodes with the specified path (this was defined in the grid flow editor's `Create Path` node)
            return pathName == "shop";
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow_Query\Example_QueryPathName\GridFlowPathSelector_TreasurePath.cs:
 using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Samples.GridFlow
{
    public class GridFlowPathSelector_TreasurePath : SelectorRule
    {
        public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
        {
            var gridFlowModel = model as GridFlowDungeonModel;
            if (gridFlowModel == null) return false;

            var query = gridFlowModel.Query;
            if (query == null) return false;

            var markerLocation = Matrix.GetTranslation(ref propTransform);
            var pathName = query.GetPathName(markerLocation);
            var isRoom = query.GetRoomType(markerLocation) == GridFlowLayoutNodeRoomType.Room;

            // Select nodes with the specified path (this was defined in the grid flow editor's `Create Path` node)
            return pathName == "bonus_main" && isRoom;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow_Query\Example_QueryRoomTypes\GridFlowCaveSelector.cs:
 using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Samples.GridFlow
{
    public class GridFlowCaveSelector : SelectorRule
    {
        public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
        {
            var gridFlowModel = model as GridFlowDungeonModel;
            if (gridFlowModel == null) return false;

            var query = gridFlowModel.Query;
            if (query == null) return false;

            var markerLocation = Matrix.GetTranslation(ref propTransform);
            var roomType = query.GetRoomType(markerLocation);

            return roomType == GridFlowLayoutNodeRoomType.Cave;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow_Query\Example_QueryRoomTypes\GridFlowRoomSelector.cs:
 using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Samples.GridFlow
{
    public class GridFlowRoomSelector : SelectorRule
    {
        public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
        {
            var gridFlowModel = model as GridFlowDungeonModel;
            if (gridFlowModel == null) return false;

            var query = gridFlowModel.Query;
            if (query == null) return false;

            var markerLocation = Matrix.GetTranslation(ref propTransform);
            var roomType = query.GetRoomType(markerLocation);

            return roomType == GridFlowLayoutNodeRoomType.Room;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_InfinityCaves\Scripts\InfinityCavesDemoController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.InfinityCaves
{
    public class InfinityCavesDemoController : MonoBehaviour
    {
        public InfinityDungeon dungeon;

        void Start()
        {
            if (dungeon != null)
            {
                dungeon.BuildDungeon();
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SimpleCity\Scripts\CitySkyscraperInserter.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.SimpleCity;

[System.Serializable]
public class SkyscraperRange
{
	public float startDistance;
	public float endDistance;
	public string markerName;
};

public class CitySkyscraperInserter : DungeonEventListener {
	public SkyscraperRange[] skyscraperRanges;

	public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers) { 
		var cityModel = model as SimpleCityDungeonModel;
		var width = cityModel.CityWidth;
		var height = cityModel.CityHeight;
		var center = Vector3.Scale(new Vector3 (width / 2.0f, 0, height / 2.0f), new Vector3 (cityModel.Config.CellSize.x, 0, cityModel.Config.CellSize.y));
		center += dungeon.transform.position;

		foreach (var marker in markers) {
			if (marker.SocketType == SimpleCityDungeonMarkerNames.House) {
				var distanceFromCenter = (Matrix.GetTranslation (ref marker.Transform) - center).magnitude;
				foreach (var rangeInfo in skyscraperRanges) {
					if (distanceFromCenter >= rangeInfo.startDistance && distanceFromCenter <= rangeInfo.endDistance) {
						marker.SocketType = rangeInfo.markerName;
						break;
					}
				}
			}
		}
	}

}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_Snap\Scripts\SnapDemo_ProceduralLevelLayout.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect.Grammar;

public class SnapDemo_ProceduralLevelLayout : MonoBehaviour, IGrammarGraphBuildScript
{
    public void Generate(IGrammarGraphBuilder grammarBuilder)
    {
        var random = new System.Random();
        int execIndex = 0;
        var spawnRoom = grammarBuilder.CreateNode("SpawnRoom", execIndex++);
        var shop = grammarBuilder.CreateNode("Shop", execIndex++);
        grammarBuilder.LinkNodes(spawnRoom, shop);

        var lastNodeId = spawnRoom;
        int numRoomGraphs = random.Range(2, 5);
        for (int i = 0; i < numRoomGraphs; i++)
        {
            var roomNode = grammarBuilder.CreateNode("RoomGraph", execIndex++);
            grammarBuilder.LinkNodes(lastNodeId, roomNode);
            lastNodeId = roomNode;
            
            // Create branches from here if necessary...
        }

        var bossRoom = grammarBuilder.CreateNode("Boss", execIndex++);
        grammarBuilder.LinkNodes(lastNodeId, bossRoom);

        var exitRoom = grammarBuilder.CreateNode("Exit", execIndex++);
        grammarBuilder.LinkNodes(bossRoom, exitRoom);
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow\Scripts\SGFDemoController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect;
using UnityEngine;

namespace DungeonArchitect.Samples.SnapGridFlow
{
    public class SGFDemoController : MonoBehaviour
    {
        public Dungeon dungeon;

        protected virtual void Start()
        {
            if (dungeon != null)
            {
                dungeon.Build();
                
                // Setup the visibility graph to track the player
                var playerObject = GameObject.FindWithTag("Player");
                if (playerObject != null)
                {
                    // Detach the spawned player object from the room prefab
                    playerObject.transform.SetParent(null, true);
                }
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow\Scripts\SGFDemoController_VisiblityGraph.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect;
using DungeonArchitect.Builders.SnapGridFlow;
using UnityEngine;

namespace DungeonArchitect.Samples.SnapGridFlow
{
    public class SGFDemoController_VisiblityGraph : MonoBehaviour
    {
        public Dungeon dungeon;

        protected virtual void Start()
        {
            if (dungeon != null)
            {
                dungeon.Build();
                
                // Setup the visibility graph to track the player
                var playerObject = GameObject.FindWithTag("Player");
                if (playerObject != null)
                {
                    var visibilityGraph = dungeon.GetComponent<SnapGridFlowVisibilityGraph>();
                    if (visibilityGraph != null)
                    {
                        visibilityGraph.trackedObjects = new Transform[] { playerObject.transform };
                    }
                    
                    // Detach the spawned player object from the room prefab (we don't want to hide the player's camera when the spawn room hides)
                    playerObject.transform.SetParent(null, true);
                }
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_Query\RoomQueryScripts\SGFRoomDebugDrawer.cs:
 using System;
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.SnapGridFlow;
using DungeonArchitect.Utils;

public class SGFRoomDebugDrawer : MonoBehaviour
{
    public Dungeon dungeon;

    private SnapGridFlowQuery query;
    private Transform player;

    private Bounds roomBoundsToDraw = new Bounds();
    
    private void Awake()
    {
        query = dungeon != null ? dungeon.GetComponent<SnapGridFlowQuery>() : null;
    }

    void Update()
    {
        // Make sure the dungeon is ready and the player is available
        if (query == null || !query.IsValid()) return;
        if (player == null)
        {
            // Try to find the player
            var playerObject = GameObject.FindWithTag("Player");
            if (playerObject != null)
            {
                player = playerObject.transform;
            }
        }
        if (player == null) return;
        
        
        // Get the room module at the player location
        var module = query.GetRoomNodeAtLocation(player.position);
        roomBoundsToDraw = module.GetModuleBounds();
        
        // Draw a red box around the room (in the scene view)
        DebugDrawUtils.DrawBounds(roomBoundsToDraw, Color.red);
        
        // Draw a green circle near the doors
        foreach (var sgfModuleDoor in module.Doors)
        {
            var connection = sgfModuleDoor.SpawnedDoor;
            if (connection == null || !connection.IsDoorState())
            {
                // We're only interested in doors
                continue;
            }

            var connectionObject = connection.gameObject;
            DebugDrawUtils.DrawCircle(connectionObject.transform.position, 1, Color.green);
        }
        
    }
    
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_Simple\Constraints\SGFDemoNodeConstraintFloor0.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect;
using UnityEngine;

public class SGFDemoNodeConstraintFloor0 : ScriptableObject, ISGFLayoutNodePositionConstraint
{
    public int level = 0;
    public bool CanCreateNodeAt(SGFLayoutNodePositionConstraintSettings settings)
    {
        return settings.NodeCoord.y == level;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_Simple\Constraints\SGFDemoNodeConstraintFloor1.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect;
using UnityEngine;

public class SGFDemoNodeConstraintFloor1 : ScriptableObject, ISGFLayoutNodePositionConstraint
{
    public bool CanCreateNodeAt(SGFLayoutNodePositionConstraintSettings settings)
    {
        return settings.NodeCoord.y == 1;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_Simple\Constraints\SGFDemoNodeConstraintFloor2.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect;
using UnityEngine;

public class SGFDemoNodeConstraintFloor2 : ScriptableObject, ISGFLayoutNodePositionConstraint
{
    public bool CanCreateNodeAt(SGFLayoutNodePositionConstraintSettings settings)
    {
        return settings.NodeCoord.y == 2;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_Simple\Constraints\SGFDemoNodeConstraints.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect;
using UnityEngine;

public class SGFDemoNodeConstraints : ScriptableObject, ISGFLayoutNodePositionConstraint
{
    public bool CanCreateNodeAt(SGFLayoutNodePositionConstraintSettings settings)
    {
        if (settings.CurrentPathPosition == settings.TotalPathLength - 1)
        {
            return settings.NodeCoord == new Vector3Int(0, 0, 0);
        }

        return true;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_Simple\Scripts\SGFDemoPlayer.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Samples.SnapGridFlow
{
    public class SGFDemoPlayer : MonoBehaviour
    {
        private CharacterController character;

        private void Awake()
        {
            character = GetComponent<CharacterController>();
        }

        void Update()
        {
            if (Input.GetKeyDown(KeyCode.Space))
            {
            
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_VisiblityGraph\Scripts\VG_GameController.cs:
 using System.Collections;
using System.Collections.Generic;
using DungeonArchitect;
using DungeonArchitect.Builders.SnapGridFlow;
using UnityEngine;

public class VG_GameController : MonoBehaviour
{
    public Dungeon dungeon;
    public Material redMaterial;

    private Transform playerTransform;
    private SnapGridFlowQuery query;

    void Awake()
    {
        if (dungeon != null)
        {
            query = dungeon.GetComponent<SnapGridFlowQuery>();
        }
    }
    
    void Start()
    {
        if (dungeon != null)
        {
            dungeon.Config.Seed = (uint)(Random.value * int.MaxValue);
            dungeon.Build();

            var visibilityGraph = dungeon.GetComponent<SnapGridFlowVisibilityGraph>();
            if (visibilityGraph != null)
            {
                // Use your own logic to find your player game object
                var playerObject = GameObject.FindGameObjectWithTag("Player");
                
                if (playerObject != null)
                {
                    playerTransform = playerObject.transform;
                    
                    // Detach the spawned player object from the room prefab (we don't want to hide the player's camera when the spawn room hides)
                    playerTransform.SetParent(null, true);
                
                    visibilityGraph.trackedObjects = new Transform[] { playerObject.transform };
                }
            }
        }
    }

    void Update()
    {
        // Paint the rooms red when we pass through them
        if (playerTransform != null && query != null)
        {
            var module = query.GetRoomNodeAtLocation(playerTransform.position);
            
            // Grab the bounds like this
            var roomBounds = module.GetModuleBounds();
            
            // Grab the spawned room game object like this
            var roomGameObject = module.SpawnedModule;
            
            // Set the color to red
            if (redMaterial != null)
            {
                var renderers = roomGameObject.GetComponentsInChildren<Renderer>();
                foreach (var roomRenderer in renderers)
                {
                    roomRenderer.material = redMaterial;
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_Snap_SideScroller\Scripts\SSCamera.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DASideScroller
{
    public class SSCamera : MonoBehaviour
    {
        public Transform target;            // The position that that camera will be following.
        public float positionSmoothing = 5f;        // The speed with which the camera will be following.
        public float lookAtSmoothing = 5f;        // The speed with which the camera will be following.
        public Vector3 offset;                     // The initial offset from the target.

        Vector3 currentLookAt;

        void Start()
        {
            // Calculate the initial offset.
            //offset = transform.position - target.position;
            currentLookAt = target.position;
        }


        void Update()
        {
            // Create a postion the camera is aiming for based on the offset from the target.
            Vector3 targetCamPos = target.position + offset;

            // Smoothly interpolate between the camera's current position and it's target position.
            transform.position = Vector3.Lerp(transform.position, targetCamPos, positionSmoothing * Time.deltaTime);
            currentLookAt = Vector3.Lerp(currentLookAt, target.position, lookAtSmoothing * Time.deltaTime);
            transform.LookAt(currentLookAt);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_Snap_SideScroller\Scripts\SSGame.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DASideScroller
{
    public class SSGame : MonoBehaviour
    {
        // Start is called before the first frame update
        void Start()
        {
            

        }

        // Update is called once per frame
        void Update()
        {

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_Snap_SideScroller\Scripts\SSPlayerMovement.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DASideScroller
{
    public class SSPlayerMovement : MonoBehaviour
    {
        public float speed = 6f;            // The speed that the player will move at.
        public float gravity = 40;
        public float jumpSpeed = 15;
        public int maxJumps = 2;
        public float interJumpDelay = 0.4f;

        bool facingLeft = false;
        CharacterController character;
        Vector3 movement;                   // The vector to store the direction of the player's movement.
        Animator anim;                      // Reference to the animator component.
        int numJumpsPerformed = 0;
        float lastJumpTimestamp = 0;

        void Awake()
        {
            anim = GetComponent<Animator>();
            character = GetComponent<CharacterController>();
            //character.enabled = false;
        }

        public void OnTeleportered()
        {
            character.enabled = true;
        }


        void Update()
        {
            // Store the input axes.
            float h = Input.GetAxisRaw("Horizontal");
            //float v = Input.GetAxisRaw("Vertical");

            // Move the player around the scene.
            Move(h);

            // Turn the player to face the mouse cursor.
            Turning(h);

            // Animate the player.
            Animating(h);
        }

        void PerformJump()
        {
            if (numJumpsPerformed >= maxJumps)
            {
                return;
            }

            // Check if enough time has passed since
            if (Time.time - lastJumpTimestamp < interJumpDelay)
            {
                return;
            }

            movement.y = jumpSpeed;
            numJumpsPerformed++;
            lastJumpTimestamp = Time.time;
        }

        void Move(float h)
        {

            if (character.isGrounded)
            {
                // Set the movement vector based on the axis input.
                movement.Set(h, 0, 0);
                movement *= speed;
                numJumpsPerformed = 0;
            }
            else
            {
                movement.x = h * speed;

                if (character.velocity.y == 0)
                {
                    movement.y = 0;
                }
            }

            if (Input.GetButton("Jump"))
            {
                PerformJump();
            }

            // Apply gravity
            movement.y -= gravity * Time.deltaTime;
            
            if (character.enabled)
            {
                character.Move(movement * Time.deltaTime);
            }
        }


        void Turning(float h)
        {
            if (h != 0)
            {
                facingLeft = (h < 0);
            }

            var angle = facingLeft ? -90 : 90;
            transform.rotation = Quaternion.Euler(0, angle, 0);
            /*
            // Create a ray from the mouse cursor on screen in the direction of the camera.
            Ray camRay = Camera.main.ScreenPointToRay(Input.mousePosition);

            // Create a RaycastHit variable to store information about what was hit by the ray.
            RaycastHit floorHit;

            // Perform the raycast and if it hits something on the floor layer...
            if (Physics.Raycast(camRay, out floorHit, camRayLength))
            {
                // Create a vector from the player to the point on the floor the raycast from the mouse hit.
                Vector3 playerToMouse = floorHit.point - transform.position;

                // Ensure the vector is entirely along the floor plane.
                playerToMouse.y = 0f;

                // Create a quaternion (rotation) based on looking down the vector from the player to the mouse.
                Quaternion newRotatation = Quaternion.LookRotation(playerToMouse);

                // Set the player's rotation to this new rotation.
                transform.rotation = newRotatation;
                //playerRigidbody.MoveRotation (newRotatation);
            }
            */
        }


        void Animating(float h)
        {
            // Create a boolean that is true if either of the input axes is non-zero.
            bool walking = h != 0f;

            // Tell the animator whether or not the player is walking.
            anim.SetBool("IsWalking", walking);
        }

    }

}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Demo_PlaceableMarker\Scripts\PlaceableMarker.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples
{
    public class PlaceableMarker : MonoBehaviour
    {
        public string markerName = "MyMarker";

        void OnDrawGizmosSelected()
        {
            DrawGizmo(true);
        }

        void OnDrawGizmos()
        {
            DrawGizmo(false);
        }

        void DrawGizmo(bool selected)
        {
            // Draw the wireframe
            Gizmos.color = selected ? Color.red : Color.yellow;
            Gizmos.DrawSphere(transform.position, 0.2f);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Demo_PlaceableMarker\Scripts\PlaceableMarkerInjector.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
namespace DungeonArchitect.Samples
{
    public class PlaceableMarkerInjector : DungeonEventListener
    {
        public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers)
        {
            // Grab all the placeable markers in the scene
            var placeableMarkers = FindObjectsOfType<PlaceableMarker>();
            foreach (var placeableMarker in placeableMarkers)
            {
                // Insert a new marker in this location
                var marker = new PropSocket();
                marker.Id = 0;
                marker.SocketType = placeableMarker.markerName;
                marker.Transform = placeableMarker.transform.localToWorldMatrix;
                marker.gridPosition = IntVector.Zero;
                marker.cellId = 0;

                markers.Add(marker);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\EnemyController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect.Navigation;

namespace JackRabbit {
	public class EnemyController : MonoBehaviour {

		public Animator animator;
		public float maxHealth;

		bool facingRight = true;
		float currentHealth;


		Rigidbody2D rigidBody2D;
		void Awake() {
			rigidBody2D = GetComponent<Rigidbody2D>();
			currentHealth = maxHealth;
		}

		// Update is called once per frame
		void FixedUpdate () {
			animator.SetFloat("Speed", rigidBody2D.velocity.magnitude);

			var moveX = rigidBody2D.velocity.x;
			if (moveX > 0 && facingRight) {
				Flip();
			} else if (moveX < 0 && !facingRight) {
				Flip ();
			}

		}
		
		void Flip() {
			facingRight = !facingRight;
			var scale = transform.localScale;
			scale.x *= -1;
			transform.localScale = scale;
		}

		public bool Alive {
			get { return currentHealth > 0; }
		}

		public void ApplyDamage(float amount) {
			if (Alive) {
				currentHealth -= amount;
				if (!Alive) {
					OnDead();
				}
			}
		}

		void OnDead() {
			animator.SetTrigger("Dead");
			rigidBody2D.velocity = Vector2.zero;
			rigidBody2D.collisionDetectionMode = CollisionDetectionMode2D.Discrete;
			var colliders = GetComponents<Collider2D>();
			foreach (var collider in colliders) {
				collider.enabled = false;
			}

			
			GetComponent<DungeonNavAgent>().enabled = false;
			GetComponent<DungeonArchitect.Samples.ShooterGame.TwoD.AIController2D>().enabled = false;
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\FollowPlayer.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect.Navigation;

namespace JackRabbit {
	public class FollowPlayer : MonoBehaviour {
		DungeonNavAgent agent;
		// Use this for initialization
		void Start () {
			agent = GetComponent<DungeonNavAgent>();
		}
		
		// Update is called once per frame
		void FixedUpdate () {
			var player = GameObject.FindGameObjectWithTag(DungeonArchitect.Samples.ShooterGame.GameTags.Player);
			agent.Destination = player.transform.position;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\FollowTarget.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace JackRabbit
{
    public class FollowTarget : MonoBehaviour
    {
        public Transform target;
        public float sensitivity = 1;

        void Awake()
        {
            SetTarget(target.position);
        }

        // Update is called once per frame
        void Update()
        {
            var current = gameObject.transform.position;
            var desired = target.position;
            var dt = Mathf.Min(Time.deltaTime, 0.1f);
            var t = sensitivity * dt;
            SetTarget(Vector3.Lerp(current, desired, t));
        }

        void SetTarget(Vector3 position3D)
        {
            var position = gameObject.transform.position;
            position.x = position3D.x;
            position.y = position3D.y;
            gameObject.transform.position = position;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\GameControllerJackRabbit.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using DungeonArchitect;
using DungeonArchitect.Navigation;

namespace JackRabbit {
    public interface IJackRabbitGameController
    {
        void CreateNewLevel();
    }

	public class GameControllerJackRabbit : MonoBehaviour, IJackRabbitGameController
    {
		public Dungeon dungeon;
		public DungeonNavMesh navMesh;
		public Text loadingText;
		private static GameControllerJackRabbit instance;

        DungeonArchitect.Samples.ShooterGame.LevelNpcSpawner npcSpawner;
        DungeonArchitect.Samples.ShooterGame.WaypointGenerator waypointGenerator;
        SpecialRoomFinder2D specialRoomFinder;
		
		public static IJackRabbitGameController Instance {
			get {
				return instance;
			}
		}


		void Awake() {
			Physics2D.gravity = Vector2.zero;
            instance = this;
            npcSpawner = GetComponent<DungeonArchitect.Samples.ShooterGame.LevelNpcSpawner>();
            waypointGenerator = GetComponent<DungeonArchitect.Samples.ShooterGame.WaypointGenerator>();
            specialRoomFinder = GetComponent<SpecialRoomFinder2D>();
			CreateNewLevel();
		}

		public void CreateNewLevel() {
			dungeon.Config.Seed = (uint)(Random.value * int.MaxValue);
			StartCoroutine(RebuildLevelRoutine());
		}

		void SetLoadingTextVisible(bool visible) {
			var container = loadingText.gameObject.transform.parent.gameObject;
			container.SetActive(visible);
		}

        void NotifyBuild()
        {
            waypointGenerator.BuildWaypoints(dungeon.ActiveModel, dungeon.Markers);
            specialRoomFinder.FindSpecialRooms(dungeon.ActiveModel);
        }

        void NotifyDestroyed() {
            waypointGenerator.OnDungeonDestroyed(dungeon);
            specialRoomFinder.OnDungeonDestroyed(dungeon);
        }

		IEnumerator RebuildLevelRoutine() {
			SetLoadingTextVisible(true);
			loadingText.text = "";
			AppendLoadingText("Generating Level... ");
			dungeon.DestroyDungeon();
            NotifyDestroyed();
			yield return 0;	

			dungeon.Build();
			yield return 0;
            NotifyBuild();
			yield return 0;	
			AppendLoadingText("DONE!\n");
			AppendLoadingText("Building Navigation... ");
			yield return 0;		// Wait for a frame to show our loading text

			RebuildNavigation();
			AppendLoadingText("DONE!\n");
			AppendLoadingText("Spawning NPCs...");
			yield return 0;		// Wait for a frame to show our loading text

			npcSpawner.RebuildNPCs();
			AppendLoadingText("DONE!\n");
			SetLoadingTextVisible(false);
			yield return null;
		}

		void AppendLoadingText(string text) {
			loadingText.text += text;
		}

		void Update() {
			if (Input.GetKeyDown(KeyCode.Space)) {
				CreateNewLevel();
			}
		}

		void RebuildNavigation() {
			navMesh.Build();
		}


	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\GameControllerJackRabbit_GridFlow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using DungeonArchitect;
using DungeonArchitect.Navigation;

namespace JackRabbit {
	public class GameControllerJackRabbit_GridFlow : MonoBehaviour, IJackRabbitGameController
    {
		public Dungeon dungeon;
		public DungeonNavMesh navMesh;
		public Text loadingText;
		private static GameControllerJackRabbit_GridFlow instance;

        DungeonArchitect.Samples.ShooterGame.LevelNpcSpawner npcSpawner;
        DungeonArchitect.Samples.ShooterGame.WaypointGenerator waypointGenerator;
		
		public static GameControllerJackRabbit_GridFlow Instance {
			get {
				return instance;
			}
		}


		void Awake() {
			Physics2D.gravity = Vector2.zero;
            instance = this;
            npcSpawner = GetComponent<DungeonArchitect.Samples.ShooterGame.LevelNpcSpawner>();
            waypointGenerator = GetComponent<DungeonArchitect.Samples.ShooterGame.WaypointGenerator>();
			CreateNewLevel();
		}

		public void CreateNewLevel() {
			dungeon.Config.Seed = (uint)(Random.value * int.MaxValue);
			StartCoroutine(RebuildLevelRoutine());
		}

		void SetLoadingTextVisible(bool visible) {
			var container = loadingText.gameObject.transform.parent.gameObject;
			container.SetActive(visible);
		}

        void NotifyBuild()
        {
            waypointGenerator.BuildWaypoints(dungeon.ActiveModel, dungeon.Markers);
        }

        void NotifyDestroyed() {
            waypointGenerator.OnDungeonDestroyed(dungeon);
        }

		IEnumerator RebuildLevelRoutine() {
			SetLoadingTextVisible(true);
			loadingText.text = "";
			AppendLoadingText("Generating Level... ");
			dungeon.DestroyDungeon();
            NotifyDestroyed();
			yield return 0;	

			dungeon.Build();
			yield return 0;
            NotifyBuild();
			yield return 0;	
			AppendLoadingText("DONE!\n");
			AppendLoadingText("Building Navigation... ");
			yield return 0;		// Wait for a frame to show our loading text

			RebuildNavigation();
			AppendLoadingText("DONE!\n");
			AppendLoadingText("Spawning NPCs...");
			yield return 0;		// Wait for a frame to show our loading text

			npcSpawner.RebuildNPCs();
			AppendLoadingText("DONE!\n");
			SetLoadingTextVisible(false);
			yield return null;
		}

		void AppendLoadingText(string text) {
			loadingText.text += text;
		}

		void Update() {
			if (Input.GetKeyDown(KeyCode.Space)) {
				CreateNewLevel();
			}
		}

		void RebuildNavigation() {
			navMesh.Build();
		}


	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\LevelEndGoal2D.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace JackRabbit {
	public class LevelEndGoal2D : MonoBehaviour {
		
		void OnTriggerEnter2D(Collider2D other) {
			if (other.isTrigger) return;
			if (other.gameObject.CompareTag(DungeonArchitect.Samples.ShooterGame.GameTags.Player)) {
				// Recreate the level
				GameControllerJackRabbit.Instance.CreateNewLevel();
			}
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\Pickup.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

public class Pickup : MonoBehaviour {

	// Use this for initialization
	void Start () {
	
	}
	
	void OnTriggerEnter2D(Collider2D other) {
		if (other.isTrigger) return;
		if (other.gameObject.CompareTag(DungeonArchitect.Samples.ShooterGame.GameTags.Player)) {
			// Destroy on pickup
			Destroy (gameObject);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\PickupWobbler.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

public class PickupWobbler : MonoBehaviour {
	public Vector2 wobbleDirection = Vector2.up;
	public float speed = 1;
	public float randomStartAngle;	// So they don't all wobble in the same sequence

	Vector3 originalPosition;
	// Use this for initialization
	void Start () {
		originalPosition = transform.position;
		randomStartAngle = Random.value * 100;
	}
	
	// Update is called once per frame
	void Update () {
		var t = Time.time * Mathf.PI + randomStartAngle;
		t *= speed;
		var offset = Mathf.Sin(t) * wobbleDirection;
		transform.position = originalPosition + new Vector3(offset.x, offset.y, 0);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\PlayerCameraZoom.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

public class PlayerCameraZoom : MonoBehaviour {
	public float sensitivity = 1;
	public float zoomMultiplier = 1.2f;
	public float maxSpeed = 8;
	public Rigidbody2D rigidBody2D;

	float startingZoom;
	float targetZoom;
	Camera cam;

	void Awake() {
		cam = GetComponent<Camera>();
		startingZoom = cam.orthographicSize;
	}

	// Update is called once per frame
	void Update () {
		var speed = rigidBody2D.velocity.magnitude;
		var t = speed / maxSpeed;
		var multiplier = Mathf.Lerp (1, zoomMultiplier, t);
		targetZoom = startingZoom * multiplier;

		cam.orthographicSize = Mathf.Lerp(cam.orthographicSize, targetZoom, sensitivity * Time.deltaTime);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\PlayerController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace JackRabbit {
	public class PlayerController : MonoBehaviour {
		public float maxSpeed = 5;
		public float attackMoveSpeedMultiplier = 0.1f;
		public float sprintMultiplier = 1.5f;
		public float movementSensitivity = 0.1f;
		public float attackStength = 40;

		bool facingRight = true;
		Rigidbody2D rigidBody2D;
		Animator animator;
		bool attacking = false;


		void Awake() {
			rigidBody2D = GetComponent<Rigidbody2D>();
			animator = GetComponent<Animator>();
		}

		void FixedUpdate () {
			float moveX = Input.GetAxis("Horizontal");
			float moveY = Input.GetAxis("Vertical");
			
			attacking = Input.GetButton("Fire1");
			animator.SetBool("Attack", attacking);

			var sprintPressed = Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift);
			var targetSpeed = maxSpeed;
			if (attacking) {
				targetSpeed *= attackMoveSpeedMultiplier;
			}
			else if (sprintPressed) {
				targetSpeed *= sprintMultiplier;
			}
			var direction = new Vector2(moveX, moveY);
			var directionLength = direction.magnitude;
			if (directionLength > 1) {
				direction /= directionLength;
			}

			var currentSpeed = rigidBody2D.velocity.magnitude;
			var desiredSpeed = Mathf.Lerp(currentSpeed, targetSpeed, movementSensitivity);

			rigidBody2D.velocity = direction * desiredSpeed;
			
			if (moveX > 0 && !facingRight) {
				Flip();
			} else if (moveX < 0 && facingRight) {
				Flip ();
			}

			animator.SetFloat("Speed", rigidBody2D.velocity.magnitude);
		}

		void OnAttack() {
			var offset = new Vector3(0.3f, 0.7f, 0);
			offset.x *= Mathf.Sign (transform.localScale.x);
			var radius = 0.7f;
			var colliders = Physics2D.OverlapCircleAll(gameObject.transform.position + offset, radius);
			foreach (var collider in colliders) {
                var enemyController = collider.gameObject.GetComponent<DungeonArchitect.Samples.ShooterGame.TwoD.AIController2D>();
                if (enemyController != null)
                {
					// Apply damage to the enemy
					var enemy = collider.gameObject.GetComponent<EnemyController>();
					if (enemy != null) {
						enemy.ApplyDamage(attackStength);
					}
				}
			}
		}

		void Update() {
		}

		void Flip() {
			facingRight = !facingRight;
			var scale = transform.localScale;
			scale.x *= -1;
			transform.localScale = scale;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\RotatorZ.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

public class RotatorZ : MonoBehaviour {
	public float frequency = 1;
	
	// Update is called once per frame
	void Update () {
		var delta = Mathf.PI * 2 * frequency * Time.deltaTime;
		transform.Rotate(0, 0, delta);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Scripts\SpecialRoomFinder2D.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;

namespace JackRabbit {
	public class SpecialRoomFinder2D : DungeonEventListener {
		public GameObject levelEndGoalTemplate;
		
		/// <summary>
		/// Called after the dungeon is completely built
		/// </summary>
		/// <param name="model">The dungeon model</param>
        public override void OnPostDungeonLayoutBuild(Dungeon dungeon, DungeonModel model)
        {
            FindSpecialRooms(model);
        }

        public void FindSpecialRooms(DungeonModel model)
        {
			var gridModel = model as GridDungeonModel;
			if (gridModel == null) return;
			
			var furthestCells = GridDungeonModelUtils.FindFurthestRooms(gridModel);
			if (furthestCells.Length == 2 && furthestCells[0] != null && furthestCells[1] != null) {
				var startCell = furthestCells[0];
				var endCell = furthestCells[1];
				
				SetStartingCell(gridModel, startCell);
				SetEndingCell(gridModel, endCell);
			}
		}
		
		public override void OnDungeonDestroyed(Dungeon dungeon) {
			
		}
		
		void SetStartingCell(GridDungeonModel model, Cell cell) {
			var roomCenter = MathUtils.GridToWorld(model.Config.GridCellSize, cell.CenterF);
			
			// Teleport the player here
			var player = GameObject.FindGameObjectWithTag(DungeonArchitect.Samples.ShooterGame.GameTags.Player);
			if (player != null) {
				player.transform.position = FlipYZ(roomCenter);
			}
		}
		
		void SetEndingCell(GridDungeonModel model, Cell cell) {
			var roomCenter = MathUtils.GridToWorld(model.Config.GridCellSize, cell.CenterF);
			
            // Destroy all old level goal objects
            var oldGoals = GameObject.FindObjectsOfType<LevelEndGoal2D>();
            foreach (var oldGoal in oldGoals)
            {
                var oldGoalObj = oldGoal.gameObject;
                if (oldGoalObj != null)
                {
                    if (Application.isPlaying)
                    {
                        Destroy(oldGoalObj);
                    }
                    else
                    {
                        DestroyImmediate(oldGoalObj);
                    }
                }
            }
			
			var goal = Instantiate(levelEndGoalTemplate) as GameObject;
			goal.transform.position = FlipYZ(roomCenter);

            if (goal.GetComponent<LevelEndGoal2D>() == null)
            {
                Debug.LogWarning("No LevelGoal component attached to the Level goal prefab.  cleanup will not be proper");
            }
		}

		Vector3 FlipYZ(Vector3 v) {
			return new Vector3(v.x, v.z, v.y);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Editor\GameTagRegistration.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEditor;

namespace DungeonArchitect.Samples.ShooterGame.Editors
{
	public class GameTagRegistration : AssetPostprocessor 
	{
		static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
		{
			//DungeonEditorHelper.CreateEditorTag(GameTags.Enemy);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Sample_Global_State\DungeonState.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using DungeonArchitect;
using UnityEngine;

public class DungeonState : DungeonEventListener
{
    public int maxAllowedItem = 2;

    public int numItemsSpawned { get; set; } = 0;
    
    public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers)
    {
        // Reset your state here so the next rebuild works correctly
        numItemsSpawned = 0;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Sample_Global_State\ItemStateSelectionRule.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using DungeonArchitect;
using UnityEngine;

public class ItemStateSelectionRule : SelectorRule
{
    private DungeonState state;
    
    public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
    {
        if (state == null)
        {
            state = model.gameObject.GetComponent<DungeonState>();
        }
        
        if (state != null && state.numItemsSpawned < state.maxAllowedItem)
        {
            state.numItemsSpawned++;
            return true;
        }

        return false;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Scripts\AdjacentCorridorTracker.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect;
using DungeonArchitect.Builders.Grid;

public class AdjacentCorridorTracker : MonoBehaviour {

    public Dungeon dungeon;
    GridDungeonModel gridModel;
    Material materialCursor;
    Material materialCorridors;
    Material materialRooms;

    List<int> ConnectedCorridors = new List<int>();
    List<int> ConnectedRooms = new List<int>();
    int cursorCellId;

    void Start()
    {
        if (dungeon != null)
        {
            // Requires a rebuild for now as the state is not fully saved (data in hash sets is not serialized properly)
            dungeon.Build();
            gridModel = dungeon.GetComponent<GridDungeonModel>();
        }

        // Setup materials
        materialCursor = CreateMaterial(Color.white);
        materialCorridors = CreateMaterial(Color.yellow);
        materialRooms = CreateMaterial(Color.red);
    }

    Material CreateMaterial(Color color)
    {
        var shader = Shader.Find("Hidden/Internal-Colored");
        var mat = new Material(shader);
        mat.hideFlags = HideFlags.HideAndDontSave;
        mat.SetInt("_Cull", (int)UnityEngine.Rendering.CullMode.Off);
        mat.SetInt("_ZWrite", 0);
        mat.SetInt("_ZTest", (int)UnityEngine.Rendering.CompareFunction.Always);
        mat.SetColor("_Color", color);

        return mat;
    }

    void Update() {

        ConnectedCorridors.Clear();
        ConnectedRooms.Clear();

        var cellAtMouse = FindCellAtMousePosition(Camera.main);
        if (cellAtMouse == null) return;
        
        GridBuilderUtils.GetAdjacentCorridors(gridModel, cellAtMouse.Id, ref ConnectedCorridors, ref ConnectedRooms);

        cursorCellId = cellAtMouse.Id;
        // We don't want to override the color of the cell under the mouse 
        ConnectedCorridors.Remove(cursorCellId);
        ConnectedRooms.Remove(cursorCellId);
    }
    
    void OnPostRender()
    {

        // activate the first shader pass (in this case we know it is the only pass)
        
        // draw a quad over whole screen
        DrawCells(ConnectedCorridors, materialCorridors);
        DrawCells(ConnectedRooms, materialRooms);

        var cursorCells = new List<int>();
        cursorCells.Add(cursorCellId);
        DrawCells(cursorCells, materialCursor);
    }

    void DrawCells(List<int> cellIds, Material mat)
    {
        if (gridModel == null || gridModel.Config == null) return;
        var gridSize = gridModel.Config.GridCellSize;
        
        mat.SetPass(0);

        GL.Begin(GL.QUADS);

        foreach (var cellId in cellIds)
        {
            var cell = gridModel.GetCell(cellId);
            if (cell == null) continue;

            var start = cell.Bounds.Location * gridSize;
            var size = cell.Bounds.Size * gridSize;

            DrawQuad(start, size);
        }

        GL.End();
    }

    void DrawQuad(Vector3 start, Vector3 size)
    {
        float y = start.y;
        float x0 = start.x;
        float x1 = start.x + size.x;
        float z0 = start.z;
        float z1 = start.z + size.z;
        
        GL.Vertex3(x0, y, z0);
        GL.Vertex3(x1, y, z0);
        GL.Vertex3(x1, y, z1);
        GL.Vertex3(x0, y, z1);
    }

    Cell FindCellAtMousePosition(Camera cam) {
        if (gridModel == null || gridModel.Config == null) return null;
        var gridSize = gridModel.Config.GridCellSize;
        
        Ray ray = cam.ScreenPointToRay(Input.mousePosition);

        Cell bestCell = null;
        float bestDistance = float.MaxValue;

        // plane Z to world position hits
        var hitPositionAtY = new Dictionary<float, Vector3>();
        foreach (var cell in gridModel.Cells)
        {
            var worldY = cell.Bounds.Location.y * gridSize.y;
            if (!hitPositionAtY.ContainsKey(worldY))
            {
                // raycast from here
                var plane = new Plane(Vector3.up, new Vector3(0, worldY, 0));
                float rayDistance;
                plane.Raycast(ray, out rayDistance);
                var hitPoint = ray.GetPoint(rayDistance);
                hitPositionAtY.Add(worldY, hitPoint);
            }

            Vector3 worldHitPoint = hitPositionAtY[worldY];

            // Check if we are within the bounds of the cell
            var start = cell.Bounds.Location * gridSize;
            var size = cell.Bounds.Size * gridSize;

            // Check if we are within the bounds
            Rect bounds2D = new Rect(start.x, start.z, size.x, size.z);
            if (bounds2D.Contains(new Vector2(worldHitPoint.x, worldHitPoint.z)))
            {
                var distance = (worldHitPoint - cam.transform.position).sqrMagnitude;
                if (distance < bestDistance)
                {
                    bestDistance = distance;
                    bestCell = cell;
                }
            }
        }

        return bestCell;
    }

    
    
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Scripts\RemoveDuplicateMarkersWithinCell.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;

public class RemoveDuplicateMarkersWithinCell : DungeonEventListener {
    public string markerName;

    public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers) {
        var config = dungeon.Config as GridDungeonConfig;
        var gridSize = config.GridCellSize;

        var SpatialPartition = new HashSet<IntVector>();
        var markersToRemove = new List<PropSocket>();
        foreach (var marker in markers)
        {
            if (marker.SocketType == markerName)
            {
                // Check if a marker with this name has already been encountered before in this spatial cell
                var markerLocation = Matrix.GetTranslation(ref marker.Transform);
                int sx = Mathf.FloorToInt(markerLocation.x / gridSize.x);
                int sz = Mathf.FloorToInt(markerLocation.z / gridSize.z);
                var spatialKey = new IntVector(sx, 0, sz);

                if (SpatialPartition.Contains(spatialKey)) {
                    // We have found a marker within this cell before. remove it from the list
                    markersToRemove.Add(marker);
                    continue;
                }

                // Register it so we can remove duplicates later
                SpatialPartition.Add(spatialKey);
            }
        }

        // Remove all the markers that were marked for removal
        foreach (var markerToRemove in markersToRemove)
        {
            markers.Remove(markerToRemove);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Scripts\VolumeSpawnExampleListener.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect;
using DungeonArchitect.Graphs;
using DungeonArchitect.Builders.Grid;

/// <summary>
/// This example spawns various theme override volumes around rooms 
/// This is done by hooking into the build events of DA and adding 
/// volumes right after the layout is built, but before the theme engine executes
/// </summary>
public class VolumeSpawnExampleListener : DungeonEventListener {

    // DungeonArchitect.Graphs.Graph is a theme graph asset stored in disk
    public Graph bossRoomTheme;
    public Graph spawnRoomTheme;

    public Graph[] roomThemes;

    [SerializeField]
    List<GameObject> managedVolumes = new List<GameObject>();

    /// <summary>
    /// The template required to clone and duplicate a theme override volume. 
    /// Supply the reference of the theme override volume prefab here
    /// </summary>
    public Volume themeVolumeTemplate;
    
    /// <summary>
    /// Called after the layout is built in memory, but before the markers are emitted
    /// We would like to spawn volumes here that encompass the rooms, so each room has a different theme applied to it
    /// </summary>
    /// <param name="model">The dungeon model</param>
    public override void OnPostDungeonLayoutBuild(Dungeon dungeon, DungeonModel model) {
        DestroyManagedVolumes();

        // Make sure we are working with the grid builder
        var gridModel = model as GridDungeonModel;
        if (gridModel == null) return;

        // Pick the start / end rooms for special decoration
        Cell spawnCell, finalBossCell;
        FindStartEndRooms(gridModel, out spawnCell, out finalBossCell);

        // Start decorating the rooms with random themes (except start / end rooms which have their own decorations)
        foreach (var cell in gridModel.Cells)
        {
            if (cell.CellType != CellType.Room)
            {
                // We only way to decorate rooms
                continue;
            }

            if (cell == spawnCell)
            {
                DecorateRoom(dungeon, gridModel, cell, spawnRoomTheme);
            }
            else if (cell == finalBossCell)
            {
                DecorateRoom(dungeon, gridModel, cell, bossRoomTheme);
            }
            else
            {
                DecorateRoom(dungeon, gridModel, cell, GetRandomTheme());
            }
        }
    }

    public override void OnDungeonDestroyed(Dungeon dungeon) {
        DestroyManagedVolumes();
    }
    
    void DecorateRoom(Dungeon dungeon, GridDungeonModel gridModel, Cell cell, Graph theme)
    {
        if (theme == null || cell == null) return;

        // Grid size used to convert logical grid coords to world coords
        var gridSize = gridModel.Config.GridCellSize;

        Vector3 position = cell.Bounds.Location * gridSize;
        Vector3 size = cell.Bounds.Size * gridSize;
        var center = position + size / 2.0f;
        var scale = size;
        scale.y = 5;    // Fixed height of the volume.  Optionally make this customizable

        var volumeObject = Instantiate(themeVolumeTemplate.gameObject) as GameObject;
        volumeObject.transform.position = center;
        volumeObject.transform.localScale = scale;
        var volume = volumeObject.GetComponent<ThemeOverrideVolume>();
        volume.dungeon = dungeon;       // Let the volume know that it belongs to this dungeon
        volume.overrideTheme = theme;   // Assign the theme we'd like this volume to override

        // Save a reference to the volume so we can destroy it when it is rebuilt the next time (or we will end up with duplicate volumes on rebuilds)
        managedVolumes.Add(volumeObject);
    }

    Graph GetRandomTheme()
    {
        if (roomThemes.Length == 0)
        {
            return null;
        }
        // Pick a random theme from the supplied theme list
        return roomThemes[Random.Range(0, roomThemes.Length)];
    }

    void FindStartEndRooms(GridDungeonModel gridModel, out Cell spawnCell, out Cell finalBossCell)
    {
        var furthestCells = GridDungeonModelUtils.FindFurthestRooms(gridModel);
        if (furthestCells.Length == 2 && furthestCells[0] != null && furthestCells[1] != null)
        {
            spawnCell = furthestCells[0];
            finalBossCell = furthestCells[1];
        }
        else
        {
            spawnCell = null;
            finalBossCell = null;
        }
    }

    void DestroyManagedVolumes()
    {
        foreach (var volume in managedVolumes)
        {
            if (Application.isPlaying)
            {
                Destroy(volume);
            }
            else
            {
                DestroyImmediate(volume);
            }
        }

        managedVolumes.Clear();
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Builders\FloorPlan\FloorPlanCorridorToolEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.FloorPlan;
using DungeonArchitect.Builders.FloorPlan.Tooling;
using UnityEditor;
using UnityEngine;
using MathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Editors
{
    [ExecuteInEditMode]
    [CustomEditor(typeof(FloorPlanCorridorTool))]
    public class FloorPlanCorridorToolEditor : Editor
    {
        IntVector positionOnGrid;
        bool requestRebuild = false;

        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            if (GUILayout.Button("Rebuild Dungeon"))
            {
                requestRebuild = true;
            }
        }


        void OnEnable()
        {
            EditorApplication.update += EditorUpdate;
            SceneView.duringSceneGui += OnUpdate;
        }

        void OnDisable()
        {
            SceneView.duringSceneGui -= OnUpdate;
            EditorApplication.update -= EditorUpdate;
        }

        void EditorUpdate()
        {
            if (requestRebuild)
            {
                Rebuild();
                requestRebuild = false;
            }
        }
        public virtual void OnUpdate(SceneView sceneView)
        {
            var tool = target as FloorPlanCorridorTool;
            if (tool != null)
            {
                if (tool.dynamicUpdate)
                {
                    var transform = tool.transform;
                    if (transform.hasChanged)
                    {
                        OnTransformModified(tool);
                        transform.hasChanged = false;
                    }
                }
            }
        }

        void Rebuild()
        {
            var tool = target as FloorPlanCorridorTool;
            if (tool != null && tool.dungeon != null)
            {
                var dungeon = tool.dungeon;
                dungeon.Build(new EditorDungeonSceneObjectInstantiator());
            }
        }

        protected void OnTransformModified(FloorPlanCorridorTool tool)
        {
            if (tool == null || tool.dungeon == null)
            {
                return;
            }
            var config = tool.dungeon.GetComponent<FloorPlanConfig>();
            if (config == null)
            {
                return;
            }

            var newPositionOnGrid = MathUtils.ToIntVector(MathUtils.Divide(tool.transform.position, config.GridSize));

            if (!positionOnGrid.Equals(newPositionOnGrid))
            {
                positionOnGrid = newPositionOnGrid;
                OnGridTransformModified();
            }

        }

        void OnGridTransformModified()
        {
            requestRebuild = true;
        }
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Builders\Grid\DungeonPaintModeGridEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;
using DMathUtils = DungeonArchitect.Utils.MathUtils;
using DungeonArchitect.Builders.Grid;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for the Paint model game object
    /// </summary>
    [CustomEditor(typeof(DungeonPaintModeGrid))]
    public class DungeonPaintModeGridEditor : DungeonPaintModeEditor
    {
        Vector3 cursorPosition;
        bool modeDelete = false;

        private readonly IDungeonSceneObjectInstantiator sceneObjectInstantiator = new EditorDungeonSceneObjectInstantiator();

        Vector3 SnapToGrid(Vector3 value)
        {
            var result = value;
            var mode = target as DungeonPaintModeGrid;
            var config = mode.GetDungeonConfig() as GridDungeonConfig;
            if (config == null)
            {
                return result;
            }
            var gridSize = config.GridCellSize;
            result.x = Mathf.FloorToInt(value.x / gridSize.x) * gridSize.x;
            result.y = mode.cursorLogicalHeight * gridSize.y;
            result.z = Mathf.FloorToInt(value.z / gridSize.z) * gridSize.z;
            return result;
        }

        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            if (GUILayout.Button("Clear Paint Data"))
            {
                ClearPaintData();
            }
        }

		void UpdateCursorPosition(DungeonPaintModeGrid mode) {
			float distance;
			var e = Event.current;
			Plane plane;
			if (mode.mode2D) {
				var planePoint = Vector3.zero;
				plane = new Plane(new Vector3(0, 0, 1), planePoint);
			} else {
				var cursorHeight = mode.GetCursorHeight();
				var planePoint = new Vector3(0, cursorHeight, 0);
				plane = new Plane(Vector3.up, planePoint);
			}

			var ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);
			if (plane.Raycast(ray, out distance))
			{
				var hitpoint = ray.GetPoint(distance);
				if (mode.mode2D) {
					hitpoint = DMathUtils.FlipYZ(hitpoint);
				}
				hitpoint = SnapToGrid(hitpoint);
				cursorPosition = hitpoint;

				if (!mode.mode2D) {
					if (e.type == EventType.ScrollWheel)
					{
						var delta = (int)Mathf.Sign(e.delta.y);
						mode.SetElevationDelta(delta);
					}
				}
			}
		}


        protected override void SceneGUI(SceneView sceneview)
        {
            var e = Event.current;
            var mode = target as DungeonPaintModeGrid;
			UpdateCursorPosition(mode);
            modeDelete = e.shift;

            int buttonId = 0;
			if (e.type == EventType.MouseDown && e.button == buttonId)
            {
                ProcessPaintRequest(e);
                e.Use();
            }
            else if (e.type == EventType.MouseUp && e.button == buttonId)
            {
                e.Use();
            }
            else if (e.type == EventType.MouseDrag && e.button == buttonId)
            {
                ProcessPaintRequest(e);
                e.Use();
            }
            else if (e.type == EventType.ScrollWheel && !mode.mode2D)
            {
                e.Use();
            }
            else if (e.type == EventType.Layout)
            {
                HandleUtility.AddDefaultControl(GUIUtility.GetControlID(GetHashCode(), FocusType.Passive));
            }

			var config = mode.GetDungeonConfig() as GridDungeonConfig;
			var model = mode.GetDungeonModelGrid() as GridDungeonModel;

			DrawOverlayData(config, model, mode.mode2D);
			DrawCursor(config, mode.mode2D, mode.brushSize);

            SceneView.RepaintAll();
        }

        void ClearPaintData()
        {
            var mode = target as DungeonPaintMode;
            if (mode != null)
            {
	            var toolData = mode.GetToolData() as GridDungeonToolData;
	            var dungeon = mode.GetDungeon();

	            if (toolData != null)
	            {
		            var modified = toolData.ClearToolOverlayData();
		            if (modified)
		            {
			            EditorUtility.SetDirty(toolData);
			            dungeon.Build(sceneObjectInstantiator);
		            }
	            }
            }
        }
        
        void ProcessPaintRequest(Event e)
        {
            var mode = target as DungeonPaintModeGrid;
            if (mode == null) return;
            
            var toolData = mode.GetToolData() as GridDungeonToolData;
            if (toolData == null) return;
            
            var config = mode.GetDungeonConfig() as GridDungeonConfig;
            if (config == null) return;
            
            var gridSize = config.GridCellSize;
            var cursorGridPosition = new IntVector(
                Mathf.RoundToInt(cursorPosition.x / gridSize.x),
                Mathf.RoundToInt(cursorPosition.y / gridSize.y),
                Mathf.RoundToInt(cursorPosition.z / gridSize.z));
            var dungeon = mode.GetDungeon();
			
			var cursorSize = Mathf.Max (1, mode.brushSize);
			for (int dx = 0; dx < cursorSize; dx++) {
				for (int dz = 0; dz < cursorSize; dz++) {
					var position = cursorGridPosition + new IntVector(dx, 0, dz);
					if (modeDelete)
					{
						var stateModified = toolData.RemovePaintCell(position);
                        if (stateModified) {
	                        dungeon.Build(sceneObjectInstantiator);
	                        EditorUtility.SetDirty(toolData);
                            //Undo.RecordObject(toolData, "Delete Painted Cell");
                        }
					}
					else
					{
                        var stateModified = toolData.AddPaintCell(position);
                        if (stateModified)
                        {
	                        dungeon.Build(sceneObjectInstantiator);
	                        EditorUtility.SetDirty(toolData);
                            //Undo.RecordObject(toolData, "Add Painted Cell");
                        }
					}
				}
			}

            EditorUtility.SetDirty(dungeon.gameObject);
        }

        void DrawCursor(GridDungeonConfig config, bool mode2D, int size)
        {
			size = Mathf.Max (1, size);
            var cursorSize = config.GridCellSize * size;
			DrawRect(cursorPosition, cursorSize, Color.red, 0.25f, 0.8f, mode2D);
        }

		void DrawRect(Vector3 position, Vector3 size, Color color, float faceOpacity, float outlineOpacity, bool mode2D)
        {
            var verts = new Vector3[] {
				position,
				position + new Vector3(size.x, 0, 0),
				position + new Vector3(size.x, 0, size.z),
				position + new Vector3(0, 0, size.z)
			};
			if (mode2D) {
				for(int i = 0; i < verts.Length; i++) {
					verts[i] = DMathUtils.FlipYZ(verts[i]);
				}
			}
            Color faceColor = new Color(color.r, color.g, color.b, faceOpacity);
            Color outlineColor = new Color(color.r, color.g, color.b, outlineOpacity);
            Handles.DrawSolidRectangleWithOutline(verts, faceColor, outlineColor);
            
        }

		void DrawOverlayData(GridDungeonConfig config, GridDungeonModel model, bool mode2D)
        {
            var mode = target as DungeonPaintModeGrid;
            var opacity = mode.overlayOpacity;
            var gridSize = config.GridCellSize;
            var cellColorProcedural = Color.blue;
            var cellColorUserDefined = Color.cyan;

            // Visualize the user defined cells defined by the paint tool
            foreach (var cell in model.Cells)
            {
                var size = Vector3.Scale(DMathUtils.ToVector3(cell.Bounds.Size), gridSize);
                var location = Vector3.Scale(DMathUtils.ToVector3(cell.Bounds.Location), gridSize);
                var color = cell.UserDefined ? cellColorUserDefined : cellColorProcedural;
                DrawRect(location, size, color, opacity, 0.3f, mode2D);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Builders\Grid\GridDungeonConfigEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;
using DungeonArchitect.Builders.Grid;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for the grid based dungeon configuration
    /// </summary>
	[CustomEditor(typeof(GridDungeonConfig))]
	public class GridDungeonConfigEditor : Editor {
		SerializedObject sobject;
		SerializedProperty Seed;
		SerializedProperty NumCells;
		SerializedProperty MinCellSize;
		SerializedProperty MaxCellSize;
		SerializedProperty RoomAreaThreshold;
		//SerializedProperty FloorHeight;
		SerializedProperty RoomAspectDelta;
		SerializedProperty CorridorWidth;
		SerializedProperty InitialRoomRadius;
		SerializedProperty SpanningTreeLoopProbability;
        SerializedProperty StairConnectionTollerance;
        SerializedProperty HeightVariationProbability;
		SerializedProperty NormalMean;
		SerializedProperty NormalStd;
		SerializedProperty GridCellSize;
		SerializedProperty MaxAllowedStairHeight;
		SerializedProperty Mode2D;
        SerializedProperty DoorProximitySteps;
        
        SerializedProperty UseFastCellDistribution;
        SerializedProperty CellDistributionWidth;
        SerializedProperty CellDistributionLength;
        SerializedProperty WallLayoutType;

        public void OnEnable() {
			sobject = new SerializedObject(target);
			Seed = sobject.FindProperty("Seed");
			NumCells = sobject.FindProperty("NumCells");
			MinCellSize = sobject.FindProperty("MinCellSize");
			MaxCellSize = sobject.FindProperty("MaxCellSize");
			RoomAreaThreshold = sobject.FindProperty("RoomAreaThreshold");
			//FloorHeight = sobject.FindProperty("FloorHeight");
			RoomAspectDelta = sobject.FindProperty("RoomAspectDelta");
            CorridorWidth = sobject.FindProperty("CorridorWidth");
			InitialRoomRadius = sobject.FindProperty("InitialRoomRadius");
			SpanningTreeLoopProbability = sobject.FindProperty("SpanningTreeLoopProbability");
			StairConnectionTollerance = sobject.FindProperty("StairConnectionTollerance");
			HeightVariationProbability = sobject.FindProperty("HeightVariationProbability");
			NormalMean = sobject.FindProperty("NormalMean");
			NormalStd = sobject.FindProperty("NormalStd");
			GridCellSize = sobject.FindProperty("GridCellSize");
			MaxAllowedStairHeight = sobject.FindProperty("MaxAllowedStairHeight");
            Mode2D = sobject.FindProperty("Mode2D");
            DoorProximitySteps = sobject.FindProperty("DoorProximitySteps");


            UseFastCellDistribution = sobject.FindProperty("UseFastCellDistribution");
            CellDistributionWidth = sobject.FindProperty("CellDistributionWidth");
            CellDistributionLength = sobject.FindProperty("CellDistributionLength");
            
            WallLayoutType = sobject.FindProperty("WallLayoutType");

        }

		public override void OnInspectorGUI()
		{
			sobject.Update();
			GUILayout.Label("Core Config", EditorStyles.boldLabel);
			// Core
			GUILayout.BeginHorizontal();
			EditorGUILayout.PropertyField(Seed);
			if (GUILayout.Button("R", GUILayout.Width(20), GUILayout.MaxHeight(15))) {
				RandomizeSeed();
			}
			GUILayout.EndHorizontal();

			EditorGUILayout.PropertyField(NumCells);
			EditorGUILayout.PropertyField(GridCellSize);
            EditorGUILayout.Space();

            // Cell dimensions
            GUILayout.Label("Cell Dimensions", EditorStyles.boldLabel);
			EditorGUILayout.PropertyField(MinCellSize);
			EditorGUILayout.PropertyField(MaxCellSize);
			EditorGUILayout.PropertyField(RoomAreaThreshold);
			EditorGUILayout.PropertyField(RoomAspectDelta);
			EditorGUILayout.PropertyField(CorridorWidth);
            EditorGUILayout.Space();

            // Height variations
            GUILayout.Label("Height Variations", EditorStyles.boldLabel);
			EditorGUILayout.PropertyField(HeightVariationProbability);
			EditorGUILayout.PropertyField(MaxAllowedStairHeight);
			EditorGUILayout.PropertyField(StairConnectionTollerance);
			EditorGUILayout.PropertyField(SpanningTreeLoopProbability);
            EditorGUILayout.Space();

            // Misc
            GUILayout.Label("Misc", EditorStyles.boldLabel);
			EditorGUILayout.PropertyField(Mode2D);
			EditorGUILayout.PropertyField(NormalMean);
			EditorGUILayout.PropertyField(NormalStd);
			EditorGUILayout.PropertyField(InitialRoomRadius);
            EditorGUILayout.PropertyField(DoorProximitySteps);
            EditorGUILayout.Space();

            GUILayout.Label("Experimental", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(UseFastCellDistribution);
            EditorGUILayout.PropertyField(CellDistributionWidth);
            EditorGUILayout.PropertyField(CellDistributionLength);

            EditorGUILayout.PropertyField(WallLayoutType);

            EditorGUILayout.Space();

            //EditorGUILayout.PropertyField(FloorHeight);

            sobject.ApplyModifiedProperties();
		}

		void RandomizeSeed() {
			Seed.intValue = Mathf.RoundToInt(Random.value * int.MaxValue);
		}
	}

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Builders\Snap\SnapConnectionEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Frameworks.Snap;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors
{
	[CustomEditor(typeof(SnapConnection))]
	public class SnapConnectionEditor : Editor
	{
		private SerializedObject sobject;
		private SerializedProperty doorObject;
		private SerializedProperty wallObject;
		private SerializedProperty category;
		
		private SerializedProperty oneWayDoorObject;
		private SerializedProperty lockedDoors;
		
		public void OnEnable()
		{
			sobject = new SerializedObject(target);
			
			doorObject = sobject.FindProperty("doorObject");
			wallObject = sobject.FindProperty("wallObject");
			category = sobject.FindProperty("category");
			
			oneWayDoorObject = sobject.FindProperty("oneWayDoorObject");
			lockedDoors = sobject.FindProperty("lockedDoors");
		}

		public override void OnInspectorGUI()
		{
			sobject.Update();

			GUILayout.Label("Snap Connection", EditorStyles.boldLabel);
			EditorGUILayout.PropertyField(doorObject);
			EditorGUILayout.PropertyField(wallObject);
			EditorGUILayout.PropertyField(category);
			EditorGUILayout.Space();
			
			GUILayout.Label("Advanced Doors", EditorStyles.boldLabel);
			EditorGUILayout.PropertyField(oneWayDoorObject);
			EditorGUILayout.PropertyField(lockedDoors);

			sobject.ApplyModifiedProperties();
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\DungeonArchitectMenu.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.SnapFlow;
using DungeonArchitect.Editors.Flow.Impl;
using DungeonArchitect.Editors.SpatialConstraints;
using UnityEditor;

namespace DungeonArchitect.Editors
{
    public class DungeonArchitectMenu
    {

        //------------------- Create Menu -------------------
        [MenuItem("Dungeon Architect/Create/Dungeon Theme", priority = 100)]
        public static void CreateThemeAssetInBrowser()
        {
            DungeonEditorHelper.CreateThemeAssetInBrowser();
        }

        [MenuItem("Dungeon Architect/Create/Snap Builder/Snap Graph", priority = 1000)]
        public static void CreateDungeonSnapFlowAssetInBrowser()
        {
            DungeonEditorHelper.CreateSnapAssetInBrowser();
        }

        [MenuItem("Dungeon Architect/Create/Snap Builder/Snap Connection", priority = 1000)]
        public static void CreateDungeonSnapFlowConnectionAssetInBrowser()
        {
            DungeonEditorHelper.CreateSnapAssetInBrowser();
        }

        
        [MenuItem("Dungeon Architect/Create/Grid Flow Builder/Grid Flow Graph", priority = 1000)]
        public static void CreateDungeonGridFlowAssetInBrowser()
        {
            DungeonEditorHelper.CreateGridFlowAssetInBrowser();
        }

        [MenuItem("Dungeon Architect/Create/Snap Grid Flow Builder/Snap Grid Flow Graph", priority = 1000)]
        public static void CreateSnapGridFlowGraphAssetInBrowser()
        {
            DungeonEditorHelper.CreateSnapGridFlowGraphAssetInBrowser();
        }
        
        [MenuItem("Dungeon Architect/Create/Snap Grid Flow Builder/Module Bounds", priority = 1000)]
        public static void CreateSnapGridFlowModuleBoundsAssetInBrowser()
        {
            DungeonEditorHelper.CreateSnapGridFlowModuleBoundsAssetInBrowser();
        }
        
        [MenuItem("Dungeon Architect/Create/Snap Grid Flow Builder/Module Database", priority = 1000)]
        public static void CreateSnapGridFlowModuleDatabaseAssetInBrowser()
        {
            DungeonEditorHelper.CreateSnapGridFlowModuleDatabaseAssetInBrowser();
        }

        [MenuItem("Dungeon Architect/Create/Snap Grid Flow Builder/Placeable Marker", priority = 1000)]
        public static void CreateSnapGridFlowPlaceableMarkerAssetInBrowser()
        {
            DungeonEditorHelper.CreateSnapGridFlowPlaceableMarkerAssetInBrowser();
        }

        [MenuItem("Dungeon Architect/Create/Snap Grid Flow Builder/Snap Connection", priority = 1000)]
        public static void CreateSnapGridFlowConnectionAssetInBrowser()
        {
            DungeonEditorHelper.CreateSnapGridFlowConnectionAssetInBrowser();
        }
        
        [MenuItem("Dungeon Architect/Create/Landscape/Landscape Restoration Cache", priority = 1000)]
        public static void CreateDungeonLandscapeRestCacheInBrowser()
        {
            DungeonEditorHelper.CreateDungeonLandscapeRestCacheInBrowser();
        }

        /*
        //------------------- Windows Menu -------------------
        [MenuItem("Dungeon Architect/Windows/Theme Editor", priority = 111)]
        public static void OpenWindow_ThemeEditor()
        {
            DungeonThemeEditorWindow.ShowEditor();
        }

        [MenuItem("Dungeon Architect/Windows/Grid Flow", priority = 112)]
        public static void OpenWindow_GridFlow()
        {
            GridFlowEditorWindow.ShowWindow();
        }

        // TODO: Hide this from the menu
        [MenuItem("Dungeon Architect/Windows/Snap Grid Flow", priority = 113)]
        public static void OpenWindow_SnapGridFlow()
        {
            SnapGridFlowEditorWindow.ShowWindow();
        }

        [MenuItem("Dungeon Architect/Windows/SnapFlow", priority = 114)]
        public static void OpenWindow_SnapFlow()
        {
            SnapEditorWindow.ShowEditor();
        }
        [MenuItem("Dungeon Architect/Windows/Spatial Constraints", priority = 115)]
        public static void OpenWindow_SpatialConstraints()
        {
            SpatialConstraintsEditorWindow.ShowWindow();
        }
        */
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\DungeonAssetPostprocessor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Editors
{
    /*
    /// <summary>
    /// An asset processor to create dungeon tags when DungeonArchitect is imported into a new project
    /// </summary>
    public class DungeonAssetPostprocessor : AssetPostprocessor
    {
        static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
        {
            foreach (var asset in importedAssets)
            {
                Debug.Log("Imported: " + asset);
            }
        }
    }
    */
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\DungeonBuilderEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;

namespace DungeonArchitect.Editors
{
    [CustomEditor(typeof(DungeonBuilder), true)]
    public class DungeonBuilderEditor : Editor
    {
        SerializedObject sobject;
        SerializedProperty asyncBuild;
        SerializedProperty maxBuildTimePerFrame;
        SerializedProperty asyncBuildStartPosition;
        
        protected virtual void OnEnable()
        {
            sobject = new SerializedObject(target);
            asyncBuild = sobject.FindProperty("asyncBuild");
            maxBuildTimePerFrame = sobject.FindProperty("maxBuildTimePerFrame");
            asyncBuildStartPosition = sobject.FindProperty("asyncBuildStartPosition");
        }
        
        public override void OnInspectorGUI()
        {
            sobject.Update();

            GUILayout.Label("Async Building", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(asyncBuild);
            EditorGUILayout.PropertyField(maxBuildTimePerFrame);
            EditorGUILayout.PropertyField(asyncBuildStartPosition);

            sobject.ApplyModifiedProperties();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\DungeonInfinityEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;

namespace DungeonArchitect.Editors
{
    [CustomEditor(typeof(InfinityDungeon))]
    public class DungeonInfinityEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            if (GUILayout.Button("Build Dungeon"))
            {
                var dungeon = target as InfinityDungeon;
                dungeon.BuildDungeon();
            }
            if (GUILayout.Button("Destroy Dungeon"))
            {
                var dungeon = target as InfinityDungeon;
                dungeon.DestroyDungeon();
            }
        }

        protected virtual void OnEnable()
        {
            EditorApplication.update += EditorUpdate;
        }

        protected virtual void OnDisable()
        {
            EditorApplication.update -= EditorUpdate;
        }

        void EditorUpdate()
        {
            var dungeon = target as InfinityDungeon;
            dungeon.EditorUpdate();
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\DungeonInfinityEditorUpdater.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors
{
    [CustomEditor(typeof(InfinityDungeonEditorUpdate))]
    public class DungeonInfinityEditorUpdater : Editor
    {

        protected virtual void OnEnable()
        {
            EditorApplication.update += EditorUpdate;
        }

        protected virtual void OnDisable()
        {
            EditorApplication.update -= EditorUpdate;
        }

        void EditorUpdate()
        {
            var updater = target as InfinityDungeonEditorUpdate;
            updater.EditorUpdate();
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\DungeonPaintModeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;
using DMathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for the paint mode object
    /// </summary>
    public class DungeonPaintModeEditor : Editor
    {
        protected virtual void OnEnable()
        {
            SceneView.duringSceneGui += SceneGUI;
        }
        
        protected virtual void OnDisable()
        {
            SceneView.duringSceneGui -= SceneGUI;
        }

        protected virtual void SceneGUI(SceneView sceneview) {
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\DungeonPropertyEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using UnityEditor;
using UnityEngine;
using System.Collections;
using DungeonArchitect.Splatmap;
using DungeonArchitect.UI;
using Random = UnityEngine.Random;

namespace DungeonArchitect.Editors
{
    public class DungeonPropertyEditorHook
    {
        public delegate void OnDungeonBuilt(Dungeon dungeon);
        public event OnDungeonBuilt DungeonBuilt;

        private DungeonPropertyEditorHook() { }
        private static DungeonPropertyEditorHook instance;
        public static DungeonPropertyEditorHook Get()
        {
            if (instance == null)
            {
                instance = new DungeonPropertyEditorHook();
            }
            return instance;
        }
        public static void NotifyDungeonBuilt(Dungeon dungeon)
        {
            if (Get().DungeonBuilt != null)
            {
                Get().DungeonBuilt.Invoke(dungeon);
            }
        }
    }
    /// <summary>
    /// Custom property editor for the dungeon game object
    /// </summary>
    [CustomEditor(typeof(Dungeon))]
	public class DungeonPropertyEditor : Editor
    {
	    private Texture2D iconDiscord;
	    private Texture2D iconDocs;
	    public static DungeonPropertyEditor Instance { get; private set; }
	    
	    protected virtual void OnEnable()
	    {
		    //EditorApplication.update += EditorUpdate;
		    Instance = this;
	    }
	    
		public override void OnInspectorGUI()
		{
			DrawDefaultInspector();
			Instance ??= this;
			if (GUILayout.Button ("Build Dungeon")) {
				BuildDungeon();
			}
			if (GUILayout.Button ("Destroy Dungeon")) {
				DestroyDungeon();
			}
			
			EditorGUILayout.Separator();

			if (iconDiscord == null)
			{
				iconDiscord = Resources.Load(UIResourceLookup.ICON_DISCORD_16x, typeof(Texture2D)) as Texture2D;
			}

			if (iconDocs == null)
			{
				iconDocs = Resources.Load(UIResourceLookup.ICON_DOCS_16x, typeof(Texture2D)) as Texture2D;
			}

			GUILayout.Label("Help / Support", EditorStyles.boldLabel);
			GUILayout.BeginHorizontal();
			if (GUILayout.Button(new GUIContent(" Discord Support", iconDiscord)))
			{
				ExternalLinks.LaunchUrl(ExternalLinks.DiscordInvite);
			}
			if (GUILayout.Button(new GUIContent("Documentation", iconDocs)))
			{
				ExternalLinks.LaunchUrl(ExternalLinks.Documentation);
			}
			GUILayout.EndHorizontal();
			if (GUILayout.Button(new GUIContent("Launch Pad")))
			{
				OpenLaunchPad();
			}
		}

		void OpenLaunchPad()
		{
			System.Type launchPadType = Type.GetType("DungeonArchitect.Editors.LaunchPad.LaunchPadWindow, DungeonArchitect.LaunchPad");
			if (launchPadType != null)
			{
				var window = EditorWindow.GetWindow(launchPadType);
				if (window != null)
				{
					// Call the init function
					foreach (var methodInfo in launchPadType.GetMethods())
					{
						if (methodInfo.Name == "Init")
						{
							methodInfo.Invoke(window, new object[] { });
						}
					}

					window.Show();
				}
			}
			/*
			// Search all assemblies
			foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
			{
				type = asm.GetType(typeName);
				if (type != null)
				{
					break;
				}
			}
			*/
		}
        
        protected virtual void OnDisable()
        {
            //EditorApplication.update -= EditorUpdate;
        }

        void EditorUpdate()
        {
            var dungeon = target as Dungeon;
            dungeon.Update();
        }

        public static void StaticBuildDungeon(bool isRandomSeed = false)
        {
	        Instance.BuildDungeon(isRandomSeed);
        }

        public void BuildDungeon(bool isRandomSeed = false) {
            // Make sure we have a theme defined
            bool valid = false;
			Dungeon dungeon = target as Dungeon;
			if (dungeon != null) {
				if (HasValidThemes(dungeon)) {
                    var config = dungeon.Config;
                    if (isRandomSeed)
	                    config.Seed = (uint)Random.Range(1, 1000000000);
                    if (config != null)
                    {
                        string configErrorMessage = "";
                        if (config.HasValidConfig(ref configErrorMessage))
                        {
                            valid = true;
                        }
                        else
                        {
                            EditorUtility.DisplayDialog("Dungeon Architect", configErrorMessage, "Ok");
                        }
                    }
                    else
                    {
                        EditorUtility.DisplayDialog("Dungeon Architect", "Missing dungeon config component in dungeon game object", "Ok");
                    }
				} 
				else {
					//Highlighter.Highlight ("Inspector", "Dungeon Themes");

					// Notify the user that at least one theme needs to be set
					EditorUtility.DisplayDialog("Dungeon Architect", "Please assign at least one Dungeon Theme before building", "Ok");
				}
			}

            if (valid)
            {
                // Create the splat maps for this dungeon, if necessary
                var splatComponent = dungeon.GetComponent<DungeonSplatmap>();
                SplatmapPropertyEditor.CreateSplatMapAsset(splatComponent);

                // Build the dungeon
                //Undo.RecordObjects(new Object[] { dungeon, dungeon.ActiveModel }, "Dungeon Built");
                dungeon.Build(new EditorDungeonSceneObjectInstantiator());
                DungeonEditorHelper.MarkSceneDirty();
                DungeonPropertyEditorHook.NotifyDungeonBuilt(dungeon);

                // Mark the splatmaps as dirty
                if (splatComponent != null && splatComponent.splatmap != null)
                {
                    EditorUtility.SetDirty(splatComponent.splatmap);
                }
                
                // Notify the theme editor that the dungeon was rebuilt manually from the editor
                var themeEditorWindow = DungeonEditorHelper.GetWindowIfOpen<DungeonThemeEditorWindow>();
                if (themeEditorWindow != null)
                {
	                themeEditorWindow.OnDungeonBuiltByUser(dungeon);
                }
                
                var model = dungeon.GetComponent<DungeonModel>();
                if (model != null)
                {
	                EditorUtility.SetDirty(model);
                }
            }
		}

		IEnumerator StopHighlighter() {
			yield return new WaitForSeconds(2);
			Highlighter.Stop();
		}

		void DestroyDungeon() {
			Dungeon dungeon = target as Dungeon;
            if (dungeon != null)
            {
                //Undo.RecordObjects(new Object[] { dungeon, dungeon.ActiveModel }, "Dungeon Destroyed");
                dungeon.DestroyDungeon();
                EditorUtility.SetDirty(dungeon.gameObject);
                
                // Notify the theme editor that the dungeon was rebuilt manually from the editor
                var themeEditorWindow = DungeonEditorHelper.GetWindowIfOpen<DungeonThemeEditorWindow>();
                if (themeEditorWindow != null)
                {
	                themeEditorWindow.OnDungeonDestroyedByUser(dungeon);
                }
                
                var model = dungeon.GetComponent<DungeonModel>();
                if (model != null)
                {
	                EditorUtility.SetDirty(model);
                }
            }
		}

        bool HasValidThemes(Dungeon dungeon) {
            var builder = dungeon.gameObject.GetComponent<DungeonBuilder>();
            if (builder != null && !builder.IsThemingSupported())
            {
                // Theming is not supported in this builder. empty theme configuration would do
                return true;
            }

            if (dungeon.dungeonThemes == null) return false;
			foreach (var theme in dungeon.dungeonThemes) {
				if (theme != null) {
					return true;
				}
			}
			return false;
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\EditorDungeonSceneObjectInstantiator.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors
{
    public class EditorDungeonSceneObjectInstantiator : IDungeonSceneObjectInstantiator
    {
        public GameObject Instantiate(GameObject template, Vector3 position, Quaternion rotation, Vector3 scale, Transform parent)
        {
            var gameObj = PrefabUtility.InstantiatePrefab(template) as GameObject;
            gameObj.transform.SetParent(parent);
            gameObj.transform.position = position;
            gameObj.transform.rotation = rotation;
            gameObj.transform.localScale = scale;
            return gameObj;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\SpatialConstraints\SpatialConstraintsEditorContextMenu.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors.SpatialConstraints
{
    public class SpatialConstraintsEditorContextMenu : GraphContextMenu
    {
        class ItemInfo
        {
            public ItemInfo(UISystem uiSystem, SpatialConstraintEditorMenuAction action)
            {
                this.uiSystem = uiSystem;
                this.action = action;
            }
            public UISystem uiSystem;
            public SpatialConstraintEditorMenuAction action;
        }

        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
            var menu = new GenericMenu();
            menu.AddItem(new GUIContent("Create Rule Node"), false, HandleContextMenu, new ItemInfo(uiSystem, SpatialConstraintEditorMenuAction.CreateRuleNode));
            menu.AddItem(new GUIContent("Create Comment Node"), false, HandleContextMenu, new ItemInfo(uiSystem, SpatialConstraintEditorMenuAction.CreateCommentNode));
            menu.ShowAsContext();
        }

        void HandleContextMenu(object userdata)
        {
            var item = userdata as ItemInfo;

            DispatchMenuItemEvent(item.action, BuildEvent(null, item.uiSystem));
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\SpatialConstraints\SpatialConstraintsEditorWindow.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.SpatialConstraints;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Impl.UnityEditor;

namespace DungeonArchitect.Editors.SpatialConstraints
{

    public class SpatialConstraintsEditorWindow : EditorWindow
    {
        public static void ShowWindow()
        {
            GetWindowWithRect<SpatialConstraintsEditorWindow>(new Rect(0, 0, 256, 256));
        }

        public UISystem uiSystem { get; private set; }
        UIRenderer renderer;

        [SerializeField]
        SpatialConstraintsGraphEditor graphEditor;
        public SpatialConstraintsGraphEditor GraphEditor
        {
            get { return graphEditor; }
        }

        public void Init(SpatialConstraintAsset assetBeingEdited, SpatialConstraintsEditorAssignmentState assignmentState)
        {
            CreateUISystem();
            graphEditor = CreateInstance<SpatialConstraintsGraphEditor>();
            var graph = (assetBeingEdited != null) ? assetBeingEdited.Graph : null;
            graphEditor.Init(graph, position, graph, uiSystem);
            graphEditor.AssignmentState = assignmentState;
            graphEditor.AssetBeingEdited = assetBeingEdited;

            Repaint();
        }

        void CreateUISystem()
        {
            uiSystem = new UnityEditorUISystem();
            renderer = new UnityEditorUIRenderer();
        }

        void OnEnable()
        {
            wantsMouseMove = true;
            UpdateTitle();

            Init(null, SpatialConstraintsEditorAssignmentState.NotAssigned);
            graphEditor.OnEnable();
            uiSystem = new UnityEditorUISystem();
        }

        void OnDisable()
        {
            if (graphEditor != null)
            {
                graphEditor.OnDisable();
            }
        }

        void OnDestroy()
        {
            if (graphEditor != null)
            {
                graphEditor.OnDisable();
                graphEditor.OnDestroy();
                graphEditor = null;
            }
        }

        void Update()
        {
            if (graphEditor != null)
            {
                graphEditor.Update();
            }
        }

        void OnGUI()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (graphEditor != null)
            {
                var guiState = new GUIState(renderer);

                var bounds = new Rect(Vector2.zero, position.size);
                graphEditor.UpdateWidget(uiSystem, bounds);
                graphEditor.Draw(uiSystem, renderer);

                guiState.Restore();
                DrawToolbar();

                HandleInput(Event.current);
            }
        }

        void HandleInput(Event e)
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            graphEditor.HandleInput(e, uiSystem);
            
            switch (e.type)
            {
                case EventType.MouseMove:
                case EventType.MouseDrag:
                case EventType.MouseDown:
                case EventType.MouseUp:
                case EventType.KeyDown:
                case EventType.Layout:
                case EventType.MouseEnterWindow:
                case EventType.MouseLeaveWindow:
                    Repaint();
                    break;
            }
        }

        void UpdateTitle()
        {
            titleContent = new GUIContent("Spatial Constraints");
        }

        void DrawToolbar()
        {
            var graphValid = (graphEditor != null && graphEditor.Graph != null);

            if (graphValid)
            {
                var spatialGraphEditor = graphEditor as SpatialConstraintsGraphEditor;

                EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);

                GUILayout.FlexibleSpace();
                spatialGraphEditor.RealtimeUpdate = GUILayout.Toggle(spatialGraphEditor.RealtimeUpdate, "Realtime Update", EditorStyles.toolbarButton);

                EditorGUILayout.EndHorizontal();
            }

        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\SpatialConstraints\SpatialConstraintsGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using System.Linq;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.Graphs.SpatialConstraints;
using DungeonArchitect.SpatialConstraints;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.SpatialConstraints
{
    enum SpatialConstraintEditorMenuAction
    {
        CreateRuleNode,
        CreateCommentNode,
        MakeOwnerNode
    }

    public enum SpatialConstraintsEditorAssignmentState
    {
        Assigned,
        NotAssigned,
        ConstraintsDisabled,
    }

    public class SpatialConstraintsGraphEditor : GraphEditor
    {
        [SerializeField]
        private bool realtimeUpdate = true;
        public bool RealtimeUpdate
        {
            get { return realtimeUpdate; }
            set {
                realtimeUpdate = value;
            }
        }

        [SerializeField]
        private SpatialConstraintsEditorAssignmentState assignmentState;
        public SpatialConstraintsEditorAssignmentState AssignmentState
        {
            get { return assignmentState; }
            set { assignmentState = value; }
        }

        [SerializeField]
        private SpatialConstraintAsset assetBeingEdited;
        public SpatialConstraintAsset AssetBeingEdited
        {
            get { return assetBeingEdited; }
            set { assetBeingEdited = value; }
        }

        protected override GraphContextMenu CreateContextMenu()
        {
            return new SpatialConstraintsEditorContextMenu();
        }

        protected override void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers)
        {
            nodeRenderers.RegisterNodeRenderer(typeof(SCRuleNode), new SCDomainNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(SCReferenceNode), new SCDomainNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(CommentNode), new CommentNodeRenderer(EditorStyle.commentTextColor));
        }

        public override void HandleGraphStateChanged(UISystem uiSystem)
        {
            base.HandleGraphStateChanged(uiSystem);

            if (RealtimeUpdate)
            {
                var themeEditorWindow = DungeonEditorHelper.GetWindowIfOpen<DungeonThemeEditorWindow>();
                if (themeEditorWindow != null)
                {
                    var themeEditor = themeEditorWindow.GraphEditor;
                    themeEditor.HandleGraphStateChanged(themeEditorWindow.uiSystem);
                }
            }

            HandleMarkedDirty(uiSystem);
        }

        public override void HandleMarkedDirty(UISystem uiSystem)
        {
            // Mark the host graph as dirty

            if (assetBeingEdited != null && assetBeingEdited.hostThemeNode != null)
            {
                var hostGraph = assetBeingEdited.hostThemeNode.Graph;
                if (hostGraph != null)
                {
                    uiSystem.Platform.MarkAssetDirty(hostGraph);
                }
            }
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {
            var action = (SpatialConstraintEditorMenuAction)userdata;
            HandleAction(action, e);
        }

        void HandleAction(SpatialConstraintEditorMenuAction action, GraphContextMenuEvent e)
        {
            var mouseScreen = lastMousePosition;
            if (action == SpatialConstraintEditorMenuAction.CreateRuleNode)
            {
                CreateSpatialNodeAtMouse<SCRuleNode>(mouseScreen, e.uiSystem);
            }
            else if (action == SpatialConstraintEditorMenuAction.CreateCommentNode)
            {
                CreateCommentNode(mouseScreen, e.uiSystem);
            }
        }
        
        void CreateCommentNode(Vector2 screenPos, UISystem uiSystem)
        {
            var worldPos = camera.ScreenToWorld(screenPos);
            var commentNode = CreateNode<CommentNode>(worldPos, uiSystem);
            commentNode.Position = worldPos;
            commentNode.background = new Color(0.224f, 1.0f, 0.161f, 0.7f);
            BringToFront(commentNode);
            SelectNode(commentNode, uiSystem);
        }

        void CreateSpatialNodeAtMouse<T>(Vector2 screenPos, UISystem uiSystem) where T : SCBaseDomainNode
        {
            var worldPos = camera.ScreenToWorld(screenPos);
            var node = DungeonEditorHelper.CreateSpatialConstraintNode<T>(assetBeingEdited, worldPos, uiSystem.Undo);
            BringToFront(node);
            node.SnapNode();

            SelectNode(node, uiSystem);
        }

        protected override void DrawOverlay(UIRenderer renderer, Rect bounds)
        {
            if (draggingNodes)
            {
                var selectedNodes = graph.Nodes.Where(node => node.Selected && node is SCBaseDomainNode);
                if (selectedNodes.Count() > 0)
                {
                    DrawNodeDragOverlay(renderer, bounds);
                }

            }
        }

        private UnityEngine.Object GetAssetObject()
        {
            if (assetBeingEdited == null || assetBeingEdited.hostThemeNode == null) return null;
            return assetBeingEdited.hostThemeNode.Graph;
        }

        protected override GraphNode DuplicateNode(GraphNode sourceNode, UISystem uiSystem)
        {
            var copiedNode = base.DuplicateNode(sourceNode, uiSystem);

            if (copiedNode is SCRuleNode && sourceNode is SCRuleNode)
            {
                var sourceRuleNode = sourceNode as SCRuleNode;
                var copiedRuleNode = copiedNode as SCRuleNode;
                var assetObject = GetAssetObject();

                var constraintList = new List<ConstraintRule>();
                foreach (var sourceConstraint in sourceRuleNode.constraints)
                {
                    var constraint = Instantiate(sourceConstraint) as ConstraintRule;
                    constraintList.Add(constraint);
                    
                    AssetDatabase.AddObjectToAsset(constraint, assetObject);
                }
                copiedRuleNode.constraints = constraintList.ToArray();
            }

            return copiedNode;
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            return new StraightLineGraphLinkRenderer();
        }

        void DrawNodeDragOverlay(UIRenderer renderer, Rect bounds)
        {
            var cursorWorld = camera.ScreenToWorld(lastMousePosition);

            var ringTexture = renderer.GetResource<Texture2D>(UIResourceLookup.TEXTURE_CURSOR_RING_SOLID) as Texture2D;

            int sx = Mathf.RoundToInt(cursorWorld.x / SCBaseDomainNode.TileSize);
            int sy = Mathf.RoundToInt(cursorWorld.y / SCBaseDomainNode.TileSize);
            int drawNodeRangeRadius = 4;
            float drawPixelRangeRadius = drawNodeRangeRadius * SCBaseDomainNode.TileSize;
            float maxCursorSize = 20;
            

            for (int x = sx - drawNodeRangeRadius; x <= sx + drawNodeRangeRadius; x++)
            {
                for (int y = sy - drawNodeRangeRadius; y <= sy + drawNodeRangeRadius; y++)
                {
                    for (int ox = 0; ox < 2; ox++)
                    {
                        for (int oy = 0; oy < 2; oy++)
                        {
                            var offset = new Vector2(ox, oy) * 0.5f;
                            var pos = (new Vector2(x, y) + offset) * SCBaseDomainNode.TileSize;

                            var distanceToCursor = (pos - cursorWorld).magnitude;
                            var cursorScale = Mathf.Clamp(1 - distanceToCursor / drawPixelRangeRadius, 0.0f, 1.0f);

                            // Ease the size
                            {
                                cursorScale = Mathf.Pow(cursorScale, 3);
                            }

                            float cursorSize = maxCursorSize * cursorScale;
                            var size = new Vector2(cursorSize, cursorSize);
                            pos -= size / 2.0f;
                            pos = camera.WorldToScreen(pos);

                            size /= camera.ZoomLevel;
                            var ringBounds = new Rect(pos, size);
                            var color = new Color(1, 0.3f, 0, cursorScale / 2.0f);
                            renderer.DrawTexture(ringBounds, ringTexture, ScaleMode.ScaleToFit, true, color);
                        }
                    }
                }
            }

            var selectedNodes = GetSelectedNodes();
            foreach (var node in selectedNodes)
            {
                var start = node.Bounds.center;
                var end = SCBaseDomainNode.GetSnapPosition(start);

                start = camera.WorldToScreen(start);
                end = camera.WorldToScreen(end);

                var color = new Color(0, 0, 0, 0.5f);
                renderer.DrawLine(color, start, end);
            }
        }
        
        public override void OnNodeSelectionChanged(UISystem uiSystem)
        {
            // Fetch all selected nodes
            var selectedNodes = (from node in graph.Nodes
                                where node.Selected
                                select node).ToArray();

            if (selectedNodes.Length > 0)
            {
                uiSystem.Platform.ShowObjectProperties(selectedNodes);
            }
            else
            {
                uiSystem.Platform.ShowObjectProperty(assetBeingEdited.hostThemeNode);
            }

        }
        
        protected override void SortNodesForDeletion(GraphNode[] nodesToDelete)
        {
        }

        public override void SortPinsForDrawing(GraphPin[] pins)
        {
        }

        protected override string GetGraphNotInitializedMessage()
        {
            if (AssignmentState == SpatialConstraintsEditorAssignmentState.NotAssigned)
            {
                return "Select a node in the theme editor to edit the Spatial Constraints";
            }
            else if (AssignmentState == SpatialConstraintsEditorAssignmentState.ConstraintsDisabled)
            {
                return "Enable Spatial Constraints in the node settings to start editing";
            }
            else
            {
                return "";
            }
        }

        public override void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            base.Init(graph, editorBounds, assetObject, uiSystem);

            events.OnNodeDragStart.Event += OnNodeDragStart_Event;
            events.OnNodeDragEnd.Event += OnNodeDragEnd_Event;
            events.OnNodeDragged.Event += OnNodeDragged_Event;
            events.OnNodeCreated.Event += OnNodeCreated_Event;

            camera.MaxAllowedZoom = 2.0f;
            renderCullingBias = SCBaseDomainNode.TileSize / 2.0f;

            OnEnable();
        }

        private void OnNodeCreated_Event(object sender, GraphNodeEventArgs e)
        {
            foreach (var node in e.Nodes)
            {
                if (node is SCBaseDomainNode)
                {
                    var baseNode = node as SCBaseDomainNode;
                    baseNode.SnapNode();
                }
            }
        }

        void SnapNodes(GraphNode[] nodes)
        {
            foreach (var node in nodes)
            {
                if (node is SCBaseDomainNode)
                {
                    var baseNode = node as SCBaseDomainNode;
                    baseNode.SnapNode();
                }
            }
        }

        private void OnNodeDragged_Event(object sender, GraphNodeEventArgs e)
        {
            foreach (var node in e.Nodes)
            {
                if (node is SCBaseDomainNode)
                {
                    var baseNode = node as SCBaseDomainNode;
                    var snappedCenter = SCBaseDomainNode.GetSnapPosition(baseNode.Bounds.center);
                    bool bCannotBeSnapped = baseNode.ContainsOtherNodeAt(snappedCenter);
                    baseNode.IsSnapped = !bCannotBeSnapped;
                }
            }
        }

        private void OnNodeDragEnd_Event(object sender, GraphNodeEventArgs e)
        {
            SnapNodes(e.Nodes);
            HandleGraphStateChanged(e.uiSystem);
        }

        private void OnNodeDragStart_Event(object sender, GraphNodeEventArgs e)
        {
        }

        protected override GraphEditorStyle CreateEditorStyle()
        {
            var editorStyle = new GraphEditorStyle();
            editorStyle.backgroundColor = Color.white;
            editorStyle.gridCellSpacing = SCBaseDomainNode.TileSize / 2.0f;
            editorStyle.gridLineColorThick = new Color(0, 0, 0, 0.2f);
            editorStyle.gridLineColorThin = new Color(0, 0, 0, 0.05f);
            editorStyle.gridScaling = true;
            editorStyle.branding = "Spatial Constraints";
            editorStyle.brandingColor = new Color(0, 0, 0, 0.2f);
            editorStyle.overlayTextColorLo = new Color(0, 0, 0, 0.2f);
            editorStyle.overlayTextColorHi = new Color(0, 0, 0, 0.6f);
            editorStyle.selectionBoxColor = new Color(0, 0.6f, 1, 0.6f);
            editorStyle.commentTextColor = Color.black;
            editorStyle.displayAssetFilename = false;
            editorStyle.brandingSize = 30;

            return editorStyle;
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Volumes\MarkerReplaceVolumeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for Negation volumes
    /// </summary>
    [CustomEditor(typeof(MarkerReplaceVolume))]
    public class MarkerReplaceVolumeEditor : VolumeEditor
    {
        public override void OnUpdate(SceneView sceneView)
        {
            dynamicUpdate = false;
            onlyReapplyTheme = true;
            base.OnUpdate(sceneView);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Volumes\MirrorVolumeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors
{   
    /// <summary>
    /// Custom property editor for Platform volumes
    /// </summary>
    [CustomEditor(typeof(MirrorVolume))]
    public class MirrorVolumeEditor : VolumeEditor
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Volumes\NegationVolumeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for Negation volumes
    /// </summary>
    [CustomEditor(typeof(NegationVolume))]
    public class NegationVolumeEditor : VolumeEditor
    {

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Volumes\PlatformVolumeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using DungeonArchitect.Builders.Grid;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for Platform volumes
    /// </summary>
    [CustomEditor(typeof(PlatformVolume))]
    public class PlatformVolumeEditor : VolumeEditor
    {
        public override void OnUpdate(SceneView sceneView)
        {
            base.OnUpdate(sceneView);
            /*
            var platform = target as PlatformVolume;
            if (platform != null)
            {
                var transform = platform.gameObject.transform;
                if (transform.hasChanged)
                {
                    OnTransformModified(platform);
                    transform.hasChanged = false;
                }
            }
            */
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Volumes\ThemeOverrideVolumeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for Theme override volumes
    /// </summary>
    [CustomEditor(typeof(ThemeOverrideVolume))]
    public class ThemeOverrideVolumeEditor : VolumeEditor
    {

        public override void OnUpdate(SceneView sceneView)
        {
            onlyReapplyTheme = true;
            base.OnUpdate(sceneView);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Volumes\VolumeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for volumes game objects
    /// </summary>
    [ExecuteInEditMode]
    public class VolumeEditor : Editor
    {
        IntVector positionOnGrid;
        IntVector sizeOnGrid;
        protected bool dynamicUpdate = true;
        protected bool onlyReapplyTheme = false;    // If true, Does not rebuild the layout and only applies the theme again over the existing layout
        protected bool requestRebuild = false;

        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            if (GUILayout.Button("Rebuild Dungeon"))
            {
                requestRebuild = true;
            }
        }


        void OnEnable()
        {
            EditorApplication.update += EditorUpdate;
            SceneView.duringSceneGui += OnUpdate;
        }

        void OnDisable()
        {
            SceneView.duringSceneGui -= OnUpdate;
            EditorApplication.update -= EditorUpdate;
        }

        void EditorUpdate()
        {
            if (requestRebuild)
            {
                Rebuild();
                requestRebuild = false;
            }
        }
        public virtual void OnUpdate(SceneView sceneView)
        {
            if (dynamicUpdate)
            {
                var volume = target as Volume;
                if (volume != null)
                {
                    var transform = volume.gameObject.transform;
                    if (transform.hasChanged)
                    {
                        OnTransformModified(volume);
                        transform.hasChanged = false;
                    }
                }
            }
        }

        void Rebuild()
        {
            var volume = target as Volume;
            if (volume != null && volume.dungeon != null)
            {
                var dungeon = volume.dungeon;
                if (onlyReapplyTheme)
                {
                    dungeon.ApplyTheme(new EditorDungeonSceneObjectInstantiator());
                }
                else
                {
                    dungeon.Build(new EditorDungeonSceneObjectInstantiator());
                }
            }
        }

        protected void OnTransformModified(Volume volume)
        {
            if (volume == null || volume.dungeon == null)
            {
                return;
            }
            var builder = volume.dungeon.GetComponent<DungeonBuilder>();
            if (builder == null)
            {
                return;
            }

            IntVector newPositionOnGrid, newSizeOnGrid;
            builder.OnVolumePositionModified(volume, out newPositionOnGrid, out newSizeOnGrid);

            if (!positionOnGrid.Equals(newPositionOnGrid) || !sizeOnGrid.Equals(newSizeOnGrid))
            {
                positionOnGrid = newPositionOnGrid;
                sizeOnGrid = newSizeOnGrid;
                OnGridTransformModified();
            }

        }

        void OnGridTransformModified()
        {
            requestRebuild = true;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\FlowEditorConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Editors.Flow
{
    public abstract class FlowEditorConfig : ScriptableObject
    {
        public bool randomizeSeed = true;
        public int seed = 0;

        public abstract DungeonBuilder FlowBuilder { get; }
        
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\FlowEditorWindow.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.DomainEditors;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow;
using DungeonArchitect.UI.Impl.UnityEditor;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.UI;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow
{
    public abstract class FlowEditorWindow : EditorWindow
    {
        protected UISystem uiSystem;
        protected UIRenderer renderer;
        protected List<IDeferredUICommand> deferredCommands = new List<IDeferredUICommand>();
        private FlowExecNodeOutputRegistry previewNodeOutputRegistry = null;
        private BorderWidget domainHostWidget;
        private IWidget domainEmptyWidget;
        private SpacerWidget toolbarPadding;
        private bool requestRepaint = false;

        [SerializeField]
        public FlowAssetBase flowAsset;
        
        [SerializeField]
        protected GraphPanel<FlowExecGraphEditor> execGraphPanel;
        
        [SerializeField]
        protected FlowEditorConfig editorConfig = null;
        
        [SerializeField]
        private List<FlowDomainEditor> domainEditors = new List<FlowDomainEditor>();
        
        protected abstract FlowEditorConfig CreateEditorConfig();
        protected abstract FlowExecNodeOutputRegistry GetLinkedDungeonNodeOutputRegistry();
        protected abstract bool IsDomainStateInvalid();
        protected abstract IWidget DomainLayoutWidget { get; set; }
        protected abstract void InitDomains();
        protected abstract string WindowTitle { get; }
        
        public virtual void Init(FlowAssetBase flowAsset)
        {
            CreateUISystem();
            this.flowAsset = flowAsset;
            titleContent = new GUIContent(WindowTitle);
            editorConfig = CreateEditorConfig();

            if (flowAsset == null)
            {
                uiSystem.ClearLayout();
                return;
            }
            
            domainEmptyWidget = new BorderWidget()
                .SetPadding(0, 0, 0, 0)
                .SetColor(new Color(0.15f, 0.15f, 0.15f))
                .SetContent(
                    new LabelWidget("Execute the graph and \r\nselect a node to preview")
                        .SetColor(new Color(1, 1, 1, 0.5f))
                        .SetFontSize(24)
                        .SetTextAlign(TextAnchor.MiddleCenter));
            
            DomainLayoutWidget = domainEmptyWidget;
            
            domainEditors.Clear();
            InitDomains();
            
            // Build the exec graph panel
            {
                execGraphPanel = new GraphPanel<FlowExecGraphEditor>(flowAsset.execGraph, flowAsset, uiSystem);
                execGraphPanel.GraphEditor.Events.OnNodeSelectionChanged.Event += OnExecNodeSelectionChanged;
                execGraphPanel.Border.SetTitle("Execution Graph");
                execGraphPanel.Border.SetColor(new Color(0.2f, 0.2f, 0.5f));
                
                // Add the flow domains
                var domains = new List<IFlowDomain>();
                foreach (var domainEditor in domainEditors)
                { 
                    if (domainEditor != null && domainEditor.FlowDomain != null)
                    {
                        domains.Add(domainEditor.FlowDomain);
                    }
                }

                execGraphPanel.GraphEditor.Domains = domains.ToArray();
            }

            BuildLayout();

            // Initialize the UI state
            {
                var bounds = new Rect(Vector2.zero, position.size);
                uiSystem.Update(bounds);
                
                // Reset the camera state of the exec graph editor
                execGraphPanel.GraphEditor.FocusCameraOnBestFit();
            }
        }

        void CreateUISystem()
        {
            uiSystem = new UnityEditorUISystem();
            renderer = new UnityEditorUIRenderer();
        }

        public virtual void SetReadOnly(bool readOnly)
        {
            if (execGraphPanel != null)
            {
                execGraphPanel.GraphEditor.SetReadOnly(readOnly);
            }

        }

        private void OnExecNodeSelectionChanged(object sender, GraphNodeEventArgs e)
        {
            var selectedNode = (e.Nodes.Length > 0) ? e.Nodes[0] as FlowExecRuleGraphNode : null;
            FlowExecRuleGraphNode targetNode = (selectedNode != null) ? selectedNode : flowAsset.execGraph.resultNode;
            UpdatePreview(targetNode);
            
            // Show the selected node in the inspector
            {
                var graph = flowAsset.execGraph;
                // Fetch the first selected node
                var selectedNodes = (from node in graph.Nodes
                    where node.Selected
                    select node).ToArray();

                if (selectedNodes.Length > 0)
                {
                    var node = selectedNodes[0];
                    if (node is FlowExecRuleGraphNode)
                    {
                        var ruleNode = node as FlowExecRuleGraphNode;
                        uiSystem.Platform.ShowObjectProperty(ruleNode.task);
                    }
                    else
                    {
                        uiSystem.Platform.ShowObjectProperty(node);
                    }
                }
                else
                {
                    uiSystem.Platform.ShowObjectProperty(editorConfig);
                }
            }
        }

        protected virtual IWidget CreateMainLayout(IWidget execGraphWidget, IWidget domainsWidget)
        {
            return new Splitter(SplitterDirection.Vertical)
                .AddWidget(execGraphWidget, 1)
                .AddWidget(domainsWidget, 2);
        }

        protected void BuildLayout()
        {
            domainHostWidget = new BorderWidget()
                .SetPadding(0, 0, 0, 0);

            if (DomainLayoutWidget == null)
            {
                DomainLayoutWidget = domainEmptyWidget;
            }
            domainHostWidget.SetContent(DomainLayoutWidget);

            IWidget layout = CreateMainLayout(execGraphPanel, domainHostWidget);

            toolbarPadding = new SpacerWidget(new Vector2(20, 20)); 
            layout = new StackPanelWidget(StackPanelOrientation.Vertical)
                .AddWidget(toolbarPadding, 0, true)
                .AddWidget(layout);
            
            uiSystem.SetLayout(layout);

            deferredCommands.Add(new EditorCommand_InitializeGraphCameras(layout));
        }

        void ShowEditorSettings()
        {
            uiSystem.Platform.ShowObjectProperty(editorConfig);
        }
        
        public void HandleExecuteButtonPressed()
        {
            ExecuteGraph();

            // Select the result node
            execGraphPanel.GraphEditor.SelectNode(flowAsset.execGraph.resultNode, uiSystem);

            UpdatePreview(flowAsset.execGraph.resultNode);
            
            requestRepaint = true;
        }

        protected virtual void AddDomainExtenders(FlowDomainExtensions domainExtensions)
        {
        }
        
        private void ExecuteGraph()
        {
            if (editorConfig.randomizeSeed)
            {
                editorConfig.seed = new System.Random().Next();
            }

            if (flowAsset == null)
            {
                return;
            }
            
            var execGraph = flowAsset.execGraph;
            var random = new System.Random(editorConfig.seed);

            var domainExtensions = new FlowDomainExtensions();
            AddDomainExtenders(domainExtensions);
            
            FlowExecutor executor = new FlowExecutor();
            if (!executor.Execute(execGraph, random, domainExtensions, 100, out previewNodeOutputRegistry))
            {
                Debug.LogError("Failed to produce graph");
            }

            // Build the reference scene dungeon, if specified
            if (editorConfig.FlowBuilder != null)
            {
                var dungeonGameObject = editorConfig.FlowBuilder.gameObject;
                if (dungeonGameObject != null)
                {
                    // Build the dungeon only if all the domains have a valid state
                    var allDomainsValid = true;
                    foreach (var domainEditor in domainEditors)
                    {
                        if (domainEditor != null && !domainEditor.StateValid)
                        {
                            allDomainsValid = false;
                            break;
                        }
                    }

                    if (allDomainsValid)
                    {
                        if (editorConfig.randomizeSeed)
                        {
                            var dungeonConfig = dungeonGameObject.GetComponent<DungeonConfig>();
                            if (dungeonConfig != null)
                            {
                                dungeonConfig.Seed = (uint) editorConfig.seed;
                            }
                        }

                        var dungeon = dungeonGameObject.GetComponent<Dungeon>();
                        if (dungeon != null)
                        {
                            dungeon.Build(new EditorDungeonSceneObjectInstantiator());
                            DungeonEditorHelper.MarkSceneDirty();
                        }
                    }
                }
            }
        }
       
        void UpdatePreview(FlowExecRuleGraphNode node)
        {
            if (node == null || node.task == null) return;
            if (previewNodeOutputRegistry == null) return;
            var execState = previewNodeOutputRegistry.Get(node.Id);

            var taskState = execState != null ? execState.State : null;
            UpdateDomainPreview(taskState);
            
            if (DomainLayoutWidget == null)
            {
                DomainLayoutWidget = domainEmptyWidget;
            }
            domainHostWidget.SetContent(DomainLayoutWidget);

            // Request a layout update
            var windowBounds = new Rect(Vector2.zero, position.size);
            deferredCommands.Add(new EditorCommand_UpdateWidget(uiSystem.Layout, windowBounds));
            deferredCommands.Add(new EditorCommand_InitializeGraphCameras(domainHostWidget));
        }

        protected virtual void OnEnable()
        {
            this.wantsMouseMove = true;

            Init(flowAsset);

            var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(uiSystem.Layout);
            graphEditors.ForEach(g => g.OnEnable());

            DungeonPropertyEditorHook.Get().DungeonBuilt += OnLinkedDungeonBuilt;
            InspectorNotify.FlowTaskPropertyChanged += OnTaskPropertyChanged;
        }

        protected virtual void OnDisable()
        {
            var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(uiSystem.Layout);
            graphEditors.ForEach(g => g.OnDisable());

            DungeonPropertyEditorHook.Get().DungeonBuilt -= OnLinkedDungeonBuilt;
            InspectorNotify.FlowTaskPropertyChanged -= OnTaskPropertyChanged;
        }

        private void OnTaskPropertyChanged(FlowExecTask task)
        {
            requestRepaint = true;
        }

        protected void RegisterDomainEditor(FlowDomainEditor domainEditor)
        {
            domainEditors.Add(domainEditor);
        }

        protected virtual void UpdateDomainPreview(FlowExecTaskState taskState)
        {
            foreach (var domainEditor in domainEditors)
            {
                if (domainEditor != null)
                {
                    domainEditor.UpdateNodePreview(taskState);
                }
            }
        }

        protected virtual void OnDestroy()
        {
            var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(uiSystem.Layout);
            graphEditors.ForEach(g =>
            {
                g.OnDisable();
                g.OnDestroy();
            });

            DungeonPropertyEditorHook.Get().DungeonBuilt -= OnLinkedDungeonBuilt;
            
            foreach (var domainEditor in domainEditors)
            {
                if (domainEditor != null)
                {
                    domainEditor.Destroy();
                }
            }
        }


        protected virtual void Update()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (IsEditorStateInvalid())
            {
                Init(flowAsset);
            }
            
            if (uiSystem != null)
            {
                var bounds = new Rect(Vector2.zero, position.size);
                uiSystem.Update(bounds);
                
                var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(uiSystem.Layout);
                graphEditors.ForEach(g => g.Update());
            }

            foreach (var domainEditor in domainEditors)
            {
                if (domainEditor != null)
                {
                    domainEditor.Update();
                }
            }

            // check if any of the domains require a repaint
            if (!requestRepaint)
            {
                foreach (var domainEditor in domainEditors)
                {
                    if (domainEditor != null && domainEditor.RequiresRepaint())
                    {
                        requestRepaint = true;
                        break;
                    }
                }
            }

            
            if (requestRepaint)
            {
                Repaint();
                requestRepaint = false;
            }
        }

        private void OnLinkedDungeonBuilt(Dungeon dungeon)
        {
            if (dungeon == null || flowAsset == null || flowAsset.execGraph == null || flowAsset.execGraph.resultNode == null) return;
            if (execGraphPanel == null) return;

            var linkedDungeonBuilder = editorConfig.FlowBuilder;
            if (linkedDungeonBuilder == null || linkedDungeonBuilder.gameObject == null) return;
            var linkedDungeon = linkedDungeonBuilder.gameObject.GetComponent<Dungeon>();
            if (dungeon != linkedDungeon) return;

            previewNodeOutputRegistry = GetLinkedDungeonNodeOutputRegistry();

            var resultNode = flowAsset.execGraph.resultNode;
            if (resultNode != null)
            {
                // Select the result node
                execGraphPanel.GraphEditor.SelectNode(resultNode, uiSystem);
                UpdatePreview(resultNode);
                uiSystem.Platform.ShowObjectProperty(dungeon.gameObject);
                requestRepaint = true;
            }
        }

        void UpdateDragDropState(Event e)
        {
            if (uiSystem != null)
            {
                if (e.type == EventType.DragUpdated)
                {
                    uiSystem.SetDragging(true);
                }
                else if (e.type == EventType.DragPerform || e.type == EventType.DragExited)
                {
                    uiSystem.SetDragging(false);
                }
            }
        }

        void ProcessDeferredCommands()
        {
            // Execute the deferred UI commands
            foreach (var command in deferredCommands)
            {
                command.Execute(uiSystem);
            }

            deferredCommands.Clear();
        }

        void DrawToolbar()
        {
            var guiState = new GUIState(renderer);
            renderer.backgroundColor = EditorGUIUtility.isProSkin
                ? new Color(0.5f, 0.5f, 1.0f, 1.0f)
                : new Color(0.85f, 0.85f, 1.0f, 1.0f);
            var rect = EditorGUILayout.BeginHorizontal(EditorStyles.toolbar, GUILayout.Height(30));

            var iconBuild = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_PLAY_16xb) as Texture2D;
            if (GUILayout.Button(new GUIContent("Build", iconBuild), EditorStyles.toolbarButton))
            {
                HandleExecuteButtonPressed();
            }
            GUILayout.Space(5);

            var iconSettings = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_SETTINGS_16x) as Texture2D;
            if (GUILayout.Button(new GUIContent(" Settings", iconSettings), EditorStyles.toolbarButton))
            {
                ShowEditorSettings();
            }

            GUILayout.FlexibleSpace();

            {
                renderer.backgroundColor = new Color(1, 0.25f, 0.25f, 1);
                renderer.color = Color.white;
                
                var iconDiscord = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_DISCORD_16x) as Texture2D;
                if (GUILayout.Button(new GUIContent(" Discord Support", iconDiscord), DungeonEditorStyles.discordToolButtonStyle))
                {
                    ExternalLinks.LaunchUrl(ExternalLinks.DiscordInvite);
                }

                renderer.backgroundColor = new Color(0.25f, 0.25f, 1, 1);
                renderer.color = Color.white;
                var iconDocs = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_DOCS_16x) as Texture2D;
                if (GUILayout.Button(new GUIContent("Documentation", iconDocs), DungeonEditorStyles.discordToolButtonStyle))
                {
                    ExternalLinks.LaunchUrl(ExternalLinks.Documentation);
                }

            }
            
            EditorGUILayout.EndHorizontal();

            if (toolbarPadding != null && rect.height > 0)
            {
                toolbarPadding.SetSize(new Vector2(1, rect.height));
            }
            
            guiState.Restore();
        }

        bool IsEditorStateInvalid()
        {
            if (domainEditors == null) return true;
            foreach (var domainEditor in domainEditors) {
                if (domainEditor == null)
                {
                    return true;
                }
            }

            if (IsDomainStateInvalid())
            {
                return true;
            }

            return false;
        }
        
        void OnGUI()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (uiSystem.Layout == null)
            {
                BuildLayout();
            }

            if (IsEditorStateInvalid())
            {
                // Wait for the next update cycle to fix this
                return;
            }

            var bounds = new Rect(Vector2.zero, position.size);
            renderer.DrawRect(bounds, new Color(0.5f, 0.5f, 0.5f));

            DrawToolbar();
            uiSystem.Draw(renderer);

            var e = Event.current;
            if (e != null)
            {
                if (e.isScrollWheel)
                {
                    requestRepaint = true;
                }

                switch (e.type)
                {
                    case EventType.MouseMove:
                    case EventType.MouseDrag:
                    case EventType.MouseDown:
                    case EventType.MouseUp:
                    case EventType.KeyDown:
                    case EventType.KeyUp:
                    case EventType.MouseEnterWindow:
                    case EventType.MouseLeaveWindow:
                        requestRepaint = true;
                        break;
                }
            }

            ProcessDeferredCommands();
            HandleInput(Event.current);
        }

        public void RequestRepaint()
        {
            requestRepaint = true;
        }

        void HandleInput(Event e)
        {
            if (uiSystem != null)
            {
                if (renderer == null)
                {
                    CreateUISystem();
                }

                if (uiSystem.Layout != null)
                {
                    var layout = uiSystem.Layout;
                    if (e.type == EventType.MouseDown || e.type == EventType.ScrollWheel)
                    {
                        WidgetUtils.ProcessInputFocus(e.mousePosition, uiSystem, layout);
                    }

                    if (uiSystem.IsDragDrop)
                    {
                        WidgetUtils.ProcessDragOperation(e, layout, uiSystem);
                    }

                    UpdateDragDropState(e);

                    if (uiSystem.FocusedWidget != null)
                    {
                        Vector2 resultMousePosition = Vector2.zero;
                        if (WidgetUtils.BuildWidgetEvent(e.mousePosition, layout, uiSystem.FocusedWidget, ref resultMousePosition))
                        {
                            Event widgetEvent = new Event(e);
                            widgetEvent.mousePosition = resultMousePosition;
                            uiSystem.FocusedWidget.HandleInput(widgetEvent, uiSystem);
                        }
                    }
                }
                
                foreach (var domainEditor in domainEditors)
                {
                    if (domainEditor != null)
                    {
                        domainEditor.HandleInput(uiSystem);
                    }
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\MarkerGenEditorWindow.cs:
 using System;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Editors.MarkerGenerator.Editors;
using DungeonArchitect.Editors.MarkerGenerator.TextGen;
using DungeonArchitect.Editors.MarkerGenerator.UI;
using DungeonArchitect.Editors.MarkerGenerator.UI.Viewport;
using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Nodes;
using DungeonArchitect.MarkerGenerator.Rule;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Impl.UnityEditor;
using DungeonArchitect.UI.Widgets;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator
{
    public class MarkerGenEditorWindow : EditorWindow
    {
        private UIRenderer renderer;
        private bool requestRepaint = false;

        private MarkerGenPatternListPanel patternListPanel;
        private PatternViewportWidget patternViewport;
        private ToolbarWidget patternViewportToolbar;
        private GraphPanel<MarkerGenRuleGraphEditor> ruleGraphPanel;
        private BorderWidget ruleGraphEditorHost;
        private IWidget ruleGraphNullWidget;
        private SpacerWidget toolbarPadding;
        private MarkerGenEditor editor;
        
        [SerializeField]
        private MarkerGenPattern activePattern = null;
        
        [SerializeField]
        private MarkerGenRule activeRule = null;
        
        static readonly string BTN_RECENTER_VIEW = "RecenterView";

        public UISystem uiSystem { get; private set; }
        public MarkerGeneratorAsset Asset { get; set; }
        
        private List<IDeferredUICommand> deferredCommands = new List<IDeferredUICommand>();

        private double lastUpdateTimestamp = 0;
        public void Init(MarkerGeneratorAsset asset)
        {
            titleContent = new GUIContent("Pattern Editor");
            Asset = asset;

            if (asset == null)
            {
                BuildEmptyLayout();
                return;
            }

            lastUpdateTimestamp = EditorApplication.timeSinceStartup;
            CreateUISystem();
            
            // Build the Rule graph
            {
                ruleGraphEditorHost = new BorderWidget()
                    .SetPadding(0, 0, 0, 0);
                
                ruleGraphNullWidget =  new BorderWidget()
                    .SetPadding(0, 0, 0, 0)
                    .SetColor(new Color(0.2f, 0.2f, 0.2f))
                    .SetContent(
                        new LabelWidget("Select a rule block to view the graph")
                            .SetColor(new Color(1, 1, 1, 0.5f))
                            .SetFontSize(24)
                            .SetTextAlign(TextAnchor.MiddleCenter));

                ruleGraphEditorHost.SetContent(ruleGraphNullWidget);
            }
            
            // Build the pattern list view panel
            {
                patternListPanel = new MarkerGenPatternListPanel(asset);
                patternListPanel.ListView.SelectionChanged += PatternListView_SelectionChanged;
                patternListPanel.ListView.ItemClicked += PatternListView_ItemClicked;
                patternListPanel.OnAddItem += OnAddPatternClicked;
                patternListPanel.OnRemoveItem += OnRemoveItemClicked;
            }

            // Build the pattern viewport
            {
                patternViewport = new PatternViewportWidget();
                patternViewport.SetClearState(true, true, new Color(0.90f, 0.95f, 1.0f));
                patternViewport.MoveSpeed = 8;
                
                patternViewportToolbar = new ToolbarWidget();
                patternViewportToolbar.ButtonSize = 24;
                patternViewportToolbar.Padding = 0;
                patternViewportToolbar.Background = new Color(0, 0, 0, 0);
                patternViewportToolbar.AddButton(BTN_RECENTER_VIEW, UIResourceLookup.ICON_ZOOMFIT_16x);
                patternViewportToolbar.ButtonPressed += RecenterPatternViewport;
            }
            
            editor = asset != null ? MarkerGenEditorFactory.Create(asset) : null;
            if (editor != null)
            {
                editor.PatternViewport = patternViewport;
                editor.RuleSelected += OnRuleSelected;
            }

            BuildLayout();

            if (activePattern == null)
            {
                activePattern = asset.patterns.Length > 0 ? asset.patterns[0] : null;
            }

            if (activePattern != null)
            {
                patternListPanel.ListView.SetSelectedItem(uiSystem, activePattern);
            }
        }

        private void OnRuleSelected(MarkerGenRule rule)
        {
            SetActiveRule(rule);
        }

        private void OnAddPatternClicked()
        {
            if (editor != null)
            {
                var pattern = MarkerGenEditorUtils.AddNewPattern(editor.PatternType, Asset, uiSystem.Platform);
                int index = Array.FindIndex(Asset.patterns, l => l == pattern);
                patternListPanel.ListView.NotifyDataChanged();
                patternListPanel.ListView.SetSelectedIndex(index);
            }
        }

        private void OnRemoveItemClicked(MarkerGenPattern pattern)
        {
            if (pattern != null)
            {
                string message = string.Format("Are you sure you want to delete the pattern \'{0}\'?", pattern.patternName);
                bool removeItem = EditorUtility.DisplayDialog("Delete Pattern?", message, "Delete", "Cancel");
                if (removeItem)
                {
                    int index = System.Array.FindIndex(Asset.patterns, r => r == pattern);
                    MarkerGenEditorUtils.RemovePattern(Asset, pattern);
                    patternListPanel.ListView.NotifyDataChanged();

                    if (index >= Asset.patterns.Length)
                    {
                        index = Asset.patterns.Length - 1;
                    }
                    patternListPanel.ListView.SetSelectedIndex(index);
                }
            }
        }

        private void OnEnable()
        {
            this.wantsMouseMove = true;
            if (ruleGraphPanel != null && ruleGraphPanel.GraphEditor != null)
            {
                ruleGraphPanel.GraphEditor.OnEnable();
            }
            
            DungeonPropertyEditorHook.Get().DungeonBuilt += OnLinkedDungeonBuilt;
            InspectorNotify.MarkerGenPropertyChanged += OnPropertyChanged;
        }
        
        private void OnDisable()
        {
            if (ruleGraphPanel != null && ruleGraphPanel.GraphEditor != null)
            {
                ruleGraphPanel.GraphEditor.OnDisable();
            }

            if (patternViewport != null)
            {
                patternViewport.Release();
            }

            DungeonPropertyEditorHook.Get().DungeonBuilt -= OnLinkedDungeonBuilt;
            InspectorNotify.MarkerGenPropertyChanged -= OnPropertyChanged;
        }

        private void OnPropertyChanged(object obj)
        {
            if (obj is GraphNode || obj is GraphPin || obj is Graph)
            {
                RuleGraphChanged();
            }
            if (editor != null && obj is MarkerGenRule rule)
            {
                editor.HandleRulePropertyChange(rule);
            }

            requestRepaint = true;
        }

        private void OnLinkedDungeonBuilt(Dungeon dungeon)
        {
        }

        private void RecenterPatternViewport(UISystem uiSystem, string id)
        {
            if (id == BTN_RECENTER_VIEW)
            {
                patternViewport.RecenterView();
            }
        }

        void Update()
        {
            double frameTime = EditorApplication.timeSinceStartup - lastUpdateTimestamp;
            lastUpdateTimestamp = EditorApplication.timeSinceStartup;
            
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (Asset == null)
            {
                return;
            }
            
            if (IsEditorStateInvalid())
            {
                Init(Asset);
            }

            var bounds = new Rect(Vector2.zero, position.size);
            if (uiSystem != null)
            {
                uiSystem.Update(bounds);
            }

            if (editor != null)
            {
                editor.Update(frameTime);
                if (editor.RequestRepaint)
                {
                    editor.RequestRepaint = false;
                    patternViewport?.Invalidate();
                    requestRepaint = true;
                }
            }
            
            if (patternViewport != null)
            {
                requestRepaint |= patternViewport.RequiresRepaint();
            }
            
            if (requestRepaint)
            {
                Repaint();
                requestRepaint = false;
            }
            
            ProcessDeferredCommands();
        }

        void OnGUI()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (Asset == null)
            {
                return;
            }

            if (uiSystem.Layout == null)
            {
                BuildLayout();
            }
            
            if (ruleGraphPanel != null && ruleGraphPanel.GraphEditor != null)
            {
                ruleGraphPanel.GraphEditor.Update();
            }

            if (IsEditorStateInvalid())
            {
                // Wait for the next update cycle to fix this
                return;
            }
            
            var bounds = new Rect(Vector2.zero, position.size);
            renderer.DrawRect(bounds, new Color(0.5f, 0.5f, 0.5f));

            DrawToolbar();
            uiSystem.Draw(renderer);
            
            var e = Event.current;
            if (e != null)
            {
                if (e.isScrollWheel)
                {
                    requestRepaint = true;
                }

                switch (e.type)
                {
                    case EventType.MouseMove:
                    case EventType.MouseDrag:
                    case EventType.MouseDown:
                    case EventType.MouseUp:
                    case EventType.KeyDown:
                    case EventType.KeyUp:
                    case EventType.MouseEnterWindow:
                    case EventType.MouseLeaveWindow:
                        requestRepaint = true;
                        break;
                }
            }
            
            HandleInput(Event.current);
        }

        void DrawToolbar()
        {
            var guiState = new GUIState(renderer);
            var rect = EditorGUILayout.BeginHorizontal(EditorStyles.toolbar, GUILayout.Height(30));

            var iconBuild = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_PLAY_16xb) as Texture2D;
            renderer.backgroundColor = new Color(1, 0.25f, 0.25f, 1);

            if (GUILayout.Button(new GUIContent("Rebuild Dungeon", iconBuild), EditorStyles.toolbarButton))
            {
                HandleRebuildDungeonButtonPressed();
            }
            GUILayout.Space(5);
            renderer.backgroundColor = EditorGUIUtility.isProSkin
                ? new Color(0.5f, 0.5f, 0.5f, 1.0f)
                : new Color(0.85f, 0.85f, 0.85f, 1.0f);

            GUILayout.FlexibleSpace();

            {
                renderer.color = Color.white;
                
                var iconDiscord = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_DISCORD_16x) as Texture2D;
                if (GUILayout.Button(new GUIContent(" Discord Support", iconDiscord), DungeonEditorStyles.discordToolButtonStyle))
                {
                    ExternalLinks.LaunchUrl(ExternalLinks.DiscordInvite);
                }

                renderer.backgroundColor = new Color(0.25f, 0.25f, 1, 1);
                renderer.color = Color.white;
                var iconDocs = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_DOCS_16x) as Texture2D;
                if (GUILayout.Button(new GUIContent("Documentation", iconDocs), DungeonEditorStyles.discordToolButtonStyle))
                {
                    ExternalLinks.LaunchUrl(ExternalLinks.DocumentationPatternEditor);
                }

            }
            
            EditorGUILayout.EndHorizontal();

            if (toolbarPadding != null && rect.height > 0)
            {
                toolbarPadding.SetSize(new Vector2(1, rect.height));
            }
            
            guiState.Restore();
        }

        void FindAndRebuildTrackedDungeons()
        {
            var trackedDungeons = UnityEngine.Object.FindObjectsOfType<Dungeon>();
            trackedDungeons = trackedDungeons.Where(d => d.patterns.Contains(Asset)).ToArray();
            foreach (var trackedDungeon in trackedDungeons)
            {
                trackedDungeon.Build(new EditorDungeonSceneObjectInstantiator());
            }
        }

        private void HandleRebuildDungeonButtonPressed()
        {
            FindAndRebuildTrackedDungeons();
        }

        void ProcessDeferredCommands()
        {
            // Execute the deferred UI commands
            foreach (var command in deferredCommands)
            {
                command.Execute(uiSystem);
            }

            deferredCommands.Clear();
        }

        void HandleInput(Event e)
        {
            if (uiSystem != null)
            {
                if (renderer == null)
                {
                    CreateUISystem();
                }

                if (uiSystem.Layout != null)
                {
                    var layout = uiSystem.Layout;
                    if (e.type == EventType.MouseDown || e.type == EventType.ScrollWheel || e.type == EventType.MouseMove)
                    {
                        WidgetUtils.ProcessInputFocus(e.mousePosition, uiSystem, layout);
                    }

                    if (uiSystem.IsDragDrop)
                    {
                        WidgetUtils.ProcessDragOperation(e, layout, uiSystem);
                    }

                    UpdateDragDropState(e);

                    if (uiSystem.FocusedWidget != null)
                    {
                        Vector2 resultMousePosition = Vector2.zero;
                        if (WidgetUtils.BuildWidgetEvent(e.mousePosition, layout, uiSystem.FocusedWidget, ref resultMousePosition))
                        {
                            Event widgetEvent = new Event(e);
                            widgetEvent.mousePosition = resultMousePosition;
                            uiSystem.FocusedWidget.HandleInput(widgetEvent, uiSystem);

                            if (uiSystem.FocusedWidget == patternViewport && editor != null)
                            {
                                editor.HandleInput(widgetEvent, uiSystem);
                            }
                        }
                    }
                }
            }
        }
        
        void UpdateDragDropState(Event e)
        {
            if (uiSystem != null)
            {
                if (e.type == EventType.DragUpdated)
                {
                    uiSystem.SetDragging(true);
                }
                else if (e.type == EventType.DragPerform || e.type == EventType.DragExited)
                {
                    uiSystem.SetDragging(false);
                }
            }
        }
        
        private void PatternListView_SelectionChanged(MarkerGenPattern item)
        {
            SetActivePattern(item);
            Selection.activeObject = item;
        }

        private void PatternListView_ItemClicked(MarkerGenPattern item)
        {
            SetActivePattern(item);
            Selection.activeObject = item;
        }

        private void SetActivePattern(MarkerGenPattern pattern)
        {
            activePattern = pattern;
            LoadScene(pattern);
            SetActiveRule(null);
        }

        private void LoadScene(MarkerGenPattern pattern)
        {
            if (patternViewport != null && uiSystem != null)
            {
                patternViewport.World.Clear();

                if (editor != null)
                {
                    editor.LoadScene(pattern, uiSystem.Platform);
                }
                
                patternViewport.RecenterView();
            }
        }
        
        private void SetActiveRule(MarkerGenRule rule)
        {
            activeRule = rule;
            SetRuleGraph(rule);
        }

        private void SetRuleGraph(MarkerGenRule rule)
        {
            var ruleGraph = rule != null ? rule.ruleGraph : null;
            if (ruleGraph != null)
            {
                ruleGraphPanel = new GraphPanel<MarkerGenRuleGraphEditor>(ruleGraph, Asset, uiSystem);
                ruleGraphPanel.Border.SetTitle("Rule Graph");
                ruleGraphPanel.Border.SetColor(new Color(0.2f, 0.3f, 0.2f));
                ruleGraphPanel.GraphEditor.supportInteractiveWidgets = true;
                ruleGraphPanel.GraphEditor.GraphChanged += (graph, system) => RuleGraphChanged();
                ruleGraphEditorHost.SetContent(ruleGraphPanel);

                InitializeRuleGraphCamera();
                UpdateCompileStatus();
            }
            else
            {
                ruleGraphEditorHost.SetContent(ruleGraphNullWidget);
            }            
        }

        private void RuleGraphChanged()
        {
            if (activeRule == null)
            {
                return;
            }
            
            // Compile the rule program whenever the graph changes
            CompileProgram(uiSystem.Platform);
            UpdateCompileStatus();
            
            if (editor != null)
            {
                editor.OnRuleGraphChanged(activeRule);
            }
        }

        private void UpdateCompileStatus()
        {
            if (activeRule != null && ruleGraphPanel != null && ruleGraphPanel.GraphEditor != null)
            {
                ruleGraphPanel.GraphEditor.drawInvalidGraphMessage = (activeRule.program != null && !activeRule.program.compiled);
            }
        }
        
        public void CompileProgram(UIPlatform platform)
        {
            if (activeRule != null && activeRule.ruleGraph != null)
            {
                MarkerGenEditorUtils.CompileRule(activeRule, Asset, platform);
            }
        }
        
        void InitializeRuleGraphCamera()
        {
            if (uiSystem != null && uiSystem.Layout != null)
            {
                deferredCommands.Add(new EditorCommand_InitializeGraphCameras(uiSystem.Layout));
            }
        }
        
        void CreateUISystem()
        {
            uiSystem = new UnityEditorUISystem();
            renderer = new UnityEditorUIRenderer();
        }

        bool IsEditorStateInvalid()
        {
            return patternListPanel == null 
                   || ruleGraphEditorHost == null
                   || editor == null
                   || patternViewport == null
                   || patternViewport.Renderer == null
                   || patternViewport.Renderer.Texture == null
        ;
    }

        void BuildLayout()
        {
            IWidget layout = new Splitter(SplitterDirection.Vertical)
                    .AddWidget(
                        new Splitter(SplitterDirection.Horizontal)
                            .AddWidget(patternListPanel)
                            .AddWidget(new OverlayPanelWidget()
                                .AddWidget(patternViewport)
                                .AddWidget(patternViewportToolbar, OverlayPanelHAlign.Right, OverlayPanelVAlign.Top, new Vector2(24, 24), new Vector2(10, 10))
                                , 4)
                    )
                    .AddWidget(ruleGraphEditorHost)
                ;

            toolbarPadding = new SpacerWidget(new Vector2(20, 20)); 
            layout = new StackPanelWidget(StackPanelOrientation.Vertical)
                .AddWidget(toolbarPadding, 0, true)
                .AddWidget(layout);
            
            uiSystem.SetLayout(layout);

            deferredCommands.Add(new EditorCommand_InitializeGraphCameras(layout));
        }

        private void BuildEmptyLayout()
        {
            var layout = new LabelWidget("Open a Theme Pattern to start editing")
                .SetColor(new Color(1, 1, 1, 0.5f))
                .SetFontSize(24)
                .SetTextAlign(TextAnchor.MiddleCenter);
            
            uiSystem.SetLayout(layout);
        }


        private void ButtonOnButtonPressed(UISystem uisystem)
        {
            Debug.Log("Button pressed");
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\RoomDesigner\DungeonRoomDesignerEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.RoomDesigner.Editors
{
    [CustomEditor(typeof(DungeonRoomDesigner))]
    public class DungeonRoomDesignerEditor : Editor
    {
        private DungeonRoomDesignerTools activeTool = null;
        private DungeonRoomDesignerToolbar toolbar = new DungeonRoomDesignerToolbar();

        protected virtual void OnSceneGUI()
        {
            var room = target as DungeonRoomDesigner;
            if (toolbar.Draw(room) || activeTool == null)
            {
                CreateToolInstance();
            }

            // Draw the active tool
            if (activeTool != null)
            {
                activeTool.DrawSceneGUI(room);
            }
        }


        void CreateToolInstance()
        {
            activeTool = null;
            if (toolbar.MainToolIndex == 0 && toolbar.SubToolIndex == 0)
            {
                activeTool = new DungeonRoomDesignerTool_RoomMove();
            }
            else if (toolbar.MainToolIndex == 0 && toolbar.SubToolIndex == 1)
            {
                activeTool = new DungeonRoomDesignerTool_RoomBounds();
            }

            else if (toolbar.MainToolIndex == 1 && toolbar.SubToolIndex == 0)
            {
                activeTool = new DungeonRoomDesignerTool_DoorMove();
            }
            else if (toolbar.MainToolIndex == 1 && toolbar.SubToolIndex == 1)
            {
                activeTool = new DungeonRoomDesignerTool_DoorBounds();
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\RoomDesigner\DungeonRoomDesignerTool.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.RoomDesigner.Editors
{
    public abstract class DungeonRoomDesignerTools
    {
        public abstract void DrawSceneGUI(DungeonRoomDesigner room);

        protected Vector3 GetWorldCoord(IntVector iv, Vector3 gridSize)
        {
            return Vector3.Scale(iv.ToVector3(), gridSize);
        }

        protected void RequestRebuild(DungeonRoomDesigner room)
        {
            if (room.realtimeUpdate && room.dungeon != null)
            {
                room.dungeon.Build();
            }
        }

    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\RoomDesigner\DungeonRoomDesignerToolbar.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;

namespace DungeonArchitect.RoomDesigner.Editors
{
    public class DungeonRoomDesignerToolbar
    {
        private int mainToolIndex = 1;
        public int MainToolIndex
        {
            get { return mainToolIndex; }
            set { mainToolIndex = value; }
        }

        private int subToolIndex = 0;
        public int SubToolIndex
        {
            get { return subToolIndex; }
            set { subToolIndex = value; }
        }


        public bool Draw(DungeonRoomDesigner room)
        {
            EditorGUI.BeginChangeCheck();
            DrawMainToolbar();
            DrawSubToolbar();
            return EditorGUI.EndChangeCheck();
        }

        void DrawMainToolbar()
        {
            Handles.BeginGUI();
            string[] tabs = new string[] { "Room", "Doors" };

            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            mainToolIndex = GUILayout.Toolbar(mainToolIndex, tabs);
            GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();
            Handles.EndGUI();
        }

        void DrawSubToolbar()
        {
            Handles.BeginGUI();
            string[] tabs;

            if (mainToolIndex == 0)
            {
                tabs = new string[] { "Move", "Bounds" };
            }
            else if (mainToolIndex == 1)
            {
                tabs = new string[] { "Move", "Bounds" };
            }
            else
            {
                tabs = new string[0];
            }

            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            subToolIndex = GUILayout.Toolbar(subToolIndex, tabs);
            GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();
            Handles.EndGUI();
        }
        
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\SnapEditorUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Grammar;
using System.Linq;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class SnapEditorUtils 
    {
        #region Asset Management
        public static void InitAsset(SnapFlowAsset asset, UIPlatform platform)
        {
            if (asset == null) return;

            asset.executionGraph = CreateAssetObject<GrammarExecGraph>(asset);
            asset.resultGraph = CreateAssetObject<GrammarGraph>(asset);
            asset.productionRules = new GrammarProductionRule[0];
            asset.nodeTypes = new GrammarNodeType[0];

            var startNodeType = AddNodeType(asset, "S");
            var taskNodeType = AddNodeType(asset, "T");

            asset.wildcardNodeType = CreateAssetObject<GrammarNodeType>(asset);
            asset.wildcardNodeType.nodeName = "*";
            asset.wildcardNodeType.wildcard = true;

            var startRule = AddProductionRule(asset, "Start Rule");
            InitializeStartRule(startRule, startNodeType, taskNodeType, asset, platform);

            InitializeExecutionGraph(asset, startRule, platform);
        }

        static T CreateGraphNode<T>(Vector2 position, Graph graph, SnapFlowAsset asset, UIPlatform platform) where T : GraphNode
        {
            var node = GraphOperations.CreateNode(graph, typeof(T), null);
            GraphEditorUtils.AddToAsset(platform, asset, node);
            return node as T;
        }

        static void InitializeStartRule(GrammarProductionRule startRule, GrammarNodeType startNodeType, GrammarNodeType taskNodeType, SnapFlowAsset asset, UIPlatform platform)
        {
            var startNode = CreateGraphNode<GrammarTaskNode>(Vector2.zero, startRule.LHSGraph, asset, platform);
            startNode.NodeType = startNodeType;

            if (startRule.RHSGraphs.Count > 0)
            {
                var taskNode = CreateGraphNode<GrammarTaskNode>(Vector2.zero, startRule.RHSGraphs[0].graph, asset, platform);
                taskNode.NodeType = taskNodeType;
            }
        }

        private static T CreateAssetObject<T>(SnapFlowAsset asset) where T : ScriptableObject
        {
            var obj = ScriptableObject.CreateInstance<T>();
            obj.hideFlags = HideFlags.HideInHierarchy;
            AssetDatabase.AddObjectToAsset(obj, asset);
            return obj;
        }

        private static void DestroyAssetObject<T>(T obj) where T : ScriptableObject
        {
            //AssetDatabase.RemoveObjectFromAsset(obj);
            Undo.DestroyObjectImmediate(obj);
        }
        #endregion

        #region Production Rule Management
        public static GrammarProductionRule AddProductionRule(SnapFlowAsset asset, string ruleName)
        {
            if (asset == null) return null;

            var production = CreateAssetObject<GrammarProductionRule>(asset);
            production.ruleName = ruleName;

            production.LHSGraph = CreateAssetObject<GrammarGraph>(asset);
            AddProductionRuleRHS(asset, production);

            asset.productionRules = asset.productionRules.Concat(new []{ production }).ToArray();
            return production;
        }
        public static void RemoveProductionRule(SnapFlowAsset asset, GrammarProductionRule production)
        {
            if (asset == null) return;

            asset.productionRules = asset.productionRules.Where(p => p != production).ToArray();

            // TODO: Remove LHS and RHS graphs
            DestroyAssetObject(production.LHSGraph);
            foreach (var rhs in production.RHSGraphs)
            {
                DestroyAssetObject(rhs.graph);
                DestroyAssetObject(rhs);
            }

            DestroyAssetObject(production);
        }
        #endregion

        #region Production Rule RHS Management
        public static WeightedGrammarGraph AddProductionRuleRHS(SnapFlowAsset asset, GrammarProductionRule production)
        {
            if (asset == null) return null;

            var RHSGraph = CreateAssetObject<WeightedGrammarGraph>(asset);
            RHSGraph.weight = 1;
            RHSGraph.graph = CreateAssetObject<GrammarGraph>(asset);

            //production.RHSGraphs = production.RHSGraphs.Concat(new[] { RHSGraph }).ToArray();
            production.RHSGraphs.Add(RHSGraph);

            return RHSGraph;
        }
        public static void RemoveProductionRuleRHS(GrammarProductionRule production, WeightedGrammarGraph rhs)
        {
            if (production == null) return;

            //production.RHSGraphs = production.RHSGraphs.Where(r => r.graph != rhs.graph).ToArray();
            production.RHSGraphs.Remove(rhs);

            DestroyAssetObject(rhs.graph);
            DestroyAssetObject(rhs);
        }
        #endregion

        #region Node Type Management
        public static GrammarNodeType AddNodeType(SnapFlowAsset asset, string nodeName)
        {
            if (asset == null) return null;

            var nodeType = CreateAssetObject<GrammarNodeType>(asset);
            nodeType.nodeName = nodeName;

            asset.nodeTypes = asset.nodeTypes.Concat(new[] { nodeType }).ToArray();
            return nodeType;
        }
        public static void RemoveNodeType(SnapFlowAsset asset, GrammarNodeType nodeType)
        {
            if (asset == null) return;

            asset.nodeTypes = asset.nodeTypes.Where(t => t != nodeType).ToArray();
            DestroyAssetObject(nodeType);
        }

        #endregion

        #region Execution Graph Management

        private static void InitializeExecutionGraph(SnapFlowAsset asset, GrammarProductionRule startRule, UIPlatform platform)
        {
            // Create an entry node in the execution graph
            var entryNode = CreateGraphNode<GrammarExecEntryNode>(Vector2.zero, asset.executionGraph, asset, platform);
            entryNode.Position = Vector2.zero;
            asset.executionGraph.entryNode = entryNode;

            var execRuleNode = CreateGraphNode<GrammarExecRuleNode>(Vector2.zero, asset.executionGraph, asset, platform);
            execRuleNode.rule = startRule;
            execRuleNode.Position = new Vector2(120, 0);

            var link = GraphOperations.CreateLink<GraphLink>(asset.executionGraph);
            GraphEditorUtils.AddToAsset(platform, asset, link);
            link.Input = execRuleNode.InputPin;
            link.Output = entryNode.OutputPin;
        }

        #endregion
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\SnapEditorWindow.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Grammar;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI.Impl.UnityEditor;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class SnapEditorWindow : EditorWindow
    {
        ProductionRuleWidget ruleEditor;
        RuleListPanel ruleListPanel;
        NodeListPanel nodeListPanel;
        ErrorListPanel errorListPanel;

        GraphPanel<SnapEdResultGraphEditor> resultGraphPanel; 
        GraphPanel<SnapEdExecutionGraphEditor> execGraphPanel;
        SpacerWidget toolbarPadding;

        DungeonFlowErrorList errorList;
        UIRenderer renderer;
        private bool requestRepaint = false;
        
        public UISystem uiSystem { get; private set; }
        public SnapFlowAsset FlowAsset { get; set; }

        List<IDeferredUICommand> deferredCommands = new List<IDeferredUICommand>();

        readonly static string CMD_EXEC_GRAMMAR = "ExecuteGrammar";

        public void Init(SnapFlowAsset flowAsset)
        {
            titleContent = new GUIContent("Snap Flow Editor");
            this.FlowAsset = flowAsset;
            ruleEditor = new ProductionRuleWidget();
            CreateUISystem();

            // Build the result graph
            {
                var resultGraph = flowAsset ? flowAsset.resultGraph : null;
                resultGraphPanel = new GraphPanel<SnapEdResultGraphEditor>(resultGraph, flowAsset, uiSystem);
                resultGraphPanel.Border.SetTitle("Result Graph");
                resultGraphPanel.Border.SetColor(new Color(0.2f, 0.3f, 0.2f));
                LoadResultGraphEditorState();
            }

            // Build the execution graph
            {
                var execToolbar = new ToolbarWidget();
                execToolbar.ButtonSize = 24;
                execToolbar.Padding = 4;
                execToolbar.Background = new Color(0, 0, 0, 0);
                execToolbar.AddButton(CMD_EXEC_GRAMMAR, UIResourceLookup.ICON_PLAY_16x);
                execToolbar.ButtonPressed += ExecToolbar_ButtonPressed;

                var graph = flowAsset ? flowAsset.executionGraph : null;
                execGraphPanel = new GraphPanel<SnapEdExecutionGraphEditor>(graph, flowAsset, uiSystem, execToolbar);
                execGraphPanel.Border.SetTitle("Execution Graph");
                execGraphPanel.Border.SetColor(new Color(0.2f, 0.2f, 0.5f));
            }

            // Build the rule list view
            {
                ruleListPanel = new RuleListPanel(flowAsset);
                ruleListPanel.ListView.SelectionChanged += RuleListView_SelectionChanged;
                ruleListPanel.ListView.ItemClicked += RuleListView_ItemClicked;
            }

            // Build the node list view
            {
                nodeListPanel = new NodeListPanel(flowAsset);
                nodeListPanel.ListView.SelectionChanged += NodeListView_SelectionChanged;
                nodeListPanel.ListView.ItemClicked += NodeListView__ItemClicked;
            }

            // Build the error list panel
            {
                errorList = new DungeonFlowErrorList();
                errorListPanel = new ErrorListPanel(errorList);
                errorListPanel.ListView.ItemDoubleClicked += ErrorListView_ItemDoubleClicked;
            }

            BuildLayout();
            
            // Select the first rule for modification
            ruleListPanel.ListView.SetSelectedIndex(0);
        }

        void CreateUISystem()
        {
            uiSystem = new UnityEditorUISystem();
            renderer = new UnityEditorUIRenderer();
        }

        private void ExecToolbar_ButtonPressed(UISystem uiSystem, string id)
        {
            if (id == CMD_EXEC_GRAMMAR)
            {
                deferredCommands.Add(new EditorCommand_ExecuteSnapFlowGraph(this));
            }
        }

        public void ExecuteGraphGrammar(UISystem uiSystem)
        {
            if (FlowAsset != null)
            {
                var settings = new GraphGrammarProcessorSettings();
                settings.seed = Random.Range(0, 100000);
                settings.runGraphGenerationScripts = false;
                var processor = new GraphGrammarProcessor(FlowAsset, settings);
                processor.Build();

                if (FlowAsset != null && FlowAsset.resultGraph != null)
                {
                    resultGraphPanel.GraphEditor.RefreshGraph(FlowAsset.resultGraph, processor.Grammar.ResultGraph, uiSystem);
                    SaveResultGraphEditorState();
                }
            }
            else
            {
                Debug.LogWarning("No Flow asset has been define. Please load a snap flow graph first");
            }
        }

        private void RuleListView_ItemClicked(GrammarProductionRule rule)
        {
            UpdateProductionRuleGraphCameras(rule);
            Selection.activeObject = rule;
        }

        private void NodeListView__ItemClicked(GrammarNodeType nodeType)
        {
            Selection.activeObject = nodeType;
        }

        private void ErrorListView_ItemDoubleClicked(DungeonFlowErrorEntry Item)
        {
            if (Item.Action != null)
            {
                Item.Action.Execute(this);
            }
        }

        private void NodeListView_SelectionChanged(GrammarNodeType nodeType)
        {
        }

        private void RuleListView_SelectionChanged(GrammarProductionRule rule)
        {
            UpdateProductionRuleGraphCameras(rule);
        }

        void UpdateProductionRuleGraphCameras(GrammarProductionRule rule)
        {
            if (ruleEditor != null)
            {
                ruleEditor.Init(FlowAsset, rule, uiSystem);
                ruleEditor.UpdateWidget(uiSystem, ruleEditor.WidgetBounds);

                deferredCommands.Add(new EditorCommand_InitializeGraphCameras(ruleEditor));
            }
        }


        public IWidget GetRootLayout() { return uiSystem.Layout; }
        public ProductionRuleWidget GetProductionRuleWidget() { return ruleEditor; }
        public RuleListPanel GetRuleListPanel() { return ruleListPanel; }
        public NodeListPanel GetNodeListPanel() { return nodeListPanel; }
        public ErrorListPanel GetErrorListPanel() { return errorListPanel; }
        public GraphPanel<SnapEdExecutionGraphEditor> GetExecGraphPanel() { return execGraphPanel; }
        public GraphPanel<SnapEdResultGraphEditor> GetResultGraphPanel() { return resultGraphPanel; }

        public void AddDeferredCommand(IDeferredUICommand command)
        {
            deferredCommands.Add(command);
        }

        void Update()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }
            
            var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(uiSystem.Layout);
            graphEditors.ForEach(g => g.Update());
            
            if (requestRepaint)
            {
                Repaint();
                requestRepaint = false;
            }
        }

        void DrawToolbar()
        {
            var guiState = new GUIState(renderer);
            renderer.backgroundColor = EditorGUIUtility.isProSkin
                ? new Color(0.5f, 0.5f, 1.0f, 1.0f)
                : new Color(0.85f, 0.85f, 1.0f, 1.0f);
            
            var rect = EditorGUILayout.BeginHorizontal(EditorStyles.toolbar, GUILayout.Height(30));

            var iconBuild = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_PLAY_16xb) as Texture2D;
            if (GUILayout.Button(new GUIContent("Build", iconBuild), EditorStyles.toolbarButton))
            {
                deferredCommands.Add(new EditorCommand_ExecuteSnapFlowGraph(this));
            }

            GUILayout.FlexibleSpace();
            
            {
                renderer.backgroundColor = new Color(1, 0.25f, 0.25f, 1);
                renderer.color = Color.white;
                
                var iconDiscord = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_DISCORD_16x) as Texture2D;
                if (GUILayout.Button(new GUIContent(" Discord Support", iconDiscord), DungeonEditorStyles.discordToolButtonStyle))
                {
                    ExternalLinks.LaunchUrl(ExternalLinks.DiscordInvite);
                }

                renderer.backgroundColor = new Color(0.25f, 0.25f, 1, 1);
                renderer.color = Color.white;
                var iconDocs = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_DOCS_16x) as Texture2D;
                if (GUILayout.Button(new GUIContent("Documentation", iconDocs), DungeonEditorStyles.discordToolButtonStyle))
                {
                    ExternalLinks.LaunchUrl(ExternalLinks.Documentation);
                }

            }
            
            EditorGUILayout.EndHorizontal();

            if (toolbarPadding != null && rect.height > 0)
            {
                toolbarPadding.SetSize(new Vector2(1, rect.height));
            }
            
            guiState.Restore();
        }

        void OnGUI()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (uiSystem.Layout == null)
            {
                BuildLayout();
            }

            // Draw the background
            var bounds = new Rect(Vector2.zero, position.size);
            renderer.DrawRect(bounds, new Color(0.5f, 0.5f, 0.5f));

            DrawToolbar();
            
            uiSystem.Update(bounds);
            uiSystem.Draw(renderer);

            ProcessDeferredCommands();

            var e = Event.current;
            if (e != null)
            {
                if (e.isScrollWheel)
                {
                    requestRepaint = true;
                }

                switch (e.type)
                {
                    case EventType.MouseMove:
                    case EventType.MouseDrag:
                    case EventType.MouseDown:
                    case EventType.MouseUp:
                    case EventType.KeyDown:
                    case EventType.KeyUp:
                    case EventType.MouseEnterWindow:
                    case EventType.MouseLeaveWindow:
                        requestRepaint = true;
                        break;
                }
            }

            HandleInput(e);
        }


        void ProcessDeferredCommands()
        {
            // Execute the deferred UI commands
            foreach (var command in deferredCommands)
            {
                command.Execute(uiSystem);
            }

            deferredCommands.Clear();
        }

        void PerformValidation()
        {
            if (errorListPanel == null)
            {
                return;
            }

            int selectedIndex = errorListPanel.ListView.GetSelectedIndex();
            var scrollPosition = errorListPanel.ListView.ScrollView.ScrollPosition;

            errorList.Errors.Clear();
            SnapEdValidator.Validate(FlowAsset, errorList);

            // Notify the list view that the data has changed and restore the selected index after a reload
            errorListPanel.ListView.NotifyDataChanged();
            errorListPanel.ListView.SetSelectedIndex(selectedIndex);
            errorListPanel.ListView.ScrollView.ScrollPosition = scrollPosition;
        }

        void BuildLayout()
        {
            IWidget layout = new Splitter(SplitterDirection.Horizontal)
                .AddWidget(
                    new Splitter(SplitterDirection.Vertical)
                    .AddWidget(ruleListPanel)
                    .AddWidget(nodeListPanel)
                )
                .AddWidget(
                    new Splitter(SplitterDirection.Vertical)
                    .AddWidget(ruleEditor, 5)
                    .AddWidget(errorListPanel)
                , 2)
                .AddWidget(
                    new Splitter(SplitterDirection.Vertical)
                    .AddWidget(execGraphPanel)
                    .AddWidget(resultGraphPanel)
                , 2)
            ;

            toolbarPadding = new SpacerWidget(Vector2.zero); 
            layout = new StackPanelWidget(StackPanelOrientation.Vertical)
                .AddWidget(toolbarPadding, 0, true)
                .AddWidget(layout);
            
            uiSystem.SetLayout(layout);

            deferredCommands.Add(new EditorCommand_InitializeGraphCameras(layout));
        }


        void OnEnable()
        {
            this.wantsMouseMove = true;

            Init(FlowAsset);

            var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(uiSystem.Layout);
            graphEditors.ForEach(g => g.OnEnable());
            
            InspectorNotify.SnapPropertyChanged += OnPropertyChanged;
        }

        void OnDisable()
        {
            var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(uiSystem.Layout);
            graphEditors.ForEach(g => g.OnDisable());
            
            InspectorNotify.SnapPropertyChanged -= OnPropertyChanged;
        }

        void OnDestroy()
        {
            var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(uiSystem.Layout);
            graphEditors.ForEach(g => {
                g.OnDisable();
                g.OnDestroy();
            });
        }
        
        private void OnPropertyChanged(object obj)
        {
            requestRepaint = true;
        }

        void OnInspectorUpdate()
        {
            PerformValidation();
        }

        public void ForceUpdateWidgetFromCache(IWidget widget)
        {
            widget.UpdateWidget(uiSystem, widget.WidgetBounds);
        }

        void UpdateDragDropState(Event e)
        {
            if (uiSystem != null)
            {
                if (e.type == EventType.DragUpdated)
                {
                    uiSystem.SetDragging(true);
                }
                else if (e.type == EventType.DragPerform || e.type == EventType.DragExited)
                {
                    uiSystem.SetDragging(false);
                }
            }
        }

        private void SaveResultGraphEditorState()
        {
            if (FlowAsset != null && FlowAsset.resultGraph != null && FlowAsset.resultGraph.editorData != null)
            {
                var editorData = FlowAsset.resultGraph.editorData;
                if (resultGraphPanel != null && resultGraphPanel.GraphEditor != null)
                {
                    var config = resultGraphPanel.GraphEditor.ResultGraphPanelConfig;
                    if (config != null)
                    {
                        config.SaveState(editorData);
                    }
                }
            }
        }

        private void LoadResultGraphEditorState()
        {
            if (FlowAsset != null && FlowAsset.resultGraph != null && FlowAsset.resultGraph.editorData != null)
            {
                var editorData = FlowAsset.resultGraph.editorData;
                if (resultGraphPanel != null && resultGraphPanel.GraphEditor != null)
                {
                    var config = resultGraphPanel.GraphEditor.ResultGraphPanelConfig;
                    if (config != null)
                    {
                        config.LoadState(editorData);
                    }
                }
            }
        }

        void HandleInput(Event e)
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (uiSystem != null && uiSystem.Layout != null)
            {
                var layout = uiSystem.Layout;
                if (e.type == EventType.MouseDown || e.type == EventType.ScrollWheel)
                {
                    WidgetUtils.ProcessInputFocus(e.mousePosition, uiSystem, layout);
                }

                if (uiSystem.IsDragDrop)
                {
                    WidgetUtils.ProcessDragOperation(e, layout, uiSystem);
                }

                UpdateDragDropState(e);

                if (uiSystem.FocusedWidget != null)
                {
                    Vector2 resultMousePosition = Vector2.zero;
                    if (WidgetUtils.BuildWidgetEvent(e.mousePosition, layout, uiSystem.FocusedWidget, ref resultMousePosition))
                    {
                        Event widgetEvent = new Event(e);
                        widgetEvent.mousePosition = resultMousePosition;
                        uiSystem.FocusedWidget.HandleInput(widgetEvent, uiSystem);
                    }
                }
            }

        }

        public static void ShowEditor()
        {
            SnapEditorWindow window = EditorWindow.GetWindow<SnapEditorWindow>(); 
            window.Init(null);
        }
    }


    public enum DungeonFlowEditorHighlightID
    {
        RulePanel,
        NodePanel,
        ProductionAddRHSButton
    }

    class DungeonFlowEditorHighlighter
    {
        private static void TraverseTree(IWidget widget, System.Action<IWidget> visit)
        {
            if (widget == null) return;

            visit(widget);

            var children = widget.GetChildWidgets();
            if (children != null)
            {
                foreach (var child in children)
                {
                    TraverseTree(child, visit);
                }
            }
        }

        public static void HighlightObjects(UISystem uiSystem, IWidget root, object objectOfInterest)
        {
            if (objectOfInterest == null)
            {
                return;
            }

            TraverseTree(root, widget => {
                if (widget is HighlightWidget)
                {
                    var highlightWidget = widget as HighlightWidget;
                    var highlightObject = highlightWidget.ObjectOfInterest;
                    if (objectOfInterest.Equals(highlightObject))
                    {
                        highlightWidget.Activate(uiSystem);
                    }
                }
            });
        }

        public static void HighlightObjects(UISystem uiSystem, IWidget root, object[] objectsOfInterest)
        {
            if (objectsOfInterest == null)
            {
                return;
            }

            TraverseTree(root, widget => {
                if (widget is HighlightWidget)
                {
                    var highlightWidget = widget as HighlightWidget;
                    var highlightObject = highlightWidget.ObjectOfInterest;
                    if (objectsOfInterest.Contains(highlightObject))
                    {
                        highlightWidget.Activate(uiSystem);
                    }
                }
            });
        }
    }
    
    
    class EditorCommand_ExecuteSnapFlowGraph : DeferredUICommandBase
    {
        private readonly SnapEditorWindow window;
        public EditorCommand_ExecuteSnapFlowGraph(SnapEditorWindow window)
        {
            this.window = window;
        }

        public override void Execute(UISystem uiSystem)
        {
            window.ExecuteGraphGrammar(uiSystem);
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\DungeonThemeEditorContextMenu.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// The type of menu action to perform
    /// </summary>
    public enum ThemeEditorMenuAction
    {
        AddGameObjectNode,
        AddGameObjectArrayNode,
        AddSpriteNode,
        AddMarkerNode,
        AddMarkerEmitterNode,
        AddCommentNode
    }

    public class DungeonThemeEditorContextMenu : GraphContextMenu
    {
        bool showItemMeshNode;
        bool showItemMarkerNode;
        bool showCommentNode;
        bool showItemMarkerEmitterNode;

        /// <summary>
        /// Shows the context menu in the theme graph editor
        /// </summary>
        /// <param name="graph">The graph shown in the graph editor</param>
        /// <param name="sourcePin">The source pin, if the user dragged a link out of a pin. null otherwise</param>
        /// <param name="mouseWorld">The position of the mouse. The context menu would be shown from here</param>
        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
            this.sourcePin = sourcePin;
            this.mouseWorldPosition = mouseWorld;

            if (sourcePin == null)
            {
                showItemMeshNode = true;
                showItemMarkerNode = true;
                showItemMarkerEmitterNode = true;
                showCommentNode = true;
            }
            else
            {
                showItemMeshNode = false;
                showItemMarkerNode = false;
                showItemMarkerEmitterNode = false;
                showCommentNode = false;

                if (sourcePin.Node is MarkerNode)
                {
                    showItemMeshNode = true;
                }
                else if (sourcePin.Node is VisualNode)
                {
                    if (sourcePin.PinType == GraphPinType.Input)
                    {
                        // We can only create marker nodes from here
                        showItemMarkerNode = true;
                    }
                    else
                    {
                        // We can only create marker emitter nodes from here
                        showItemMarkerEmitterNode = true;
                    }
                }
                else if (sourcePin.Node is MarkerEmitterNode)
                {
                    // we can only create mesh nodes from the input pin of this node
                    showItemMeshNode = true;
                }
            }

            ShowMenu(graphEditor, uiSystem);
        }

        string[] GetMarkers(Graph graph)
        {
            var markers = new List<string>();
            if (graph != null)
            {
                foreach (var node in graph.Nodes)
                {
                    if (node is MarkerNode)
                    {
                        markers.Add(node.Caption);
                    }
                }
            }
            var markerArray = markers.ToArray();
            System.Array.Sort(markerArray);
            return markerArray;
        }


        private void ShowMenu(GraphEditor graphEditor, UISystem uiSystem)
        {
            var menu = new GenericMenu();
            if (showItemMeshNode)
            {
                menu.AddItem(new GUIContent("Add Game Object Node"), false, HandleMenuItemClicked, new ItemInfo(uiSystem, ThemeEditorMenuAction.AddGameObjectNode));
                menu.AddItem(new GUIContent("Add Game Object Array Node"), false, HandleMenuItemClicked, new ItemInfo(uiSystem, ThemeEditorMenuAction.AddGameObjectArrayNode));
                menu.AddItem(new GUIContent("Add Sprite Node"), false, HandleMenuItemClicked, new ItemInfo(uiSystem, ThemeEditorMenuAction.AddSpriteNode));
            }
            if (showItemMarkerNode)
            {
                menu.AddItem(new GUIContent("Add Marker Node"), false, HandleMenuItemClicked, new ItemInfo(uiSystem, ThemeEditorMenuAction.AddMarkerNode));
            }

            if (showCommentNode)
            {
                menu.AddItem(new GUIContent("Add Comment Node"), false, HandleMenuItemClicked, new ItemInfo(uiSystem, ThemeEditorMenuAction.AddCommentNode));
            }

            if (showItemMarkerEmitterNode)
            {
                var markers = GetMarkers(graphEditor.Graph);
                if (markers.Length > 0)
                {
                    if (showItemMeshNode || showItemMarkerNode)
                    {
                        menu.AddSeparator("");
                    }
                    foreach (var marker in markers)
                    {
                        menu.AddItem(new GUIContent("Add Marker Emitter: " + marker), false, HandleMenuItemClicked, new ItemInfo(uiSystem, ThemeEditorMenuAction.AddMarkerEmitterNode, marker));
                    }
                }
            }

            menu.ShowAsContext();
        }

        class ItemInfo
        {
            public ItemInfo(UISystem uiSystem, ThemeEditorMenuAction action)
                : this(uiSystem, action, null)
            {
            }

            public ItemInfo(UISystem uiSystem, ThemeEditorMenuAction action, object userdata)
            {
                this.uiSystem = uiSystem;
                this.action = action;
                this.userdata = userdata;
            }
            public UISystem uiSystem;
            public ThemeEditorMenuAction action;
            public object userdata;
        }

        void HandleMenuItemClicked(object itemObject)
        {
            var item = itemObject as ItemInfo;
            DispatchMenuItemEvent(item.action, BuildEvent(item.userdata, item.uiSystem));
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\DungeonThemeEditorWindow.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using System;
using System.Linq;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Impl.UnityEditor;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// The main editor window for the Theme graph editor.  This hosts the graph editor for managing the theme graph
    /// </summary>
    public class DungeonThemeEditorWindow : EditorWindow
    {
        [SerializeField]
        DungeonThemeGraphEditor graphEditor;
        
        public DungeonThemeGraphEditor GraphEditor
        {
            get { return graphEditor; }
        }

        public UISystem uiSystem { get; private set; }
        UIRenderer renderer;

        public static void ShowEditor()
        {
            EditorWindow.GetWindow<DungeonThemeEditorWindow>();
        }

        public void Init(Graph graph)
        {
            CreateUISystem();
            this.titleContent = new GUIContent("Dungeon Theme");
            if (graphEditor != null)
            {
                graphEditor.Init(graph, position, graph, uiSystem);
                Repaint();
            }

            // Grab the list of tools that we would be using
            toolFunctions = FetchToolFunctions();
        }

        void CreateUISystem()
        {
            uiSystem = new UnityEditorUISystem();
            renderer = new UnityEditorUIRenderer();
        }

        ThemeEditorToolFunctionInfo[] toolFunctions;

        static ThemeEditorToolFunctionInfo[] FetchToolFunctions()
        {
            var functions = new List<ThemeEditorToolFunctionInfo>();
            var assembly = System.Reflection.Assembly.GetAssembly(typeof(ThemeEditorToolFunctionDelegate));
            var methods = assembly.GetTypes()
                      .SelectMany(t => t.GetMethods())
                      .Where(m => m.GetCustomAttributes(typeof(ThemeEditorToolAttribute), false).Length > 0)
                      .ToArray();
            foreach (var method in methods)
            {
                if (method.IsStatic)
                {
                    var function = Delegate.CreateDelegate(typeof(ThemeEditorToolFunctionDelegate), method) as ThemeEditorToolFunctionDelegate;
                    if (function != null)
                    {
                        var functionInfo = new ThemeEditorToolFunctionInfo();
                        functionInfo.function = function;
                        functionInfo.attribute = method.GetCustomAttributes(typeof(ThemeEditorToolAttribute), false)[0] as ThemeEditorToolAttribute;
                        functions.Add(functionInfo);
                    }
                }
            }

            // Sort based no priority
            return functions.OrderBy(o => o.attribute.Priority).ToArray();
        }
        
        void OnEnable()
        {
            if (graphEditor == null)
            {
                graphEditor = CreateInstance<DungeonThemeGraphEditor>();
            }
            this.wantsMouseMove = true;

            graphEditor.OnEnable();
        }

        void OnDisable()
        {
            if (graphEditor != null)
            {
                graphEditor.OnDisable();
            }
        }

        void OnDestroy()
        {
            if (graphEditor != null)
            {
                graphEditor.OnDisable();
                graphEditor.OnDestroy();
                graphEditor = null;
            }
        }

        void Update()
        {
            if (graphEditor != null)
            {
                graphEditor.Update();
            }
        }

        void OnInspectorUpdate()
        {
            Repaint();
        }

        string[] GetMarkerNames()
        {
            var markerNames = new List<string>();
            if (graphEditor != null && graphEditor.Graph != null)
            {
                var graph = graphEditor.Graph;
                foreach (var node in graph.Nodes)
                {
                    if (node is MarkerNode)
                    {
                        var markerNode = node as MarkerNode;
                        markerNames.Add(markerNode.Caption);
                    }
                }
            }
            var markerArray = markerNames.ToArray();
            System.Array.Sort(markerArray);
            return markerArray;
        }

        void HandleVisualizeMarkerButtonPressed()
        {
            graphEditor.UpdateMarkerVisualizer();
        }

        void DrawToolbar()
        {
            var graphValid = (graphEditor != null && graphEditor.Graph != null);
            if (toolFunctions == null)
            {
                toolFunctions = FetchToolFunctions();
            }

            if (graphValid)
            {
                EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);

                if (GUILayout.Button("Navigate To", EditorStyles.toolbarDropDown))
                {
                    GenericMenu markerMenu = new GenericMenu();
                    var markerNames = GetMarkerNames();
                    if (markerNames.Length > 0)
                    {
                        foreach (var markerName in markerNames)
                        {
							markerMenu.AddItem(new GUIContent(markerName), false, OnJumpTo_MarkerName, markerName);
                        }
                    }

                    // Offset menu from right of editor window
					markerMenu.DropDown(new Rect(0, 0, 0, 20));
                    EditorGUIUtility.ExitGUI();
                }

				if (GUILayout.Button("Tools", EditorStyles.toolbarDropDown)) {
					GenericMenu toolsMenu = new GenericMenu();
                    foreach (var functionInfo in toolFunctions)
                    {
                        toolsMenu.AddItem(new GUIContent(functionInfo.attribute.Path), false, ToolFunctionInvoker, functionInfo.function);
                    }

                    // Offset menu from right of editor window
                    toolsMenu.DropDown(new Rect(80, 0, 0, 20));
					EditorGUIUtility.ExitGUI();
                }

                var themeGraphEditor = graphEditor as DungeonThemeGraphEditor;
                themeGraphEditor.realtimeUpdate = GUILayout.Toggle(themeGraphEditor.realtimeUpdate, "Realtime Update", EditorStyles.toolbarButton);

                var oldVisualizeMarkers = themeGraphEditor.visualizeMarkers;
                themeGraphEditor.visualizeMarkers = GUILayout.Toggle(themeGraphEditor.visualizeMarkers, "Visualize Markers", EditorStyles.toolbarButton);
                if (oldVisualizeMarkers != themeGraphEditor.visualizeMarkers)
                {
                    HandleVisualizeMarkerButtonPressed();
                }

                GUILayout.FlexibleSpace();

                {
                    renderer.backgroundColor = new Color(1, 0.25f, 0.25f, 1);
                    renderer.color = Color.white;
                
                    var iconDiscord = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_DISCORD_16x) as Texture2D;
                    if (GUILayout.Button(new GUIContent(" Discord Support", iconDiscord), DungeonEditorStyles.discordToolButtonStyle))
                    {
                        ExternalLinks.LaunchUrl(ExternalLinks.DiscordInvite);
                    }

                    renderer.backgroundColor = new Color(0.25f, 0.25f, 1, 1);
                    renderer.color = Color.white;
                    var iconDocs = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_DOCS_16x) as Texture2D;
                    if (GUILayout.Button(new GUIContent("Documentation", iconDocs), DungeonEditorStyles.discordToolButtonStyle))
                    {
                        ExternalLinks.LaunchUrl(ExternalLinks.Documentation);
                    }

                }

                EditorGUILayout.EndHorizontal();
            }

        }

        void ToolFunctionInvoker(object userData)
        {
            var toolFunction = userData as ThemeEditorToolFunctionDelegate;
            toolFunction(this);
        }

		void Advanced_OnCreateNodeIds() {
			var confirm = EditorUtility.DisplayDialog("Recreate Node Ids?",
				"Are you sure you want to recreate node Ids?  You should do this after cloning a theme file", "Yes", "Cancel");
			if (confirm) {
				DungeonEditorHelper._Advanced_RecreateGraphNodeIds();
			}
		}

		void OnRefreshThumbnail() {
			AssetThumbnailCache.Instance.Reset();
		}

        void OnJumpTo_MarkerName(object userdata)
        {
            var markerName = userdata as string;
            if (markerName != null && graphEditor != null)
            {
                graphEditor.FocusCameraOnMarker(markerName, position);
            }
        }

        void OnJumpTo_CenterGraph()
        {
            if (graphEditor != null)
            {
                graphEditor.FocusCameraOnBestFit(position);
            }
        }

        void OnGUI()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            var guiState = new GUIState(renderer);

            var bounds = new Rect(Vector2.zero, position.size);
            graphEditor.UpdateWidget(uiSystem, bounds);
            graphEditor.Draw(uiSystem, renderer);

            Event e = Event.current;
            switch (e.type)
            {
            case EventType.DragUpdated:
            case EventType.DragPerform:
                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
                if (e.type == EventType.DragPerform)
                {
                    DragAndDrop.AcceptDrag();

					var gameObjects = new List<GameObject>();
					var sprites = new List<Sprite>();

					foreach (var draggedObject in DragAndDrop.objectReferences) {
						if (draggedObject is GameObject) {
							gameObjects.Add(draggedObject as GameObject);
						} 
						else if (draggedObject is Sprite) {
							sprites.Add(draggedObject as Sprite);
						}
					}

					// Build the sprite nodes
					foreach (var sprite in sprites) {
						var node = graphEditor.CreateNode<SpriteNode>(e.mousePosition, uiSystem);
						node.sprite = sprite;
						graphEditor.SelectNode(node, uiSystem);
					}

					// Build the game object nodes
					if (gameObjects.Count > 0) {
						if (gameObjects.Count == 1) {
							// Build a game object node
							var node = graphEditor.CreateNode<GameObjectNode>(e.mousePosition, uiSystem);
							node.Template = gameObjects[0];

							var originalTransform = node.Template.transform;
							node.offset = Matrix4x4.TRS(Vector3.zero, originalTransform.rotation, originalTransform.localScale);

							graphEditor.SelectNode(node, uiSystem);
						}
						else {
							// Build a game object array node
							var node = graphEditor.CreateNode<GameObjectArrayNode>(e.mousePosition, uiSystem);
							node.Templates = gameObjects.ToArray();
							graphEditor.SelectNode(node, uiSystem);
						}
					}
                }
                break;
            }

            guiState.Restore();
            DrawToolbar();

            HandleInput(Event.current);
        }

        void HandleInput(Event e)
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            graphEditor.HandleInput(e, uiSystem);
            if (e.isScrollWheel)
            {
                Repaint();
            }

            switch (e.type)
            {
                case EventType.MouseMove:
                case EventType.MouseDrag:
                case EventType.MouseDown:
                case EventType.MouseUp:
                case EventType.KeyDown:
                case EventType.KeyUp:
                case EventType.MouseEnterWindow:
                case EventType.MouseLeaveWindow:
                    Repaint();
                    break;
            }
        }

        public void OnDungeonBuiltByUser(Dungeon dungeon)
        {
            if (dungeon == graphEditor.TrackedDungeon)
            {
                graphEditor.UpdateMarkerVisualizer();
            }
        }
        
        public void OnDungeonDestroyedByUser(Dungeon dungeon)
        {
            if (dungeon == graphEditor.TrackedDungeon)
            {
                graphEditor.ClearMarkerVisualizer();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\DungeonThemeGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using System;
using System.Linq;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.SpatialConstraints;
using DungeonArchitect.Editors.SpatialConstraints;
using DungeonArchitect.Editors.Utils;
using DungeonArchitect.Editors.Visualization;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors
{
    public class DungeonThemeGraphEditor : GraphEditor
    {
        // tracks dungeon objects in the scene that have the same graph being edited. This is used for realtime updates
        readonly DungeonObjectTracker dungeonObjectTracker = new DungeonObjectTracker();

        [SerializeField]
        public bool realtimeUpdate = true;

        [SerializeField]
        public bool visualizeMarkers = false;
        
        [SerializeField]
        ThemeEditorSceneVisualizer visualizer = new ThemeEditorSceneVisualizer();
        
        
        protected override void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers)
        {
            nodeRenderers.RegisterNodeRenderer(typeof(MarkerNode), new MarkerNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(GameObjectNode), new MeshNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(GameObjectArrayNode), new MeshArrayNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(SpriteNode), new SpriteNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(MarkerEmitterNode), new MarkerEmitterNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(CommentNode), new CommentNodeRenderer(EditorStyle.commentTextColor));
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            return new SplineGraphLinkRenderer();
        }

        public override GraphSchema GetGraphSchema()
        {
            return new ThemeGraphSchema();
        }

        public Dungeon TrackedDungeon
        {
            get => (dungeonObjectTracker != null) ? dungeonObjectTracker.ActiveDungeon : null;
        }

        
        /// <summary>
        /// Moves the graph editor viewport to show the marker on the screen
        /// </summary>
        /// <param name="markerName">The name of the marker to focus on</param>
        /// <param name="editorBounds">The bounds of the editor</param>
        public void FocusCameraOnMarker(string markerName, Rect editorBounds)
        {
            GraphNode nodeToFocus = null;
            foreach (var node in graph.Nodes)
            {
                if (node is MarkerNode)
                {
                    var markerNode = node as MarkerNode;
                    if (markerNode.Caption == markerName)
                    {
                        nodeToFocus = node;
                        break;
                    }
                }
            }

            camera.FocusOnNode(nodeToFocus, editorBounds);
        }
        
        public override void Update()
        {
            base.Update();

            if (realtimeUpdate)
            {
                dungeonObjectTracker.ActiveGraph = graph;
                dungeonObjectTracker.Update();
            }
        }

        public override void HandleGraphStateChanged(UISystem uiSystem)
        {
            base.HandleGraphStateChanged(uiSystem);
            if (realtimeUpdate)
            {
                dungeonObjectTracker.RequestRebuild();
            }
        }

        public override void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            base.Init(graph, editorBounds, assetObject, uiSystem);

            // Make sure the spatial constraint assets are created and bound to the asset file 
            foreach (var node in graph.Nodes)
            {
                if (node is VisualNode)
                {
                    var visualNode = node as VisualNode;
                    if (visualNode.spatialConstraint == null)
                    {
                        CreateSpatialConstraintAsset(visualNode, uiSystem);
                    }
                }
            }

            dungeonObjectTracker.ActiveGraph = graph;
            
            UpdateSpatialConstraintEditorWindow(uiSystem);
            
                        
            if (visualizeMarkers) {
                UpdateMarkerVisualizer();
            }
        }

        public void ClearMarkerVisualizer()
        {
            if (visualizer != null)
            {
                visualizer.Clear();
            }
        }
        
        public void UpdateMarkerVisualizer()
        {
            if (visualizer == null) return;
            if (!visualizeMarkers)
            {
                visualizer.Clear();
                return;
            }

            if (Graph == null)
            {
                return;
            }
            
            var selectedNodes = new List<GraphNode>();
            foreach (var node in Graph.Nodes)
            {
                if (node.Selected)
                {
                    selectedNodes.Add(node);
                }
            }

            
            MarkerNode markerNode = (selectedNodes.Count == 1) 
                ? ThemeEditorUtils.GetMarkerNodeInHierarchy(selectedNodes[0]) 
                : null;

            var dungeon = TrackedDungeon;
            if (markerNode != null && dungeon != null)
            {
                if (!dungeon.IsLayoutBuilt)
                {
                    dungeon.Build(new EditorDungeonSceneObjectInstantiator());
                }
                visualizer.Build(dungeon, markerNode.MarkerName);
            }
            else
            {
                visualizer.Clear();
            }
        }

        public override void OnDestroy()
        {
            base.OnDestroy();
            
            if (visualizer != null)
            {
                visualizer.Clear();
            }
        }

        public override GraphNode CreateNode(Vector2 screenCoord, System.Type nodeType, UISystem uiSystem)
        {
            var node = base.CreateNode(screenCoord, nodeType, uiSystem);

            if (node is VisualNode)
            {
                var visualNode = node as VisualNode;
                CreateSpatialConstraintAsset(visualNode, uiSystem);
            }

            return node;
        }

        void CreateSpatialConstraintAsset(VisualNode visualNode, UISystem uiSystem)
        {
            if (visualNode.spatialConstraint == null)
            {
                visualNode.spatialConstraint = CreateInstance<SpatialConstraintAsset>();
                visualNode.spatialConstraint.Init(visualNode);
                AssetDatabase.AddObjectToAsset(visualNode.spatialConstraint, graph);
                AssetDatabase.AddObjectToAsset(visualNode.spatialConstraint.Graph, graph);
                DungeonEditorHelper.CreateDefaultSpatialConstraintNodes(visualNode.spatialConstraint, null);
            }
        }

        protected override void DestroyNode(GraphNode node, UISystem uiSystem)
        {
            if (node is VisualNode)
            {
                // Destroy the spatial constraint asset
                var visualNode = node as VisualNode;
                DungeonEditorHelper.DestroySpatialConstraintAsset(visualNode.spatialConstraint);
                visualNode.spatialConstraint = null;
            }
            
            // If this is a marker node, delete all the referenced emitter nodes as well
            if (node is MarkerNode)
            {
                DestroyEmitterNodes(graph, node as MarkerNode, uiSystem.Undo);
            }
            
            base.DestroyNode(node, uiSystem);
        }

        private static void DestroyEmitterNodes(Graph graph, MarkerNode markerNode, UIUndoSystem undo)
        {
            var emitterNodes = new List<GraphNode>();
            foreach (var node in graph.Nodes)
            {
                if (node is MarkerEmitterNode)
                {
                    var emitterNode = node as MarkerEmitterNode;
                    if (emitterNode.Marker == markerNode)
                    {
                        emitterNodes.Add(emitterNode);
                    }
                }
            }

            // delete the emitter nodes
            foreach (var emitterNode in emitterNodes)
            {
                GraphOperations.DestroyNode(emitterNode, undo);
            }
        }

        protected override GraphContextMenu CreateContextMenu()
        {
            return new DungeonThemeEditorContextMenu();
        }

        protected override void SortNodesForDeletion(GraphNode[] nodesToDelete)
        {
            System.Array.Sort(nodesToDelete, new NodeDeletionOrderComparer());
        }

        public override void SortPinsForDrawing(GraphPin[] pins)
        {
            Array.Sort(pins, new GraphPinHierarchyComparer());
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {
            var action = (ThemeEditorMenuAction)userdata;
            var mouseScreen = lastMousePosition;
            GraphNode node = null;
            if (action == ThemeEditorMenuAction.AddGameObjectNode)
            {
                node = CreateNode<GameObjectNode>(mouseScreen, e.uiSystem);
                SelectNode(node, e.uiSystem);
            }
            if (action == ThemeEditorMenuAction.AddGameObjectArrayNode)
            {
                node = CreateNode<GameObjectArrayNode>(mouseScreen, e.uiSystem);
                SelectNode(node, e.uiSystem);
            }
            else if (action == ThemeEditorMenuAction.AddSpriteNode)
            {
                node = CreateNode<SpriteNode>(mouseScreen, e.uiSystem);
                SelectNode(node, e.uiSystem);
            }
            else if (action == ThemeEditorMenuAction.AddMarkerNode)
            {
                node = CreateNode<MarkerNode>(mouseScreen, e.uiSystem);
                SelectNode(node, e.uiSystem);
            }
            else if (action == ThemeEditorMenuAction.AddCommentNode)
            {
                node = CreateNode<CommentNode>(mouseScreen, e.uiSystem);
                SelectNode(node, e.uiSystem);
            }
            else if (action == ThemeEditorMenuAction.AddMarkerEmitterNode)
            {
                if (e.userdata != null)
                {
                    var markerName = e.userdata as String;
                    node = CreateMarkerEmitterNode(mouseScreen, markerName, e.uiSystem);
                    if (node != null)
                    {
                        SelectNode(node, e.uiSystem);
                    }
                }
            }


            if (node != null)
            {
                // Check if the menu was created by dragging out a link
                if (e.sourcePin != null)
                {
                    GraphPin targetPin =
                            e.sourcePin.PinType == GraphPinType.Input ?
                            node.OutputPins[0] :
                            node.InputPins[0];

                    // Align the target pin with the mouse position where the link was dragged and released
                    node.Position = e.mouseWorldPosition - targetPin.Position;

                    GraphPin inputPin, outputPin;
                    if (e.sourcePin.PinType == GraphPinType.Input)
                    {
                        inputPin = e.sourcePin;
                        outputPin = targetPin;
                    }
                    else
                    {
                        inputPin = targetPin;
                        outputPin = e.sourcePin;
                    }
                    CreateLinkBetweenPins(outputPin, inputPin, e.uiSystem);
                }
            }
        }
        
        public override void OnNodeSelectionChanged(UISystem uiSystem)
        {
            base.OnNodeSelectionChanged(uiSystem);

            UpdateSpatialConstraintEditorWindow(uiSystem);
            
            if (visualizeMarkers) {
                UpdateMarkerVisualizer();
            }
        }

        void UpdateSpatialConstraintEditorWindow(UISystem uiSystem)
        {
            var selectedNodes = from node in graph.Nodes
                                where (node.Selected && node is VisualNode)
                                select node as VisualNode;

            var nodes = selectedNodes.ToArray();

            // Set the active spatial constraint asset in the editor window
            UpdateSpatialConstraintEditorWindow(nodes);
        }

        public override void HandleNodePropertyChanged(GraphNode node)
        {
            UpdateSpatialConstraintEditorWindow(new GraphNode[] { node });
        }

        void UpdateSpatialConstraintEditorWindow(GraphNode[] nodes)
        {
            SpatialConstraintAsset spatialAsset = null;
            SpatialConstraintsEditorAssignmentState assetState;
            VisualNode node = null;
            if (nodes.Length == 1 && nodes[0] is VisualNode)
            {
                node = nodes[0] as VisualNode;
            }

            if (node != null)
            {
                if (node.spatialConstraint == null)
                {
                    Debug.LogError("Spatial Constraint asset not assigned. Please reload the theme editor");
                    return;
                }

                if (node.useSpatialConstraint)
                {
                    spatialAsset = node.spatialConstraint;
                    assetState = SpatialConstraintsEditorAssignmentState.Assigned;
                }
                else
                {
                    assetState = SpatialConstraintsEditorAssignmentState.ConstraintsDisabled;
                }
            }
            else
            {
                assetState = SpatialConstraintsEditorAssignmentState.NotAssigned;
            }

            SetSpatialConstraintEditorAsset(spatialAsset, assetState);
        }

        class SpatialConstraintWindowState
        {
            public SpatialConstraintAsset spatialAsset = null;
            public SpatialConstraintsEditorAssignmentState assignmentState = SpatialConstraintsEditorAssignmentState.NotAssigned;
            public bool initialized = false;
        }
        SpatialConstraintWindowState spatailWindowState = new SpatialConstraintWindowState();

        void SetSpatialConstraintEditorAsset(SpatialConstraintAsset spatialAsset, SpatialConstraintsEditorAssignmentState state)
        {
            if (spatailWindowState.initialized
                && spatailWindowState.spatialAsset == spatialAsset 
                && spatailWindowState.assignmentState == state)
            {
                // The states are the same. no need to assign
                return;
            }

            spatailWindowState.initialized = true;
            spatailWindowState.spatialAsset = spatialAsset;
            spatailWindowState.assignmentState = state;

            var existingWindow = DungeonEditorHelper.GetWindowIfOpen<SpatialConstraintsEditorWindow>();

            // Open a window only if we are assigning
            if (state == SpatialConstraintsEditorAssignmentState.Assigned && existingWindow == null)
            {
                existingWindow = EditorWindow.GetWindow<SpatialConstraintsEditorWindow>();
            }

            if (existingWindow != null)
            {
                existingWindow.Init(spatialAsset, state);
            }
        }

        protected override string GetGraphNotInitializedMessage()
        {
            return "Please open a theme file to edit";
        }

        MarkerEmitterNode CreateMarkerEmitterNode(Vector2 mouseScreenPos, string markerName, UISystem uiSystem)
        {
            // find the marker node with this name
            MarkerNode markerNode = null;
            foreach (var node in graph.Nodes)
            {
                if (node is MarkerNode)
                {
                    var marker = node as MarkerNode;
                    if (marker.Caption == markerName)
                    {
                        markerNode = marker;
                        break;
                    }
                }
            }

            if (markerNode == null)
            {
                // No marker node found with this ids
                return null;
            }
            var emitterNode = CreateNode<MarkerEmitterNode>(mouseScreenPos, uiSystem);
            emitterNode.Marker = markerNode;
            return emitterNode;
        }
    }

    /// <summary>
    /// Tracks active dungeon objects in the scene and finds ones that have the active graph being edited
    /// This is used for real-time updates on the dungeon object as the graph is modified from the editor
    /// </summary>
    class DungeonObjectTracker
    {
        Graph activeGraph;

        /// <summary>
        /// The active graph being edited by the theme graph editor
        /// </summary>
        public Graph ActiveGraph
        {
            get
            {
                return activeGraph;
            }
            set
            {
                activeGraph = value;
            }
        }

        public Dungeon ActiveDungeon
        {
            get
            {
                if (_dungeons.Length == 0)
                {
                    FindDungeonObjects();
                }
                return _dungeons.Length > 0 ? _dungeons[0] : null;  
            } 
        }

        bool requestRebuild = false;

        Dungeon[] _dungeons = new Dungeon[0];


        public void Update()
        {
            if (activeGraph == null)
            {
                return;
            }

            _dungeons = _dungeons.Where(d => d != null && d.dungeonThemes.Contains(activeGraph)).ToArray();

            if (requestRebuild)
            {
                RebuildDungeon();
                requestRebuild = false;
            }
        }

        /// <summary>
        /// Finds all dungeon objects in the scene that use the theme graph tracked by this object
        /// </summary>
        void FindDungeonObjects()
        {
            _dungeons = UnityEngine.Object.FindObjectsOfType<Dungeon>();
            _dungeons = _dungeons.Where(d => d != null && d.dungeonThemes.Contains(activeGraph)).ToArray();
        }

        /// <summary>
        /// Rebuilds the dungeons that reference the theme graphs tracked by this object
        /// </summary>
        public void RequestRebuild()
        {
            requestRebuild = true;
        }

        void RebuildDungeon()
        {
            if (_dungeons.Length == 0)
            {
                FindDungeonObjects();
            }

            foreach (var dungeon in _dungeons)
            {
                if (dungeon == null) continue;
                if (!dungeon.IsLayoutBuilt)
                {
                    dungeon.Build(new EditorDungeonSceneObjectInstantiator());
                }
                else
                {
                    // Do not rebuild the layout as it has already been built. Just reapply the theme on the existing layout
                    dungeon.ApplyTheme(new EditorDungeonSceneObjectInstantiator());
                }
            }
        }
    }


    /// <summary>
    /// Sorts based on the node's Z-index in descending order
    /// </summary>
    class NodeDeletionOrderComparer : IComparer<GraphNode>
    {
        int GetWeight(GraphNode node)
        {
            if (node is MarkerEmitterNode) return 0;
            if (node is VisualNode) return 1;
            if (node is MarkerNode) return 2;
            return 3;
        }

        public int Compare(GraphNode x, GraphNode y)
        {
            int wx = GetWeight(x);
            int wy = GetWeight(y);
            if (wx == wy) return 0;
            return (wx < wy) ? -1 : 1;
        }
    }

    /// <summary>
    /// Sorts the pins based on their owning node's type 
    /// </summary>
    class GraphPinHierarchyComparer : IComparer<GraphPin>
    {
        int GetWeight(GraphNode node)
        {
            if (node is MarkerNode) return 1;
            else if (node is VisualNode) return 2;
            else if (node is MarkerEmitterNode) return 3;
            else return 4;
        }

        public int Compare(GraphPin x, GraphPin y)
        {
            if (x == null || y == null) return 0;
            var wx = GetWeight(x.Node);
            var wy = GetWeight(y.Node);

            if (wx == wy) return 0;
            return wx < wy ? -1 : 1;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\FlowEditorInspectors.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Builders.GridFlow;

namespace DungeonArchitect.Editors.Flow
{
    public abstract class FlowExecGraphEditorConfigInspector : Editor
    {
        protected SerializedObject sobject;
        private SerializedProperty randomizeSeed;
        private SerializedProperty seed;

        protected virtual void OnEnable()
        {
            sobject = new SerializedObject(target);
            randomizeSeed = sobject.FindProperty("randomizeSeed");
            seed = sobject.FindProperty("seed");
        }

        protected abstract void DrawDungeonProperty();
        
        public override void OnInspectorGUI()
        {
            sobject.Update();
            var config = target as FlowEditorConfig;

            GUILayout.Label("Linked Dungeon", EditorStyles.boldLabel);
            DrawDungeonProperty();

            GUILayout.Label("Preview Settings", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(randomizeSeed);
            bool enableSeedEdit = true;
            if (config.FlowBuilder == null)
            {
                if (config.randomizeSeed)
                {
                    enableSeedEdit = false;
                }
            }
            else
            {
                enableSeedEdit = false;
                var dungeonConfig = config.FlowBuilder.gameObject.GetComponent<GridFlowDungeonConfig>();
                if (dungeonConfig != null)
                {
                    int seed = (int)dungeonConfig.Seed;
                    config.seed = seed;
                    EditorGUILayout.HelpBox("The seed cannot be modified, it is taken from the linked dungeon game object", MessageType.Info);
                }
                else
                {
                    EditorGUILayout.HelpBox("Invalid dungeon prefab configuration. Cannot find GridFlowDungeonConfig component", MessageType.Info);
                }
            }

            GUI.enabled = enableSeedEdit;
            EditorGUILayout.PropertyField(seed);
            GUI.enabled = true;

            sobject.ApplyModifiedProperties();
        }

    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\FlowExecNodeInspectors.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Exec;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow
{
    public class FlowExecNodeHandlerInspectorBase : DAInspectorBase
    {

        public virtual void HandleInspectorGUI()
        {
            var attribute = FlowExecNodeInfoAttribute.GetHandlerAttribute(target.GetType());
            var title = "Node Settings";
            if (attribute != null)
            {
                title = attribute.Title;
            }
            
            // Draw the header
            GUILayout.Box(title, InspectorStyles.TitleStyle);
            EditorGUILayout.Space();
            
        }

        protected virtual void DrawMiscProperties()
        {
            DrawProperty("description");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();

            HandleInspectorGUI();
            
            DrawHeader("Misc");
            {
                EditorGUI.indentLevel++;
                DrawMiscProperties();
                EditorGUI.indentLevel--;
            }

            InspectorNotify.Dispatch(sobject, target);
        }
    }
    
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Graph\CommentNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{
    /// <summary>
    /// Custom property editors for MarkerNode
    /// </summary>
    [CustomEditor(typeof(CommentNode))]
    public class CommentNodeEditor : Editor
    {
        SerializedObject sobject;
        SerializedProperty message;
        SerializedProperty background;
        const int CATEGORY_SPACING = 10;

        public void OnEnable()
        {
            sobject = new SerializedObject(target);
            message = sobject.FindProperty("message");
            background = sobject.FindProperty("background");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            
            GUILayout.Label("Comment Node", InspectorStyles.TitleStyle);
            GUILayout.Space(CATEGORY_SPACING);
            
            message.stringValue = EditorGUILayout.TextArea(message.stringValue, GUILayout.MinHeight(60));
            EditorGUILayout.PropertyField(background);
            sobject.ApplyModifiedProperties();
        }
        
    }

    /// <summary>
    /// Renders a comment node
    /// </summary>
    public class CommentNodeRenderer : GraphNodeRenderer
    {
        Color textColor = Color.white;
        public CommentNodeRenderer(Color textColor)
        {
            this.textColor = textColor;
        }

        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            var commentNode = node as CommentNode;

            DrawMessage(renderer, rendererContext, commentNode, camera);
            
            // Draw the pins
            base.Draw(renderer, rendererContext, node, camera);

            if (camera.ZoomLevel >= 1.5f)
            {
                var nodeScreen = camera.WorldToScreen(node.Bounds);
                if (nodeScreen.Contains(rendererContext.GraphEditor.LastMousePosition))
                {
                    GraphTooltip.message = commentNode.message;
                }
            }
        }

        void DrawMessage(UIRenderer renderer, GraphRendererContext rendererContext, CommentNode node, GraphCamera camera)
        {
            var style = new GUIStyle(EditorStyles.label);
            style.alignment = TextAnchor.UpperLeft;

            style.normal.textColor = node.Selected ? GraphEditorConstants.TEXT_COLOR_SELECTED : GraphEditorConstants.TEXT_COLOR;

            {
                style.font = EditorStyles.standardFont;
                float scaledFontSize = style.fontSize == 0 ? style.font.fontSize : style.fontSize;
                scaledFontSize = Mathf.Max(1.0f, scaledFontSize / camera.ZoomLevel);
                style.fontSize = Mathf.RoundToInt(scaledFontSize);
            }

            var guiState = new GUIState(renderer);
            renderer.backgroundColor = node.background;

            // Update the node bounds
            var padding = new Vector2(10, 10);
            var screenPadding = padding / camera.ZoomLevel;
            var textSize = style.CalcSize(new GUIContent(node.message));
            var nodeSize = textSize + screenPadding * 2;

            Rect boxBounds;
            {
                var positionScreen = camera.WorldToScreen(node.Position);
                var sizeScreen = nodeSize;
                boxBounds = new Rect(positionScreen, sizeScreen);
            }

            Rect textBounds;
            {
                var positionScreen = camera.WorldToScreen(node.Position + padding);
                var sizeScreen = textSize;
                textBounds = new Rect(positionScreen, sizeScreen);
            }

            renderer.DrawRect(boxBounds, node.background);
            style.normal.textColor = textColor;
            renderer.Label(textBounds, node.message, style);

            var updateWorldSize = nodeSize * camera.ZoomLevel;
            {
                var nodeBounds = node.Bounds;
                nodeBounds.size = updateWorldSize;
                node.Bounds = nodeBounds;
            }

            guiState.Restore();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Graph\GraphNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors
{
    public class GraphNodeEditor : Editor
    {
        protected SerializedObject sobject;

        public virtual void OnEnable()
        {
            sobject = new SerializedObject(targets);
        }


        public override void OnInspectorGUI()
        {
            EditorGUI.BeginChangeCheck();
            sobject.Update();

            HandleInspectorGUI();

            sobject.ApplyModifiedProperties();
            
            if (EditorGUI.EndChangeCheck())
            {
                OnGuiChanged();
            }
        }

        protected virtual void OnGuiChanged()
        {
        }

        protected virtual void HandleInspectorGUI() { }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\MarkerGen\MarkerGenInspectors.cs:
 using DungeonArchitect.Editors.MarkerGenerator;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Grid;
using DungeonArchitect.MarkerGenerator.Nodes.Actions;
using DungeonArchitect.MarkerGenerator.Nodes.Condition;
using DungeonArchitect.MarkerGenerator.Rule.Grid;
using DungeonArchitect.Utils;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGen
{
    public class MarkerGenInspectorBase : DAInspectorBase
    {
        
        protected virtual void HandleInspectorGUI()
        {
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();

            HandleInspectorGUI();

            InspectorNotify.Dispatch(sobject, target);
        }
    }

    [CustomEditor(typeof(MarkerGenRuleNodeMarkerExists), false)]
    public class MarkerGenRuleMarkerExistsInspector : MarkerGenInspectorBase
    {
        protected override void HandleInspectorGUI()
        {
            DrawHeader("Marker Exists");
            {
                EditorGUI.indentLevel++;
                DrawProperties("markerName");
                EditorGUI.indentLevel--;
            }
            
        }
    }
    
    [CustomEditor(typeof(MarkerGenRuleNodeConditionScript), false)]
    public class MarkerGenRuleScriptInspector : MarkerGenInspectorBase
    {
        InstanceCache instanceCache = new InstanceCache();
        protected override void HandleInspectorGUI()
        {
            var scriptNode = target as MarkerGenRuleNodeConditionScript;
            if (scriptNode == null)
            {
                return;
            }
            
            DrawHeader("Script Node");
            {
                EditorGUI.indentLevel++;
                var oldClassName = scriptNode.scriptClassName;
                DrawRule<GridMarkerGenRuleUserScript>("Script", oldClassName, out var newClassName);
                if (oldClassName != newClassName)
                {
                    var propClassName = GetProperty("scriptClassName");
                    propClassName.stringValue = newClassName;
                }
                EditorGUILayout.HelpBox("Specify a script that inherits from GridMarkerGenRuleUserScript. Override the method ValidateRule with your own logic", MessageType.Info);
                EditorGUI.indentLevel--;
            }
        }
        
        void DrawRule<T>(string caption, string ruleClassName, out string newRuleClassName) where T : ScriptableObject
        {
            newRuleClassName = ruleClassName;
            
            GUI.enabled = true;
            EditorGUILayout.BeginHorizontal();
            MonoScript script = null;
            EditorGUILayout.LabelField(caption, new GUILayoutOption[] { GUILayout.MaxWidth(80) });
            if (!string.IsNullOrEmpty(ruleClassName))
            {
                var rule = instanceCache.GetInstance(ruleClassName) as ScriptableObject;
                if (rule != null)
                {
                    script = MonoScript.FromScriptableObject(rule);
                } 
            }
            var oldScript = script;
            script = EditorGUILayout.ObjectField(script, typeof(MonoScript), false) as MonoScript;
            if (oldScript != script && script != null)
            {
                var ruleType = script.GetClass();
                if (ruleType.IsSubclassOf(typeof(T)))
                {
                    newRuleClassName = script.GetClass().AssemblyQualifiedName;
                }
                else
                {
                    newRuleClassName = null;
                }
            }
            else if (script == null)
            {
                newRuleClassName = null;
            }

            EditorGUILayout.EndHorizontal();
        }
    }
    
    [CustomEditor(typeof(MarkerGenRuleNodeAddMarker), false)]
    public class MarkerGenRuleAddMarkerInspector : MarkerGenInspectorBase
    {
        protected override void HandleInspectorGUI()
        {
            DrawHeader("Add Marker");
            {
                EditorGUI.indentLevel++;
                DrawProperties("markerName");
                DrawProperty("copyRotationFromMarkers", true);
                DrawProperty("copyHeightFromMarkers", true);
                EditorGUI.indentLevel--;
            }
            
        }
    }
    
    [CustomEditor(typeof(MarkerGenRuleNodeRemoveMarker), false)]
    public class MarkerGenRuleRemoveMarkerInspector : MarkerGenInspectorBase
    {
        protected override void HandleInspectorGUI()
        {
            DrawHeader("Remove Marker Marker");
            {
                EditorGUI.indentLevel++;
                DrawProperties("markerName");
                EditorGUI.indentLevel--;
            }
            
        }
    }
    
    [CustomEditor(typeof(GridMarkerGenPattern), false)]
    public class GridMarkerGenLayerInspector : MarkerGenInspectorBase
    {
        protected override void HandleInspectorGUI()
        {
            DrawHeader("Grid Layer");
            {
                EditorGUI.indentLevel++;
                DrawProperties("patternName", "probability", "rotateToFit", "randomizeFittingOrder", "allowInsertionOverlaps");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Advanced");
            {
                EditorGUI.indentLevel++;
                DrawProperty("sameHeightMarkers", true);
                DrawProperties("expandMarkerDomain", "expandMarkerDomainAmount");
                EditorGUI.indentLevel--;
            }

        }
    }
    
    [CustomEditor(typeof(GridMarkerGenRule), false)]
    public class GridMarkerGenRuleInspector : MarkerGenInspectorBase
    {
        protected override void HandleInspectorGUI()
        {
            DrawHeader("Pattern Rule");
            {
                EditorGUI.indentLevel++;
                DrawProperties("hintWillInsertAssetHere");
                EditorGUI.indentLevel--;
            }
            
            DrawHeader("Misc");
            {
                EditorGUI.indentLevel++;
                DrawProperties("visuallyDominant");
                if (GUILayout.Button("Randomize Color"))
                {
                    if (target is GridMarkerGenRule rule)
                    {
                        var colorProperty = sobject.FindProperty("color");
                        colorProperty.colorValue = MarkerGenEditorUtils.CreateRandomColor(); 
                    }
                }
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Snap\GrammarExecRuleNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Grammar;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    [CustomEditor(typeof(GrammarExecRuleNode))]
    public class GrammarExecRuleNodeEditor : Editor
    {
        SerializedObject sobject;
        SerializedProperty runMode;
        SerializedProperty runProbability;
        SerializedProperty iterateCount;
        SerializedProperty minIterateCount;
        SerializedProperty maxIterateCount;

        public void OnEnable()
        {
            sobject = new SerializedObject(target);
            runMode = sobject.FindProperty("runMode");
            runProbability = sobject.FindProperty("runProbability");
            iterateCount = sobject.FindProperty("iterateCount");
            minIterateCount = sobject.FindProperty("minIterateCount");
            maxIterateCount = sobject.FindProperty("maxIterateCount");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();

            var node = target as GrammarExecRuleNode;

            if (node != null)
            {
                GUILayout.Label("Task Node", EditorStyles.boldLabel);
                EditorGUILayout.PropertyField(runMode);
                if (node.runMode == GrammarExecRuleRunMode.RunWithProbability)
                {
                    EditorGUILayout.PropertyField(runProbability);
                }
                else if(node.runMode == GrammarExecRuleRunMode.Iterate)
                {
                    EditorGUILayout.PropertyField(iterateCount);
                }
                else if (node.runMode == GrammarExecRuleRunMode.IterateRange)
                {
                    EditorGUILayout.PropertyField(minIterateCount);
                    EditorGUILayout.PropertyField(maxIterateCount);
                }
            }

            InspectorNotify.Dispatch(sobject, target);
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Snap\GrammarGraphInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Linq;
using DungeonArchitect.Editors.Graphs;
using DungeonArchitect.Grammar;
using DungeonArchitect.Graphs;
using DungeonArchitect.Graphs.Layouts;
using DungeonArchitect.Graphs.Layouts.Spring;
using DungeonArchitect.UI;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    [CustomEditor(typeof(GrammarGraph), true)]
    public class GrammarGraphInspector : Editor
    {
        SerializedObject sobject;
        SerializedProperty useProceduralScript;

        protected virtual void OnEnable()
        {
            sobject = new SerializedObject(target);
            useProceduralScript = sobject.FindProperty("useProceduralScript");
        }

        ScriptableObject generatorInstanceCache = null;
        MonoScript generatorMonoScriptCache = null;

        void UpdateGeneratorInstance(string scriptClassName)
        {
            if (scriptClassName == null || scriptClassName.Length == 0)
            {
                generatorInstanceCache = null;
                generatorMonoScriptCache = null;
                return;
            }

            var type = System.Type.GetType(scriptClassName);
            if (type == null)
            {
                generatorInstanceCache = null;
                generatorMonoScriptCache = null;
                return;
            }

            if (generatorInstanceCache == null || generatorInstanceCache.GetType() != type)
            {
                generatorInstanceCache = CreateInstance(type);
                generatorMonoScriptCache = MonoScript.FromScriptableObject(generatorInstanceCache);
            }
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();

            var grammar = target as GrammarGraph;
            GUILayout.Label("Grammar Properties", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox("Use a script to generate your graph", MessageType.Info);
            EditorGUILayout.PropertyField(useProceduralScript);
            if (grammar.useProceduralScript)
            {
                UpdateGeneratorInstance(grammar.generatorScriptClass);
                var newScript = EditorGUILayout.ObjectField("Script", generatorMonoScriptCache, typeof(MonoScript), false) as MonoScript;
                if (newScript != generatorMonoScriptCache)
                {
                    if (newScript == null)
                    {
                        grammar.generatorScriptClass = null;
                    }
                    else
                    {
                        if (!newScript.GetClass().GetInterfaces().Contains(typeof(IGrammarGraphBuildScript)))
                        {
                            // The script doesn't implement the interface
                            grammar.generatorScriptClass = null;
                        }
                        else
                        {
                            grammar.generatorScriptClass = newScript.GetClass().AssemblyQualifiedName;
                        }
                    }
                }

                EditorGUILayout.HelpBox("Warning: Clicking build will replace your existing graph!", MessageType.Warning);
                var generatorScript = generatorInstanceCache as IGrammarGraphBuildScript;
                if (generatorScript == null)
                {
                    GUI.enabled = false;
                }
                if (GUILayout.Button("Build"))
                {
                    // Find the active editor window and grab the flow asset that is being modified 
                    var editorWindow = EditorWindow.GetWindow<SnapEditorWindow>();
                    if (editorWindow != null && editorWindow.FlowAsset != null)
                    {
                        var flowAsset = editorWindow.FlowAsset;
                        var productionRule = GetProductionRule(flowAsset, grammar);
                        if (productionRule != null && generatorScript != null)
                        {
                            ExecuteGeneratorScript(generatorScript, grammar, flowAsset, editorWindow.uiSystem.Platform, editorWindow.uiSystem.Undo);
                            PerformLayout(grammar);
                            FocusEditorOnGrammar(editorWindow, grammar, productionRule);
                        }
                    }
                }
                GUI.enabled = true;
            }

            InspectorNotify.Dispatch(sobject, target);
        }

        void PerformLayout(GrammarGraph graph)
        {
            var config = new GraphLayoutSpringConfig();
            var layout = new GraphLayoutSpring<GraphNode>(config);
            var nodes = graph.Nodes.ToArray();
            nodes = nodes.Where(n => !(n is CommentNode)).ToArray();
            layout.Layout(nodes, new DefaultGraphLayoutNodeActions(graph));
        }

        void ExecuteGeneratorScript(IGrammarGraphBuildScript generatorScript, GrammarGraph grammar, SnapFlowAsset flowAsset, UIPlatform platform, UIUndoSystem undo)
        {
            var graphBuilder = new EditorGraphBuilder(grammar, flowAsset, platform, undo);
            GrammarGraphBuilder grammarBuilder = new GrammarGraphBuilder(grammar, flowAsset.nodeTypes, graphBuilder);
            grammarBuilder.ClearGraph();
            generatorScript.Generate(grammarBuilder);
        }

        // Focus on the graph editor panel
        void FocusEditorOnGrammar(SnapEditorWindow editorWindow, GrammarGraph grammar, GrammarProductionRule productionRule)
        {
            var rulePanel = editorWindow.GetRuleListPanel();
            rulePanel.ListView.SetSelectedItem(editorWindow.uiSystem, productionRule);
            editorWindow.ForceUpdateWidgetFromCache(rulePanel);

            var productionRuleEditor = editorWindow.GetProductionRuleWidget();
            DungeonFlowEditorHighlighter.HighlightObjects(editorWindow.uiSystem, productionRuleEditor, grammar);

            // Center the camera
            foreach (var graphEditor in productionRuleEditor.GetGraphEditors())
            {
                if (graphEditor.Graph == grammar)
                {
                    editorWindow.AddDeferredCommand(new EditorCommand_InitializeGraphCameras(graphEditor));
                }
            }
        }

        GrammarProductionRule GetProductionRule(SnapFlowAsset flowAsset, GrammarGraph grammar)
        {
            // make sure this object belongs to the asset
            if (flowAsset != null)
            {
                foreach (var rule in flowAsset.productionRules)
                {
                    if (grammar == rule.LHSGraph)
                    {
                        return rule;
                    }

                    foreach (var rhs in rule.RHSGraphs)
                    {
                        if (rhs.graph == grammar)
                        {
                            return rule;
                        }
                    }
                }
            }
            return null;
        }

    }

} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Snap\GrammarNodeTypeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Grammar;
using UnityEditor;

namespace DungeonArchitect.Editors.SnapFlow
{
    [CustomEditor(typeof(GrammarNodeType))]
    public class GrammarNodeTypeEditor : Editor
    {
        SerializedObject sobject;
        SerializedProperty nodeName;
        SerializedProperty description;
        SerializedProperty nodeColor;

        private void OnEnable()
        {
            sobject = new SerializedObject(target);
            nodeName = sobject.FindProperty("nodeName");
            description = sobject.FindProperty("description");
            nodeColor = sobject.FindProperty("nodeColor");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            
            EditorGUILayout.PropertyField(nodeName);
            EditorGUILayout.PropertyField(description);
            EditorGUILayout.PropertyField(nodeColor);
            
            InspectorNotify.Dispatch(sobject, target);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Snap\GrammarProductionRuleEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Grammar;
using UnityEditor;

namespace DungeonArchitect.Editors.SnapFlow
{
    [CustomEditor(typeof(GrammarProductionRule))]
    public class GrammarProductionRuleEditor : Editor
    {
        SerializedObject sobject;
        SerializedProperty ruleName;

        private void OnEnable()
        {
            sobject = new SerializedObject(target);
            ruleName = sobject.FindProperty("ruleName");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            
            EditorGUILayout.PropertyField(ruleName);
            
            InspectorNotify.Dispatch(sobject, target);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Snap\GrammarTaskNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Grammar;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    [CustomEditor(typeof(GrammarTaskNode))]
    public class GrammarTaskNodeEditor : Editor
    {
        SerializedObject sobject;
        SerializedProperty executionIndex;

        public void OnEnable()
        {
            sobject = new SerializedObject(target);
            executionIndex = sobject.FindProperty("executionIndex");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();

            GUILayout.Label("Task Node", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(executionIndex);
            
            InspectorNotify.Dispatch(sobject, target);
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Snap\SnapFlowResultGraphEditorConfigInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs.Layouts;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    [CustomEditor(typeof(SnapEdResultGraphEditorConfig), true)]
    public class SnapFlowResultGraphEditorConfigInspector : Editor
    {
        SerializedObject sobject;
        SerializedProperty layoutType;

        SerializedProperty configLayered_Separation;

        SerializedProperty configSpring_springDistance;
        SerializedProperty configSpring_nodeDistance;

        protected virtual void OnEnable()
        {
            sobject = new SerializedObject(target);
            layoutType = sobject.FindProperty("layoutType");

            var configLayered = sobject.FindProperty("configLayered");
            configLayered_Separation = configLayered.FindPropertyRelative("separation");

            var configSpring = sobject.FindProperty("configSpring");
            configSpring_springDistance = configSpring.FindPropertyRelative("springDistance");
            configSpring_nodeDistance = configSpring.FindPropertyRelative("interNodeDistance");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();


            GUILayout.Label("Layout Config", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(layoutType);
            GUILayout.Space(10);

            var targetConfig = target as SnapEdResultGraphEditorConfig;
            if (targetConfig.layoutType == GraphLayoutType.Layered)
            {
                EditorGUILayout.PropertyField(configLayered_Separation);
            }
            else if (targetConfig.layoutType == GraphLayoutType.Spring)
            {
                EditorGUILayout.PropertyField(configSpring_springDistance);
                EditorGUILayout.PropertyField(configSpring_nodeDistance);
            }

            InspectorNotify.Dispatch(sobject, target);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Snap\WeightedGrammarGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Grammar;
using UnityEditor;

namespace DungeonArchitect.Editors.SnapFlow
{
    [CustomEditor(typeof(WeightedGrammarGraph))]
    public class WeightedGrammarGraphEditor : Editor
    {
        SerializedObject sobject;
        SerializedProperty weight;
        
        private void OnEnable()
        {
            sobject = new SerializedObject(target);
            weight = sobject.FindProperty("weight");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            
            EditorGUILayout.PropertyField(weight);
            
            InspectorNotify.Dispatch(sobject, target);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Utils\Graph\EditorGraphBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.Graphs
{
    public class EditorGraphBuilder : GraphBuilder
    {
        private Object assetObject;
        private UIPlatform platform;
        private UIUndoSystem undo;

        public EditorGraphBuilder(Graph graph, Object assetObject, UIPlatform platform, UIUndoSystem undo) 
            : base(graph)
        {
            this.assetObject = assetObject;
            this.platform = platform;
            this.undo = undo;
        }

        public override GraphNode CreateNode(System.Type nodeType)
        {
            var node = GraphOperations.CreateNode(graph, nodeType, undo);
            node.Position = Vector2.zero;
            if (assetObject != null)
            {
                GraphEditorUtils.AddToAsset(platform, assetObject, node);
            }
            return node;
        }

        public override void DestroyNode(GraphNode node)
        {
            GraphOperations.DestroyNode(node, undo);
        }

        public override TLink LinkNodes<TLink>(GraphPin outputPin, GraphPin inputPin)
        {
            // Make sure a link doesn't already exists
            foreach (var existingLink in graph.Links)
            {
                if (existingLink.Input == inputPin && existingLink.Output == outputPin)
                {
                    return null;
                }
            }

            TLink link = GraphOperations.CreateLink<TLink>(graph);
            link.Input = inputPin;
            link.Output = outputPin;

            if (assetObject != null)
            {
                GraphEditorUtils.AddToAsset(platform, assetObject, link);
            }
            return link;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\CircularCity\CircularCityDungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.RoadNetworks;
using DungeonArchitect.Splatmap;

namespace DungeonArchitect.Builders.CircularCity
{
    public static class CircularCityDungeonMarkerNames
    {
        public static readonly string House = "House";
        public static readonly string WallMarkerName = "CityWall";
        public static readonly string DoorMarkerName = "CityDoor";
        public static readonly string GroundMarkerName = "CityGround";
        public static readonly string CornerTowerMarkerName = "CornerTower";
        public static readonly string WallPaddingMarkerName = "CityWallPadding";
    }

    public class CircularCityDungeonBuilder : DungeonBuilder
    {
        CircularCityDungeonConfig cityConfig;
        CircularCityDungeonModel cityModel;

        new System.Random random;
        /// <summary>
        /// Builds the dungeon layout.  In this method, you should build your dungeon layout and save it in your model file
        /// No markers should be emitted here.   (EmitMarkers function will be called later by the engine to do that)
        /// </summary>
        /// <param name="config">The builder configuration</param>
        /// <param name="model">The dungeon model that the builder will populate</param>
        public override void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();

            base.BuildDungeon(config, model);

            random = new System.Random((int)config.Seed);

            // We know that the dungeon prefab would have the appropriate config and models attached to it
            // Cast and save it for future reference
            cityConfig = config as CircularCityDungeonConfig;
            cityModel = model as CircularCityDungeonModel;
            cityModel.Config = cityConfig;

            // Generate the city layout and save it in a model.   No markers are emitted here. 
            GenerateCityLayout();

            sw.Stop();
            Debug.Log("Time elapsed: " + (sw.ElapsedMilliseconds / 1000.0f) + " s");
        }
        
        public override void OnDestroyed()
        {
            base.OnDestroyed();

            cityModel = model as CircularCityDungeonModel;
            if (cityModel.roadGraph != null)
            {
                //cityModel.roadGraph.nodes = new RoadGraphNode[0];
            }
        }
        

        /// <summary>
        /// Override the builder's emit marker function to emit our own markers based on the layout that we built
        /// You should emit your markers based on the layout you have saved in the model generated previously
        /// When the user is designing the theme interactively, this function will be called whenever the graph state changes,
        /// so the theme engine can populate the scene (BuildDungeon will not be called if there is no need to rebuild the layout again)
        /// </summary>
        public override void EmitMarkers()
        {
            base.EmitMarkers();
            EmitCityMarkers();
            ProcessMarkerOverrideVolumes();
        }

        delegate void InsertHouseDelegate();

        /// <summary>
        /// Grabs the texture stored in the splat asset.  The index is based on the texture info array you define in the splat component
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        Texture2D GetSplatTexture(int index)
        {
            var splatComponent = GetComponent<DungeonSplatmap>();
            if (splatComponent == null) return null;
            if (splatComponent.splatmap == null) return null;

            var splatmap = splatComponent.splatmap;
            if (index >= splatmap.splatTextures.Length) return null;

            return splatmap.splatTextures[index];
        }

        Texture2D GetRoadmap()
        {
            return GetSplatTexture(0);  
        }
        
        /// <summary>
        /// Generate a layout and save it in the model
        /// </summary>
        void GenerateCityLayout()
        {
            var roadGraphSettings = new RoadGraphBuilderSettings();
            roadGraphSettings.interNodeDistance = cityConfig.interNodeDistance;
            var roadGraphBuilder = new RoadGraphBuilder(roadGraphSettings);

            float startRadius = cityConfig.startRadius;
            float endRadius = cityConfig.endRadius;
            var center = Vector3.zero;

            float mainRoadStrength = cityConfig.mainRoadStrength;
            float sideRoadStrength = cityConfig.sideRoadStrength;
            float interRingDistance = (endRadius - startRadius) / (cityConfig.numRings - 1);

            // Draw the city rings
            {
                float ringRadius = startRadius;
                for (int r = 0; r < cityConfig.numRings; r++)
                {
                    roadGraphBuilder.CreateCircle(center, ringRadius, mainRoadStrength);
                    if (r < cityConfig.numRings - 1)
                    {
                        float ringLaneRadius = ringRadius + interRingDistance / 2.0f;
                        roadGraphBuilder.CreateCircle(center, ringLaneRadius, sideRoadStrength);
                    }
                    ringRadius += interRingDistance;
                }
            }

            // Draw the ray lanes ejecting out from the center
            float interRayAngle = Mathf.PI * 2 / cityConfig.numRays;
            for (int i = 0; i < cityConfig.numRays; i++)
            {
                float ringRadius = startRadius;
                int mainSegmentToRemove = random.Next() % (cityConfig.numRings - 1);
                for (int r = 0; r < cityConfig.numRings - 1; r++)
                {
                    float nextRingRadius = ringRadius + interRingDistance;

                    bool bDrawMainSegment = (r != mainSegmentToRemove);

                    if (bDrawMainSegment)
                    {
                        float angle = i * interRayAngle;
                        var direction = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));
                        float midRingRadius = ringRadius + (nextRingRadius - ringRadius) / 2.0f;

                        var start = center + direction * ringRadius;
                        var end = center + direction * midRingRadius;
                        roadGraphBuilder.CreateLine(start, end, mainRoadStrength);

                        start = center + direction * midRingRadius;
                        end = center + direction * nextRingRadius;
                        roadGraphBuilder.CreateLine(start, end, mainRoadStrength);
                    }

                    // Draw the side segments
                    {
                        float interSideRayAngle = interRayAngle / (r + 2);
                        float sideRayAngle = i * interRayAngle;
                        float interSideRingDistance = interRingDistance / 2.0f;
                        for (int si = 0; si <= r; si++)
                        {
                            sideRayAngle += interSideRayAngle;
                            for (int t = 0; t < 2; t++)
                            {
                                bool bRemoveSideSegment = (random.NextFloat() < cityConfig.sideRoadRemovalProbability);
                                if (!bRemoveSideSegment)
                                {
                                    float perimeter = Mathf.PI * 2 * ringRadius;
                                    float angleRandomization = cityConfig.randomSideLaneOffsetAngle * Mathf.Deg2Rad / perimeter;
                                    float randomValue = random.NextFloat() * 2 - 1;
                                    float randomizedAngle = sideRayAngle + angleRandomization * randomValue;
                                    float laneStartRadius = ringRadius + interSideRingDistance * t;
                                    float laneEndRadius = ringRadius + interSideRingDistance * (t + 1);

                                    var direction = new Vector3(Mathf.Cos(randomizedAngle), 0, Mathf.Sin(randomizedAngle));
                                    var start = center + direction * laneStartRadius;
                                    var end = center + direction * laneEndRadius;
                                    roadGraphBuilder.CreateLine(start, end, sideRoadStrength);
                                }
                            }
                        }
                    }

                    ringRadius = nextRingRadius;
                }
            }

            cityModel.roadGraph = roadGraphBuilder.BakeRoadGraph();

            var layoutBuilder = new RoadLayoutBuilder(cityModel.roadGraph, cityConfig.roadMesh);
            layoutBuilder.RoadBlockLayoutBuilt += LayoutBuilder_RoadBlockLayoutBuilt;

            cityModel.layoutGraph = layoutBuilder.BakeLayoutGraph();
        }

        private void LayoutBuilder_RoadBlockLayoutBuilt(ref Vector3[] layout)
        {
            
        }

        void DebugDrawGraphGizmo(RoadGraph graph, Color edgeColor, Color nodeColor)
        {
            if (graph == null || graph.nodes == null)
            {
                return;
            }

            // Create a hash table of the nodes for fast lookup
            var nodes = new Dictionary<int, RoadGraphNode>();
            foreach (var node in graph.nodes)
            {
                nodes.Add(node.nodeId, node);
            }

            // Draw the edges
            Gizmos.color = edgeColor;
            foreach (var node in graph.nodes)
            {
                foreach (var edge in node.adjacentEdges)
                {
                    var otherNode = nodes[edge.otherNodeId];
                    Gizmos.DrawLine(node.position, otherNode.position);
                }
            }

            // Draw the nodes
            Gizmos.color = nodeColor;
            foreach (var node in graph.nodes)
            {
                Gizmos.DrawSphere(node.position, .25f);
            }
        }

        public override void DebugDrawGizmos()
        {
            if (cityConfig == null)
            {
                cityConfig = GetComponent<CircularCityDungeonConfig>();
                if (cityConfig == null) return;
            }

            if (model == null)
            {
                model = GetComponent<CircularCityDungeonModel>();
            }

            if (cityModel == null) {
                cityModel = model as CircularCityDungeonModel;
            }

            if (cityModel == null)
            {
                return;
            }

            DebugDrawGraphGizmo(cityModel.roadGraph, Color.green, Color.red);
            DebugDrawGraphGizmo(cityModel.layoutGraph, Color.yellow, Color.blue);
        }

        class SpatialPartitionCache
        {
            private int gridSize;
            Dictionary<IntVector2, List<Vector3>> occupancyGrid = new Dictionary<IntVector2, List<Vector3>>();

            public SpatialPartitionCache(int gridSize)
            {
                this.gridSize = gridSize;
            }

            public void RegisterAsOccupied(Vector3 position)
            {
                var cell = GetCell(position);
                if (!occupancyGrid.ContainsKey(cell))
                {
                    occupancyGrid.Add(cell, new List<Vector3>());
                }
                occupancyGrid[cell].Add(position);
            }

            public bool IsFree(Vector3 position, float distanceSearch)
            {
                var baseCell = GetCell(position);
                for (int dx = -1; dx <= 1; dx++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        var cell = baseCell + new IntVector2(dx, dy);
                        if (!IsFree(position, cell, distanceSearch))
                        {
                            return false;
                        }
                    }
                }
                return true;
            }

            bool IsFree(Vector3 sourcePosition, IntVector2 cell, float distanceSearch)
            {
                if (!occupancyGrid.ContainsKey(cell))
                {
                    return true;
                }

                float distanceSearchSq = distanceSearch * distanceSearch;
                foreach (var position in occupancyGrid[cell])
                {
                    var distanceSq = (sourcePosition - position).sqrMagnitude;
                    if (distanceSq < distanceSearchSq)
                    {
                        return false;
                    }
                }
                return true;
            }

            IntVector2 GetCell(Vector3 position)
            {
                var cell = new IntVector2();
                cell.x = Mathf.RoundToInt(position.x / gridSize);
                cell.y = Mathf.RoundToInt(position.z / gridSize);
                return cell;
            }

        }

        /// <summary>
        /// Emit marker points so that the theme can decorate the scene layout that we just built
        /// </summary>
        void EmitCityMarkers()
        {
            var basePosition = transform.position;

            float occupancySearchDistance = cityConfig.buildingSize * 1.0f;
            int cacheGridResolution = Mathf.RoundToInt(occupancySearchDistance * 2.0f);
            var spatialOccupancy = new SpatialPartitionCache(cacheGridResolution);
            foreach (var node in cityModel.roadGraph.nodes)
            {
                spatialOccupancy.RegisterAsOccupied(node.position);
            }
            foreach (var node in cityModel.layoutGraph.nodes)
            {
                spatialOccupancy.RegisterAsOccupied(node.position);
            }

            for (float r = cityConfig.startRadius; r < cityConfig.endRadius; r += cityConfig.buildingSize)
            {
                float circumference = 2 * Mathf.PI * r;
                int numBuildings = Mathf.RoundToInt(circumference / cityConfig.buildingSize);
                for (int i = 0; i < numBuildings; i++)
                {
                    float angle = 2 * Mathf.PI * i / (float)numBuildings;
                    var offset = Vector3.zero;
                    offset.x = Mathf.Cos(angle) * r;
                    offset.z = Mathf.Sin(angle) * r;
                    var position = basePosition + offset;
                    if (!spatialOccupancy.IsFree(offset, occupancySearchDistance))
                    {
                        continue;
                    }
                    var rotation = Quaternion.Euler(0, -angle * Mathf.Rad2Deg, 0);
                    EmitMarkerAt(CircularCityDungeonMarkerNames.House, position, rotation);
                }
            }

        }
                

        void EmitMarkerAt(string markerName, Vector3 worldPosition, Quaternion rotation)
        {
            var transformation = Matrix4x4.TRS(worldPosition, rotation, Vector3.one);
            var gridPosition = IntVector.Zero;
            EmitMarker(markerName, transformation, gridPosition, -1);
        }
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\CircularCity\CircularCityDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.CircularCity
{
    public class CircularCityDungeonConfig : DungeonConfig
    {
        public int numRings = 5;
        public int numRays = 7;

        public float startRadius = 50;
        public int endRadius = 200;

        public float mainRoadStrength = 4.0f;
        public float sideRoadStrength = 2.0f;

        public float mainRoadRemovalProbability = 0.1f;
        public float sideRoadRemovalProbability = 0.2f;

        public float randomSideLaneOffsetAngle = 3;

        public float interNodeDistance = 6.0f;

        public float buildingSize = 4.0f;

        public MeshFilter roadMesh;
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\CircularCity\CircularCityDungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.RoadNetworks;

namespace DungeonArchitect.Builders.CircularCity
{

    public enum CircularCityCellType
    {
        Road,
        House,
        Park,
        CityWallPadding,
        UserDefined,
        Empty
    }

    public class CircularCityCell
    {
        public IntVector Position;
        public CircularCityCellType CellType;
        public Quaternion Rotation;
        public Vector3 BlockSize = new Vector3(1, 0, 1);
        public string MarkerNameOverride;
    }

    public class CircularCityDungeonModel : DungeonModel
    {
        [HideInInspector]
        public CircularCityDungeonConfig Config;

        //[HideInInspector]
        public RoadGraph roadGraph;

        //[HideInInspector]
        public RoadGraph layoutGraph;
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Common\DungeonBuilderDefaultMarkers.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Builders.FloorPlan;
using DungeonArchitect.Builders.Isaac;
using DungeonArchitect.Builders.SimpleCity;
using DungeonArchitect.Builders.CircularCity;
using DungeonArchitect.Builders.Snap;
using DungeonArchitect.Builders.Mario;
using DungeonArchitect.Builders.Maze;
using DungeonArchitect.Builders.BSP;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Builders.Infinity.Caves;
using DungeonArchitect.Builders.SnapGridFlow;

namespace DungeonArchitect.Builders
{
    public static class DungeonBuilderDefaultMarkers
    {
        static Dictionary<Type, string[]> DefaultMarkersByBuilder = new Dictionary<Type, string[]>();

        static DungeonBuilderDefaultMarkers()
        {
            DefaultMarkersByBuilder.Add(typeof(GridDungeonBuilder), new string[] {
	            GridDungeonMarkerNames.Ground,
	            GridDungeonMarkerNames.Wall,
	            GridDungeonMarkerNames.WallSeparator,
	            GridDungeonMarkerNames.Fence,
	            GridDungeonMarkerNames.FenceSeparator,
	            GridDungeonMarkerNames.Door,
	            GridDungeonMarkerNames.Stair,
	            GridDungeonMarkerNames.Stair2X,
	            GridDungeonMarkerNames.WallHalf,
	            GridDungeonMarkerNames.WallHalfSeparator
	        });

            DefaultMarkersByBuilder.Add(typeof(GridFlowDungeonBuilder), new string[] {
                GridFlowDungeonMarkerNames.Ground,
                GridFlowDungeonMarkerNames.Wall,
                GridFlowDungeonMarkerNames.WallSeparator,
                GridFlowDungeonMarkerNames.Fence,
                GridFlowDungeonMarkerNames.FenceSeparator,
                GridFlowDungeonMarkerNames.Door,
                GridFlowDungeonMarkerNames.DoorOneWay
            });

            DefaultMarkersByBuilder.Add(typeof(SimpleCityDungeonBuilder), new string[] {
	            SimpleCityDungeonMarkerNames.House,
	            SimpleCityDungeonMarkerNames.Park,
	            SimpleCityDungeonMarkerNames.Road_X,
	            SimpleCityDungeonMarkerNames.Road_T,
	            SimpleCityDungeonMarkerNames.Road_Corner,
	            SimpleCityDungeonMarkerNames.Road_S,
	            SimpleCityDungeonMarkerNames.Road_E,
	            SimpleCityDungeonMarkerNames.Road,

	            SimpleCityDungeonMarkerNames.CityWall,
	            SimpleCityDungeonMarkerNames.CityDoor,
	            SimpleCityDungeonMarkerNames.CityGround,
	            SimpleCityDungeonMarkerNames.CornerTower,
	            SimpleCityDungeonMarkerNames.CityWallPadding,
	        });

            DefaultMarkersByBuilder.Add(typeof(CircularCityDungeonBuilder), new string[] {
                CircularCityDungeonMarkerNames.House,
                CircularCityDungeonMarkerNames.WallMarkerName,
                CircularCityDungeonMarkerNames.DoorMarkerName,
                CircularCityDungeonMarkerNames.GroundMarkerName,
                CircularCityDungeonMarkerNames.CornerTowerMarkerName,
                CircularCityDungeonMarkerNames.WallPaddingMarkerName,
            });

            DefaultMarkersByBuilder.Add(typeof(FloorPlanBuilder), new string[] {
	            FloorPlanMarkerNames.Ground,
	            FloorPlanMarkerNames.Ceiling,
	            FloorPlanMarkerNames.Wall,
	            FloorPlanMarkerNames.Door,
	            FloorPlanMarkerNames.BuildingWall
	        });

			DefaultMarkersByBuilder.Add(typeof(IsaacDungeonBuilder), new string[] {
				IsaacDungeonMarkerNames.Ground,
				IsaacDungeonMarkerNames.Wall,
				IsaacDungeonMarkerNames.Door
			});

			DefaultMarkersByBuilder.Add(typeof(MarioDungeonBuilder), new string[] {
                MarioDungeonMarkerNames.Ground,
                MarioDungeonMarkerNames.WallFront,
                MarioDungeonMarkerNames.WallBack,
                MarioDungeonMarkerNames.WallSide,
                MarioDungeonMarkerNames.BackgroundGround,
                MarioDungeonMarkerNames.BackgroundCeiling,
                MarioDungeonMarkerNames.BackgroundWall,
                MarioDungeonMarkerNames.Stair,
                MarioDungeonMarkerNames.Corridor,
            });

            DefaultMarkersByBuilder.Add(typeof(MazeDungeonBuilder), new string[] {
                MazeDungeonMarkerNames.GroundBlock,
                MazeDungeonMarkerNames.WallBlock,
            });

            DefaultMarkersByBuilder.Add(typeof(BSPDungeonBuilder), new string[] {
                BSPDungeonMarkerNames.GroundRoom,
                BSPDungeonMarkerNames.GroundCorridor,
                BSPDungeonMarkerNames.Door,
                BSPDungeonMarkerNames.WallRoom,
                BSPDungeonMarkerNames.WallCorridor,
                BSPDungeonMarkerNames.WallSeparator,
            });

            DefaultMarkersByBuilder.Add(typeof(InfinityCaveChunkBuilder), new string[] {
                InfinityCaveChunkMarkerNames.GroundBlock,
                InfinityCaveChunkMarkerNames.WallBlock,
                InfinityCaveChunkMarkerNames.RockBlock
            });

            DefaultMarkersByBuilder.Add(typeof(SnapBuilder), new string[] {

            });

            DefaultMarkersByBuilder.Add(typeof(SnapGridFlowBuilder), new string[] {

            });
        }

        public static string[] GetDefaultMarkers(Type builderClass)
        {
            if (!DefaultMarkersByBuilder.ContainsKey(builderClass))
            {
                return new string[0];
            }

            return DefaultMarkersByBuilder[builderClass];
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\FloorPlanner\FloorPlanBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.FloorPlan
{
    public static class FloorPlanMarkerNames
    {
        public static readonly string Ground = "Ground";
        public static readonly string Ceiling = "Ceiling";
        public static readonly string Wall = "Wall";
        public static readonly string Door = "Door";
        public static readonly string BuildingWall = "BuildingWall";
    }

    public class FloorPlanBuilder : DungeonBuilder
    {
        FloorPlanConfig floorPlanConfig;
        FloorPlanModel floorPlanModel;

        FloorChunkDB ChunkDB;
        FloorDoorManager DoorManager;
        HashSet<int> Visited = new HashSet<int>();

        new System.Random random;
        /// <summary>
        /// Builds the dungeon layout.  In this method, you should build your dungeon layout and save it in your model file
        /// No markers should be emitted here.   (EmitMarkers function will be called later by the engine to do that)
        /// </summary>
        /// <param name="config">The builder configuration</param>
        /// <param name="model">The dungeon model that the builder will populate</param>
        public override void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            base.BuildDungeon(config, model);

            random = new System.Random((int)config.Seed);

            // We know that the dungeon prefab would have the appropriate config and models attached to it
            // Cast and save it for future reference
            floorPlanConfig = config as FloorPlanConfig;
            floorPlanModel = model as FloorPlanModel;
            floorPlanModel.Config = floorPlanConfig;

            // Generate the floor plan layout and save it in a model.   No markers are emitted here. 
            BuildLayout();

            markers.Clear();
        }

        /// <summary>
        /// Override the builder's emit marker function to emit our own markers based on the layout that we built
        /// You should emit your markers based on the layout you have saved in the model generated previously
        /// When the user is designing the theme interactively, this function will be called whenever the graph state changes,
        /// so the theme engine can populate the scene (BuildDungeon will not be called if there is no need to rebuild the layout again)
        /// </summary>
        public override void EmitMarkers()
        {
            base.EmitMarkers();
            EmitBuildingMarkers();
            ProcessMarkerOverrideVolumes();
        }

        void BuildLayout() {

            ChunkDB = new FloorChunkDB();
            DoorManager = new FloorDoorManager();
            Visited.Clear();
	        random = new System.Random((int)floorPlanConfig.Seed);

	        var userDefinedSplits = new List<Vector2>();
	        var dungeonPosition = transform.position;
	        foreach (var pointTool  in floorPlanConfig.manualHallwayPoints)
	        {
		        if (pointTool == null) continue;
		        var worldPosition = pointTool.transform.position - dungeonPosition;
		        var localPoint = new Vector2(worldPosition.x / floorPlanConfig.GridSize.x, worldPosition.z / floorPlanConfig.GridSize.z);
		        userDefinedSplits.Add(localPoint);
	        }
	        
	        int NumFloors = Mathf.RoundToInt(floorPlanConfig.BuildingSize.y);
	        for (int y = 0; y < NumFloors; y++) {
		        // Build the hallways and the intermediate floor chunks (which will hold the rooms)
		        List<FloorChunk> FloorChunks = new List<FloorChunk>();
		        {
			        FloorChunk InitialFloor = ChunkDB.Create();
			        InitialFloor.Bounds.Location = new IntVector(0, y, 0);
			        InitialFloor.Bounds.Size = MathUtils.ToIntVector(floorPlanConfig.BuildingSize);

			        Stack<FloorChunk> Stack = new Stack<FloorChunk>();
			        Stack.Push(InitialFloor);
			        while (Stack.Count > 0) {
				        FloorChunk Top = Stack.Pop();
				        float Area = Top.Area();
				        if (Area <= 0) continue;
				        if (Top.Area() <= floorPlanConfig.MinRoomChunkArea) {
					        FloorChunks.Add(Top);
				        }
				        else {
					        // Needs to be split further
					        FloorChunk Left = ChunkDB.Create();
					        FloorChunk Right = ChunkDB.Create();
					        FloorChunk Hallway = ChunkDB.Create();

					        bool userManualSplit = false;
					        if (userDefinedSplits.Count > 0)
					        {
						        var localPosition = userDefinedSplits[0];
						        if (Top.Bounds.Contains(Mathf.FloorToInt(localPosition.x), Mathf.FloorToInt(localPosition.y)))
						        {
							        userManualSplit = true;
						        }
					        }

					        if (userManualSplit)
					        {
						        var localPosition = userDefinedSplits[0];
						        userDefinedSplits.RemoveAt(0);

						        float ratio = 0;
						        if (Top.Bounds.Size.x > Top.Bounds.Size.z)
						        {
							        ratio = localPosition.x - Top.Bounds.X;
						        }
						        else
						        {
							        ratio = localPosition.y - Top.Bounds.Z;
						        }
						        
						        SplitChunk(Top, ratio, Left, Right, Hallway);
					        }
					        else
					        {
						        SplitChunk(Top, Left, Right, Hallway);
					        }

					        ChunkDB.Register(Hallway);

					        Stack.Push(Left);
					        Stack.Push(Right);
				        }
			        }
		        }

		        // Split the floor chunks (space between the hallways) to create rooms
		        foreach (FloorChunk Chunk in FloorChunks) {
			        Stack<FloorChunk> Stack = new Stack<FloorChunk>();
			        Stack.Push(Chunk);
                    int MinRoomSize = Mathf.Max(1, floorPlanConfig.MinRoomSize);
                    int MaxRoomSize = Mathf.Max(1, floorPlanConfig.MaxRoomSize);
                    MaxRoomSize = Mathf.Max(MinRoomSize, MaxRoomSize);

                    int MinArea = MinRoomSize * MinRoomSize;
			        int MaxArea = MaxRoomSize * MaxRoomSize;

			        while (Stack.Count > 0) {
				        FloorChunk Top = Stack.Pop();
				        bool bRequiresSplit = true;
				        int Area = Top.Area();
				        int Length = Top.GetLength();
				        if (Length > MaxRoomSize) {
					        // Length is too big. force a split
					        bRequiresSplit = true;
				        }
				        else if (Area <= MinArea) {
					        // This room is too small and should not be split
					        bRequiresSplit = false;
				        }
				        else if (Area <= MaxArea) {
					        float SplitProbability = (Area - MinArea) / (MaxArea - MinArea);
					        SplitProbability += floorPlanConfig.RoomSplitProbabilityOffset;
					        if (Chunk.GetLength() >= Chunk.GetWidth() * 2) {
						        SplitProbability += floorPlanConfig.RoomSplitProbabilityOffset;
					        }
					        bRequiresSplit = (random.Next() < SplitProbability);
				        }

				        if (bRequiresSplit) {
					        FloorChunk Left = ChunkDB.Create();
					        FloorChunk Right = ChunkDB.Create();
					        SplitChunk(Top, Left, Right);
					        Stack.Push(Left);
					        Stack.Push(Right);
				        }
				        else {
					        ChunkDB.Register(Top);
				        }
			        }
		        }

                // TODO: Add support for floor plan specific volumes
                // ...
	        }

	        ChunkDB.CacheChunkPositions();

	        for (int y = 0; y < floorPlanConfig.BuildingSize.y; y++) {
		        CreateDoors(y);
            }

            // Save the data to the model
            floorPlanModel.Chunks = ChunkDB.GetAllChunks();
        }
        
        void SplitChunk(FloorChunk Chunk, FloorChunk OutLeft, FloorChunk OutRight, FloorChunk OutHallway)
        {
            int HallWidth = floorPlanConfig.HallWidth;
	        int Length = Chunk.GetLength();
	        int RemainingLength = Length - HallWidth;
	        int MinChunkLength = floorPlanConfig.MinRoomSize;
	        int LengthLeft = MinChunkLength + random.Next(0, Mathf.Max(0, RemainingLength - MinChunkLength * 2 + 1));
	        int LengthRight = RemainingLength - LengthLeft;
	        SplitChunk(Chunk, LengthLeft, LengthRight, OutLeft, OutRight, OutHallway);
        }

        void SplitChunk(FloorChunk Chunk, float ratio, FloorChunk OutLeft, FloorChunk OutRight, FloorChunk OutHallway)
        {
	        int HallWidth = floorPlanConfig.HallWidth;
	        int Length = Chunk.GetLength();
	        int RemainingLength = Length - HallWidth;
	        int MinChunkLength = floorPlanConfig.MinRoomSize;
	        //int LengthLeft = MinChunkLength + random.Next(0, Mathf.Max(0, RemainingLength - MinChunkLength * 2 + 1));
	        int LengthLeft = Mathf.FloorToInt(ratio);
	        LengthLeft = Mathf.Max(MinChunkLength, LengthLeft);
	        int LengthRight = RemainingLength - LengthLeft;
	        
	        SplitChunk(Chunk, LengthLeft, LengthRight, OutLeft, OutRight, OutHallway);
        }

        void SplitChunk(FloorChunk Chunk, int LengthLeft, int LengthRight, FloorChunk OutLeft, FloorChunk OutRight, FloorChunk OutHallway)
        {
	        int HallWidth = floorPlanConfig.HallWidth;
	        OutLeft.Bounds = Chunk.Bounds;
	        OutLeft.ChunkType = FloorChunkType.Room;
	        OutLeft.SetLength(LengthLeft);

	        OutHallway.Bounds = Chunk.Bounds;
	        OutHallway.ChunkType = FloorChunkType.Hall;
	        OutHallway.OffsetAlongLength(LengthLeft);
	        OutHallway.SetLength(HallWidth);

	        OutRight.Bounds = Chunk.Bounds;
	        OutRight.ChunkType = FloorChunkType.Room;
	        OutRight.OffsetAlongLength(LengthLeft + HallWidth);
	        OutRight.SetLength(LengthRight);
	        
        }

        void SplitChunk(FloorChunk Chunk, FloorChunk OutLeft, FloorChunk OutRight)
        {
            int MinRoomLength = floorPlanConfig.MinRoomSize;
	        int Length = Chunk.GetLength();
            int LengthLeft = MinRoomLength + random.Next(0, Mathf.Max(0, Length - MinRoomLength * 2));
	        int LengthRight = Length - LengthLeft;
	        OutLeft.Bounds = Chunk.Bounds;
	        OutLeft.ChunkType = FloorChunkType.Room;
	        OutLeft.SetLength(LengthLeft);
	
	        OutRight.Bounds = Chunk.Bounds;
	        OutRight.OffsetAlongLength(LengthLeft);
	        OutRight.ChunkType = FloorChunkType.Room;
	        OutRight.SetLength(LengthRight);
        }
        void EmitMarkerAt(Vector3 WorldLocation, string MarkerName, Quaternion Rotation)
        {
	        Vector3 BasePosition = gameObject.transform.position;
	        Vector3 MarkerPosition = BasePosition + WorldLocation;
            Matrix4x4 Transform = Matrix4x4.TRS(MarkerPosition, Rotation, Vector3.one);
	        EmitMarker(MarkerName, Transform, IntVector.Zero, -1);
        }
        void EmitMarkerAt(Vector3 WorldLocation, string MarkerName, float Angle)
        {
	        EmitMarkerAt(WorldLocation, MarkerName, Quaternion.Euler(0, Angle, 0));
        }

	    bool VolumeEncompassesPoint(DungeonArchitect.Volume volume, IntVector GridPoint) {
            // TODO: Implement me
            return false;
        }
	    void GetVolumeCells(DungeonArchitect.Volume volume, int y, List<IntVector> OutCells) {
            OutCells.Clear();
            // TODO: Implement me
        }

        
        //////////////////////////// Door connection //////////////////////////
        static int GetChunkDoorConnectionScore(FloorChunk Chunk) {
	        if (Chunk == null) return -1000;
	        if (Chunk.bReachable) return -500;
	        if (!Chunk.bConnectDoors) return -1000;
	        if (Chunk.ChunkType == FloorChunkType.Hall) return 1000;
	        if (Chunk.ChunkType == FloorChunkType.Room) return 500;
	        return 0;
        }

        public class FloorIslandNode {
	        public FloorIslandNode() {
                IslandId = -1;
                Location = IntVector.Zero;
            }
	        public int IslandId;
	        public FloorChunk Chunk;
	        public IntVector Location;
        };

        void FloodFill(IntVector StartLocation, int IslandId, HashSet<IntVector> Visited, List<FloorIslandNode> IslandNodes, FloorChunkDB ChunkDB) {

	        FloorChunk PreferedChunk = ChunkDB.GetChunkAt(StartLocation);
	        if (!PreferedChunk.bConnectDoors) {
		        // We don't want doors here
		        return;
	        }
	        if (PreferedChunk == null) {
		        return;
	        }

	        Queue<IntVector> Queue = new Queue<IntVector>();
	        Queue.Enqueue(StartLocation);

	        while (Queue.Count > 0) {
		        IntVector Location = Queue.Dequeue();

		        FloorChunk CurrentChunk = ChunkDB.GetChunkAt(Location);
		        if (CurrentChunk != PreferedChunk) {
			        continue;
		        }

		        // Create a node here
		        FloorIslandNode Node = new FloorIslandNode();
		        Node.IslandId = IslandId;
		        Node.Chunk = CurrentChunk;
		        Node.Location = Location;

		        IslandNodes.Add(Node);

		        // Add the neighbors to the queue
		        List<IntVector> Neighbors = new List<IntVector>();
		        Neighbors.Add(Location + new IntVector(-1, 0, 0));
		        Neighbors.Add(Location + new IntVector(1, 0, 0));
		        Neighbors.Add(Location + new IntVector(0, 0, 1));
		        Neighbors.Add(Location + new IntVector(0, 0, -1));

		        foreach (IntVector Neighbor in Neighbors) {
			        if (Visited.Contains(Neighbor)) {
				        continue;
			        }
			        FloorChunk NeighborChunk = ChunkDB.GetChunkAt(Neighbor);
			        if (NeighborChunk != null && NeighborChunk.Id == CurrentChunk.Id) {
				        Queue.Enqueue(Neighbor);
				        Visited.Add(Neighbor);
			        }
		        }
	        }
        }

        class FloorIslandAdjacency {
	        public FloorIslandNode A;
	        public FloorIslandNode B;
        };

        class IslandNodePriorityPredicate : IComparer<int> {
	        public IslandNodePriorityPredicate(Dictionary<int, FloorChunk> InIslandToChunkMap) {
                IslandToChunkMap = InIslandToChunkMap; 
            }
            public int Compare(int IslandA, int IslandB)  
            {
                FloorChunk ChunkA = IslandToChunkMap.ContainsKey(IslandA) ? IslandToChunkMap[IslandA] : null;
		        FloorChunk ChunkB = IslandToChunkMap.ContainsKey(IslandB) ? IslandToChunkMap[IslandB] : null;
                
                int ScoreA = GetChunkDoorConnectionScore(ChunkA);
                int ScoreB = GetChunkDoorConnectionScore(ChunkB);
                if (ScoreA == ScoreB) return 0;
                return ScoreA < ScoreB ? 1 : -1;
            }

	        Dictionary<int, FloorChunk> IslandToChunkMap;

        };

        void ConnectIslandRecursive(int IslandId, Dictionary<int, List<FloorIslandAdjacency>> AdjacencyByIslands, 
		        HashSet<int> IslandVisited, System.Random random, FloorDoorManager DoorManager, Dictionary<int, FloorChunk> IslandToChunkMap) {

	        if (IslandVisited.Contains(IslandId)) {
		        return;
	        }
	        IslandVisited.Add(IslandId);

	        if (!AdjacencyByIslands.ContainsKey(IslandId)) {
		        // No adjacent islands
		        return;
	        }

	        List<FloorIslandAdjacency> AdjacentNodes = AdjacencyByIslands[IslandId];
	        HashSet<int> AdjacentIslands = new HashSet<int>();
	        foreach (FloorIslandAdjacency AdjacentNode in AdjacentNodes) {
		        AdjacentIslands.Add(AdjacentNode.A.IslandId);
		        AdjacentIslands.Add(AdjacentNode.B.IslandId);
	        }
	        AdjacentIslands.Remove(IslandId);
	        IslandNodePriorityPredicate SortPredicate = new IslandNodePriorityPredicate(IslandToChunkMap);
            int[] AdjacentIslandArray = new List<int>(AdjacentIslands).ToArray();
            System.Array.Sort(AdjacentIslandArray, SortPredicate);

	        foreach (int AdjacentIsland in AdjacentIslandArray) {
		        if (IslandVisited.Contains(AdjacentIsland)) {
			        continue;
		        }

		        // Find all the adjacent cells between these two islands
		        List<FloorIslandAdjacency> EdgeNodes = new List<FloorIslandAdjacency>();
		        foreach (FloorIslandAdjacency AdjacentNode in AdjacentNodes) {
			        if (AdjacentNode.A.IslandId == AdjacentIsland || AdjacentNode.B.IslandId == AdjacentIsland) {
				        EdgeNodes.Add(AdjacentNode);
			        }
		        }

		        // Connect a door in any one of the edge nodes
		        if (EdgeNodes.Count > 0) {
			        int Index = random.Next(0, EdgeNodes.Count);
			        FloorIslandAdjacency DoorEdge = EdgeNodes[Index];
			        // Create a door here
			        DoorManager.RegisterDoor(DoorEdge.A.Location, DoorEdge.B.Location);

			        // Move into this room now
			        ConnectIslandRecursive(AdjacentIsland, AdjacencyByIslands, IslandVisited, random, DoorManager, IslandToChunkMap);
		        }
	        }
        }
        

        void CreateDoors(int y)
        {
            // Tag all islands
	        // Create adjacency list
	        // Do a DFS on the tagged islands and connect the islands with doors

	        HashSet<IntVector> Visited = new HashSet<IntVector>();
	        List<FloorIslandNode> IslandNodes = new List<FloorIslandNode>();
	        int TotalIslands = 0;

	        // Tag islands with a flood fill.  This helps if custom volume split existing
	        // rooms into multiple parts and needs to be treated separately (islands)
	        {
		        int IslandId = 0;
		        for (int x = 0; x < floorPlanConfig.BuildingSize.x; x++) {
			        for (int z = 0; z < floorPlanConfig.BuildingSize.z; z++) {
				        IntVector Location = new IntVector(x, y, z);
				        if (!Visited.Contains(Location)) {
					        // Flood fill from here
					        Visited.Add(Location);
					        FloodFill(Location, IslandId, Visited, IslandNodes, ChunkDB);
					        IslandId++;
				        }
			        }
		        }
		        TotalIslands = IslandId;
	        }

	        // Create a node map for faster access
	        Dictionary<IntVector, FloorIslandNode> IslandNodeByLocation = new Dictionary<IntVector,FloorIslandNode>();
	        foreach (FloorIslandNode Node in IslandNodes) {
		        if (Node.IslandId == -1) continue;
		        IslandNodeByLocation.Add(Node.Location, Node);
	        }

	        // Create adjacency list for each island
	        List<FloorIslandAdjacency> AdjacencyList = new List<FloorIslandAdjacency>();
	        for (int x = 0; x < floorPlanConfig.BuildingSize.x; x++) {
		        for (int z = 0; z < floorPlanConfig.BuildingSize.z; z++) {
			        IntVector Loc00 = new IntVector(x, y, z);
			        if (!IslandNodeByLocation.ContainsKey(Loc00)) {
				        continue;
			        }
			        FloorIslandNode Node00 = IslandNodeByLocation[Loc00];
			        if (Node00.IslandId == -1) {
				        continue;
			        }
			
			        // Test along the left cell
			        {
				        IntVector Loc10 = new IntVector(x + 1, y, z);
				        if (IslandNodeByLocation.ContainsKey(Loc10)) {
					        FloorIslandNode Node10 = IslandNodeByLocation[Loc10];
					        if (Node10.IslandId != -1 && Node00.IslandId != Node10.IslandId) {
						        // Different adjacent nodes.  Add to the list
						        FloorIslandAdjacency Adjacency = new FloorIslandAdjacency();
						        Adjacency.A = Node00;
						        Adjacency.B = Node10;
						        AdjacencyList.Add(Adjacency);
					        }
				        }
			        }

			        // Test along the bottom cell
			        {
                        IntVector Loc01 = new IntVector(x, y, z + 1);
				        if (IslandNodeByLocation.ContainsKey(Loc01)) {
					        FloorIslandNode Node01 = IslandNodeByLocation[Loc01];
					        if (Node01.IslandId != -1 && Node00.IslandId != Node01.IslandId) {
						        // Different adjacent nodes.  Add to the list
						        FloorIslandAdjacency Adjacency = new FloorIslandAdjacency();
						        Adjacency.A = Node00;
						        Adjacency.B = Node01;
						        AdjacencyList.Add(Adjacency);
					        }
				        }
			        }
		        }
	        }

	        // Create another lookup for faster access
	        Dictionary<int, List<FloorIslandAdjacency>> AdjacencyByIsland = new Dictionary<int,List<FloorIslandAdjacency>>();
	        foreach (FloorIslandAdjacency Adjacency in AdjacencyList) {
		        int IslandA = Adjacency.A.IslandId;
		        int IslandB = Adjacency.B.IslandId;
		        if (!AdjacencyByIsland.ContainsKey(IslandA)) AdjacencyByIsland.Add(IslandA, new List<FloorIslandAdjacency>());
		        if (!AdjacencyByIsland.ContainsKey(IslandB)) AdjacencyByIsland.Add(IslandB, new List<FloorIslandAdjacency>());

		        AdjacencyByIsland[IslandA].Add(Adjacency);
		        AdjacencyByIsland[IslandB].Add(Adjacency);
	        }

	        Dictionary<int, FloorChunk> IslandToChunkMap = new Dictionary<int,FloorChunk>();
	        foreach (FloorIslandNode IslandNode in IslandNodes) {
		        if (IslandToChunkMap.ContainsKey(IslandNode.IslandId)) {
			        continue;
		        }
		        IslandToChunkMap.Add(IslandNode.IslandId, IslandNode.Chunk);
	        }

	        // Connect the islands to the main network with doors
	        HashSet<int> IslandVisited = new HashSet<int>();
	        for (int IslandId = 0; IslandId < TotalIslands; IslandId++) {
		        ConnectIslandRecursive(IslandId, AdjacencyByIsland, IslandVisited, random, DoorManager, IslandToChunkMap);
	        }
        }
        
        protected override LevelMarkerList CreateMarkerListObject(DungeonConfig config)
        {
	        var floorConfig = config as FloorPlanConfig;
	        if (floorConfig != null)
	        {
		        var bucketSize = Mathf.Max(floorConfig.GridSize.x, floorConfig.GridSize.z) * 2;
		        bucketSize = Mathf.Max(0.1f, bucketSize);
		        return new SpatialPartionedLevelMarkerList(bucketSize);
	        }
	        else
	        {
		        return base.CreateMarkerListObject(config);
	        }
        }
        
        FloorChunk GetPriorityChunk(FloorChunk A, FloorChunk B)
        {
            if (A == null) return B;
            if (B == null) return A;
            return A.Priority > B.Priority ? A : B;
        }

        string GetDoorMarkerName(FloorChunk ChunkA, FloorChunk ChunkB)
        {
            if (ChunkA == null && ChunkB == null)
            {
                return FloorPlanMarkerNames.Door;
            }

            FloorChunk PreferedChunk;
            if (ChunkA == null)
            {
                PreferedChunk = ChunkB;
            }
            else if (ChunkB == null)
            {
                PreferedChunk = ChunkA;
            }
            else
            {
                PreferedChunk = (ChunkA.Priority > ChunkB.Priority) ? ChunkA : ChunkB;
            }

            return PreferedChunk.DoorMarker.Length > 0 ? PreferedChunk.DoorMarker : FloorPlanMarkerNames.Door;
        }

        /// <summary>
        /// Generate a layout and save it in the model
        /// </summary>
        void EmitBuildingMarkers()
        {
            floorPlanConfig = config as FloorPlanConfig;
            floorPlanModel = model as FloorPlanModel;

            ClearSockets();

	        //TArray<AFloorPlanDoorVolume*> DoorVolumes = UDungeonModelHelper::GetVolumes<AFloorPlanDoorVolume>(Dungeon)

	        ClearSockets();
	        int NumFloors = Mathf.RoundToInt(floorPlanConfig.BuildingSize.y);
	        Vector3 GridSize = floorPlanConfig.GridSize;
	        bool bBuildingWallLeft, bBuildingWallBottom;
	        for (int y = 0; y < NumFloors; y++) {
		        for (int x = -1; x < floorPlanConfig.BuildingSize.x; x++) {
			        bBuildingWallLeft = (x == -1 || x == floorPlanConfig.BuildingSize.x - 1);
			        for (int z = -1; z < floorPlanConfig.BuildingSize.z; z++) {
				        bBuildingWallBottom = (z == -1 || z == floorPlanConfig.BuildingSize.z - 1);
				        FloorChunk Chunk00 = ChunkDB.GetChunkAt(x, y, z);
				        FloorChunk Chunk10 = ChunkDB.GetChunkAt(x + 1, y, z);
				        FloorChunk Chunk01 = ChunkDB.GetChunkAt(x, y, z + 1);

				        string GroundMarkerName = FloorPlanMarkerNames.Ground;
				        string CeilingMarkerName = FloorPlanMarkerNames.Ceiling;

				        FloorChunk ChunkAbove = ChunkDB.GetChunkAt(x, y + 1, z);
				        FloorChunk ChunkBelow = ChunkDB.GetChunkAt(x, y - 1, z);
				        bool bEmitGroundMarker = (Chunk00 != ChunkBelow);
				        bool bEmitCeilingMarker = (Chunk00 != ChunkAbove);

				        // Emit the ground marker
				        if (Chunk00 != null && Chunk00.ChunkType != FloorChunkType.Outside) {
					        if (bEmitGroundMarker) {
						        Vector3 GridLocation = new Vector3(x + 0.5f, y, z + 0.5f);
						        Vector3 WorldLocation = Vector3.Scale(GridLocation, GridSize);
						        if (Chunk00.GroundMarker.Length > 0) {
							        GroundMarkerName = Chunk00.GroundMarker;
						        }
						        EmitMarkerAt(WorldLocation, GroundMarkerName, 0);
					        }
					        if (bEmitCeilingMarker) {
						        Vector3 GridLocation = new Vector3(x + 0.5f, y + 1, z + 0.5f);
						        Vector3 WorldLocation = Vector3.Scale(GridLocation, GridSize);
						        if (Chunk00.CeilingMarker.Length > 0) {
							        CeilingMarkerName = Chunk00.CeilingMarker;
						        }
						        EmitMarkerAt(WorldLocation, CeilingMarkerName, Quaternion.Euler(180, 0, 0));
					        }
				        }

				        int Chunk00Id = (Chunk00 != null ? Chunk00.Id : -1);
				        int Chunk10Id = (Chunk10 != null ? Chunk10.Id : -1);
				        int Chunk01Id = (Chunk01 != null ? Chunk01.Id : -1);

				        bool bEmitLeftWall = (Chunk00Id != Chunk10Id);
				        bool bEmitBottomWall = (Chunk00Id != Chunk01Id);
				        bool bLeftDoor = DoorManager.ContainsDoor(new IntVector(x, y, z), new IntVector(x + 1, y, z));
					        // || DoorManager.ContainsDoorVolume(Vector3.Scale(new Vector(x + 1, y, z + 0.5f) * GridSize), DoorVolumes);
				        bool bBottomDoor = DoorManager.ContainsDoor(new IntVector(x, y, z), new IntVector(x, y, z + 1));
					        // || DoorManager.ContainsDoorVolume(Vector3.Scale(new Vector(x + 0.5f, y, z + 1) * GridSize), DoorVolumes);

				        if (Chunk00 != null && Chunk10 != null && Chunk00.ChunkType == FloorChunkType.Hall && Chunk10.ChunkType == FloorChunkType.Hall) {
					        // Do not block the halls with a wall
					        bEmitLeftWall = false;
				        }
				        if (Chunk00 != null && Chunk01 != null && Chunk00.ChunkType == FloorChunkType.Hall && Chunk01.ChunkType == FloorChunkType.Hall) {
					        // Do not block the halls with a wall
					        bEmitBottomWall = false;
				        }

				        if (Chunk00 != null && Chunk10 != null && (!Chunk00.bEmitGroundMarker || !Chunk10.bEmitGroundMarker)) {
					        // We don't have ground in one of the adjacent chunks. Can't have doors
					        bLeftDoor = false;
				        }
				        if (Chunk00 != null && Chunk01 != null && (!Chunk00.bEmitGroundMarker || !Chunk01.bEmitGroundMarker)) {
					        // We don't have ground in one of the adjacent chunks. Can't have doors
					        bBottomDoor = false;
				        }

				        float wallAngleLeft = 0;
				        if (bEmitLeftWall) {
					        FloorChunk PriorityChunk = GetPriorityChunk(Chunk00, Chunk10);
					        bEmitLeftWall = PriorityChunk != null ? PriorityChunk.bCreateWalls : true;
					        wallAngleLeft = (PriorityChunk == Chunk10) ? 90 : -90;
				        }
				        
				        float wallAngleBottom = 0;
				        if (bEmitBottomWall) {
					        FloorChunk PriorityChunk = GetPriorityChunk(Chunk00, Chunk01);
					        bEmitBottomWall = PriorityChunk != null ? PriorityChunk.bCreateWalls : true;
					        wallAngleBottom = (PriorityChunk == Chunk01) ? 0 : 180;
				        }

				        if (bEmitLeftWall) {
					        Vector3 GridLocation = new Vector3(x + 1, y, z + 0.5f);
					        Vector3 WorldLocation = Vector3.Scale(GridLocation, GridSize);

					        string MarkerName;
					        if (bLeftDoor) {
						        MarkerName = GetDoorMarkerName(Chunk00, Chunk10);
					        } 
					        else {
						        MarkerName = FloorPlanMarkerNames.Wall;
						        if (bBuildingWallLeft) {
							        MarkerName = FloorPlanMarkerNames.BuildingWall;
						        }
						        else {
							        if (Chunk00 != null && Chunk10 != null) {
								        FloorChunk PriorityChunk = (Chunk00.Priority > Chunk10.Priority) ? Chunk00 : Chunk10;
								        if (PriorityChunk.WallMarker.Length > 0) {
									        MarkerName = PriorityChunk.WallMarker;
								        }
							        }
						        }
					        }

					        EmitMarkerAt(WorldLocation, MarkerName, wallAngleLeft);
				        }
				        if (bEmitBottomWall) {
					        Vector3 GridLocation = new Vector3(x + 0.5f, y, z + 1);
					        Vector3 WorldLocation = Vector3.Scale(GridLocation, GridSize);

					        string MarkerName;
					        if (bBottomDoor) {
						        MarkerName = GetDoorMarkerName(Chunk00, Chunk01);
					        }
					        else {
						        MarkerName = FloorPlanMarkerNames.Wall;
						        if (bBuildingWallBottom) {
							        MarkerName = FloorPlanMarkerNames.BuildingWall;
						        }
						        else {
							        if (Chunk00 != null && Chunk01 != null) {
								        FloorChunk PriorityChunk = (Chunk00.Priority > Chunk01.Priority) ? Chunk00 : Chunk01;
								        if (PriorityChunk.WallMarker.Length > 0) {
									        MarkerName = PriorityChunk.WallMarker;
								        }
							        }
						        }
					        }

					        EmitMarkerAt(WorldLocation, MarkerName, wallAngleBottom);
				        }
			        }
		        }
	        }


	        // Emit center marker if specified
	        List<FloorChunk> Chunks = new List<FloorChunk>();
	        ChunkDB.GetChunks(Chunks);
	        foreach (FloorChunk Chunk in Chunks) {
		        if (Chunk.bEmitGroundMarker && Chunk.CenterMarker.Length > 0) {
			        Vector3 ChunkSize = MathUtils.ToVector3(Chunk.Bounds.Size) / 2.0f;
			        ChunkSize.y = 0;
			        Vector3 GridLocation = MathUtils.ToVector3(Chunk.Bounds.Location) + ChunkSize;
			        Vector3 WorldLocation = Vector3.Scale(GridLocation, GridSize);
			        EmitMarkerAt(WorldLocation, Chunk.CenterMarker, 0);
		        }
	        }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\FloorPlanner\FloorPlanConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Builders.FloorPlan.Tooling;

namespace DungeonArchitect.Builders.FloorPlan
{
    public class FloorPlanConfig : DungeonConfig
    {

        public Vector3 BuildingSize;

        public Vector3 GridSize = new Vector3(4, 2, 4);

        public int MinRoomSize = 2;

        public int MaxRoomSize = 3;

        public int HallWidth = 1;

        public int MinRoomChunkArea = 24;

        public int RoomSplitProbabilityOffset;

        public FloorPlanCorridorTool[] manualHallwayPoints;
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\FloorPlanner\FloorPlanModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Linq;
using System.Collections.Generic;

namespace DungeonArchitect.Builders.FloorPlan
{
    public class FloorPlanModel : DungeonModel
    {
        [HideInInspector]
        public FloorPlanConfig Config;

        [HideInInspector]
        public FloorChunk[] Chunks;
    }

    public enum FloorChunkType
    {
	    Room,
	    Hall,
	    Outside	// Outside the floorplan
    };


    public class FloorChunk {
	    public FloorChunk()
	    {
            Id = -1;
		    ChunkType = FloorChunkType.Outside;
		    bReachable = false;
		    bConnectDoors = true;
		    bCreateWalls = true;
		    Priority = 0;
		    bEmitGroundMarker = true;
            bEmitCeilingMarker = true;
        }

	    public int Id;
	    public FloorChunkType ChunkType;
	    public Rectangle Bounds = new Rectangle();
	    public List<IntVector> BoundCells = new List<IntVector>();

	    public bool bReachable;
	    public float Priority;

	    public bool bEmitGroundMarker;
	    public bool bEmitCeilingMarker;
	    public bool bConnectDoors;
	    public bool bCreateWalls;

	    public string WallMarker = "";
        public string GroundMarker = "";
        public string CeilingMarker = "";
        public string DoorMarker = "";
        public string CenterMarker = "";

	    public int Area() { return Bounds.Size.x * Bounds.Size.z; }
	    /** Gets the dimension of the largest side */
	    public int GetLength() { return Bounds.Size.x > Bounds.Size.z ? Bounds.Size.x : Bounds.Size.z; }
	    public int GetWidth() { return Bounds.Size.x < Bounds.Size.z ? Bounds.Size.x : Bounds.Size.z; }

	    /** Sets the dimensions of the largest side */
	    public void SetLength(int Length) {
            IntVector Size = Bounds.Size;
		    if (Bounds.Size.x > Bounds.Size.z) {
			    Size.x = Length;
		    }
		    else {
			    Size.z = Length;
		    }
            Bounds.Size = Size;
	    }

	    public void OffsetAlongLength(int Offset) {
            IntVector Location = Bounds.Location;
		    if (Bounds.Size.x > Bounds.Size.z) {
			    Location.x += Offset;
		    }
		    else {
			    Location.z += Offset;
		    }
            Bounds.Location = Location;
	    }
    };



    public class FloorChunkDB
    {
    
	    public FloorChunkDB() {
            IdCounter = 0;
        }
        public FloorChunk Create()
        {
            var Chunk = new FloorChunk();
            Chunk.Id = ++IdCounter;
            return Chunk;
        }

        public void Register(FloorChunk Chunk)
        {
            if (!Chunks.ContainsKey(Chunk.Id))
            {
                Chunks.Add(Chunk.Id, Chunk);
            }
        }

        public void GetChunks(List<FloorChunk> OutChunks)
        {
            OutChunks.Clear();
            OutChunks.AddRange(Chunks.Values);
        }
        public void GetChunks(List<FloorChunk> OutChunks, FloorChunkType ChunkType)
        {
            var AllChunks = new List<FloorChunk>();
            GetChunks(AllChunks);

            OutChunks.Clear();
            foreach (var Chunk in Chunks.Values)
            {
                if (Chunk.ChunkType == ChunkType)
                {
                    OutChunks.Add(Chunk);
                }
            }
        }

        public FloorChunk GetChunk(int Id)
        {
            return Chunks.ContainsKey(Id) ? Chunks[Id] : null;
        }


        public FloorChunk GetChunkAt(int x, int y, int z)
        {
            int Hash = HASH(x, y, z);
            if (CachePositionToChunk.ContainsKey(Hash))
            {
                int ChunkId = CachePositionToChunk[Hash].ChunkId;
                return GetChunk(ChunkId);
            }
            else
            {
                return null;
            }
        }

        public FloorChunk GetChunkAt(IntVector Location)
        {
            return GetChunkAt(Location.x, Location.y, Location.z);
        }

	    /** Create the cache for faster access */
        public void CacheChunkPositions()
        {
            
	        List<FloorChunk> Chunks = new List<FloorChunk>();
	        GetChunks(Chunks);

	        foreach (FloorChunk Chunk in Chunks) {
		        int X0 = Chunk.Bounds.Location.x;
		        int Z0 = Chunk.Bounds.Location.z;
		        int X1 = X0 + Chunk.Bounds.Size.x;
		        int Z1 = Z0 + Chunk.Bounds.Size.z;
		        int y = Chunk.Bounds.Location.y;
		        List<IntVector> BoundCells = Chunk.BoundCells;
		        if (BoundCells.Count == 0) {
			        for (int x = X0; x < X1; x++) {
				        for (int z = Z0; z < Z1; z++) {
					        BoundCells.Add(new IntVector(x, y, z));
				        }
			        }
		        }

		        foreach (IntVector Cell in BoundCells) {
			        int Hash = HASH(Cell.x, Cell.y, Cell.z);
			        if (!CachePositionToChunk.ContainsKey(Hash)) {
				        CachePositionToChunk.Add(Hash, new FChunkCacheNode(Chunk.Id, Chunk.Priority));
			        }
			        else {
				        // Entry already exists.  Override if the priority is higher
				        FChunkCacheNode Node = CachePositionToChunk[Hash];
				        if (Node.Priority < Chunk.Priority) {
					        Node.ChunkId = Chunk.Id;
					        Node.Priority = Chunk.Priority;
				        }
			        }
		        }
	        }
        }

    
	    public int HASH(int x, int y, int z) {
		    return new IntVector(x, y, z).GetHashCode();
		    //return  (x + 16384) << 16 | (y + 16384); 
	    }

	    class FChunkCacheNode {
		    public FChunkCacheNode() {
                ChunkId = -1;
                Priority = 0;
            }
            public FChunkCacheNode(int InChunkId, float InPriority)
            {
                ChunkId = InChunkId;
                Priority = InPriority;
            }

		    public int ChunkId;
            public float Priority;
	    };

        public FloorChunk[] GetAllChunks()
        {
            return Chunks.Values.ToArray();
        }

        private Dictionary<int, FloorChunk> Chunks = new Dictionary<int,FloorChunk>();
        private Dictionary<int, FChunkCacheNode> CachePositionToChunk = new Dictionary<int,FChunkCacheNode>();
        private int IdCounter;
    }


    public class FloorDoorManager
    {

        public void RegisterDoor(IntVector A, IntVector B)
        {
            if (!DoorMap.ContainsKey(A))
            {
                DoorMap.Add(A, new HashSet<IntVector>());
            }
            DoorMap[A].Add(B);

            if (!DoorMap.ContainsKey(B))
            {
                DoorMap.Add(B, new HashSet<IntVector>());
            }
            DoorMap[B].Add(A);
        }

        public bool ContainsDoorVolume(Vector3 WorldLocation, List<DungeonArchitect.Volume> DoorVolumes)
        {
            // TODO: Implement me
            return false;
        }

	    public bool ContainsDoor(IntVector A, IntVector B) {
		    if (!DoorMap.ContainsKey(A)) {
			    return false;
		    }
		    return DoorMap[A].Contains(B);
	    }

	    public void Clear() {
		    DoorMap.Clear();
	    }

        private Dictionary<IntVector, HashSet<IntVector>> DoorMap = new Dictionary<IntVector,HashSet<IntVector>>();
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\FloorPlanner\FloorPlanSpatialConstraintProcessor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Builders.FloorPlan
{
    public class FloorPlanSpatialConstraintProcessor : SpatialConstraintProcessor
    {
        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var floorPlanConfig = context.config as FloorPlanConfig;

            var domain = base.GetDomain(context);
            domain.gridSize = floorPlanConfig.GridSize;
            return domain;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\GridDungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Builders.Grid.Mirroring;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Grid;
using DungeonArchitect.MarkerGenerator.Processor;
using DungeonArchitect.MarkerGenerator.Processor.Grid;
using DungeonArchitect.Utils;
using DungeonArchitect.Themeing;

namespace DungeonArchitect.Builders.Grid
{
    using PropBySocketType_t = Dictionary<string, List<DungeonThemeItem>>;
    using PropBySocketTypeByTheme_t = Dictionary<DungeonThemeData, Dictionary<string, List<DungeonThemeItem>>>;

    /// <summary>
    /// Contains meta data about the cells.  This structure is used for caching cell
    /// information for faster lookup during and after generation of the dungeon
    /// </summary>
    public class GridCellInfo
    {
        public int CellId;
        public CellType CellType;
        public bool ContainsDoor;

        public GridCellInfo()
        {
            CellId = 0;
            CellType = CellType.Unknown;
            ContainsDoor = false;
        }
        public GridCellInfo(int pCellId, CellType pCellType)
        {
            this.CellId = pCellId;
            this.CellType = pCellType;
            this.ContainsDoor = false;
        }
    }

    public class GridBuilderDoorMetadata
    {
        public GridBuilderDoorMetadata(int cellIdA, int cellIdB)
        {
            this.CellA = cellIdA;
            this.CellB = cellIdB;
        }
        public int CellA;
        public int CellB;
    }

    /// <summary>
    /// Temporary data-structure to hold the height data of the cell node
    /// A graph is build of the dungeon layout while the heights are assigned and this
    /// node contains the cell's height information
    /// </summary>
    public class CellHeightNode
    {
        public int CellId;
        public int Height;
        public bool MarkForIncrease;
        public bool MarkForDecrease;
    };

    /// <summary>
    /// Temporary data-structure used while assigning stairs on the dungeon.
    /// </summary>
    public class StairAdjacencyQueueNode
    {
        public StairAdjacencyQueueNode(int pCellId, int pDepth)
        {
            this.cellId = pCellId;
            this.depth = pDepth;
        }
        public int cellId;
        public int depth;
    };

    /// <summary>
    /// Temporary data-structure used while assigning heights on the dungeon.
    /// </summary>
    public class CellHeightFrameInfo
    {
        public CellHeightFrameInfo(int pCellId, int pCurrentHeight)
        {
            this.CellId = pCellId;
            this.CurrentHeight = pCurrentHeight;
        }
        public int CellId;
        public int CurrentHeight;
    };

    /// <summary>
    /// Data structure to hold the adjacent cells connected to the stairs (entry / exit)
    /// </summary>
    public struct StairEdgeInfo
    {
        public StairEdgeInfo(int pCellIdA, int pCellIdB)
        {
            this.CellIdA = pCellIdA;
            this.CellIdB = pCellIdB;
        }

        public int CellIdA;
        public int CellIdB;
    };
    

    /// <summary>
    /// A Dungeon Builder implementation that builds a grid based dungeon.   
    /// 
    /// It is based on the awesome algorithm described here by the TinyKeep game's author
    /// https://www.reddit.com/r/gamedev/comments/1dlwc4/procedural_dungeon_generation_algorithm_explained/ 
    /// </summary>
    [ExecuteInEditMode]
    public class GridDungeonBuilder : DungeonBuilder
    {
        int _CellIdCounter = 0;
        Dictionary<int, List<StairInfo>> CellStairs
        {
            get
            {
                return gridModel.CellStairs;
            }
		}

        GridDungeonModel gridModel;
        GridDungeonConfig gridConfig;
        Dictionary<int, Dictionary<int, GridCellInfo>> GridCellInfoLookup
        {
            get { return gridModel.GridCellInfoLookup; }
        }
        GridCellInfo GetGridCellLookup(int x, int z)
        {
            return gridModel.GetGridCellLookup(x, z);
        }

        Vector3 GridToMeshScale
        {
            get
            {
                if (gridConfig != null)
                {
                    return gridConfig.GridCellSize;
                }
                return Vector3.one;
            }
        }

        void Awake()
        {
            model = GetComponent<GridDungeonModel>();
            if (model is GridDungeonModel)
            {
                gridModel = model as GridDungeonModel;
            }
            else
            {
                Debug.LogError("Invalid dungeon model type provided to grid based dungeon builder");
                return;
            }

            config = GetComponent<GridDungeonConfig>();
            if (config is GridDungeonConfig)
            {
                gridConfig = config as GridDungeonConfig;
            }
            else
            {
                Debug.LogError("Invalid dungeon config type provided to grid based dungeon builder");
                return;
            }
        }


        /// <summary>
        /// Builds the dungeon
        /// </summary>
        /// <param name="config">The dungeon configuration</param>
        /// <param name="model">The dungeon model</param>
        public override void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            base.BuildDungeon(config, model);

            if (model is GridDungeonModel)
            {
                gridModel = model as GridDungeonModel;
            }
            else
            {
                Debug.LogError("Invalid dungeon model type provided to grid based dungeon builder");
                return;
            }

            if (config is GridDungeonConfig)
            {
                gridConfig = config as GridDungeonConfig;
            }
            else
            {
                Debug.LogError("Invalid dungeon config type provided to grid based dungeon builder");
                return;
            }

            if (gridConfig.UseFastCellDistribution)
            {
                BuildCellsWithDistribution();
            }
            else
            {
                BuildCellsWithSeparation();
            }

            ApplyBaseOffset();

            // Add cells defined by platform volumes in the world
            AddUserDefinedPlatforms();

            ClipForMirroring();
            
            // Connect the rooms with delaunay triangulation to have nice evenly spaced triangles
            TriangulateRooms();

            // Build a minimum spanning tree of the above triangulation, to avoid having lots of loops
            BuildMinimumSpanningTree();

            // Connect the rooms by converting cells between the rooms into corridors.  Also adds new corridor cells if needed for the connection
            ConnectCorridors();

            // Apply negation volumes by removing procedural geometry that lie within it
            ApplyNegationVolumes();

            // Build a lookup of adjacent tiles for later use with height and stair creation
            GenerateAdjacencyLookup();
            
            GenerateDungeonHeights();
            
			ConnectStairs(100);
			//ConnectStairs(60);
			ConnectStairs(50);
			ConnectStairs(0);
			ConnectStairs(-100);
            
            MirrorDungeon();
            
            RemoveAdjacentDoors();

        }


        void Initialize()
        {
            Markers.Clear();
            gridModel.GridCellInfoLookup.Clear();
            CellStairs.Clear();
            gridModel.Cells.Clear();
            gridModel.DoorManager.Clear();

            _CellIdCounter = 0;
        }

        protected override LevelMarkerList CreateMarkerListObject(DungeonConfig config)
        {
            var gridConfig = config as GridDungeonConfig;
            var bucketSize = Mathf.Max(gridConfig.GridCellSize.x, gridConfig.GridCellSize.z) * 2;
            bucketSize = Mathf.Max(0.1f, bucketSize);
            return new SpatialPartionedLevelMarkerList(bucketSize);
        }

        bool CanFitDistributionCell(HashSet<IntVector> Occupancy, ref Rectangle bounds)
        {
            for (int x = bounds.X; x < bounds.X + bounds.Width; x++)
            {
                for (int z = bounds.Z; z < bounds.Z + bounds.Length; z++)
                {
                    if (Occupancy.Contains(new IntVector(x, 0, z)))
                    {
                        return false;
                    }
                }
            }
            // No cells within the bounds are occupied
            return true;
        }

        void SetDistributionCellOccupied(HashSet<IntVector> Occupancy, ref Rectangle bounds)
        {
            for (int x = bounds.X; x < bounds.X + bounds.Width; x++)
            {
                for (int z = bounds.Z; z < bounds.Z + bounds.Length; z++)
                {
                    Occupancy.Add(new IntVector(x, 0, z));
                }
            }
        }

        public void BuildCellsWithDistribution()
        {
            int sx = -gridConfig.CellDistributionWidth / 2;
            int ex = gridConfig.CellDistributionWidth / 2;

            int sz = -gridConfig.CellDistributionLength / 2;
            int ez = gridConfig.CellDistributionLength / 2;

            int FitnessTries = 10;
            var Occupied = new HashSet<IntVector>();
            var cells = new List<Cell>();
            for (int ix = sx; ix <= ex; ix++)
            {
                for (int iz = sz; iz <= ez; iz++)
                {
                    for (int t = 0; t < FitnessTries; t++)
                    {
                        int offsetX, offsetZ;
                        {
                            var offset = GenerateCellSize() / 2;
                            offsetX = Mathf.RoundToInt(offset.x * random.GetNextUniformFloat());
                            offsetZ = Mathf.RoundToInt(offset.z * random.GetNextUniformFloat());
                        }

                        int x = ix + offsetX;
                        int z = iz + offsetZ;
                        var bounds = new Rectangle();
                        bounds.Size = GenerateCellSize();
                        bounds.Location = new IntVector(x, 0, z);
                        if (CanFitDistributionCell(Occupied, ref bounds))
                        {
                            var cell = BuildCell(ref bounds);
                            cells.Add(cell);
                            SetDistributionCellOccupied(Occupied, ref bounds);
                            break;
                        }
                    }
                }
            }

            gridModel.Config = gridConfig;
            gridModel.Cells = cells;
            gridModel.BuildCellLookup();
        }

        /// <summary>
        /// builds the cells in the dungeon
        /// </summary>
        public void BuildCellsWithSeparation()
        {
            if (gridConfig.Seed == 0)
            {
                //gridConfig.Seed = (uint)Mathf.FloorToInt(Random.value * int.MaxValue);
            }

            var cells = new List<Cell>();
            _CellIdCounter = 0;
            for (int i = 0; i < gridConfig.NumCells; i++)
            {
                var cell = BuildCell();
                cells.Add(cell);
            }

            gridModel.Config = gridConfig;
            gridModel.Cells = cells;
            gridModel.BuildCellLookup();
            
            // Separate the cells
            int separationTries = 0;
            int maxSeparationTries = 100;
            while (separationTries < maxSeparationTries)
            {
                bool separated = Seperate(gridModel);
                if (!separated)
                {
                    break;
                }
                separationTries++;
            }
        }

        IntVector GenerateCellSize()
        {
            var baseSize = GetRandomRoomSize();
            var width = baseSize;
            var aspectRatio = 1 + (random.GetNextUniformFloat() * 2 - 1) * gridConfig.RoomAspectDelta;
            var length = Mathf.RoundToInt(width * aspectRatio);
            if (random.GetNextUniformFloat() < 0.5f)
            {
                // Swap width / length
                var temp = width;
                width = length;
                length = temp;
            }
            return new IntVector(width, 0, length);
        }

        Cell BuildCell()
        {
            var bounds = new Rectangle();
            bounds.Location = GetRandomPointInCircle(gridConfig.InitialRoomRadius);
            bounds.Size = GenerateCellSize();
            return BuildCell(ref bounds);
        }

        Cell BuildCell(ref Rectangle bounds)
        {
            var cell = new Cell();
            cell.Id = GetNextCellId();
            cell.Bounds = bounds;

            var area = bounds.Size.x * bounds.Size.z;
            if (area >= gridConfig.RoomAreaThreshold)
            {
                cell.CellType = CellType.Room;
            }

            return cell;
        }

        int GetNextCellId()
        {
            ++_CellIdCounter;
            return _CellIdCounter;
        }

        IntVector GetBaseOffset()
        {
            var dungeonPosition = gameObject.transform.position;
            var dungeonGridPosF = MathUtils.Divide(dungeonPosition, gridConfig.GridCellSize);
            return MathUtils.RoundToIntVector(dungeonGridPosF);
        }

        Matrix4x4 GetBaseTransform()
        {
            var position = MathUtils.ToVector3(GetBaseOffset());
            return Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
        }

        public override IMarkerGenProcessor CreateMarkerGenProcessor()
        {
            var query = GetComponent<DungeonQuery>();
            return new GridMarkerGenProcessor(GetBaseTransform(), gridConfig.GridCellSize, this, model, config, query);
        }

        void ApplyBaseOffset()
        {
            //var dungeonPosition = gameObject.transform.position;
            //var dungeonGridPosF = MathUtils.Divide(dungeonPosition, gridConfig.GridCellSize);
            //var dungeonGridPos = MathUtils.RoundToIntVector(dungeonGridPosF);
            var dungeonGridPos = GetBaseOffset();
            foreach (var cell in gridModel.Cells)
            {
                var bounds = cell.Bounds;
                var location = bounds.Location;
                location += dungeonGridPos;
                bounds.Location = location;
                cell.Bounds = bounds;
            }
        }

        void ApplyNegationVolumes()
		{
			var dungeon = GetComponent<Dungeon>();
            var negationVolumes = GameObject.FindObjectsOfType<NegationVolume>();
            foreach (var negationVolume in negationVolumes)
            {
				if (dungeon != null && negationVolume.dungeon == dungeon) {
					ApplyNegationVolume(negationVolume);
				}
            }

            gridModel.BuildCellLookup();
        }

        void ApplyNegationVolume(NegationVolume volume)
        {

            IntVector position, scale;
            volume.GetVolumeGridTransform(out position, out scale, GridToMeshScale);
            position = position - scale / 2;
            var bounds = new Rectangle();
            bounds.Location = position;
            bounds.Size = scale;

            var cellsToRemove = new List<Cell>();
            foreach (var cell in gridModel.Cells)
            {
                bool removeCell;
                if (volume.inverse)
                {
                    // Inverse the negation and remove everything outside the volume
                    removeCell = !bounds.Contains(cell.Bounds);
                }
                else
                {
                    removeCell = cell.Bounds.IntersectsWith(bounds);
                }

                if (removeCell)
                {
                    cellsToRemove.Add(cell);
                }
            }

            foreach (var cell in cellsToRemove)
            {
                gridModel.Cells.Remove(cell);
            }
        }

        void GetCellBounds(Cell cell, ref Bounds bounds)
        {
            var gridSize = gridConfig.GridCellSize;
            var width = cell.Bounds.Width * gridSize.x;
            var length = cell.Bounds.Width * gridSize.z;
            var center = Vector3.Scale(cell.Bounds.CenterF(), gridSize);
            bounds.center = center;
            bounds.size = new Vector3(width, 2, length);
        }

        void AddUserDefinedPlatforms()
        {
            var toolData = GetComponent<GridDungeonToolData>();
            // Add geometry defined by the editor paint tool
            if (toolData != null && toolData.paintedCells != null)
            {
                foreach (var cellPoint in toolData.paintedCells)
                {
                    var cell = new Cell();
                    cell.Id = GetNextCellId();
                    cell.UserDefined = true;
                    var bounds = new Rectangle();
                    bounds.Location = cellPoint;
                    bounds.Size = new IntVector(1, 1, 1);
                    cell.Bounds = bounds;
                    cell.CellType = CellType.Corridor;
                    gridModel.Cells.Add(cell);
                }
            }

            var dungeon = GetComponent<Dungeon>();
            // Add platform volumes defined in the world
            var platformVolumes = GameObject.FindObjectsOfType<PlatformVolume>();
            foreach (var platformVolume in platformVolumes)
            {
				if (dungeon != null && platformVolume.dungeon == dungeon) {
					AddPlatformVolume(platformVolume);
				}
            }

            gridModel.BuildCellLookup();
        }

        void AddPlatformVolume(PlatformVolume platform)
        {
            var cell = new Cell();
            cell.Id = GetNextCellId();
            IntVector position, scale;
            platform.GetVolumeGridTransform(out position, out scale, GridToMeshScale);
            position = position - scale / 2;
            var bounds = new Rectangle();
            bounds.Location = position;
            bounds.Size = scale;
            cell.Bounds = bounds;
            cell.CellType = platform.cellType;
            cell.UserDefined = true;

            // Remove any cells that intersect with this cell
            var insertedCells = gridModel.Cells.ToArray();
            foreach (var insertedCell in insertedCells)
            {
                if (insertedCell.Bounds.IntersectsWith(cell.Bounds))
                {
                    gridModel.Cells.Remove(insertedCell);
                }
            }

            gridModel.Cells.Add(cell);
        }
        

        void ClipForMirroring()
        {
            var dungeon = GetComponent<Dungeon>();
            if (dungeon != null)
            {
                bool appliedMirroring = false;
                var mirrorVolumes = GameObject.FindObjectsOfType<MirrorVolume>();
                foreach (var mirrorVolume in mirrorVolumes)
                {
                    if (mirrorVolume.dungeon == dungeon)
                    {
                        ClipForMirroring(mirrorVolume);
                        appliedMirroring = true;
                    }
                }

                if (appliedMirroring)
                {
                    gridModel.BuildCellLookup();
                    GenerateAdjacencyLookup();
                }
            }
        }
        
        void MirrorDungeon()
        {
            var dungeon = GetComponent<Dungeon>();
            if (dungeon != null)
            {
                bool appliedMirroring = false;
                var mirrorVolumes = GameObject.FindObjectsOfType<MirrorVolume>();
                foreach (var mirrorVolume in mirrorVolumes)
                {
                    if (mirrorVolume.dungeon == dungeon)
                    {
                        MirrorDungeon(mirrorVolume);
                        appliedMirroring = true;
                    }
                }

                if (appliedMirroring)
                {
                    gridModel.BuildCellLookup();
                    GenerateAdjacencyLookup();
                }
            }
        }


        void ClipForMirroring(MirrorVolume volume)
        {
            var volumePosition = volume.transform.position;
            var volumeDirections = new List<MirrorVolumeDirection>();
            if (volume.direction == MirrorVolumeDirection.AxisXZ)
            {
                volumeDirections.Add(MirrorVolumeDirection.AxisX);
                volumeDirections.Add(MirrorVolumeDirection.AxisZ);
            }
            else
            {
                volumeDirections.Add(volume.direction);
            }

            foreach (var volumeDirection in volumeDirections)
            {
                var mirror = GridDungeonMirror.Create(volumePosition, gridConfig.GridCellSize, volumeDirection);
                var cellsToDiscard = new List<Cell>();
                var cellsToDiscardId = new List<int>();
                foreach (var cell in gridModel.Cells)
                {
                    if (mirror.CanDiscardBounds(cell.Bounds))
                    {
                        // discard this cell
                        cellsToDiscard.Add(cell);
                        cellsToDiscardId.Add(cell.Id);
                    }
                    else if (mirror.CanCropBounds(cell.Bounds))
                    {
                        // Crop this cell
                        mirror.CropCell(cell);
                    }
                }

                foreach (var cell in cellsToDiscard)
                {
                    gridModel.Cells.Remove(cell);
                }


                // Remove the doors
                {
                    var doorsToDiscard = new List<CellDoor>();
                    foreach (var door in gridModel.Doors)
                    {
                        bool validDoor = true;
                        foreach (var doorCell in door.AdjacentCells)
                        {
                            if (cellsToDiscardId.Contains(doorCell))
                            {
                                validDoor = false;
                                break;
                            }
                        }

                        if (!validDoor)
                        {
                            doorsToDiscard.Add(door);
                        }
                    }

                    foreach (var door in doorsToDiscard)
                    {
                        gridModel.DoorManager.RemoveDoor(door);
                    }
                }
            }
        }


        void MirrorDungeon(MirrorVolume volume)
        {
            var volumePosition = volume.transform.position;
            var volumeDirections = new List<MirrorVolumeDirection>();
            if (volume.direction == MirrorVolumeDirection.AxisXZ)
            {
                volumeDirections.Add(MirrorVolumeDirection.AxisX);
                volumeDirections.Add(MirrorVolumeDirection.AxisZ);
            }
            else
            {
                volumeDirections.Add(volume.direction);
            }

            foreach (var volumeDirection in volumeDirections)
            {
                var mirror = GridDungeonMirror.Create(volumePosition, gridConfig.GridCellSize, volumeDirection);
                var cellToMirrorMap = new Dictionary<int, int>();
                // Mirror the cells
                {
                    var cellsToAdd = new List<Cell>();
                    foreach (var cell in gridModel.Cells)
                    {
                        var mirroredCellBounds = mirror.CalculateMirrorReflection(cell.Bounds); 

                        var mergedBounds = new Rectangle();
                        if (cell.CellType == CellType.Room && mirror.CanMergeCells(cell.Bounds, mirroredCellBounds, ref mergedBounds))
                        {
                            cell.Bounds = mergedBounds;
                            cellToMirrorMap[cell.Id] = cell.Id;
                        }
                        else
                        {
                            var mirrorCell = new Cell();
                            mirrorCell.Id = GetNextCellId();
                            mirrorCell.UserDefined = false;
                            mirrorCell.Bounds = mirroredCellBounds;
                            mirrorCell.CellType = cell.CellType;
                            cellsToAdd.Add(mirrorCell);
                            cellToMirrorMap[cell.Id] = mirrorCell.Id;
                        }
                    }

                    foreach (var cell in cellsToAdd)
                    {
                        gridModel.Cells.Add(cell);
                    }
                }

                // Mirror the doors
                {
                    var doorsCopy = new List<CellDoor>(gridModel.Doors);
                    foreach (var door in doorsCopy)
                    {
                        if (door.AdjacentCells.Length != 2 || door.AdjacentTiles.Length != 2) continue;

                        if (!cellToMirrorMap.ContainsKey(door.AdjacentCells[0])) continue;
                        if (!cellToMirrorMap.ContainsKey(door.AdjacentCells[1])) continue;

                        var mirroredCell0 = cellToMirrorMap[door.AdjacentCells[0]];
                        var mirroredCell1 = cellToMirrorMap[door.AdjacentCells[1]];

                        var mirroredTile0 = mirror.CalculateMirrorReflection(door.AdjacentTiles[0]);
                        var mirroredTile1 = mirror.CalculateMirrorReflection(door.AdjacentTiles[1]);

                        gridModel.DoorManager.CreateDoor(mirroredTile0, mirroredTile1, mirroredCell0, mirroredCell1);
                    }
                }

                // Mirror the stairs
                {
                    var stairsCopy = new Dictionary<int, List<StairInfo>>(CellStairs);
                    foreach (var entry in stairsCopy)
                    {
                        var ownerCellId = entry.Key;
                        var stairList = entry.Value;

                        if (!cellToMirrorMap.ContainsKey(ownerCellId)) continue;
                        var mirrorOwnerCell = cellToMirrorMap[ownerCellId];
                        var mirrorStairList = new List<StairInfo>();

                        foreach (var stair in stairList)
                        {
                            if (!cellToMirrorMap.ContainsKey(stair.ConnectedToCell)) continue;
                            var mirroredStair = new StairInfo();
                            mirroredStair.OwnerCell = mirrorOwnerCell;
                            mirroredStair.ConnectedToCell = cellToMirrorMap[stair.ConnectedToCell];
                            mirroredStair.Position = mirror.CalculateMirrorReflection(stair.Position);
                            mirroredStair.Rotation = mirror.CalculateMirrorReflection(stair.Rotation);
                            mirroredStair.IPosition = mirror.CalculateMirrorReflection(stair.IPosition);
                            mirrorStairList.Add(mirroredStair);
                        }

                        CellStairs[mirrorOwnerCell] = mirrorStairList;
                    }
                }
            }
        }

        int GetRandomRoomSize()
        {
            float r = 0;
            while (r <= 0) r = nrandom.NextGaussianFloat(gridConfig.NormalMean, gridConfig.NormalStd);
            var roomSize = gridConfig.MinCellSize + r * (gridConfig.MaxCellSize - gridConfig.MinCellSize);
            return Mathf.RoundToInt(roomSize);
        }

        IntVector GetRandomPointInCircle(float radius)
        {
            var angle = random.GetNextUniformFloat() * Mathf.PI * 2;
            var u = random.GetNextUniformFloat() + random.GetNextUniformFloat();
            var r = (u > 1) ? 2 - u : u;
            r *= radius;
            var x = Mathf.RoundToInt(Mathf.Cos(angle) * r);
            var z = Mathf.RoundToInt(Mathf.Sin(angle) * r);
            return new IntVector(x, 0, z);
        }

        static void Shuffle(GridDungeonModel gridModel)
        {
            if (gridModel == null) return;
            var cells = gridModel.Cells;
            if (cells == null) return;
            var random = new PMRandom(gridModel.Config.Seed);
            int n = cells.Count;
            for (int i = 0; i < n; i++)
            {
                int r = i + (int)(random.GetNextUniformFloat() * (n - i));
                Cell t = cells[r];
                cells[r] = cells[i];
                cells[i] = t;
            }
        }

        static int CompareFromCenter(Cell cellA, Cell cellB)
        {
            float distA = cellA.Center.DistanceSq();
            float distB = cellB.Center.DistanceSq();
            if (distA == distB)
            {
                return 0;
            }
            return (distA < distB) ? -1 : 1;
        }

        /// <summary>
        /// Separates the cells built in the previous phase
        /// </summary>
        /// <param name="gridModel"></param>
        public static bool Seperate(GridDungeonModel gridModel)
        {
            if (gridModel == null) return false;
            if (gridModel.Cells == null) return false;

            var cells = gridModel.Cells.ToArray();
            System.Array.Sort(cells, CompareFromCenter);

            //Shuffle(model);
            var count = gridModel.Cells.Count;
            var forces = new IntVector[count];
            for (int a = 0; a < count; a++)
            {
                forces[a] = new IntVector();
            }
            bool separated = false;
            var random = new PMRandom(gridModel.Config.Seed);
            for (int a = 0; a < count; a++)
            {
                for (int b = 0; b < count; b++)
                {
                    if (a == b) continue;
                    var c0 = cells[a].Bounds;
                    var c1 = cells[b].Bounds;
                    if (c0.IntersectsWith(c1))
                    {
                        var force = new IntVector();
                        var intersection = Rectangle.Intersect(c0, c1);
                        //var intersection = new Rectangle(c0.Location, c0.Size);
                        //intersection.Intersect(c1);

                        bool applyOnX = (intersection.Width < intersection.Length);
                        if (intersection.Width == intersection.Length)
                        {
                            applyOnX = random.GetNextUniformFloat() > 0.5;
                        }
                        if (applyOnX)
                        {
                            force.x = intersection.Width;
                            force.x *= GetForceDirectionMultiplier(c0.X, c1.X, c0.Z, c1.Z);
                        }
                        else
                        {
                            force.z = intersection.Length;
                            force.z *= GetForceDirectionMultiplier(c0.Z, c1.Z, c0.X, c1.X);
                        }

                        forces[a].x += force.x;
                        forces[a].z += force.z;

                        forces[b].x -= force.x;
                        forces[b].z -= force.z;

                        separated = true;
                    }
                }

                {
                    var cell = cells[a];
                    var location = cell.Bounds.Location;
                    location += forces[a];
                    var size = cell.Bounds.Size;
                    cell.Bounds = new Rectangle(location, size);
                }
            }
            
            return separated;
        }

        /// <summary>
        /// Triangulates the rooms identified in the previous phase
        /// This is required to connect the corridors.   
        /// Delauney triangulation is used to find nice evenly spaced triangles for good connections
        /// </summary>
        /// <param name="gridModel"></param>
        public void TriangulateRooms()
        {
            var vertices = new List<Vector2>();
            var rooms = new List<Cell>();
            foreach (var cell in gridModel.Cells)
            {
                if (cell.CellType == CellType.Room)
                {
                    rooms.Add(cell);
                    var center = cell.CenterF;
                    //var offset = random.RandomPointOnCircle() * 0.1f;
                    var x = center.x; // + offset.x;
                    var z = center.z; // + offset.y;
                    vertices.Add(new Vector2(x, z));
                }
            }
            vertices = vertices.OrderBy(v => v.x).ToList();

            if (rooms.Count > 2)
            {
                var triangles = Triangulator.DelauneyV2.Triangulate(vertices.ToArray());
                if (triangles.Length > 0)
                {
                    foreach (var triangle in triangles)
                    {
                        var c1 = rooms[triangle.p1];
                        var c2 = rooms[triangle.p2];
                        var c3 = rooms[triangle.p3];

                        ConnectCells(c1, c2);
                        ConnectCells(c2, c3);
                        ConnectCells(c3, c1);
                    }
                }
                else
                {
                    // manually connect them since we cannot successfully triangulate (happens if the room positions lie in the same line)
                    for (int i = 0; i < rooms.Count; i++)
                    {
                        int nextIndex = (i + 1) % rooms.Count;
                        var c1 = rooms[i];
                        var c2 = rooms[nextIndex];
                        ConnectCells(c1, c2);
                    }
                }
            }
			else if (rooms.Count == 2) {
				ConnectCells(rooms[0], rooms[1]);
			}
        }

        static void ConnectCells(Cell c1, Cell c2)
        {
            if (!c1.ConnectedRooms.Contains(c2.Id))
            {
                c1.ConnectedRooms.Add(c2.Id);
            }
            if (!c2.ConnectedRooms.Contains(c1.Id))
            {
                c2.ConnectedRooms.Add(c1.Id);
            }
        }

        class Edge : System.IComparable<Edge>
        {
            public Edge(int cellA, int cellB, float weight)
            {
                this.cellA = cellA;
                this.cellB = cellB;
                this.weight = weight;
            }

            public int cellA;
            public int cellB;
            public float weight;


            public int CompareTo(Edge other)
            {
                if (weight == other.weight) return 0;
                return (weight < other.weight) ? -1 : 1;
            }
        }

        static List<Cell> GetRooms(List<Cell> cells)
        {
            var rooms = new List<Cell>();
            foreach (var cell in cells)
            {
                if (cell.CellType == CellType.Room)
                {
                    rooms.Add(cell);
                }
            }
            return rooms;
        }

        void AddUnique<T>(List<T> list, T value)
        {
            if (!list.Contains(value))
            {
                list.Add(value);
            }
        }

        void BuildMinimumSpanningTree()
        {
            List<Cell> rooms = GetCellsOfType(CellType.Room);
            var edgesMapped = new Dictionary<int, HashSet<int>>();

            // Generate unique edge list
            var edges = new List<Edge>();
            foreach (Cell room in rooms)
            {
                if (room == null) continue;
                foreach (int connectedRoomId in room.ConnectedRooms)
                {
                    Cell other = gridModel.GetCell(connectedRoomId);
                    if (other == null) continue;
                    float distance = GetDistance(room.Center, other.Center);
                    int id0 = room.Id;
                    int id1 = other.Id;
                    if (!edgesMapped.ContainsKey(id0) || !edgesMapped[id0].Contains(id1))
                    {
                        Edge edge = new Edge(id0, id1, distance);
                        edges.Add(edge);

                        if (!edgesMapped.ContainsKey(id0)) edgesMapped.Add(id0, new HashSet<int>());
                        if (!edgesMapped.ContainsKey(id1)) edgesMapped.Add(id1, new HashSet<int>());
                        edgesMapped[id0].Add(id1);
                        edgesMapped[id1].Add(id0);
                    }
                }
            }

            edges.Sort();

            foreach (Edge edge in edges)
            {
                Cell cell0 = gridModel.GetCell(edge.cellA);
                Cell cell1 = gridModel.GetCell(edge.cellB);
                if (cell0 != null && cell1 != null)
                {
                    cell0.FixedRoomConnections.Add(cell1.Id);
                    cell1.FixedRoomConnections.Add(cell0.Id);

                    // Check if this new edge insertion caused a loop in the MST
                    bool loop = ContainsLoop(rooms);
                    if (loop)
                    {
                        cell0.FixedRoomConnections.Remove(cell1.Id);
                        cell1.FixedRoomConnections.Remove(cell0.Id);
                    }
                }
            }

            // Add some edges from the Delauney triangulation based on a probability
            PMRandom srandom = new PMRandom(gridConfig.Seed);
            foreach (Cell room in rooms)
            {
                foreach (int otherDelauney in room.ConnectedRooms)
                {
                    if (!room.FixedRoomConnections.Contains(otherDelauney))
                    {
                        float probability = srandom.GetNextUniformFloat();
                        if (probability < gridConfig.SpanningTreeLoopProbability)
                        {
                            Cell other = gridModel.GetCell(otherDelauney);
                            if (other != null)
                            {
                                room.FixedRoomConnections.Add(otherDelauney);
                                other.FixedRoomConnections.Add(room.Id);
                            }
                        }
                    }
                }
            }
        }

        bool ContainsLoop(List<Cell> rooms)
        {
            foreach (Cell room in rooms)
            {
                if (room != null)
                {
                    HashSet<Cell> visited = new HashSet<Cell>();
                    bool hasLoop = CheckLoop(room, null, visited);
                    if (hasLoop) return true;
                }
            }

            return false;
        }

        bool CheckLoop(Cell currentNode, Cell comingFrom, HashSet<Cell> visited)
        {
            visited.Add(currentNode);
            // check if any of the children have already been visited
            foreach (int childId in currentNode.FixedRoomConnections)
            {
                Cell child = gridModel.GetCell(childId);
                if (child == null) continue;

                if (child == comingFrom) continue;
                if (visited.Contains(child))
                {
                    return true;
                }
                bool branchHasLoop = CheckLoop(child, currentNode, visited);
                if (branchHasLoop) return true;
            }
            return false;
        }

        static float GetDistance(IntVector a, IntVector b)
        {
            var dx = a.x - b.x;
            var dy = a.z - b.z;
            return Mathf.Sqrt(dx * dx + dy * dy);
        }

        List<Cell> GetCellsOfType(CellType cellType)
        {
            List<Cell> filtered = new List<Cell>();
            foreach (var cell in gridModel.Cells)
            {
                if (cell.CellType == cellType)
                {
                    filtered.Add(cell);
                }
            }
            return filtered;
        }

        void ConnectCorridors()
        {
            List<Cell> rooms = GetCellsOfType(CellType.Room);
            if (rooms.Count < 2) return;
            HashSet<int> visited = new HashSet<int>();
            Cell startingRoom = rooms[0];
            ConnectCooridorRecursive(-1, startingRoom.Id, visited);

            // TODO: Remove unused cells
            for (int i = 0; i < gridModel.Cells.Count; )
            {
                if (gridModel.Cells[i].CellType == CellType.Unknown)
                {
                    gridModel.Cells.RemoveAt(i);
                }
                else
                {
                    i++;
                }
            }
            // Rebuild the cell cache list, since it has been modified
            gridModel.BuildCellLookup();
        }

        void ConnectCooridorRecursive(int incomingRoomId, int currentRoomId, HashSet<int> visited)
        {
            if (incomingRoomId >= 0)
            {
                int c0 = incomingRoomId;
                int c1 = currentRoomId;
                if (visited.Contains(HASH(c0, c1))) return;
                visited.Add(HASH(c0, c1));
                visited.Add(HASH(c1, c0));

                ConnectRooms(incomingRoomId, currentRoomId);
            }

            Cell currentRoom = gridModel.GetCell(currentRoomId);
            if (currentRoom == null)
            {
                return;
            }
            HashSet<int> children = currentRoom.FixedRoomConnections;
            foreach (int otherRoomId in children)
            {
                Cell otherRoom = gridModel.GetCell(otherRoomId);
                if (otherRoom == null) continue;
                int i0 = currentRoomId;
                int i1 = otherRoomId;
                if (!visited.Contains(HASH(i0, i1)))
                {
                    ConnectCooridorRecursive(currentRoomId, otherRoomId, visited);
                }
            }
        }

        bool AreCellsAdjacent(int cellAId, int cellBId)
        {
            Cell cellA = gridModel.GetCell(cellAId);
            Cell cellB = gridModel.GetCell(cellBId);
            if (cellA == null || cellB == null)
            {
                return false;
            }
            
            Rectangle intersection = Rectangle.Intersect(cellA.Bounds, cellB.Bounds);
            bool adjacent = (intersection.Width > 0 || intersection.Length > 0);
            return adjacent;
        }
        
        void GetCorners(Rectangle bounds, out HashSet<IntVector> corners)
        {
            corners = new HashSet<IntVector>();
            int W = bounds.Width - 1;
            int H = bounds.Length - 1;
            corners.Add(new IntVector(bounds.X, 0, bounds.Z));
            corners.Add(new IntVector(bounds.X + W, 0, bounds.Z));
            corners.Add(new IntVector(bounds.X + W, 0, bounds.Z + H));
            corners.Add(new IntVector(bounds.X, 0, bounds.Z + H));
        }
        

        void ConnectAdjacentCells(int roomA, int roomB)
        {
            Cell cellA = gridModel.GetCell(roomA);
            Cell cellB = gridModel.GetCell(roomB);
            if (cellA == null || cellB == null)
            {
                return;
            }

            Rectangle intersection = Rectangle.Intersect(cellA.Bounds, cellB.Bounds);
            bool adjacent = (intersection.Width > 0 || intersection.Length > 0);
            if (adjacent)
            {
                IntVector doorPointA = new IntVector();
                IntVector doorPointB = new IntVector();
                doorPointA.y = cellA.Bounds.Location.y;
                doorPointB.y = cellB.Bounds.Location.y;
                if (intersection.Width > 0)
                {
                    // shares a horizontal edge
                    doorPointA.x = intersection.X + intersection.Width / 2;
                    doorPointA.z = intersection.Z - 1;

                    doorPointB.x = doorPointA.x;
                    doorPointB.z = doorPointA.z + 1;
                }
                else
                {
                    // shares a vertical edge
                    doorPointA.x = intersection.X - 1;
                    doorPointA.z = intersection.Z + intersection.Length / 2;

                    doorPointB.x = doorPointA.x + 1;
                    doorPointB.z = doorPointA.z;
                }

                bool isOnCornerTile = false;
                if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks)
                {
                    HashSet<IntVector> cornersA, cornersB;
                    GetCorners(cellA.Bounds, out cornersA);
                    GetCorners(cellB.Bounds, out cornersB);

                    if (cellA.CellType == CellType.Room && (cornersA.Contains(doorPointA) || cornersA.Contains(doorPointB))) {
                        isOnCornerTile = true;
                    }
                    else if (cellB.CellType == CellType.Room && (cornersB.Contains(doorPointA) || cornersB.Contains(doorPointB)))
                    {
                        isOnCornerTile = true;
                    }
                }

                // Add a door and return (no corridors needed for adjacent rooms)
                if (!isOnCornerTile)
                {
                    gridModel.DoorManager.CreateDoor(doorPointA, doorPointB, roomA, roomB);
                }
            }
        }

        void Swap(ref int A, ref int B)
        {
            int T = A;
            A = B;
            B = T;
        }
        
        void GetManhattanPathBetween(IntVector start, IntVector end, ref List<IntVector> path)
        {
            if (start == end)
            {
                path.Add(start);
                return;
            }

            int lengthX = end.x - start.x;
            int lengthZ = end.z - start.z;

            int length = Mathf.Max(Mathf.Abs(lengthX), Mathf.Abs(lengthZ));
            int dx = (lengthX == 0) ? 0 : (int)Mathf.Sign(lengthX);
            int dz = (lengthZ == 0) ? 0 : (int)Mathf.Sign(lengthZ);
            IntVector p = start;
            for (int i = 0; i < length; i++)
            {
                if (i > 0 && i < length)
                {
                    path.Add(p);
                }
                p.x += dx;
                p.z += dz;
            }
        }

        List<IntVector> GetManhattanPath(IntVector start, IntVector mid, IntVector end)
        {
            var path0 = new List<IntVector>();
            var path1 = new List<IntVector>();
            GetManhattanPathBetween(start, mid, ref path0);
            GetManhattanPathBetween(mid, end, ref path1);

            var path = new List<IntVector>();
            path.Add(start);
            path.AddRange(path0);
            if (mid != start)
            {
                path.Add(mid);
            }
            path.AddRange(path1);
            if (end != mid)
            {
                path.Add(end);
            }
            return path;
        }

        class ConnectionPointSorter : IComparer<IntVector>
        {
            public ConnectionPointSorter(Vector3 center)
            {
                this.center = center;
            }

            public int Compare(IntVector x, IntVector y)
            {
                float distX = (x.ToVector3() - center).sqrMagnitude;
                float distY = (y.ToVector3() - center).sqrMagnitude;
                if (distX == distY) return 0;
                return distX < distY ? -1 : 1;
            }
            Vector3 center;
        }

        void RemovePointsInsideBounds(Rectangle bounds, List<IntVector> points)
        {
            var pointsToRemove = new List<IntVector>();
            foreach (var point in points)
            {
                if (bounds.Contains(point))
                {
                    pointsToRemove.Add(point);
                }
            }

            foreach (var point in pointsToRemove)
            {
                points.Remove(point);
            }
        }

        bool ContainsPointInsideBounds(Rectangle bounds, List<IntVector> points)
        {
            foreach (var point in points)
            {
                if (bounds.Contains(point))
                {
                    return true;
                }
            }
            return false;
        }

        bool ContainsPointsInsideRoomCells(Cell[] roomCells, List<IntVector> points)
        {
            foreach (var room in roomCells)
            {
                if (ContainsPointInsideBounds(room.Bounds, points))
                {
                    return true;
                }
            }
            return false;
        }

        List<IntVector> FindConnectionPath(Cell roomA, Cell roomB)
        {
            var centerA = roomA.Bounds.CenterF();
            var centerB = roomB.Bounds.CenterF();
            var center = (centerA + centerB) / 2.0f;

            var connectionPointsA = new List<IntVector>();
            var connectionPointsB = new List<IntVector>();
            bool skipCornersOnPathSelection = (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks);
            GridBuilderUtils.GetRoomConnectionPointsForTiledMode(roomA.Bounds, ref connectionPointsA, skipCornersOnPathSelection);
            GridBuilderUtils.GetRoomConnectionPointsForTiledMode(roomB.Bounds, ref connectionPointsB, skipCornersOnPathSelection);

            // Remove points that are inside the other room bounds
            RemovePointsInsideBounds(roomA.Bounds, connectionPointsB);
            RemovePointsInsideBounds(roomB.Bounds, connectionPointsA);

            // Sort based on the center point
            connectionPointsA.Sort(new ConnectionPointSorter(center));
            connectionPointsB.Sort(new ConnectionPointSorter(center));

            var roomCells = GetCellsOfType(CellType.Room).ToArray();
            List<IntVector> worstPath = new List<IntVector>();
            List<IntVector> path = new List<IntVector>();
            bool solutionFound = false;
            foreach (var cpA in connectionPointsA)
            {
                foreach (var cpB in connectionPointsB)
                {
                    var start = cpA;
                    var end = cpB;

                    var mid1 = new IntVector(start.x, 0, end.z);
                    var mid2 = new IntVector(end.x, 0, start.z);

                    path = GetManhattanPath(start, mid1, end);
                    if (!ContainsPointsInsideRoomCells(roomCells, path))
                    {
                        solutionFound = true;
                        break;
                    }

                    path = GetManhattanPath(start, mid2, end);
                    if (!ContainsPointsInsideRoomCells(roomCells, path))
                    {
                        solutionFound = true;
                        break;
                    }

                    if (worstPath.Count == 0) 
                    {
                        worstPath = path;
                    }
                }

                if (solutionFound)
                {
                    break;
                }
            }

            if (!solutionFound)
            {
                //Debug.LogError("Failed to find a valid connection between the cells");
                path = worstPath;
            }
            return path;
        }

        void ConnectRooms(int roomAId, int roomBId)
        {
            Cell roomA = gridModel.GetCell(roomAId);
            Cell roomB = gridModel.GetCell(roomBId);
            if (roomA == null || roomB == null) return;

            Rectangle intersection = Rectangle.Intersect(roomA.Bounds, roomB.Bounds);
            int minIntersectionSize = 1;
            if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks)
            {
                // Compensate for the wall block tile
                minIntersectionSize = 3;
            }
            int intersectionSize = Mathf.Max(intersection.Width, intersection.Length);

            bool adjacent = intersectionSize >= minIntersectionSize;
            if (adjacent)
            {
                ConnectAdjacentCells(roomAId, roomBId);
            }
            else
            {
                var pathList = FindConnectionPath(roomA, roomB);

                int previousCellId = -1;
                var visitedCells = new HashSet<IntVector2>();
                foreach (var pathPoint in pathList)
                {
                    // add a corridor cell
                    int x = pathPoint.x;
                    int z = pathPoint.z;
                    int CurrentCellId = RegisterCorridorCell(x, z, roomAId, roomBId, true);
                    visitedCells.Add(new IntVector2(x, z));

                    // Check if we need to create a door between the two.  
                    // This is needed in case we have an extra room through the corridor.  
                    // This room needs to have doors created
                    {
                        if (previousCellId != -1 && CurrentCellId != previousCellId)
                        {
                            Cell PreviousCell = gridModel.GetCell(previousCellId);
                            Cell CurrentCell = gridModel.GetCell(CurrentCellId);
                            if (PreviousCell != null && CurrentCell != null && PreviousCell != CurrentCell)
                            {
                                if (PreviousCell.CellType == CellType.Room || PreviousCell.CellType == CellType.Room)
                                {
                                    ConnectAdjacentCells(previousCellId, CurrentCellId);
                                }
                            }
                        }
                        previousCellId = CurrentCellId;
                    }

                    int laneWidth = Mathf.Clamp(gridConfig.CorridorWidth, 1, 10);
                    if (laneWidth > 1)
                    {
                        int leftHalf = laneWidth / 2;
                        int rightHalf = laneWidth - leftHalf;
                        for (int dx = -leftHalf; dx < rightHalf; dx++)
                        {
                            for (int dz = -leftHalf; dz < rightHalf; dz++)
                            {
                                if (dx == 0 && dz == 0) continue;
                                int px = x + dx;
                                int pz = z + dz;
                                var visitedKey = new IntVector2(px, pz);
                                if (!visitedCells.Contains(visitedKey))
                                {
                                    RegisterCorridorCell(px, pz, roomAId, roomBId);
                                    visitedCells.Add(visitedKey);
                                }
                            }
                        }
                    }
                }
            }

        }

        void ConnectIfRoomCorridor(int cellAX, int cellAZ, int cellBX, int cellBZ)
        {
            var cellA = gridModel.FindCellByPosition(new IntVector(cellAX, 0, cellAZ));
            var cellB = gridModel.FindCellByPosition(new IntVector(cellBX, 0, cellBZ));
            if (cellA == null || cellB == null)
            {
                return;
            }

            int roomCount = 0;
            int corridorCount = 0;
            roomCount += (cellA.CellType == CellType.Room) ? 1 : 0;
            roomCount += (cellB.CellType == CellType.Room) ? 1 : 0;
            corridorCount += (cellA.CellType == CellType.Corridor || cellA.CellType == CellType.CorridorPadding) ? 1 : 0;
            corridorCount += (cellB.CellType == CellType.Corridor || cellB.CellType == CellType.CorridorPadding) ? 1 : 0;
            if (roomCount == 1 && corridorCount == 1)
            {
                ConnectAdjacentCells(cellA.Id, cellB.Id);
            }
        }

        int RegisterCorridorCell(int cellX, int cellZ, int roomA, int roomB)
        {
            return RegisterCorridorCell(cellX, cellZ, roomA, roomB, /* canRegisterDoors = */ false);
        }

        int RegisterCorridorCell(int cellX, int cellZ, int roomA, int roomB, bool canRegisterDoors)
        {
            Cell cellA = gridModel.GetCell(roomA);
            Cell cellB = gridModel.GetCell(roomB);

            Rectangle PaddingBounds = new Rectangle(cellX, cellZ, 1, 1);

            if (cellA.Bounds.Contains(PaddingBounds.Location) || cellB.Bounds.Contains(PaddingBounds.Location))
            {
                // ignore
                return -1;
            }

            bool bRequiresPadding = true;
            int CurrentCellId = -1;

            foreach (Cell cell in gridModel.Cells)
            {
                if (cell.Bounds.Contains(PaddingBounds.Location))
                {
                    if (cell.Id == roomA || cell.Id == roomB)
                    {
                        // collides with inside of the room.
                        return -1;
                    }
                    
                    if (cell.CellType == CellType.Unknown)
                    {
                        // Convert this cell into a corridor 
                        cell.CellType = CellType.Corridor;
                    }

                    // Intersects with an existing cell. do not add corridor padding
                    bRequiresPadding = false;
                    CurrentCellId = cell.Id;
                    break;
                }
            }

            if (bRequiresPadding)
            {
                Cell corridorCell = new Cell();
                corridorCell.Id = GetNextCellId();
                corridorCell.UserDefined = false;
                corridorCell.Bounds = PaddingBounds;
                corridorCell.CellType = CellType.CorridorPadding;
                gridModel.Cells.Add(corridorCell);
                gridModel.BuildCellLookup();

                CurrentCellId = corridorCell.Id;
            }

            if (canRegisterDoors)
            {
                // Check if we are adjacent to to any of the room nodes
                if (AreCellsAdjacent(CurrentCellId, roomA))
                {
                    ConnectAdjacentCells(CurrentCellId, roomA);
                }
                if (AreCellsAdjacent(CurrentCellId, roomB))
                {
                    ConnectAdjacentCells(CurrentCellId, roomB);
                }
            }

            return CurrentCellId;    // Return the cell id of the registered cell

            /*
            Cell corridorCell = new Cell();
            corridorCell.Id = GetNextCellId();
            corridorCell.UserDefined = false;
            corridorCell.Bounds = new Rectangle(cellX, cellZ, 1, 1);
            corridorCell.CellType = CellType.CorridorPadding;

            Cell cellA = gridModel.GetCell(roomA);
            Cell cellB = gridModel.GetCell(roomB);
            if (cellA == null || cellB == null)
            {
                outCellId = -1;
                return false;
            }

            if (cellA.Bounds.Contains(corridorCell.Bounds.Location))
            {
                // ignore
                outCellId = cellA.Id;
                return false;
            }
            if (cellB.Bounds.Contains(corridorCell.Bounds.Location))
            {
                // ignore
                outCellId = cellB.Id;
                return false;
            }

            foreach (Cell cell in gridModel.Cells)
            {
                if (cell.Bounds.Contains(corridorCell.Bounds.Location))
                {
                    if (cell.Id == roomA)
                    {
                        // collides with inside of the room.
                        outCellId = roomA;
                        return false;
                    }
                    if (cell.Id == roomB)
                    {
                        // collides with inside of the room.
                        outCellId = roomB;
                        return false;
                    }

                    if (cell.CellType == CellType.Unknown)
                    {
                        // Convert this cell into a corridor 
                        cell.CellType = CellType.Corridor;

                        if (canRegisterDoors)
                        {
                            // Check if we are adjacent to to any of the room nodes
                            if (AreCellsAdjacent(cell.Id, roomA))
                            {
                                ConnectAdjacentCells(cell.Id, roomA);
                            }
                            if (AreCellsAdjacent(cell.Id, roomB))
                            {
                                ConnectAdjacentCells(cell.Id, roomB);
                            }
                        }
                    }

                    // Intersects with a cell. do not add corridor padding
                    return true;
                }
            }

            gridModel.Cells.Add(corridorCell);
            gridModel.BuildCellLookup();

            {
                var corridorX = corridorCell.Bounds.X;
                var corridorZ = corridorCell.Bounds.Z;
                if (!gridModel.GridCellInfoLookup.ContainsKey(corridorX))
                {
                    gridModel.GridCellInfoLookup.Add(corridorX, new Dictionary<int, GridCellInfo>());
                }

                var cellInfo = new GridCellInfo(corridorCell.Id, corridorCell.CellType);
                if (!gridModel.GridCellInfoLookup[corridorX].ContainsKey(corridorZ))
                {
                    gridModel.GridCellInfoLookup[corridorX].Add(corridorZ, cellInfo);
                }
                else
                {
                    gridModel.GridCellInfoLookup[corridorX][corridorZ] = cellInfo;
                }

            }

            if (canRegisterDoors)
            {
                // Check if we are adjacent to to any of the room nodes
                if (AreCellsAdjacent(corridorCell.Id, roomA))
                {
                    ConnectAdjacentCells(corridorCell.Id, roomA);
                }
                if (AreCellsAdjacent(corridorCell.Id, roomB))
                {
                    ConnectAdjacentCells(corridorCell.Id, roomB);
                }
            }

            return true;    // Indicate used
            */
        }


        static int GetForceDirectionMultiplier(float a, float b, float a1, float b1)
        {
            if (a == b)
            {
                return (a1 < b1) ? -1 : 1;
            }
            return (a < b) ? -1 : 1;
        }

        void GenerateDungeonHeights()
        {
            // build the adjacency graph in memory
            if (gridModel.Cells.Count == 0) return;
            Dictionary<int, CellHeightNode> CellHeightNodes = new Dictionary<int, CellHeightNode>();

            HashSet<int> visited = new HashSet<int>();
            Stack<CellHeightFrameInfo> stack = new Stack<CellHeightFrameInfo>(); ;
            var initialCell = gridModel.Cells[0];
            stack.Push(new CellHeightFrameInfo(initialCell.Id, initialCell.Bounds.Location.y));
            var srandom = new PMRandom(gridConfig.Seed);

            while (stack.Count > 0)
            {
                CellHeightFrameInfo top = stack.Pop();
                if (visited.Contains(top.CellId)) continue;
                visited.Add(top.CellId);

                Cell cell = gridModel.GetCell(top.CellId);
                if (cell == null) continue;

                bool applyHeightVariation = (cell.Bounds.Size.x > 1 && cell.Bounds.Size.z > 1);
                applyHeightVariation &= (cell.CellType != CellType.Room);
                applyHeightVariation &= (cell.CellType != CellType.CorridorPadding);
                applyHeightVariation &= !cell.UserDefined;

                if (applyHeightVariation)
                {
                    float rand = srandom.GetNextUniformFloat();
                    if (rand < gridConfig.HeightVariationProbability / 2.0f)
                    {
                        top.CurrentHeight--;
                    }
                    else if (rand < gridConfig.HeightVariationProbability)
                    {
                        top.CurrentHeight++;
                    }
                }
                if (cell.UserDefined)
                {
                    top.CurrentHeight = cell.Bounds.Location.y;
                }

                CellHeightNode node = new CellHeightNode();
                node.CellId = cell.Id;
                node.Height = top.CurrentHeight;
                node.MarkForIncrease = false;
                node.MarkForDecrease = false;
                CellHeightNodes.Add(node.CellId, node);

                // Add the child nodes
                foreach (int childId in cell.AdjacentCells)
                {
                    if (visited.Contains(childId)) continue;
                    stack.Push(new CellHeightFrameInfo(childId, top.CurrentHeight));
                }
            }

            // Fix the dungeon heights
            const int FIX_MAX_TRIES = 50;	// TODO: Move to config
            int fixIterations = 0;
            while (fixIterations < FIX_MAX_TRIES && FixDungeonCellHeights(CellHeightNodes))
            {
                fixIterations++;
            }

            // Assign the calculated heights
            foreach (Cell cell in gridModel.Cells)
            {
                if (CellHeightNodes.ContainsKey(cell.Id))
                {
                    CellHeightNode node = CellHeightNodes[cell.Id];
                    var bounds = cell.Bounds;
                    var location = cell.Bounds.Location;
                    location.y = node.Height;
                    bounds.Location = location;
                    cell.Bounds = bounds;
                }
            }
        }


        bool FixDungeonCellHeights(Dictionary<int, CellHeightNode> CellHeightNodes)
        {
            bool bContinueIteration = false;
            if (gridModel.Cells.Count == 0) return bContinueIteration;

            HashSet<int> visited = new HashSet<int>();
            Stack<int> stack = new Stack<int>();
            Cell rootCell = gridModel.Cells[0];
            stack.Push(rootCell.Id);
            while (stack.Count > 0)
            {
                int cellId = stack.Pop();
                if (visited.Contains(cellId)) continue;
                visited.Add(cellId);

                Cell cell = gridModel.GetCell(cellId);
                if (cell == null) continue;

                if (!CellHeightNodes.ContainsKey(cellId)) continue;
                CellHeightNode heightNode = CellHeightNodes[cellId];

                heightNode.MarkForIncrease = false;
                heightNode.MarkForDecrease = false;

                // Check if the adjacent cells have unreachable heights
                foreach (int childId in cell.AdjacentCells)
                {
                    Cell childCell = gridModel.GetCell(childId);
                    if (childCell == null || !CellHeightNodes.ContainsKey(childId)) continue;
                    CellHeightNode childHeightNode = CellHeightNodes[childId];
                    int heightDifference = Mathf.Abs(childHeightNode.Height - heightNode.Height);
                    if (heightDifference > gridConfig.MaxAllowedStairHeight)
                    {
                        if (heightNode.Height > childHeightNode.Height)
                        {
                            heightNode.MarkForDecrease = true;
                        }
                        else
                        {
                            heightNode.MarkForIncrease = true;
                        }
                        break;
                    }
                }

                // Add the child nodes
                foreach (int childId in cell.AdjacentCells)
                {
                    if (visited.Contains(childId)) continue;
                    stack.Push(childId);
                }
            }


            bool bHeightChanged = false;
            foreach (int cellId in CellHeightNodes.Keys)
            {
                CellHeightNode heightNode = CellHeightNodes[cellId];
                if (heightNode.MarkForDecrease)
                {
                    heightNode.Height--;
                    bHeightChanged = true;
                }
                else if (heightNode.MarkForIncrease)
                {
                    heightNode.Height++;
                    bHeightChanged = true;
                }
            }

            // Iterate this function again if the height was changed in this step
            bContinueIteration = bHeightChanged;
            return bContinueIteration;
        }


        int HASH(int a, int b)
        {
            return (a << 16) + b;
        }

        void RemoveAdjacentDoors()
        {
            var doorsToRemove = new List<CellDoor>();
            foreach (var door in gridModel.DoorManager.Doors)
            {
                var cellIdA = door.AdjacentCells[0];
                var cellIdB = door.AdjacentCells[1];

                door.Enabled = false;
                // Check if it is really required to have a door here. We do this by disabling the door and 
                // check if the two adjacent cells (now with a wall instead of a door) can reach each other 
                // within the specified steps
                bool pathExists = ContainsAdjacencyPath(cellIdA, cellIdB, (int)gridConfig.DoorProximitySteps);
                if (!pathExists)
                {
                    // No path exists. We need a door here
                    door.Enabled = true;
                }
                else
                {
                    // Path exists between the doors even when the door is removed.  Remove the door for good
                    // Remove the door for good
                    doorsToRemove.Add(door);
                }
            }

            foreach (var doorToRemove in doorsToRemove)
            {
                gridModel.DoorManager.RemoveDoor(doorToRemove);
            }

        }

        bool ContainsAdjacencyPath(int cellIdA, int cellIdB, int maxDepth)
        {
            Cell cellA = gridModel.GetCell(cellIdA);
            Cell cellB = gridModel.GetCell(cellIdB);
            if (cellA == null || cellB == null)
            {
                return false;
            }
            if (cellA.CellType == CellType.Room || cellB.CellType == CellType.Room)
            {
                // Force a connection if any one is a room
                //return false;
            }

            var queue = new Queue<StairAdjacencyQueueNode>();
            var visited = new HashSet<int>();
            queue.Enqueue(new StairAdjacencyQueueNode(cellIdA, 0));

            while (queue.Count > 0)
            {
                StairAdjacencyQueueNode topNode = queue.Dequeue();
                if (topNode.depth > maxDepth) continue;

                int topId = topNode.cellId;
                if (visited.Contains(topId)) continue;
                visited.Add(topId);
                if (topId == cellIdB)
                {
                    // Reached the target cell
                    return true;
                }
                Cell top = gridModel.GetCell(topId);
                if (top == null) continue;
                foreach (int adjacentCellId in top.AdjacentCells)
                {
                    if (visited.Contains(adjacentCellId)) continue;

                    // Check if we have a valid path between these two adjacent cells 
                    // (either through same height or by a already registered stair)
                    Cell adjacentCell = gridModel.GetCell(adjacentCellId);
                    if (adjacentCell == null) continue;

                    bool pathExists = (adjacentCell.Bounds.Location.y == top.Bounds.Location.y);
                    if (!pathExists)
                    {
                        // Cells are on different heights.  Check if we have a stair connecting these cells
                        StairInfo stair = new StairInfo();
                        if (GetStair(topId, adjacentCellId, ref stair))
                        {
                            pathExists = true;
                        }
                        if (!pathExists)
                        {
                            if (GetStair(adjacentCellId, topId, ref stair))
                            {
                                pathExists = true;
                            }
                        }
                    }

					if (pathExists) {
						// If any one of the cells is a room, then make sure we have a door between them
						if (top.CellType == CellType.Room || adjacentCell.CellType == CellType.Room) {
							var containsDoor = gridModel.DoorManager.ContainsDoorBetweenCells(top.Id, adjacentCellId);
							if (!containsDoor) {
								pathExists = false;
							}
						}
					}

                    if (pathExists)
                    {
                        queue.Enqueue(new StairAdjacencyQueueNode(adjacentCellId, topNode.depth + 1));
                    }
                }
            }
            return false;
        }


		void AddCorridorPadding(int x, int y, int z) {
			Cell padding = new Cell();
			padding.Id = GetNextCellId();
			padding.UserDefined = false;
			
			var bounds = new Rectangle(x, z, 1, 1);
			bounds.SetY(y);
			padding.Bounds = bounds;
			padding.CellType = CellType.CorridorPadding;
			
			gridModel.Cells.Add(padding);
		}
        
        class StairConnectionWeight {
	        public StairConnectionWeight(int position, int weight)  {
                this.position = position;
                this.weight = weight;
            }
	        public int position;
            public int weight;

        }

        class StairConnectionWeightComparer : IComparer<StairConnectionWeight>
        {
            public int Compare(StairConnectionWeight x, StairConnectionWeight y)
            {
                if (x.weight == y.weight) return 0;
                return (x.weight < y.weight) ? 1 : -1;
            }
        }

        void ConnectStairs(int WeightThreshold)
        {
            if (gridModel.Cells.Count == 0) return;
            Stack<StairEdgeInfo> stack = new Stack<StairEdgeInfo>();
			HashSet<int> visited = new HashSet<int>();
			HashSet<int> islandsVisited = new HashSet<int>();

			for (int i = 0; i < gridModel.Cells.Count; i++) {
				var startCell = gridModel.Cells[i];
				if (islandsVisited.Contains (startCell.Id)) {
					continue;
				}
				stack.Push(new StairEdgeInfo(-1, startCell.Id));
	            while (stack.Count > 0)
	            {
	                StairEdgeInfo top = stack.Pop();
	                if (top.CellIdA >= 0)
	                {
	                    int hash1 = HASH(top.CellIdA, top.CellIdB);
	                    int hash2 = HASH(top.CellIdB, top.CellIdA);
	                    if (visited.Contains(hash1) || visited.Contains(hash2))
	                    {
	                        // Already processed
	                        continue;
						}
						// Mark as processed
						visited.Add(hash1);
						visited.Add(hash2);

						// Mark the island as processed
						islandsVisited.Add(top.CellIdA);
						islandsVisited.Add(top.CellIdB);

	                    // Check if it is really required to place a stair here.  There might be other paths nearby to this cell
	                    bool pathExists = ContainsAdjacencyPath(top.CellIdA, top.CellIdB, (int)gridConfig.StairConnectionTollerance);
                        bool stairConnectsToDoor = gridModel.DoorManager.ContainsDoorBetweenCells(top.CellIdA, top.CellIdB);
	                    if (!pathExists || stairConnectsToDoor)
	                    {
	                        // Process the edge
	                        Cell cellA = gridModel.GetCell(top.CellIdA);
	                        Cell cellB = gridModel.GetCell(top.CellIdB);
	                        if (cellA == null || cellB == null) continue;
	                        if (cellA.Bounds.Location.y != cellB.Bounds.Location.y)
	                        {
	                            // Find the adjacent line
	                            Rectangle intersection = Rectangle.Intersect(cellA.Bounds, cellB.Bounds);
	                            if (intersection.Size.x > 0)
	                            {
	                                bool cellAAbove = (cellA.Bounds.Location.y > cellB.Bounds.Location.y);
	                                Cell stairOwner = (cellAAbove ? cellB : cellA);
	                                Cell stairConnectedTo = (!cellAAbove ? cellB : cellA);

	                                if (ContainsStair(stairOwner.Id, stairConnectedTo.Id))
	                                {
	                                    // Stair already exists here. Move to the next one
	                                    continue;
	                                }

	                                bool cellOwnerOnLeft = (stairOwner.Bounds.Center().z < intersection.Location.z);
	                                int validX = intersection.Location.x;
									//int preferedLocation = MathUtils.INVALID_LOCATION;

	                                int validZ = intersection.Location.z;
	                                if (cellOwnerOnLeft) validZ--;

	                                var StairConnectionCandidates = new List<StairConnectionWeight>();
	                                for (validX = intersection.Location.x; validX < intersection.Location.x + intersection.Size.x; validX++)
	                                {
	                                    var currentPointInfo = gridModel.GetGridCellLookup(validX, validZ);
									    if (stairOwner.CellType == CellType.Room || stairConnectedTo.CellType == CellType.Room) {
										    // Make sure the stair is on a door cell
										    GridCellInfo stairCellInfo = gridModel.GetGridCellLookup(validX, validZ);
										    if (!stairCellInfo.ContainsDoor) {
											    // Stair not connected to a door. Probably trying to attach itself to a room wall. ignore
											    continue;
										    }

										    // We have a door here.  A stair case is a must, but first make sure we have a door between these two cells 
										    bool hasDoor = gridModel.DoorManager.ContainsDoorBetweenCells(stairOwner.Id, stairConnectedTo.Id);
										    if (!hasDoor) continue;

										    // Check again in more detail
										    var tz1 = validZ;
										    var tz2 = validZ - 1;
										    if (cellOwnerOnLeft) {
											    tz2 = validZ + 1;
										    }

										    hasDoor = gridModel.DoorManager.ContainsDoor(validX, tz1, validX, tz2);
										    if (hasDoor) {
											    StairConnectionCandidates.Add(new StairConnectionWeight(validX, 100));
											    break;
										    }
									    }
									    else {	// Both the cells are non-rooms (corridors)
										    int weight = 0;

										    GridCellInfo cellInfo0 = gridModel.GetGridCellLookup(validX, validZ - 1);
										    GridCellInfo cellInfo1 = gridModel.GetGridCellLookup(validX, validZ + 1);
										    weight += (cellInfo0.CellType != CellType.Unknown) ? 10 : 0;
										    weight += (cellInfo1.CellType != CellType.Unknown) ? 10 : 0;

											int adjacentOwnerZ = cellOwnerOnLeft ? (validZ - 1) : (validZ + 1);
											int adjacentConnectedToZ = !cellOwnerOnLeft ? (validZ - 1) : (validZ + 1);
										    if (currentPointInfo.ContainsDoor) {
											    // Increase the weight if we connect into a door
											    int adjacentZ = cellOwnerOnLeft ? (validZ - 1) : (validZ + 1);
											    bool ownerOnDoor = gridModel.DoorManager.ContainsDoor(validX, validZ, validX, adjacentZ);
											    if (ownerOnDoor) {
												    // Connect to this
												    weight += 100;
											    }
											    else {
												    // Add a penalty if we are creating a stair blocking a door entry/exit
												    weight -= 100;
											    }
										    }
										    else {
											    // Make sure we don't connect to a wall
												GridCellInfo adjacentOwnerCellInfo = gridModel.GetGridCellLookup(validX, adjacentOwnerZ);
											    if (adjacentOwnerCellInfo.CellType == CellType.Room) {
												    // We are connecting to a wall. Add a penalty
												    weight -= 100;
											    }
										    }

										    // Check the side of the stairs to see if we are not blocking a stair entry / exit
										    if (gridModel.ContainsStairAtLocation(validX - 1, validZ)) {
											    weight -= 60;
										    }
	                                        if (gridModel.ContainsStairAtLocation(validX + 1, validZ))
	                                        {
											    weight -= 60;
										    }

											for (int dx = -1; dx <= 1; dx++) {
												var adjacentStair = gridModel.GetStairAtLocation(validX + dx, adjacentOwnerZ);
												if (adjacentStair != null) {
													var currentRotation = Quaternion.AngleAxis(cellOwnerOnLeft ? -90 : 90, new Vector3(0, 1, 0));
													var angle = Quaternion.Angle(adjacentStair.Rotation, currentRotation);
													if (dx == 0) {
														// If we have a stair case in a perpendicular direction right near the owner, add a penalty
														var angleDelta = Mathf.Abs (Mathf.Abs(angle) - 90);
														if (angleDelta < 2) {
															weight -= 100;
														}
													} else {
														var angleDelta = Mathf.Abs (Mathf.Abs(angle) - 180);
														if (angleDelta < 2) {
															weight -= 60;
														}
													}
												}
											}
											
											// If we connect to another stair with the same angle, then increase the weight
											if (gridModel.ContainsStairAtLocation(validX, adjacentConnectedToZ)) {
												var adjacentStair = gridModel.GetStairAtLocation(validX, adjacentConnectedToZ);
												if (adjacentStair != null) {
													var currentRotation = Quaternion.AngleAxis(cellOwnerOnLeft ? -90 : 90, new Vector3(0, 1, 0));
													var angle = Quaternion.Angle(adjacentStair.Rotation, currentRotation);
													var angleDelta = Mathf.Abs(angle) % 360;
													if (angleDelta < 2) {
														weight += 50;
													}
													else {
														weight -= 50;
													}
												}
											}
											

											// check if the entry of the stair is not in a different height
											{
												var adjacentEntryCellInfo = gridModel.GetGridCellLookup(validX, adjacentOwnerZ);
												if (adjacentEntryCellInfo.CellType != CellType.Unknown) {
													var adjacentEntryCell = gridModel.GetCell(adjacentEntryCellInfo.CellId);
													if (stairOwner.Bounds.Location.y != adjacentEntryCell.Bounds.Location.y) {
														// The entry is in a different height. Check if we have a stair here
														if (!gridModel.ContainsStair(validX, adjacentOwnerZ)) {
															//Add a penalty
															weight -= 10;
														}
													}
												}
											}

										    StairConnectionCandidates.Add(new StairConnectionWeight(validX, weight));
									    }
	                                }


	                                // Create a stair if necessary
	                                if (StairConnectionCandidates.Count > 0)
	                                {
	                                    StairConnectionCandidates.Sort(new StairConnectionWeightComparer());
	                                    var candidate = StairConnectionCandidates[0];
	                                    if (candidate.weight < WeightThreshold)
	                                    {
	                                        continue;
	                                    }
	                                    validX = candidate.position;

										int stairY = stairOwner.Bounds.Location.y;
										var paddingOffset = (stairOwner.Bounds.Z > stairConnectedTo.Bounds.Z) ? 1 : -1;
										// Add a corridor padding here
										//AddCorridorPadding(validX, stairY, validZ - 1);
										for (int dx = -1; dx <= 1; dx++) {
											bool requiresPadding = false;
											if (dx == 0) {
												requiresPadding = true;
											} else {
												var cellInfo = GetGridCellLookup(validX + dx, validZ);
												if (cellInfo.CellType != CellType.Unknown) {
													requiresPadding = true;
												}
											}
											
											if (requiresPadding) {
												var paddingInfo = GetGridCellLookup(validX + dx, validZ + paddingOffset);
												if (paddingInfo.CellType == CellType.Unknown) {
													AddCorridorPadding(validX + dx, stairY, validZ + paddingOffset);
												}
											}
										}
										gridModel.BuildCellLookup();
										gridModel.BuildSpatialCellLookup();
										GenerateAdjacencyLookup();
									}
	                                else
	                                {
	                                    continue;
	                                }

	                                float validY = stairOwner.Bounds.Location.y;
	                                Vector3 StairLocation = new Vector3(validX, validY, validZ);
	                                StairLocation += new Vector3(0.5f, 0, 0.5f);
	                                StairLocation = Vector3.Scale(StairLocation, GridToMeshScale);

	                                Quaternion StairRotation = Quaternion.AngleAxis(cellOwnerOnLeft ? -90 : 90, new Vector3(0, 1, 0));

	                                if (!CellStairs.ContainsKey(stairOwner.Id))
	                                {
	                                    CellStairs.Add(stairOwner.Id, new List<StairInfo>());
	                                }
	                                StairInfo Stair = new StairInfo();
	                                Stair.OwnerCell = stairOwner.Id;
	                                Stair.ConnectedToCell = stairConnectedTo.Id;
	                                Stair.Position = StairLocation;
	                                Stair.IPosition = new IntVector(validX, (int)validY, validZ);
	                                Stair.Rotation = StairRotation;
	                                if (!gridModel.ContainsStairAtLocation(validX, validZ))
	                                {
	                                    CellStairs[stairOwner.Id].Add(Stair);
	                                }
	                            }
	                            else if (intersection.Size.z > 0)
	                            {
	                                bool cellAAbove = (cellA.Bounds.Location.y > cellB.Bounds.Location.y);

	                                Cell stairOwner = (cellAAbove ? cellB : cellA);
	                                Cell stairConnectedTo = (!cellAAbove ? cellB : cellA);

	                                if (ContainsStair(stairOwner.Id, stairConnectedTo.Id))
	                                {
	                                    // Stair already exists here. Move to the next one
	                                    continue;
	                                }

	                                bool cellOwnerOnLeft = (stairOwner.Bounds.Center().x < intersection.Location.x);

	                                int validX = intersection.Location.x;
	                                if (cellOwnerOnLeft) validX--;

									int validZ = intersection.Location.z;

	                                var StairConnectionCandidates = new List<StairConnectionWeight>();
	                                for (validZ = intersection.Location.z; validZ < intersection.Location.z + intersection.Size.z; validZ++)
	                                {
	                                    var currentPointInfo = gridModel.GetGridCellLookup(validX, validZ);
									    if (stairOwner.CellType == CellType.Room || stairConnectedTo.CellType == CellType.Room) {
										    // Make sure the stair is on a door cell
										    GridCellInfo stairCellInfo = gridModel.GetGridCellLookup(validX, validZ);
										    if (!stairCellInfo.ContainsDoor) {
											    // Stair not connected to a door. Probably trying to attach itself to a room wall. ignore
											    continue;
										    }

										    // We have a door here.  A stair case is a must, but first make sure we have a door between these two cells 
										    bool hasDoor = gridModel.DoorManager.ContainsDoorBetweenCells(stairOwner.Id, stairConnectedTo.Id);
										    if (!hasDoor) continue;

										    // Check again in more detail
										    var tx1 = validX;
										    var tx2 = validX - 1;
										    if (cellOwnerOnLeft) {
											    tx2 = validX + 1;
										    }

										    hasDoor = gridModel.DoorManager.ContainsDoor(tx1, validZ, tx2, validZ);
										    if (hasDoor) {
											    StairConnectionCandidates.Add(new StairConnectionWeight(validZ, 100));
											    break;
										    }
									    }
									    else {	// Both the cells are non-rooms (corridors)
										    int weight = 0;
                                            
										    GridCellInfo cellInfo0 = gridModel.GetGridCellLookup(validX - 1, validZ);
										    GridCellInfo cellInfo1 = gridModel.GetGridCellLookup(validX + 1, validZ);
										    weight += (cellInfo0.CellType != CellType.Unknown) ? 10 : 0;
										    weight += (cellInfo1.CellType != CellType.Unknown) ? 10 : 0;
											
											int adjacentOwnerX = cellOwnerOnLeft ? (validX - 1) : (validX + 1);
											int adjacentConnectedToX = !cellOwnerOnLeft ? (validX - 1) : (validX + 1);
											if (currentPointInfo.ContainsDoor) {
											    // Increase the weight if we connect into a door
												bool ownerOnDoor = gridModel.DoorManager.ContainsDoor(validX, validZ, adjacentOwnerX, validZ);
											    if (ownerOnDoor) {
												    // Connect to this
												    weight += 100;
											    }
											    else {
												    // Add a penalty if we are creating a stair blocking a door entry/exit
												    weight -= 100;
											    }
										    }
										    else {
											    // Make sure we don't connect to a wall
											    int adjacentX = cellOwnerOnLeft ? (validX - 1) : (validX + 1);
											    GridCellInfo adjacentOwnerCellInfo = gridModel.GetGridCellLookup(adjacentX, validZ);
											    if (adjacentOwnerCellInfo.CellType == CellType.Room) {
												    // We are connecting to a wall. Add a penalty
												    weight -= 100;
											    }
										    }

										    // Check the side of the stairs to see if we are not blocking a stair entry / exit
										    if (gridModel.ContainsStairAtLocation(validX, validZ - 1)) {
											    weight -= 60;
										    }
										    if (gridModel.ContainsStairAtLocation(validX, validZ + 1)) {
											    weight -= 60;
										    }

											// If we have a stair coming out in the opposite direction, near the entry of the stair, add a penalty
											for (int dz = -1; dz <= 1; dz++) {
												var adjacentStair = gridModel.GetStairAtLocation(adjacentOwnerX, validZ + dz);
												if (adjacentStair != null) {
													var currentRotation = Quaternion.AngleAxis(cellOwnerOnLeft ? 0 : 180, new Vector3(0, 1, 0));
													var angle = Quaternion.Angle(adjacentStair.Rotation, currentRotation);
													if (dz == 0) {
														// If we have a stair case in a perpendicular direction right near the owner, add a penalty
														var angleDelta = Mathf.Abs (Mathf.Abs(angle) - 90);
														if (angleDelta < 2) {
															weight -= 100;
														}
													} else {
														var angleDelta = Mathf.Abs (Mathf.Abs(angle) - 180);
														if (angleDelta < 2) {
															weight -= 60;
														}
													}
												}
											}

											// If we connect to another stair with the same angle, the increase the weight
											if (gridModel.ContainsStairAtLocation(adjacentConnectedToX, validZ)) {
												var adjacentStair = gridModel.GetStairAtLocation(adjacentConnectedToX, validZ);
												if (adjacentStair != null) {
													var currentRotation = Quaternion.AngleAxis(cellOwnerOnLeft ? 0 : 180, new Vector3(0, 1, 0));
													var angle = Quaternion.Angle(adjacentStair.Rotation, currentRotation);
													var angleDelta = Mathf.Abs(angle) % 360;
													if (angleDelta < 2) {
														weight += 50;
													}
													else {
														weight -= 50;
													}
												}
											}


											// check if the entry of the stair is not in a different height
											{
												var adjacentEntryCellInfo = gridModel.GetGridCellLookup(adjacentOwnerX, validZ);
												if (adjacentEntryCellInfo.CellType != CellType.Unknown) {
													var adjacentEntryCell = gridModel.GetCell(adjacentEntryCellInfo.CellId);
													if (stairOwner.Bounds.Location.y != adjacentEntryCell.Bounds.Location.y) {
														// The entry is in a different height. Check if we have a stair here
														if (!gridModel.ContainsStair(adjacentOwnerX, validZ)) {
															//Add a penalty
															weight -= 10;
														}
													}
												}
											}

										    StairConnectionCandidates.Add(new StairConnectionWeight(validZ, weight));
									    }
	                                }

	                                // Connect the stairs if necessary
	                                if (StairConnectionCandidates.Count > 0)
	                                {
	                                    StairConnectionCandidates.Sort(new StairConnectionWeightComparer());
	                                    StairConnectionWeight candidate = StairConnectionCandidates[0];
	                                    if (candidate.weight < WeightThreshold)
	                                    {
	                                        continue;
	                                    }
	                                    validZ = candidate.position;

										int stairY = stairOwner.Bounds.Location.y;
										var paddingOffset = (stairOwner.Bounds.X > stairConnectedTo.Bounds.X) ? 1 : -1;
										// Add a corridor padding here
										for (int dz = -1; dz <= 1; dz++) {
											bool requiresPadding = false;
											if (dz == 0) {
												requiresPadding = true;
											} else {
												var cellInfo = GetGridCellLookup(validX, validZ + dz);
												if (cellInfo.CellType != CellType.Unknown) {
													requiresPadding = true;
												}
											}
											
											if (requiresPadding) {
												var paddingInfo = GetGridCellLookup(validX + paddingOffset, validZ + dz);
												if (paddingInfo.CellType == CellType.Unknown) {
													AddCorridorPadding(validX + paddingOffset, stairY, validZ + dz);
												}
											}
										}
										gridModel.BuildCellLookup();
										gridModel.BuildSpatialCellLookup();
										GenerateAdjacencyLookup();
									}
	                                else
	                                {
	                                    continue;
	                                }

	                                float validY = stairOwner.Bounds.Location.y;
	                                Vector3 StairLocation = new Vector3(validX, validY, validZ);
	                                StairLocation += new Vector3(0.5f, 0, 0.5f);
	                                StairLocation = Vector3.Scale(StairLocation, GridToMeshScale);

	                                Quaternion StairRotation = Quaternion.AngleAxis(cellOwnerOnLeft ? 0 : 180, new Vector3(0, 1, 0));

	                                if (!CellStairs.ContainsKey(stairOwner.Id))
	                                {
	                                    CellStairs.Add(stairOwner.Id, new List<StairInfo>());
	                                }
	                                StairInfo Stair = new StairInfo();
	                                Stair.OwnerCell = stairOwner.Id;
	                                Stair.ConnectedToCell = stairConnectedTo.Id;
	                                Stair.Position = StairLocation;
	                                Stair.IPosition = new IntVector(validX, (int)validY, validZ);
	                                Stair.Rotation = StairRotation;
	                                if (!gridModel.ContainsStairAtLocation(validX, validZ))
	                                {
	                                    CellStairs[stairOwner.Id].Add(Stair);
	                                }
	                            }
	                        }
	                    }
	                }

	                // Move to the next adjacent nodes
	                {
	                    Cell cellB = gridModel.GetCell(top.CellIdB);
	                    if (cellB == null) continue;
	                    foreach (int adjacentCell in cellB.AdjacentCells)
	                    {
	                        int hash1 = HASH(cellB.Id, adjacentCell);
	                        int hash2 = HASH(adjacentCell, cellB.Id);
	                        if (visited.Contains(hash1) || visited.Contains(hash2)) continue;
	                        StairEdgeInfo edge = new StairEdgeInfo(top.CellIdB, adjacentCell);
	                        stack.Push(edge);
	                    }
	                }
	            }
			}
        }

        public override void OnVolumePositionModified(Volume volume, out IntVector newPositionOnGrid, out IntVector newSizeOnGrid)
        {
			volume.GetVolumeGridTransform(out newPositionOnGrid, out newSizeOnGrid, GridToMeshScale);
        }

        void CheckAndMarkAdjacent(Cell cell, int otherCellX, int otherCellZ)
        {
            GridCellInfo info = gridModel.GetGridCellLookup(otherCellX, otherCellZ);
            if (info.CellId == cell.Id) return;
            Cell otherCell = gridModel.GetCell(info.CellId);
            if (otherCell == null) return;
            if (otherCell.CellType == CellType.Unknown || cell.CellType == CellType.Unknown) return;

            // Mark the two cells as adjacent
            cell.AdjacentCells.Add(otherCell.Id);
            otherCell.AdjacentCells.Add(cell.Id);
        }

        public void GenerateAdjacencyLookup()
        {
            // Cache the cell types based on their positions
            gridModel.BuildSpatialCellLookup();

            // Create cell adjacency list
            foreach (var cell in gridModel.Cells)
            {
                if (cell.CellType == CellType.Unknown) continue;
                int SizeX = cell.Bounds.Size.x;
                int SizeZ = cell.Bounds.Size.z;
                for (int dx = 0; dx < SizeX; dx++)
                {
                    for (int dz = 0; dz < SizeZ; dz++)
                    {
                        if (dx >= 0 && dx < SizeX - 1 && dz >= 0 && dz < SizeZ - 1)
                        {
                            // Ignore the cells in the middle
                            continue;
                        }

                        int x = cell.Bounds.Location.x + dx;
                        int z = cell.Bounds.Location.z + dz;
                        CheckAndMarkAdjacent(cell, x + 1, z);
                        CheckAndMarkAdjacent(cell, x, z + 1);
                    }
                }
            }

            // Cache the positions of the doors in the grid
            foreach (CellDoor Door in gridModel.DoorManager.Doors)
            {
                int x0 = Door.AdjacentTiles[0].x;
                int z0 = Door.AdjacentTiles[0].z;
                int x1 = Door.AdjacentTiles[1].x;
                int z1 = Door.AdjacentTiles[1].z;
                if (GridCellInfoLookup.ContainsKey(x0) && GridCellInfoLookup[x0].ContainsKey(z0)) GridCellInfoLookup[x0][z0].ContainsDoor = true;
                if (GridCellInfoLookup.ContainsKey(x1) && GridCellInfoLookup[x1].ContainsKey(z1)) GridCellInfoLookup[x1][z1].ContainsDoor = true;
            }

        }

        public override void EmitMarkers()
        {
			base.EmitMarkers ();
            if (gridModel.Cells.Count == 0) return;

            // Populate the prop sockets all over the map
            foreach (var cell in gridModel.Cells)
            {
                switch (cell.CellType)
                {
                    case CellType.Room:
                        BuildMesh_Room(cell);
                        BuildMesh_RoomDecoration(cell);
                        break;

                    case CellType.Corridor:
                    case CellType.CorridorPadding:
                        {
                            if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsEdges)
                            {
                                BuildMesh_Corridor(cell);
                            }
                            else
                            {
                                BuildMesh_Corridor_BlockWalls(cell);
                            }
                        }
                        break;
                }
                BuildMesh_Stairs(cell);
            }

            RemoveOverlappingMarkers();
            
            ProcessMarkerOverrideVolumes();
        }


        int GetElevation(Cell baseCell, int x, int z, out int OutYOffset)
        {
            OutYOffset = 0;
            GridCellInfo info = GetGridCellLookup(x, z);
            int elevation = gridConfig.FloorHeight;
            if (info.CellType == CellType.Unknown) return elevation;
            Cell otherCell = gridModel.GetCell(info.CellId);
            if (otherCell == null)
            {
                return elevation;
            }
            OutYOffset = otherCell.Bounds.Location.y - baseCell.Bounds.Location.y;
            elevation = Mathf.Max(elevation, Mathf.Abs(OutYOffset));
            OutYOffset = Mathf.Max(0, OutYOffset);

            //return FMath::Max(elevation, baseCell.Bounds.Location.Z - otherCell->Bounds.Location.Z);
            return elevation;
        }

        void OffsetTransformY(float Y, ref Matrix4x4 OutTransform)
        {
            Vector3 Location = Matrix.GetTranslation(ref OutTransform);
            Location.y += Y;
            Matrix.SetTranslation(ref OutTransform, Location);
        }

        bool GetStair(int ownerCell, int connectedToCell, ref StairInfo outStair)
        {
            if (CellStairs.ContainsKey(ownerCell))
            {
                foreach (StairInfo stair in CellStairs[ownerCell])
                {
                    if (stair.ConnectedToCell == connectedToCell)
                    {
                        outStair = stair;
                        return true;
                    }
                }
            }
            return false;
        }

        bool ContainsStair(int ownerCellId, int connectedToCellId)
        {
            if (!gridModel.CellStairs.ContainsKey(ownerCellId))
            {
                return false;
            }

            foreach (var stairInfo in gridModel.CellStairs[ownerCellId])
            {
                if (stairInfo.ConnectedToCell == connectedToCellId)
                {
                    return true;
                }
            }
            return false;
        }

        bool ContainsStair(Cell baseCell, int x, int z)
        {
            GridCellInfo info = GetGridCellLookup(x, z);
            if (info.CellType == CellType.Unknown) return false;

            Cell cell = gridModel.GetCell(info.CellId);
            if (cell == null) return false;

            StairInfo stair = new StairInfo();
            if (GetStair(cell.Id, baseCell.Id, ref stair))
            {
                Vector3 IPosition = MathUtils.Divide(stair.Position, GridToMeshScale);
                int ix = Mathf.FloorToInt(IPosition.x);
                int iz = Mathf.FloorToInt(IPosition.z);
                if (ix == x && iz == z)
                {
                    return true;
                }
            }
            return false;
        }

        public bool V3Equal(Vector3 a, Vector3 b)
        {
            return Vector3.SqrMagnitude(a - b) < 1e-6f;
        }
        
        bool CanDrawFence(Cell baseCell, int x, int z, out bool isElevatedFence, out bool drawPillar, out int elevationHeight)
        {
            GridCellInfo info = GetGridCellLookup(x, z);
            isElevatedFence = false;
            drawPillar = false;
            elevationHeight = 0;
            if (info.CellType == CellType.Unknown)
            {
                isElevatedFence = false;
                drawPillar = true;
                return true;
            }
            Cell otherCell = gridModel.GetCell(info.CellId);
            if (otherCell != null && otherCell.Bounds.Location.y < baseCell.Bounds.Location.y)
            {
                isElevatedFence = true;
                elevationHeight = baseCell.Bounds.Location.y - otherCell.Bounds.Location.y;
                drawPillar = true;
                // Make sure we dont have a stair between the two cells
                if (!ContainsStair(baseCell, x, z))
                {
                    return true;
                }
            }
            return false;
        }


        bool ShouldMakeDoor(int x1, int z1, int x2, int z2, out GridCellInfo cellA, out GridCellInfo cellB)
        {
            cellA = GetGridCellLookup(x1, z1);
            cellB = GetGridCellLookup(x2, z2);
            bool makeDoor = (cellA.ContainsDoor && cellB.ContainsDoor);
            if (makeDoor)
            {
                // Now perform an exhaustive search to see if a door really exists between them
                makeDoor = gridModel.DoorManager.ContainsDoorBetweenCells(cellA.CellId, cellB.CellId);
            }
            return makeDoor;
        }

        void BuildMesh_RoomDecoration(Cell cell)
        {
        }


        void BuildMesh_Corridor_BlockWalls(Cell cell)
        {
            BuildMesh_Floor(cell);
            var fencePositions = new HashSet<IntVector>();

            var border = Rectangle.ExpandBounds(cell.Bounds, 1);
            var borderPoints = border.GetBorderPoints();
            foreach (var p in borderPoints)
            {
                if (fencePositions.Contains(p))
                {
                    continue;
                }

                var cellInfo = GetGridCellLookup(p.x, p.z);
                if (cellInfo.CellType == CellType.Unknown)
                {
                    fencePositions.Add(p);
                }
            }

            foreach (var p in fencePositions)
            {
                var gridPosition = p;

                Vector3 position = p.ToVector3();
                position += new Vector3(0.5f, 0, 0.5f);
                position = Vector3.Scale(position, GridToMeshScale);
                var rotation = Quaternion.AngleAxis(0, new Vector3(0, 1, 0));
                var transform = Matrix4x4.TRS(position, rotation, Vector3.one);

                EmitMarker(GridDungeonMarkerNames.Fence, transform, gridPosition, cell.Id);
            }
        }

        void BuildMesh_Room(Cell cell)
        {
            BuildMesh_Floor(cell);
            
            Vector3 HalfWallOffset = Vector3.Scale(GridToMeshScale, new Vector3(0, -1, 0));
            // Build the room walls

            IntVector basePosition = cell.Bounds.Location;
            int elevation;

            GridCellInfo doorCellA, doorCellB;
            object markerMetadata = null;

            var gridPosition = new IntVector();
            
            // x, y, z, new Vector3(0.5f, 0, 0), new Vector3(0, 0, 0), 180
            System.Action<int, int, int, int, int, Vector3, Vector3, float> funcDrawFence = (x, y, z, dx, dz, fenceOffset, pillarOffset, angle) => { };
            
            // build walls along the width
            for (int dx = 0; dx < cell.Bounds.Size.x; dx++)
            {
                int x = basePosition.x + dx;
                int y = basePosition.y;
                int z = basePosition.z;
                gridPosition.Set(x, y, z);

                Matrix4x4 transform = Matrix4x4.identity;
                Vector3 position = new Vector3(x, y, z);
                if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsEdges)
                {
                    position += new Vector3(0.5f, 0, 0);
                }
                else if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks)
                {
                    position += new Vector3(0.5f, 0, 0.5f);
                }
                position = Vector3.Scale(position, GridToMeshScale);
                var rotation = Quaternion.AngleAxis(180, new Vector3(0, 1, 0));
                transform = Matrix4x4.TRS(position, rotation, Vector3.one);
                int OffsetY = 0;

                //var cellLookupA = GetGridCellLookup(x, z);
                //var cellLookupB = GetGridCellLookup(x, z - 1);
                bool makeDoor = ShouldMakeDoor(x, z, x, z - 1, out doorCellA, out doorCellB);

                elevation = GetElevation(cell, x, z - 1, out OffsetY);
                OffsetTransformY(OffsetY * GridToMeshScale.y, ref transform);

                string SocketType = makeDoor ? GridDungeonMarkerNames.Door : GridDungeonMarkerNames.Wall;
                markerMetadata = makeDoor ? new GridBuilderDoorMetadata(doorCellA.CellId, doorCellB.CellId) : null;
                EmitMarker(SocketType, transform, gridPosition, cell.Id, markerMetadata);
                EmitMarker(GridDungeonMarkerNames.WallHalf, transform, elevation, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);

                // Add the pillar
                Matrix.SetTranslation(ref transform, Vector3.Scale(new Vector3(x, y, z), GridToMeshScale));
                OffsetTransformY(OffsetY * GridToMeshScale.y, ref transform);
                EmitMarker(GridDungeonMarkerNames.WallSeparator, transform, gridPosition, cell.Id);
                EmitMarker(GridDungeonMarkerNames.WallHalfSeparator, transform, elevation, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);

                z += cell.Bounds.Size.z;
                gridPosition.Set(x, y, z);

                elevation = GetElevation(cell, x, z, out OffsetY);
                GridCellInfo AdjacentCellInfo = GetGridCellLookup(x, z);
                if (AdjacentCellInfo.CellType != CellType.Room || gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks)
                {
                    if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsEdges)
                    {
                        position.z = z;
                    }
                    else if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks)
                    {
                        position.z = z - 0.5f;
                    }
                    position.z *= GridToMeshScale.z;
                    rotation = Quaternion.AngleAxis(0, new Vector3(0, 1, 0));
                    transform = Matrix4x4.TRS(position, rotation, Vector3.one);
                    
                    makeDoor = ShouldMakeDoor(x, z, x, z - 1, out doorCellA, out doorCellB);

                    SocketType = makeDoor ? GridDungeonMarkerNames.Door : GridDungeonMarkerNames.Wall;
                    markerMetadata = makeDoor ? new GridBuilderDoorMetadata(doorCellA.CellId, doorCellB.CellId) : null;
                    OffsetTransformY(OffsetY * GridToMeshScale.y, ref transform);

                    // The adjacent room will already have a door, so we ignore this if this is a door
                    bool bIgnoreMainMarker = (makeDoor && AdjacentCellInfo.CellType == CellType.Room && gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks);

                    if (!bIgnoreMainMarker)
                    {
                        EmitMarker(SocketType, transform, gridPosition, cell.Id, markerMetadata);
                    }
                    EmitMarker(GridDungeonMarkerNames.WallHalf, transform, elevation, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);

                    // Add the pillar
                    Matrix.SetTranslation(ref transform, Vector3.Scale(new Vector3(x + 1, y, z), GridToMeshScale));
                    OffsetTransformY(OffsetY * GridToMeshScale.y, ref transform);
                    gridPosition.x++;
                    EmitMarker(GridDungeonMarkerNames.WallSeparator, transform, gridPosition, cell.Id);
                    EmitMarker(GridDungeonMarkerNames.WallHalfSeparator, transform, elevation, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);
                }
            }

            // build walls along the length
            for (int dz = 0; dz < cell.Bounds.Size.z; dz++)
            {
                int x = basePosition.x;
                int y = basePosition.y;
                int z = basePosition.z + dz;
                gridPosition.Set(x, y, z);

                Matrix4x4 transform = Matrix4x4.identity;
                Vector3 position = new Vector3(x, y, z);
                if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsEdges)
                {
                    position += new Vector3(0, 0, 0.5f);
                }
                else if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks)
                {
                    position += new Vector3(0.5f, 0, 0.5f);
                }

                position = Vector3.Scale(position, GridToMeshScale);
                var rotation = Quaternion.AngleAxis(-90, new Vector3(0, 1, 0));
                transform = Matrix4x4.TRS(position, rotation, Vector3.one);
                int OffsetY = 0;

                bool makeDoor = ShouldMakeDoor(x, z, x - 1, z, out doorCellA, out doorCellB);

                elevation = GetElevation(cell, x - 1, z, out OffsetY);

                string SocketType = makeDoor ? GridDungeonMarkerNames.Door : GridDungeonMarkerNames.Wall;
                markerMetadata = makeDoor ? new GridBuilderDoorMetadata(doorCellA.CellId, doorCellB.CellId) : null;
                OffsetTransformY(OffsetY * GridToMeshScale.y, ref transform);
                EmitMarker(SocketType, transform, gridPosition, cell.Id, markerMetadata);
                EmitMarker(GridDungeonMarkerNames.WallHalf, transform, elevation, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);

                // Add the pillar
                Matrix.SetTranslation(ref transform, Vector3.Scale(new Vector3(x, y, z + 1), GridToMeshScale));
                OffsetTransformY(OffsetY * GridToMeshScale.y, ref transform);
                gridPosition.z++;
                EmitMarker(GridDungeonMarkerNames.WallSeparator, transform, gridPosition, cell.Id);
                EmitMarker(GridDungeonMarkerNames.WallHalfSeparator, transform, elevation, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);

                x += cell.Bounds.Size.x;
                gridPosition.Set(x, y, z);

                elevation = GetElevation(cell, x, z, out OffsetY);
                GridCellInfo AdjacentCellInfo = GetGridCellLookup(x, z);
                if (AdjacentCellInfo.CellType != CellType.Room || gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks)
                {
                    if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsEdges)
                    {
                        position.x = x;
                    }
                    else if (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks)
                    {
                        position.x = x - 0.5f;
                    }

                    position.x *= GridToMeshScale.x;
                    rotation = Quaternion.AngleAxis(90, new Vector3(0, 1, 0));
                    transform = Matrix4x4.TRS(position, rotation, Vector3.one);

                    makeDoor = ShouldMakeDoor(x, z, x - 1, z, out doorCellA, out doorCellB);
                    SocketType = makeDoor ? GridDungeonMarkerNames.Door : GridDungeonMarkerNames.Wall;
                    markerMetadata = makeDoor ? new GridBuilderDoorMetadata(doorCellA.CellId, doorCellB.CellId) : null;
                    OffsetTransformY(OffsetY * GridToMeshScale.y, ref transform);

                    // The adjacent room will already have a door, so we ignore this if this is a door
                    bool bIgnoreMainMarker = (makeDoor && AdjacentCellInfo.CellType == CellType.Room && gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks);

                    if (!bIgnoreMainMarker)
                    {
                        EmitMarker(SocketType, transform, gridPosition, cell.Id, markerMetadata);
                    }

                    EmitMarker(GridDungeonMarkerNames.WallHalf, transform, elevation, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);

                    // Add the pillar
                    Matrix.SetTranslation(ref transform, Vector3.Scale(new Vector3(x, y, z), GridToMeshScale));
                    OffsetTransformY(OffsetY * GridToMeshScale.y, ref transform);
                    EmitMarker(GridDungeonMarkerNames.WallSeparator, transform, gridPosition, cell.Id);
                    EmitMarker(GridDungeonMarkerNames.WallHalfSeparator, transform, elevation, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);
                }
            }
        }

        void BuildMesh_Corridor(Cell cell)
        {
            BuildMesh_Floor(cell);

            Vector3 HalfWallOffset = Vector3.Scale(GridToMeshScale, new Vector3(0, -1, 0));
            IntVector basePosition = cell.Bounds.Location;
            var gridPosition = new IntVector();

            // x, y, z, 0, 0, new Vector3(0.5f, 0, 0), new Vector3(0, 0, 0), 180
            System.Action<int, int, int, int, int, float, Vector3, Vector3, Vector3[]> funcDrawFence = (x, y, z, dx, dz, angle, fenceOffset, pillarOffset, extraWallHalfOffsets) =>
            {
                int elevationHeight;
                bool isElevatedFence, drawPillar;
                bool drawFence = CanDrawFence(cell, x + dx, z + dz, out isElevatedFence, out drawPillar, out elevationHeight);
               if (drawFence || isElevatedFence)
                {
                    var position = new Vector3(x, y, z);
                    position += fenceOffset;
                    position = Vector3.Scale(position, GridToMeshScale);
                    var rotation = Quaternion.AngleAxis(angle, new Vector3(0, 1, 0));
                    var transform = Matrix4x4.TRS(position, rotation, Vector3.one);
                    if (drawFence)
                    {
                        EmitMarker(GridDungeonMarkerNames.Fence, transform, gridPosition, cell.Id);
                    }

                    if (isElevatedFence)
                    {
                        EmitMarker(GridDungeonMarkerNames.WallHalf, transform, elevationHeight, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);
                    }
                }

                if (drawFence || drawPillar)
                {
                    var position = new Vector3(x, y, z) + pillarOffset;
                    position = Vector3.Scale(position, GridToMeshScale);
                    var rotation = Quaternion.AngleAxis(angle, new Vector3(0, 1, 0));
                    var transform = Matrix4x4.TRS(position, rotation, Vector3.one);
                    EmitMarker(GridDungeonMarkerNames.FenceSeparator, transform, gridPosition, cell.Id);

                    if (isElevatedFence)
                    {
                        var offsets = new List<KeyValuePair<Vector3, float>>();
                        offsets.Add(new KeyValuePair<Vector3, float>(pillarOffset, angle));
                        foreach (var extraWallHalfOffset in extraWallHalfOffsets)
                        {
                            offsets.Add(new KeyValuePair<Vector3, float>(extraWallHalfOffset, angle - 90));
                        }

                        var oldDuplicateState = markers.AllowDuplicateMarkers;
                        markers.AllowDuplicateMarkers = false;
                        
                        foreach (var entry in offsets)
                        {
                            position = new Vector3(x, y, z) + entry.Key;
                            position = Vector3.Scale(position, GridToMeshScale);
                            var pillarAngle = entry.Value;
                            rotation = Quaternion.AngleAxis(pillarAngle, new Vector3(0, 1, 0));
                            transform = Matrix4x4.TRS(position, rotation, Vector3.one);
                            
                            EmitMarker(GridDungeonMarkerNames.WallHalfSeparator, transform, elevationHeight, HalfWallOffset, gridPosition, cell.Id, GridToMeshScale);
                        }

                        markers.AllowDuplicateMarkers = oldDuplicateState;
                    }
                }
            };

            // build fence along the width
            for (int dx = 0; dx < cell.Bounds.Size.x; dx++)
            {
                int x = basePosition.x + dx;
                int y = basePosition.y;
                int z = basePosition.z;
                gridPosition.Set(x, y, z);
                var extraHalfPillarOffsets = new List<Vector3>();
                if (dx == cell.Bounds.Size.x - 1)
                {
                    extraHalfPillarOffsets.Add(new Vector3(1, 0, 0));
                }
                funcDrawFence(x, y, z, 0, -1, 180, new Vector3(0.5f, 0, 0), new Vector3(0, 0, 0), extraHalfPillarOffsets.ToArray());
                
                z += cell.Bounds.Size.z;
                gridPosition.Set(x, y, z);
                extraHalfPillarOffsets = new List<Vector3>();
                if (dx == 0)
                {
                    extraHalfPillarOffsets.Add(new Vector3(0, 0, 0));
                }
                funcDrawFence(x, y, z, 0, 0, 0, new Vector3(0.5f, 0, 0), new Vector3(1, 0, 0), extraHalfPillarOffsets.ToArray());
            }

            // build fence along the length
            for (int dz = 0; dz < cell.Bounds.Size.z; dz++)
            {
                int x = basePosition.x;
                int y = basePosition.y;
                int z = basePosition.z + dz;
                gridPosition.Set(x, y, z);
                var extraHalfPillarOffsets = new List<Vector3>();
                if (dz == 0)
                {
                    extraHalfPillarOffsets.Add(new Vector3(0, 0, 0));
                }
                funcDrawFence(x, y, z, -1, 0, -90, new Vector3(0, 0, 0.5f), new Vector3(0, 0, 1), extraHalfPillarOffsets.ToArray());
                
                x += cell.Bounds.Size.x;
                gridPosition.Set(x, y, z);
                extraHalfPillarOffsets = new List<Vector3>();
                if (dz == cell.Bounds.Size.z - 1)
                {
                    extraHalfPillarOffsets.Add(new Vector3(0, 0, 1));
                }
                funcDrawFence(x, y, z, 0, 0, 90, new Vector3(0, 0, 0.5f), new Vector3(0, 0, 0), extraHalfPillarOffsets.ToArray());
            }
        }

        int GetStairHeight(StairInfo stair)
        {
            Cell owner = gridModel.GetCell(stair.OwnerCell);
            Cell target = gridModel.GetCell(stair.ConnectedToCell);
            if (owner == null || target == null) return 1;
            return Mathf.Abs(owner.Bounds.Location.y - target.Bounds.Location.y);
        }

        void RemoveOverlappingMarkers()
        {
            var wallPositions = new HashSet<Vector3>();
            var wallSeparaterPositions = new HashSet<Vector3>();
            foreach (PropSocket marker in markers)
            {
                if (marker.SocketType == GridDungeonMarkerNames.Wall)
                {
                    var position = Matrix.GetTranslation(ref marker.Transform);
                    wallPositions.Add(position);
                }
                if (marker.SocketType == GridDungeonMarkerNames.WallSeparator)
                {
                    var position = Matrix.GetTranslation(ref marker.Transform);
                    wallSeparaterPositions.Add(position);
                }
            }

            var overlappingMarkers = new List<PropSocket>();
            foreach (PropSocket marker in markers)
            {
                if (marker.SocketType == GridDungeonMarkerNames.Fence)
                {
                    var position = Matrix.GetTranslation(ref marker.Transform);
                    if (wallPositions.Contains(position))
                    {
                        overlappingMarkers.Add(marker);
                    }
                }
                if (marker.SocketType == GridDungeonMarkerNames.FenceSeparator)
                {
                    var position = Matrix.GetTranslation(ref marker.Transform);
                    if (wallSeparaterPositions.Contains(position))
                    {
                        overlappingMarkers.Add(marker);
                    }
                }
            }

            // Remove all the overlapping markers
            foreach (var overlappingMarker in overlappingMarkers)
            {
                markers.Remove(overlappingMarker);
            }
        }

        void BuildMesh_Stairs(Cell cell)
        {
            // Draw all the stairs registered with this cell
            if (!CellStairs.ContainsKey(cell.Id))
            {
                // No stairs registered here
                return;
            }
            
            foreach (StairInfo stair in CellStairs[cell.Id])
            {
                Matrix4x4 transform = Matrix4x4.TRS(stair.Position, stair.Rotation, Vector3.one);
                int stairHeight = GetStairHeight(stair);
                string StairType = (stairHeight > 1) ? GridDungeonMarkerNames.Stair2X : GridDungeonMarkerNames.Stair;
                EmitMarker(StairType, transform, stair.IPosition, cell.Id);
            }
        }

        void BuildMesh_Floor(Cell cell)
        {
            var basePosition = cell.Bounds.Location;
            var gridPosition = new IntVector();
            for (int dx = 0; dx < cell.Bounds.Width; dx++)
            {
                for (int dz = 0; dz < cell.Bounds.Length; dz++)
                {
                    int x = basePosition.x + dx;
                    int y = basePosition.y;
                    int z = basePosition.z + dz;
                    gridPosition.Set(x, y, z);

                    Vector3 position = new Vector3(x, y, z);
                    position += new Vector3(0.5f, 0, 0.5f);
                    position.Scale(GridToMeshScale);

                    Matrix4x4 transform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
                    EmitMarker(GridDungeonMarkerNames.Ground, transform, gridPosition, cell.Id);
                }
            }
        }
        
        public override void DebugDraw()
        {
            if (!gridModel) return;
            foreach (var cell in gridModel.Cells)
            {
                GridDebugDrawUtils.DrawCell(cell, Color.white, gridConfig.GridCellSize, gridConfig.Mode2D);
                GridDebugDrawUtils.DrawAdjacentCells(cell, gridModel, Color.green, gridConfig.Mode2D);
                GridDebugDrawUtils.DrawCellConnectionPoints(cell, gridModel, Color.red, gridConfig.Mode2D);
            }

            foreach (var door in gridModel.DoorManager.Doors)
            {
                var start = door.AdjacentTiles[0];
                var end = door.AdjacentTiles[1];
                var boundsStart = new Rectangle(start.x, start.z, 1, 1);
                var boundsEnd = new Rectangle(end.x, end.z, 1, 1);
                IntVector location = boundsStart.Location;
                location.y = start.y;
                boundsStart.Location = location;

                location = boundsEnd.Location;
                location.y = end.y;
                boundsEnd.Location = location;

                DebugDrawUtils.DrawBounds(boundsStart, Color.yellow, gridConfig.GridCellSize, gridConfig.Mode2D);
                DebugDrawUtils.DrawBounds(boundsEnd, Color.yellow, gridConfig.GridCellSize, gridConfig.Mode2D);
            }

        }

    }

    public static class GridDungeonMarkerNames {
        public static readonly string Fence = "Fence";
        public static readonly string FenceSeparator = "FenceSeparator";
        public static readonly string Door = "Door";
        public static readonly string Door2D = "Door2D";
        public static readonly string Door2D_90 = "Door2D_90";
        public static readonly string Wall = "Wall";
        public static readonly string Wall2D = "Wall2D";
        public static readonly string WallSeparator = "WallSeparator";
        public static readonly string Ground = "Ground";
        public static readonly string Ground2D = "Ground2D";
        public static readonly string Stair = "Stair";
        public static readonly string Stair2X = "Stair2X";
        public static readonly string WallHalf = "WallHalf";
        public static readonly string WallHalfSeparator = "WallHalfSeparator";
        public static readonly string None = "None";
		
        public static readonly string RoomWall = "RoomWall";
        public static readonly string RoomWallSeparator = "RoomWallSeparator";
        public static readonly string RoomOpenSpace = "RoomOpenSpace";
        public static readonly string Light = "Light";
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\GridDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Grid
{
    [System.Serializable]
    public enum GridDungeonWallType
    {
        WallsAsEdges,
        WallsAsTileBlocks
    }

    /// <summary>
    /// The dungeon configuration for the Grid builder
    /// </summary>
    public class GridDungeonConfig : DungeonConfig
    {
        /// <summary>
        /// This dungeon builder works on a grid based system and required modular mesh assets 
        /// to be placed on each cell (floors, walls, doors etc). This important field specifies the size
        /// of the cell to use. This size is determined by the art asset used in the dungeon theme 
        /// designed by the artist. In the demo, we have a floor mesh that is 400x400. The height
        /// of a floor is chosen to be 200 units as the stair mesh is 200 units high. Hence the
        /// defaults are set to 400x400x200. You should change this to the dimension of the modular
        /// asset your designer has created for the dungeon
        /// </summary>
        [Tooltip(@"This dungeon builder works on a grid based system and required modular mesh assets to be placed on each cell (floors, walls, doors etc). This important field specifies the size of the cell to use. This size is determined by the art asset used in the dungeon theme designed by the artist. In the demo, we have a floor mesh that is 400x400. The height of a floor is chosen to be 200 units as the stair mesh is 200 units high. Hence the defaults are set to 400x400x200. You should change this to the dimension of the modular asset your designer has created for the dungeon")]
        public Vector3 GridCellSize = new Vector3(4, 2, 4);

        /// <summary>
        /// Changing this number would completely change the layout of the dungeon. 
        /// This is the base random number seed that is used to build the dungeon. 
        /// There is a convenience function to randomize this value (button labeled R)
        /// </summary>
        [Tooltip(@"Changing this number would completely change the layout of the dungeon. This is the base random number seed that is used to build the dungeon. There is a convenience function to randomize this value (button labeled R)")]
        public int NumCells = 150;

        /// <summary>
        /// This is how small a cell size can be. While generation, a cell is either converted
        /// to a room, corridor or is discarded completely. The Cell width / height is randomly 
        /// chosen within this range
        /// </summary>
        [Tooltip(@"This is how small a cell size can be. While generation, a cell is either converted to a room, corridor or is discarded completely. The Cell width / height is randomly chosen within this range")]
        public int MinCellSize = 2;

        /// <summary>
        /// This is how big a cell size can be. While generation, a cell is either 
        /// converted to a room, corridor or is discarded completely.
        /// The Cell width / height is randomly chosen within this range
        /// </summary>
        [Tooltip(@"This is how big a cell size can be. While generation, a cell is either converted to a room, corridor or is discarded completely. The Cell width / height is randomly chosen within this range")]
        public int MaxCellSize = 5;

        /// <summary>
        ///  If a cell size exceeds past this limit, it is converted into a room. After cells are
        ///  promoted to rooms, all rooms are connected to each other through corridors
        ///  (either directly or indirectly. See spanning tree later)
        /// </summary>
        [Tooltip(@"If a cell size exceeds past this limit, it is converted into a room. After cells are promoted to rooms, all rooms are connected to each other through corridors (either directly or indirectly. See spanning tree later)")]
        public int RoomAreaThreshold = 15;

        /// <summary>
        /// The aspect ratio of the cells (width to height ratio). Keeping this value near 0 would 
        /// create square rooms. Bringing this close to 1 would create elongated / stretched rooms
        /// with a high width to height ratio
        /// </summary>
        [Tooltip(@"The aspect ratio of the cells (width to height ratio). Keeping this value near 0 would create square rooms. Bringing this close to 1 would create elongated / stretched rooms with a high width to height ratio")]
        public float RoomAspectDelta = 0.4f;

        /// <summary>
        /// The extra width to apply to one side of a corridor
        /// </summary>
        [Tooltip(@"The extra width to apply to one side of a corridor")]
        public int CorridorWidth = 1;
        
        /// <summary>
        /// Tweak this value to increase / reduce the height variations (and stairs)
        /// in your dungeon. A value close to 0 reduces the height variation and increases
        /// as you approach 1. Increasing this value to a higher level might create dungeons 
        /// with no place for proper stair placement since there is too much height variation.
        /// A value of 0.2 to 0.4 seems good
        /// </summary>
        [Tooltip(@"Tweak this value to increase / reduce the height variations (and stairs) in your dungeon. A value close to 0 reduces the height variation and increases as you approach 1. Increasing this value to a higher level might create dungeons  with no place for proper stair placement since there is too much height variation. A value of 0.2 to 0.4 seems good")]
        public float HeightVariationProbability = 0.2f;

        /// <summary>
        /// The number of logical floor units the dungeon height can vary. This determines how 
        /// high the dungeon's height can vary (e.g. max 2 floors high). Set this value depending 
        /// on the stair meshes you designer has created. In the sample demo, there are two stair
        /// meshes, one 200 units high (1 floor) and another 400 units high (2 floors).
        /// So the default is set to 2
        /// </summary>
        [Tooltip(@"The number of logical floor units the dungeon height can vary. This determines how  high the dungeon's height can vary (e.g. max 2 floors high). Set this value depending  on the stair meshes you designer has created. In the sample demo, there are two stair meshes, one 200 units high (1 floor) and another 400 units high (2 floors). So the default is set to 2")]
        public int MaxAllowedStairHeight = 1;

        /// <summary>
        /// Determines how many loops you would like to have in your dungeon. A value near 0 will create
        /// fewer loops creating linear dungeons. A value near 1 would create lots of loops, which would look unoriginal.
        /// Its good to allow a few loops so a value close to zero (like 0.2 should be good)
        /// </summary>
        [Tooltip(@"Determines how many loops you would like to have in your dungeon. A value near 0 will create fewer loops creating linear dungeons. A value near 1 would create lots of loops, which would look unoriginal. Its good to allow a few loops so a value close to zero (like 0.2 should be good)")]
        public float SpanningTreeLoopProbability = 0.15f;

        /// <summary>
        /// The generator would add stairs to make different areas of the dungeon accessible. However, we do not want too
        /// many stairs. For e.g., before adding a stair in a particular elevated area, the generator would check if this
        /// area is already accessible from a nearby stair. If so, it would not add it. This tolerance parameter determines
        /// how far to look for an existing path before we can add a stair. Play with this parameter if you see too many
        /// stairs close to each other, or too few
        /// </summary>
        [Tooltip(@"The generator would add stairs to make different areas of the dungeon accessible. However, we do not want too many stairs. For e.g., before adding a stair in a particular elevated area, the generator would check if this area is already accessible from a nearby stair. If so, it would not add it. This tolerance parameter determines how far to look for an existing path before we can add a stair. Play with this parameter if you see too many stairs close to each other, or too few")]
        public float StairConnectionTollerance = 6;

        /// <summary>
        /// Increase this value to remove nearby duplicate doors.  This value determines how many cell we can move to reach the two connected cells of a door if the door was removed
        /// </summary>
        [Tooltip(@"Increase this value to remove nearby duplicate doors.  This value determines how many cell we can move to reach the two connected cells of a door if the door was removed")]
        public float DoorProximitySteps = 3;
        
        /// <summary>
        /// The random number generator used in the dungeon generator does not use a uniform distribution.
        /// Instead it uses a normal distribution to get higher frequency of lower values and fewer higher values
        /// (and hence fewer room cells and a lot more corridor cells). Play with these parameters for different results
        /// </summary>
        [Tooltip(@"The random number generator used in the dungeon generator does not use a uniform distribution. Instead it uses a normal distribution to get higher frequency of lower values and fewer higher values (and hence fewer room cells and a lot more corridor cells). Play with these parameters for different results")]
        public float NormalMean = 0;

        /// <summary>
        /// The random number generator used in the dungeon generator does not use a uniform distribution.
        /// Instead it uses a normal distribution to get higher frequency of lower values and fewer higher values
        /// (and hence fewer room cells and a lot more corridor cells). Play with these parameters for different results
        /// </summary>
        [Tooltip(@"The random number generator used in the dungeon generator does not use a uniform distribution. Instead it uses a normal distribution to get higher frequency of lower values and fewer higher values (and hence fewer room cells and a lot more corridor cells). Play with these parameters for different results")]
        public float NormalStd = 0.3f;

        /// <summary>
        /// The radius within which to spawn the initial cells before they are separated.
        /// Keep to a low value like 10-15
        /// </summary>
        [Tooltip(@"The radius within which to spawn the initial cells before they are separated. Keep to a low value like 10-15")]
        public float InitialRoomRadius = 15;


        [Tooltip(@"Whether to treat walls as edges or as large tile blocks (like ground tiles)")]
        public GridDungeonWallType WallLayoutType = GridDungeonWallType.WallsAsEdges;

        /// <summary>
        /// __Internal
        /// </summary>
        public int FloorHeight = 0;

        public bool UseFastCellDistribution = false;

        public int CellDistributionWidth = 20;

        public int CellDistributionLength = 30;

        public bool Mode2D = false;
        
        public override bool IsMode2D()
        {
            return Mode2D;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\GridDungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System;
using System.Collections.Generic;

namespace DungeonArchitect.Builders.Grid
{
    /// <summary>
    /// The type of cell used in the grid builder
    /// </summary>
	[System.Serializable]
    public enum CellType
    {
        Room,
        Corridor,
        CorridorPadding,
        Unknown
    }

    /// <summary>
    /// Data-structure to hold the stair information in the grid based builder
    /// </summary>
    [System.Serializable]
    public class StairInfo
    {
        [SerializeField]
        public int OwnerCell;

        [SerializeField]
        public int ConnectedToCell;

        [SerializeField]
        public Vector3 Position;

        [SerializeField]
        public Quaternion Rotation;

        [SerializeField]
        public IntVector IPosition;
    };

    /// <summary>
    /// Data-structure to hold the Cell information. A cell is a piece of the dungeon layout and can be either a room or a corridor
    /// </summary>
    [Serializable]
    public class Cell
    {
        public Cell()
        {
            cellType = CellType.Unknown;
        }
        public Cell(int x, int z, int width, int length)
        {
            bounds = new Rectangle(x, z, width, length);
            cellType = CellType.Unknown;
        }

        [SerializeField]
        int id;
        public int Id
        {
            get
            {
                return id;
            }
            set
            {
                id = value;
            }
        }

        [SerializeField]
        Rectangle bounds = new Rectangle();
        public Rectangle Bounds
        {
            get { return bounds; }
            set { bounds = value; }
        }
		
		[SerializeField]
        CellType cellType = CellType.Unknown;
        public CellType CellType
        {
            get { return cellType; }
            set { cellType = value; }
        }

        public Bounds GetWorldBounds(Vector3 gridSize)
        {
            var bounds = new Bounds();
            var width = this.Bounds.Width * gridSize.x;
            var length = this.Bounds.Width * gridSize.z;
            var center = Vector3.Scale(this.Bounds.CenterF(), gridSize);
            bounds.center = center;
            bounds.size = new Vector3(width, 2, length);
            return bounds;
        }

        /// <summary>
        /// Indicates if the cell is user defined and not procedurally generated
        /// </summary>
        [SerializeField]
        bool userDefined;
        public bool UserDefined
        {
            get
            {
                return userDefined;
            }
            set
            {
                userDefined = value;
            }
        }

        [SerializeField]
        HashSet<int> connectedRooms = new HashSet<int>();
        public HashSet<int> ConnectedRooms
        {
            get { return connectedRooms; }
            set { connectedRooms = value; }
        }

        [SerializeField]
        HashSet<int> fixedRoomConnections = new HashSet<int>();
        public HashSet<int> FixedRoomConnections
        {
            get { return fixedRoomConnections; }
            set { fixedRoomConnections = value; }
        }

        [SerializeField]
        HashSet<int> adjacentCells = new HashSet<int>();
        public HashSet<int> AdjacentCells
        {
            get
            {
                return adjacentCells;
            }
            set
            {
                adjacentCells = value;
            }
        }

        public IntVector Center
        {
            get
            {
                return new IntVector(bounds.X + bounds.Width / 2, 0, bounds.Z + bounds.Length / 2);
            }
        }

        public Vector3 CenterF
        {
            get
            {
                return new Vector3(bounds.X + bounds.Width / 2.0f, bounds.Location.y, bounds.Z + bounds.Length / 2.0f);
            }
        }

        public override bool Equals(System.Object obj)
        {
            if (obj == null) return false;
            if (obj is Cell)
            {
                var cell = obj as Cell;
                return this.Id == cell.Id;
            }
            return false;
        }
        public override int GetHashCode()
        {
            return id;
        }
    }

    /// <summary>
    /// Data-structure to hold the door information
    /// </summary>
    [Serializable]
    public class CellDoor
    {
        [SerializeField]
        IntVector[] adjacentTiles = new IntVector[2];

        /// <summary>
        /// The adjacent tile positions shared by this door (entry / exit tiles)
        /// </summary>
        public IntVector[] AdjacentTiles
        {
            get
            {
                return adjacentTiles;
            }
        }


        [SerializeField]
        bool enabled = true;
        public bool Enabled
        {
            get { return enabled; }
            set { enabled = value; }
        }

        /// <summary>
        /// Cell Ids of one of the cells that owns this door
        /// </summary>
        [SerializeField]
        int[] adjacentCells = new int[2];
        public int[] AdjacentCells
        {
            get
            {
                return adjacentCells;
            }
            set
            {
                adjacentCells = value;
            }
        }


        public override string ToString()
        {
            return string.Format("[CellDoor: {0} <=> {1}]", AdjacentCells[0], AdjacentCells[1]);
        }
    }

    /// <summary>
    /// Data-structure for IntVector pair. Used for caching
    /// </summary>
    [Serializable]
    public struct IntVector2Key
    {
        [SerializeField]
        public IntVector a;

        [SerializeField]
        public IntVector b;

        public IntVector2Key(IntVector a, IntVector b)
        {
            this.a = a;
            this.b = b;
        }

        public override bool Equals(System.Object obj)
        {
            if (obj != null && obj is IntVector2Key)
            {
                var other = (IntVector2Key)obj;
                return a.Equals(other.a) &&
                    b.Equals(other.b);
            }
            return false;
        }
        public override int GetHashCode()
        {
            return (a.GetHashCode() << 16) + b.GetHashCode();
        }
    }

    /// <summary>
    /// Manages the doors in the grid based builder
    /// </summary>
    [Serializable]
    public class DoorManager
    {
        [SerializeField]
        Dictionary<IntVector2Key, CellDoor> doorLookupCache = new Dictionary<IntVector2Key, CellDoor>();

        [SerializeField]
        List<CellDoor> doors = new List<CellDoor>();

        public void Clear()
        {
            doorLookupCache.Clear();
            doors.Clear();
        }

        public void RemoveDoor(CellDoor door)
        {
            var keysToRemove = new List<IntVector2Key>();
            foreach (var key in doorLookupCache.Keys)
            {
                if (doorLookupCache[key] == door)
                {
                    keysToRemove.Add(key);
                }
            }

            foreach (var key in keysToRemove)
            {
                doorLookupCache.Remove(key);
            }
            doors.Remove(door);
        }

        /// <summary>
        /// Creates a door between the two grid points
        /// </summary>
        /// <param name="p1">The grid poition 1</param>
        /// <param name="p2">The grid poition 2</param>
        /// <param name="cellId1">Cell Id of the first adjacent cell</param>
        /// <param name="cellId2">Cell Id of the second adjacent cell</param>
        /// <returns></returns>
        public CellDoor CreateDoor(IntVector p1, IntVector p2, int cellId1, int cellId2)
        {
            var key1 = new IntVector2Key(p1, p2);
            if (doorLookupCache.ContainsKey(key1)) return doorLookupCache[key1];
            var key2 = new IntVector2Key(p2, p1);
            if (doorLookupCache.ContainsKey(key2)) return doorLookupCache[key2];

            // Create a new door
            var door = new CellDoor();
            door.AdjacentTiles[0] = new IntVector(p1.x, p1.y, p1.z);
            door.AdjacentTiles[1] = new IntVector(p2.x, p2.y, p2.z);

            door.AdjacentCells[0] = cellId1;
            door.AdjacentCells[1] = cellId2;

            // Add to the memo lookup
            doorLookupCache.Add(key1, door);
            doorLookupCache.Add(key2, door);

            doors.Add(door);
            return door;
        }

        /// <summary>
        /// Check if a door exists between the two cells 
        /// </summary>
        /// <param name="cellA">Cell Id of the first cell</param>
        /// <param name="cellB">Cell Id of the second cell</param>
        /// <returns></returns>
        public bool ContainsDoorBetweenCells(int cellA, int cellB)
        {
            foreach (var door in doors)
            {
                if (!door.Enabled)
                {
                    continue;
                }
                if ((door.AdjacentCells[0] == cellA && door.AdjacentCells[1] == cellB) ||
                        (door.AdjacentCells[0] == cellB && door.AdjacentCells[1] == cellA))
                {
                    return true;
                }
            }
            return false;
        }

		public bool ContainsDoor(int x1, int z1, int x2, int z2) {
			foreach (var door in doors) {
                if (!door.Enabled) { continue; }
				var containsDoor = 
						door.AdjacentTiles[0].x == x1 && door.AdjacentTiles[0].z == z1 &&
						door.AdjacentTiles[1].x == x2 && door.AdjacentTiles[1].z == z2;
				if (containsDoor) {
					return true;
				}

				containsDoor = 
						door.AdjacentTiles[1].x == x1 && door.AdjacentTiles[1].z == z1 &&
						door.AdjacentTiles[0].x == x2 && door.AdjacentTiles[0].z == z2;
				if (containsDoor) {
					return true;
				}
			}
			return false;
		}

        /// <summary>
        /// List of registered doors
        /// </summary>
        public CellDoor[] Doors
        {
            get
            {
                return doors.ToArray();
            }
        }
    }


    /// <summary>
    /// Data model for the grid based dungeon builder
	/// </summary>
	//[System.Serializable]
    public class GridDungeonModel : DungeonModel
    {
		[HideInInspector]
        [SerializeField]
        public DoorManager DoorManager = new DoorManager();
        
        [HideInInspector]
        public GridDungeonConfig Config;
        
        [SerializeField]
        [HideInInspector]
        public List<Cell> Cells = new List<Cell>();
		
		[HideInInspector]
        [SerializeField]
        public Dictionary<int, List<StairInfo>> CellStairs = new Dictionary<int, List<StairInfo>>();

        [HideInInspector]
        public Dictionary<int, Dictionary<int, GridCellInfo>> GridCellInfoLookup = new Dictionary<int, Dictionary<int, GridCellInfo>>();

        /// <summary>
        /// Get meta-data about the grid in x, z grid coordinate
        /// </summary>
        /// <param name="x">X value in grid coordinate</param>
        /// <param name="z">Z value in grid cooridnate</param>
        /// <returns></returns>
        public GridCellInfo GetGridCellLookup(int x, int z)
        {
            if (!GridCellInfoLookup.ContainsKey(x) || !GridCellInfoLookup[x].ContainsKey(z))
            {
                return new GridCellInfo();
            }
            return GridCellInfoLookup[x][z];
        }

        /// <summary>
        /// Builds a lookup for fast data retrieval
        /// </summary>
        public void BuildSpatialCellLookup()
        {
            // Cache the cell types based on their positions
            GridCellInfoLookup.Clear();
            foreach (var cell in Cells)
            {
                if (cell.CellType == CellType.Unknown) continue;
                IntVector basePosition = cell.Bounds.Location;
                for (int dx = 0; dx < cell.Bounds.Size.x; dx++)
                {
                    for (int dz = 0; dz < cell.Bounds.Size.z; dz++)
                    {
                        int x = basePosition.x + dx;
                        int z = basePosition.z + dz;

                        // register the cell type in the lookup
                        if (!GridCellInfoLookup.ContainsKey(x)) GridCellInfoLookup.Add(x, new Dictionary<int, GridCellInfo>());
                        if (!GridCellInfoLookup[x].ContainsKey(z))
                        {
                            GridCellInfoLookup[x].Add(z, new GridCellInfo(cell.Id, cell.CellType));
                        }
                    }
                }
            }
        }

        /// <summary>
        /// The list of registered doors
        /// </summary>
        public CellDoor[] Doors
        {
            get
            {
                return DoorManager.Doors;
            }
        }

        /// <summary>
        /// Builds the cell lookup for faster cell retrieval
        /// </summary>
        public void BuildCellLookup()
        {
            CellLookup.Clear();
            foreach (var cell in Cells)
            {
                CellLookup.Add(cell.Id, cell);
            }
        }

        /// <summary>
        /// Gets the cell information
        /// </summary>
        /// <param name="Id">Id of the cell to lookup</param>
        /// <returns></returns>
        public Cell GetCell(int Id)
        {
            return CellLookup.ContainsKey(Id) ? CellLookup[Id] : null;
        }

        /// <summary>
        /// Cell lookup based on the Cell Id
        /// </summary>
        public Dictionary<int, Cell> CellLookup = new Dictionary<int, Cell>();

        /// <summary>
        /// Finds the cell based on the position in grid coordinates
        /// </summary>
        /// <param name="position">Position to lookup in grid cooridnates</param>
        /// <returns>Cell information at that location.  Returns null if none found</returns>
        public Cell FindCellByPosition(IntVector position)
        {
            foreach (var cell in Cells)
            {
                if (cell.Bounds.Contains(position))
                {
                    return cell;
                }
            }
            return null;
        }

        /// <summary>
        /// Clears the dungeon data model
        /// </summary>
        public override void ResetModel()
        {
            DoorManager = new DoorManager();
            Config = null;
            Cells = new List<Cell>();
            CellStairs.Clear();
        }

        public bool ContainsStairAtLocation(int x, int z)
        {
            foreach (var stairList in CellStairs.Values) {
                foreach (var stair in stairList) {
                    if (stair.IPosition.x == x && stair.IPosition.z == z) {
                        return true;
                    }
                }
            }
            return false;
        }

		public StairInfo GetStairAtLocation(int x, int z) {
			foreach (var stairList in CellStairs.Values) {
				foreach (var stair in stairList) {
					if (stair.IPosition.x == x && stair.IPosition.z == z) {
						return stair;
					}
				}
			}
			return null;
		}

        /// <summary>
        /// Check if a stair exists between the two cells
        /// </summary>
        /// <param name="cellA"></param>
        /// <param name="cellB"></param>
        /// <returns></returns>
        public bool ContainsStair(int cellA, int cellB)
        {
            return CheckContainStair(cellA, cellB) || CheckContainStair(cellB, cellA);
        }
        bool CheckContainStair(int cellA, int cellB)
        {
            if (!CellStairs.ContainsKey(cellA)) return false;

            foreach (var stair in CellStairs[cellA])
            {
                if (stair.ConnectedToCell == cellB) return true;
            }
            return false;
        }
    }

	public class GridDungeonModelUtils {
		struct LongestPathBFSData {
			public Cell cell;
			public int distance;
		}

        public static Cell[] FindFurthestRooms(GridDungeonModel model)
        {
            return FindFurthestRooms(model, CellType.Room, CellType.Room);
        }

        public static Cell[] FindFurthestRooms(GridDungeonModel model, CellType startCellType, CellType endCellType) {
			var result = new Cell[2];
            var bestDistance = 0;
			foreach (var startCell in model.Cells) {
                if (startCell.CellType != startCellType)
                {
                    continue;
                }
				var queue = new Queue<LongestPathBFSData>();
				var startData = new LongestPathBFSData { cell = startCell, distance = 0 };
				queue.Enqueue(startData);
                LongestPathBFSData bestEndCell = startData;
                var cellDistances = new Dictionary<int, int>();    // CellId -> Distance mapping
                
				while (queue.Count > 0) {
					var front = queue.Dequeue();
                    if (front.cell == null) continue;

                    var processCell = false;
                    if (!cellDistances.ContainsKey(front.cell.Id))
                    {
                        // We never processed this cell
                        processCell = true;
                    }
                    else if (cellDistances[front.cell.Id] > front.distance)
                    {
                        // We found a shorter path to this cell
                        processCell = true;
                    }

                    if (processCell)
                    {
                        cellDistances[front.cell.Id] = front.distance;
                        foreach (var childId in front.cell.AdjacentCells) {
                            var child = model.GetCell(childId);
                            var childData = new LongestPathBFSData { cell = child, distance = front.distance + 1 };
                            queue.Enqueue(childData);
                        }
                    }

                    if (front.cell.CellType == endCellType && front.distance > bestEndCell.distance)
                    {
                        bestEndCell = front;
                    }
				}

                if (bestEndCell.distance > bestDistance)
                {
                    result[0] = startData.cell;
                    result[1] = bestEndCell.cell;
                    bestDistance = bestEndCell.distance;
                }
			}

			return result;
		}
	}

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\GridDungeonToolData.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Builders.Grid
{
    public class GridDungeonToolData : DungeonToolData
    {
        // The cells painted by the "Paint" tool
        [SerializeField]
        [HideInInspector]
        public List<IntVector> paintedCells = new List<IntVector>();
        
        

        /// <summary>
        /// Registers a painted cell. Returns true if state was modified
        /// </summary>
        /// <param name="location">the location of the painted cell, in grid cooridnates</param>
        /// <param name="automaticRebuild">if true, the dungeon would be rebuilt, if the data model has changed due to this request</param>
		public bool AddPaintCell(IntVector location) {
			bool overlappingCell = false;
			IntVector overlappingCellValue = new IntVector();
			foreach (var cellData in paintedCells) {
				if (cellData.x == location.x && cellData.z == location.z) {
					if (cellData.y != location.y) {
						overlappingCell = true;
						overlappingCellValue = cellData;
						break;
					}
					else {
						// Cell with this data already exists.  Ignore the request
						return false;
					}
				}
			}
			if (overlappingCell) {
				paintedCells.Remove(overlappingCellValue);
			}

			paintedCells.Add(location);
			return true;
        }
        
        /// <summary>
        /// Remove a previous painted cell. Returns true if state was modified
        /// </summary>
        /// <param name="location">the location of the painted cell to remove, in grid cooridnates</param>
        /// <param name="automaticRebuild">if true, the dungeon would be rebuilt, if the data model has changed due to this request</param>
        public bool RemovePaintCell(IntVector location)
        {
	        if (paintedCells.Contains(location)) {
		        paintedCells.Remove(location);
		        return true;
	        }
	        return false;
        }


        /// <summary>
        /// Clears all overlay data
        /// </summary>
        /// <param name="automaticRebuild"></param>
        public bool ClearToolOverlayData()
        {
	        var stateModified = paintedCells.Count > 0;
			paintedCells.Clear();
			return stateModified;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\GridFlow\GridFlowDungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using DungeonArchitect.Utils;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.MarkerGenerator.Processor;
using DungeonArchitect.MarkerGenerator.Processor.Grid;

namespace DungeonArchitect.Builders.GridFlow
{
    public class GridFlowDungeonBuilder : DungeonBuilder
    {
        private GridFlowDungeonConfig gridFlowConfig;
        private GridFlowDungeonModel gridFlowModel;
        protected FlowExecNodeOutputRegistry execNodeOutputRegistry = null;
        public FlowExecNodeOutputRegistry ExecNodeOutputRegistry
        {
            get
            {
                return execNodeOutputRegistry;
            }
        }

        public override void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            gridFlowConfig = config as GridFlowDungeonConfig;
            gridFlowModel = model as GridFlowDungeonModel;

            if (gridFlowConfig.flowAsset == null)
            {
                Debug.LogError("Missing grid flow asset");
                return;
            }

            base.BuildDungeon(config, model);

            GenerateLevelLayout();

            var minimap = GetComponent<GridFlowMinimap>();
            if (minimap != null && minimap.initMode == GridFlowMinimapInitMode.OnDungeonRebuild)
            {
                minimap.Initialize();
            }
        }

        public override void EmitMarkers()
        {
            base.EmitMarkers();

            EmitLevelMarkers();

            ProcessMarkerOverrideVolumes();
        }

        void GenerateLevelLayout()
        {
            if (gridFlowConfig == null || gridFlowModel == null || gridFlowConfig.flowAsset == null)
            {
                return;
            }

            gridFlowModel.Reset();

            var execGraph = gridFlowConfig.flowAsset.execGraph;
            var random = new System.Random((int)gridFlowConfig.Seed);
            var domainExtensions = new FlowDomainExtensions();

            FlowExecutor executor = new FlowExecutor();
            if (!executor.Execute(execGraph, random, domainExtensions,gridFlowConfig.numGraphRetries, out execNodeOutputRegistry))
            {
                Debug.LogError("Failed to generate level layout. Please check your grid flow graph. Alternatively, increase the 'Num Graph Retries' parameter in the config");
            }
            else
            {
                var resultNode = execGraph.resultNode;
                var execState = execNodeOutputRegistry.Get(resultNode.Id);

                var layoutGraph = execState.State.GetState<FlowLayoutGraph>();
                var tilemap = execState.State.GetState<FlowTilemap>();
                
                var tilemapState = execState.State.GetState<GridFlowTilemapState>();
                if (tilemapState != null)
                {
                    gridFlowModel.wallsAsEdges = (tilemapState.WallGenerationMethod == TilemapFlowNodeWallGenerationMethod.WallAsEdges);
                }

                if (layoutGraph == null || tilemap == null)
                {
                    Debug.Log("Failed to generate grid flow tilemap");
                    return;
                }
                
                gridFlowModel.Initialize(layoutGraph, tilemap, gridFlowConfig.gridSize);
            }
        }

        bool IsCellOfType(FlowTilemap tilemap, int x, int y, FlowTilemapCellType[] types)
        {
            var cell = tilemap.Cells.GetCell(x, y);
            if (cell == null) return false;
            return types.Contains(cell.CellType);
        }

        class LayoutGraphLookup
        {
            private Dictionary<IntVector2, FlowLayoutGraphNode> nodesByCoord = new Dictionary<IntVector2, FlowLayoutGraphNode>();
            public LayoutGraphLookup(FlowLayoutGraph layoutGraph)
            {
                foreach (var node in layoutGraph.Nodes)
                {
                    if (node.active)
                    {
                        var coord = new IntVector2(
                            Mathf.RoundToInt(node.coord.x),
                            Mathf.RoundToInt(node.coord.y));
                        nodesByCoord[coord] = node;
                    }
                }
            }

            public FlowLayoutGraphNode GetNode(IntVector2 coord)
            {
                return nodesByCoord.ContainsKey(coord) ? nodesByCoord[coord] : null;
            }
        }
        
        GridFlowLayoutNodeRoomType GetCellRoomType(FlowTilemap tilemap, int x, int y, LayoutGraphLookup layoutGraphLookup)
        {
            var cell = tilemap.Cells.GetCell(x, y);
            if (cell == null)
            {
                return GridFlowLayoutNodeRoomType.Unknown;
            }

            var layoutNode = layoutGraphLookup.GetNode(cell.NodeCoord);
            if (layoutNode == null)
            {
                return GridFlowLayoutNodeRoomType.Unknown;
            }
            
            var domainData = layoutNode.GetDomainData<GridFlowTilemapDomainData>();
            return domainData.RoomType;
        }

        Quaternion GetBaseRotation(FlowTilemap tilemap, int x, int y)
        {
            var cellTypesToTransform = new FlowTilemapCellType[]
            {
                FlowTilemapCellType.Wall,
                FlowTilemapCellType.Door
            };

            var cell = tilemap.Cells[x, y];
            if (!cellTypesToTransform.Contains(cell.CellType))
            {
                return Quaternion.identity;
            }

            var validL = IsCellOfType(tilemap, x - 1, y, cellTypesToTransform);
            var validR = IsCellOfType(tilemap, x + 1, y, cellTypesToTransform);
            var validB = IsCellOfType(tilemap, x, y - 1, cellTypesToTransform);
            var validT = IsCellOfType(tilemap, x, y + 1, cellTypesToTransform);

            var angleY = 0;
            if (validL && validR)
            {
                angleY = validT ? 180 : 0;
            }
            else if (validT && validB)
            {
                angleY = validR ? 270 : 90;
            }
            else if (validL && validT) angleY = 180;
            else if (validL && validB) angleY = 90;
            else if (validR && validT) angleY = 270;
            else if (validR && validB) angleY = 0;

            return Quaternion.Euler(0, angleY, 0);
        }


        Matrix4x4 GetBaseTransform()
        {
            return Matrix4x4.TRS(transform.position, Quaternion.identity, Vector3.one);
        }

        public override IMarkerGenProcessor CreateMarkerGenProcessor()
        {
            var query = GetComponent<DungeonQuery>();
            return new GridMarkerGenProcessor(GetBaseTransform(), gridFlowConfig.gridSize, this, model, config, query);
        }
        
        string GetEdgeMarkerName(FlowTilemapEdgeType edgeType)
        {
            if (edgeType == FlowTilemapEdgeType.Wall) return GridFlowDungeonMarkerNames.Wall;
            else if (edgeType == FlowTilemapEdgeType.Fence) return GridFlowDungeonMarkerNames.Fence;
            else if (edgeType == FlowTilemapEdgeType.Door)
            {
                return GridFlowDungeonMarkerNames.Door;
            }
            else
            {
                return "[Empty]";
            }
        }

        protected override LevelMarkerList CreateMarkerListObject(DungeonConfig config)
        {
            var flowConfig = config as GridFlowDungeonConfig;
            if (flowConfig != null)
            {
                var bucketSize = Mathf.Max(flowConfig.gridSize.x, flowConfig.gridSize.z) * 2;
                bucketSize = Mathf.Max(0.1f, bucketSize);
                return new SpatialPartionedLevelMarkerList(bucketSize);
            }
            else
            {
                return base.CreateMarkerListObject(config);
            }
        }

        bool CreateLockItemMetadata(FlowItem item, ref string doorMarker, out FlowItemMetadata lockItemData)
        {
            if (item != null && item.type == FlowGraphItemType.Lock)
            {
                // Turn this into a locked door (lock marker will be spawned instead of a door (or a one way door)
                doorMarker = item.markerName;

                lockItemData = new FlowItemMetadata();
                lockItemData.itemId = item.itemId;
                lockItemData.itemType = item.type;
                lockItemData.referencedItems = new List<DungeonUID>(item.referencedItemIds).ToArray();
                return true;
            }
            else
            {
                lockItemData = null;
                return false;
            }
        }

        bool ChunkSupportsWalls(GridFlowLayoutNodeRoomType type)
        {
            return type == GridFlowLayoutNodeRoomType.Room || type == GridFlowLayoutNodeRoomType.Corridor;
        }
        
        
        void EmitLevelMarkers()
        {
            if (gridFlowConfig == null || gridFlowModel == null || gridFlowModel.LayoutGraph == null)
            {
                Debug.LogError("GridFlowBuilder: Invalid state");
                return;
            }

            var items = gridFlowModel.LayoutGraph.GetAllItems();
            var itemMap = new Dictionary<DungeonUID, FlowItem>();
            foreach (var item in items)
            {
                itemMap[item.itemId] = item;
            }

            var tilemap = gridFlowModel.Tilemap;
            if (tilemap == null)
            {
                return;
            }

            var basePosition = transform.position;
            var gridSize = gridFlowConfig.gridSize;
            // Emit the cell markers
            for (int x = 0; x < tilemap.Width; x++)
            {
                for (int y = 0; y < tilemap.Height; y++)
                {
                    var position = basePosition + Vector3.Scale(new Vector3(x + 0.5f, 0, y + 0.5f), gridSize);
                    var baseRotation = GetBaseRotation(tilemap, x, y);
                    var markerTransform = Matrix4x4.TRS(position, baseRotation, Vector3.one);
                    var cell = tilemap.Cells[x, y];
                    int cellId = tilemap.Width * y + x;

                    if (cell.Item != DungeonUID.Empty && itemMap.ContainsKey(cell.Item))
                    {
                        var item = itemMap[cell.Item];
                        if (item.markerName != null && item.markerName.Length > 0 && item.type != FlowGraphItemType.Lock)
                        {
                            // Emit this item
                            var itemData = new FlowItemMetadata();
                            itemData.itemId = item.itemId;
                            itemData.itemType = item.type;
                            itemData.referencedItems = new List<DungeonUID>(item.referencedItemIds).ToArray();

                            EmitMarker(item.markerName, markerTransform, new IntVector(x, 0, y), cellId, itemData);
                        }
                    }

                    bool removeElevationMarker = false;
                    if (cell.Overlay != null && cell.Overlay.markerName != null)
                    {
                        var heightOffset = 0.0f;
                        if (cell.Overlay.mergeConfig != null)
                        {
                            heightOffset += cell.LayoutCell
                                ? cell.Overlay.mergeConfig.markerHeightOffsetForLayoutTiles
                                : cell.Overlay.mergeConfig.markerHeightOffsetForNonLayoutTiles;
                        }

                        var height = cell.Height;
                        var overlayPosition = basePosition + Vector3.Scale(new Vector3(x + 0.5f, height + heightOffset, y + 0.5f), gridSize);
                        var overlayMarkerTransform = Matrix4x4.TRS(overlayPosition, Quaternion.identity, Vector3.one);
                        EmitMarker(cell.Overlay.markerName, overlayMarkerTransform, new IntVector(x, 0, y), cellId);

                        if (cell.Overlay.mergeConfig != null)
                        {
                            removeElevationMarker = cell.Overlay.mergeConfig.removeElevationMarker;
                        }
                    }

                    switch (cell.CellType)
                    {
                        case FlowTilemapCellType.Floor:
                            EmitMarker(GridFlowDungeonMarkerNames.Ground, markerTransform, new IntVector(x, 0, y), cellId);
                            break;

                        case FlowTilemapCellType.Wall:
                            EmitMarker(GridFlowDungeonMarkerNames.Wall, markerTransform, new IntVector(x, 0, y), cellId);
                            EmitMarker(GridFlowDungeonMarkerNames.Ground, markerTransform, new IntVector(x, 0, y), cellId);
                            break;

                        case FlowTilemapCellType.Door:
                            {
                                var doorMarker = GridFlowDungeonMarkerNames.Door;
                                var doorData = cell.Userdata as FlowTilemapCellDoorInfo;
                                if (doorData != null && doorData.oneWay)
                                {
                                    // One way door
                                    doorMarker = GridFlowDungeonMarkerNames.DoorOneWay;

                                    // Apply the correct one-way direction
                                    var flipDirection = (doorData.nodeA.x > doorData.nodeB.x) || (doorData.nodeA.y > doorData.nodeB.y);
                                    if (!flipDirection)
                                    {
                                        var doorRotation = baseRotation * Quaternion.Euler(0, 180, 0);
                                        markerTransform = Matrix4x4.TRS(position, doorRotation, Vector3.one);
                                    }
                                }

                                FlowItemMetadata lockItemData = null;
                                if (cell.Item != DungeonUID.Empty && itemMap.ContainsKey(cell.Item))
                                {
                                    var item = itemMap[cell.Item];
                                    CreateLockItemMetadata(item, ref doorMarker, out lockItemData);
                                }

                                EmitMarker(doorMarker, markerTransform, new IntVector(x, 0, y), cellId, lockItemData);
                                EmitMarker(GridFlowDungeonMarkerNames.Ground, markerTransform, new IntVector(x, 0, y), cellId);
                            }
                            break;

                        case FlowTilemapCellType.Custom:
                            if (cell.CustomCellInfo != null && !removeElevationMarker)
                            {
                                var markerName = cell.CustomCellInfo.name;
                                var height = cell.Height;
                                var customPosition = basePosition + Vector3.Scale(new Vector3(x + 0.5f, height, y + 0.5f), gridSize);
                                var customMarkerTransform = Matrix4x4.TRS(customPosition, Quaternion.identity, Vector3.one);

                                EmitMarker(markerName, customMarkerTransform, new IntVector(x, 0, y), cellId);
                            }
                            break;

                    }
                }
            }

            // Emit the edge markers
            {

                var walkableCellTypes = new FlowTilemapCellType[]
                {
                    FlowTilemapCellType.Floor,
                    FlowTilemapCellType.Wall,
                    FlowTilemapCellType.Door
                };

                var wallSeparators = new HashSet<IntVector2>();
                var fenceSeparators = new HashSet<IntVector2>();

                var layoutGraphLookup = new LayoutGraphLookup(gridFlowModel.LayoutGraph);
                
                foreach (var edge in tilemap.Edges)
                {
                    var coord = edge.EdgeCoord;
                    var isGroundTile = IsCellOfType(tilemap, coord.x, coord.y, walkableCellTypes);
                    var roomType = GetCellRoomType(tilemap, coord.x, coord.y, layoutGraphLookup);

                    if (edge.EdgeType == FlowTilemapEdgeType.Empty) continue;

                    Vector3 position;
                    float angle;
                    if (edge.HorizontalEdge)
                    {
                        position = basePosition + Vector3.Scale(new Vector3(coord.x + 0.5f, 0, coord.y), gridSize);
                        angle = isGroundTile ? 0 : 180;
                        if (isGroundTile && edge.EdgeType == FlowTilemapEdgeType.Wall)
                        {
                            var roomTypeBelow = GetCellRoomType(tilemap, coord.x, coord.y - 1, layoutGraphLookup);
                            if (!ChunkSupportsWalls(roomType) && ChunkSupportsWalls(roomTypeBelow))
                            {
                                angle += 180;
                            }
                        }
                    }
                    else
                    {
                        position = basePosition + Vector3.Scale(new Vector3(coord.x, 0, coord.y + 0.5f), gridSize);
                        angle = isGroundTile ? 90 : 270;
                        if (isGroundTile && edge.EdgeType == FlowTilemapEdgeType.Wall)
                        {
                            var roomTypeLeft = GetCellRoomType(tilemap, coord.x - 1, coord.y, layoutGraphLookup);
                            if (!ChunkSupportsWalls(roomType) && ChunkSupportsWalls(roomTypeLeft))
                            {
                                angle += 180;
                            }
                        }
                    }

                    if (gridFlowConfig.flipEdgeWalls)
                    {
                        if (edge.EdgeType == FlowTilemapEdgeType.Wall || edge.EdgeType == FlowTilemapEdgeType.Fence)
                        {
                            angle += 180;
                        }
                    }
                    
                    var baseRotation = Quaternion.Euler(0, angle, 0);
                    var markerTransform = Matrix4x4.TRS(position, baseRotation, Vector3.one);

                    bool supportedMarker = true;
                    var markerName = "";
                    FlowItemMetadata itemMetadata = null;
                    if (edge.EdgeType == FlowTilemapEdgeType.Wall)
                    {
                        markerName = GridFlowDungeonMarkerNames.Wall;

                        wallSeparators.Add(coord);
                        if (edge.HorizontalEdge)
                        {
                            wallSeparators.Add(coord + new IntVector2(1, 0));
                        }
                        else
                        {
                            wallSeparators.Add(coord + new IntVector2(0, 1));
                        }
                    }
                    else if (edge.EdgeType == FlowTilemapEdgeType.Fence)
                    {
                        markerName = GridFlowDungeonMarkerNames.Fence;

                        fenceSeparators.Add(coord);
                        if (edge.HorizontalEdge)
                        {
                            fenceSeparators.Add(coord + new IntVector2(1, 0));
                        }
                        else
                        {
                            fenceSeparators.Add(coord + new IntVector2(0, 1));
                        }
                    }
                    else if (edge.EdgeType == FlowTilemapEdgeType.Door)
                    {
                        markerName = GridFlowDungeonMarkerNames.Door;
                        var doorData = edge.Userdata as FlowTilemapCellDoorInfo;
                        if (doorData != null && doorData.oneWay)
                        {
                            // One way door
                            markerName = GridFlowDungeonMarkerNames.DoorOneWay;

                            // Apply the correct one-way direction
                            var flipDirection = (doorData.nodeA.x > doorData.nodeB.x) || (doorData.nodeA.y > doorData.nodeB.y);
                            if (!flipDirection)
                            {
                                var doorRotation = baseRotation * Quaternion.Euler(0, 180, 0);
                                markerTransform = Matrix4x4.TRS(position, doorRotation, Vector3.one);
                            }
                        }

                        if (edge.Item != DungeonUID.Empty && itemMap.ContainsKey(edge.Item))
                        {
                            var item = itemMap[edge.Item];
                            CreateLockItemMetadata(item, ref markerName, out itemMetadata);
                        }
                    }
                    else
                    {
                        supportedMarker = false;
                    }

                    if (supportedMarker)
                    {
                        EmitMarker(markerName, markerTransform, new IntVector(coord.x, 0, coord.y), 0, itemMetadata);
                    }
                }

                // Emit wall separator markers
                foreach (var gridCoord in wallSeparators)
                {
                    var position = basePosition + Vector3.Scale(new Vector3(gridCoord.x, 0, gridCoord.y), gridSize);
                    var markerTransform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
                    EmitMarker(GridFlowDungeonMarkerNames.WallSeparator, markerTransform, new IntVector(gridCoord.x, 0, gridCoord.y), 0);
                }

                // Emit fence separator markers
                foreach (var gridCoord in fenceSeparators)
                {
                    if (wallSeparators.Contains(gridCoord)) continue;

                    var position = basePosition + Vector3.Scale(new Vector3(gridCoord.x, 0, gridCoord.y), gridSize);
                    var markerTransform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
                    EmitMarker(GridFlowDungeonMarkerNames.FenceSeparator, markerTransform, new IntVector(gridCoord.x, 0, gridCoord.y), 0);
                }
            }
        }

        public override void DebugDraw()
        {
            
        }
    }

    public static class GridFlowDungeonMarkerNames
    {
        public static readonly string Ground = "Ground";
        public static readonly string Wall = "Wall";
        public static readonly string WallSeparator = "WallSeparator";
        public static readonly string Fence = "Fence";
        public static readonly string FenceSeparator = "FenceSeparator";
        public static readonly string Door = "Door";
        public static readonly string DoorOneWay = "DoorOneWay";

    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\GridFlow\GridFlowDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Impl.GridFlow;
using UnityEngine;

namespace DungeonArchitect.Builders.GridFlow
{
    public class GridFlowDungeonConfig : DungeonConfig
    {
        public GridFlowAsset flowAsset;
        public Vector3 gridSize = new Vector3(4, 4, 4);
        
        [Tooltip(@"If the flow graph cannot converge to a solution, retry again this many times.  Usually a dungeon converges within 1-10 tries, depending on how you've designed the flow graph")]
        public int numGraphRetries = 100;
        
        public bool Mode2D = false;

        // Advanced properties
        [Tooltip(@"If using Walls as Edges, rotates the walls by 180 along Y to make your grid builder themes work consistently with this grid flow builder")]
        public bool flipEdgeWalls = false;
        
        public override bool IsMode2D()
        {
            return Mode2D;
        }
        
        public override bool HasValidConfig(ref string errorMessage)
        {
            if (flowAsset == null)
            {
                errorMessage = "Flow Asset is not assign in the configuration";
                return false;
            }
            return true;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\GridFlow\GridFlowDungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.GridFlow
{
    public class GridFlowDungeonModel : DungeonModel
    {
        /// <summary>
        /// The high level node based layout graph
        /// </summary>
        [HideInInspector]
        [SerializeField]
        private FlowLayoutGraph layoutGraph;

        public FlowLayoutGraph LayoutGraph => layoutGraph;

        /// <summary>
        /// Rasterized tilemap representation of the abstract graph
        /// </summary>
        [HideInInspector]
        [SerializeField]
        private FlowTilemap tilemap;

        public FlowTilemap Tilemap => tilemap;
        
        /// <summary>
        /// The size of the grid this dungeon was built with
        /// </summary>
        [HideInInspector]
        [SerializeField]
        private Vector3 gridSize;
        
        /// <summary>
        /// Walls in the grid flow builder can either take up a full tile or are built as edges
        /// This is controlled from the "Initial Tilemap" node's property in the grid flow execution graph
        /// </summary>
        [HideInInspector]
        public bool wallsAsEdges = false;

        [HideInInspector]
        [SerializeField]
        private GridFlowDungeonQuery query;
        
        public GridFlowDungeonQuery Query { get => query; }
        
        public void Initialize(FlowLayoutGraph inLayoutGraph, FlowTilemap inTilemap, Vector3 inGridSize)
        {
            layoutGraph = inLayoutGraph;
            tilemap = inTilemap;
            gridSize = inGridSize;
            query = GetComponent<GridFlowDungeonQuery>();
            lookups.Build(this);
        }

        public void Reset()
        {
            layoutGraph = null;
            tilemap = null;
        }
        
        [HideInInspector]
        [SerializeField]
        GridFlowModelLookups lookups = new GridFlowModelLookups();

        public FlowTilemapCell GetTilemapCell(Vector3 worldPosition)
        {
            var tileCoord = WorldPositionToTilemapCoord(worldPosition);
            return tilemap.Cells.GetCell(tileCoord.x, tileCoord.y);
        }

        public FlowLayoutGraphNode GetLayoutNode(Vector3 worldPosition)
        {
            if (lookups == null) return null;
            
            var tile = GetTilemapCell(worldPosition);
            if (tile == null) return null;
            var nodeCoord = tile.NodeCoord;
            if (!lookups.NodeCoordLookup.ContainsKey(nodeCoord))
            {
                return null;
            }

            var nodeIndex = lookups.NodeCoordLookup[nodeCoord];
            return (nodeIndex >= 0 && nodeIndex < layoutGraph.Nodes.Count) 
                ? layoutGraph.Nodes[nodeIndex] 
                : null;
        }

        public GridFlowLayoutNodeRoomType GetRoomType(Vector3 worldPosition)
        {
            var layoutNode = GetLayoutNode(worldPosition);
            if (layoutNode != null)
            {
                var domainData = layoutNode.GetDomainData<GridFlowTilemapDomainData>();
                if (domainData != null)
                {
                    return domainData.RoomType;
                }
            }

            return GridFlowLayoutNodeRoomType.Unknown;
        }
        
        public IntVector2 WorldPositionToTilemapCoord(Vector3 worldPosition)
        {
            var basePosition = transform.position;
            var localWorld = worldPosition - basePosition;
            var localTileF = MathUtils.Divide(localWorld, gridSize);
            return new IntVector2(
                Mathf.FloorToInt(localTileF.x), 
                Mathf.FloorToInt(localTileF.z));
        }
    }
    
    [System.Serializable]
    public class GridFlowModelLookups : ISerializationCallbackReceiver
    {
        public Dictionary<IntVector2, int> NodeCoordLookup { get; } = new Dictionary<IntVector2, int>();

        public void Build(GridFlowDungeonModel model)
        {
            for (var i = 0; i < model.LayoutGraph.Nodes.Count; i++)
            {
                var node = model.LayoutGraph.Nodes[i];
                var coord = new IntVector2(
                    Mathf.RoundToInt(node.coord.x),
                    Mathf.RoundToInt(node.coord.y));
                NodeCoordLookup[coord] = i;
            }
        }
        
        #region Serialization
        [System.Serializable]
        struct SerializedNodeLookup
        {
            public IntVector2 coord;
            public int index;
        }

        [SerializeField]
        private SerializedNodeLookup[] serializedNodeCoordLookup;
        
        
        public void OnBeforeSerialize()
        {
            var serializedNodeLookupList = new List<SerializedNodeLookup>();
            foreach (var entry in NodeCoordLookup)
            {
                var lookup = new SerializedNodeLookup();
                lookup.coord = entry.Key;
                lookup.index = entry.Value;
                serializedNodeLookupList.Add(lookup);
            }

            serializedNodeCoordLookup = serializedNodeLookupList.ToArray();
        }

        public void OnAfterDeserialize()
        {
            NodeCoordLookup.Clear();
            if (serializedNodeCoordLookup != null)
            {
                foreach (var lookup in serializedNodeCoordLookup)
                {
                    NodeCoordLookup[lookup.coord] = lookup.index;
                }
            }
        }
        #endregion
        
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\GridFlow\GridFlowDungeonQuery.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Builders.GridFlow
{
    public class GridFlowDungeonQuery : DungeonQuery
    {
        private FlowTilemap tilemap;
        private FlowLayoutGraph graph;
        private Vector3 gridSize = Vector3.zero;

        Dictionary<IntVector2, FlowLayoutGraphNode> nodesByCoord = new Dictionary<IntVector2, FlowLayoutGraphNode>();
        Dictionary<IntVector2, List<FlowTilemapCell>> tilesByNode = new Dictionary<IntVector2, List<FlowTilemapCell>>();
        Dictionary<IntVector2, List<FlowTilemapCell>> freeTilesByNode = new Dictionary<IntVector2, List<FlowTilemapCell>>();

        public override void OnPostLayoutBuild()
        {
            var gridFlowModel = GetComponent<GridFlowDungeonModel>();
            if (gridFlowModel == null)
            {
                return;
            }

            var gridFlowConfig = GetComponent<GridFlowDungeonConfig>();
            if (gridFlowConfig == null)
            {
                return;
            }

            tilemap = gridFlowModel.Tilemap;
            graph = gridFlowModel.LayoutGraph;
            gridSize = gridFlowConfig.gridSize;

            GenerateTileLookup();
        }

        public override void Release()
        {
            tilemap = null;
            graph = null;
            nodesByCoord.Clear();
            tilesByNode.Clear();
            freeTilesByNode.Clear();
        }

        public bool IsMainPath(Vector3 worldPosition)
        {
            var layoutNode = WorldCoordToLayoutNode(worldPosition);
            return layoutNode != null && layoutNode.mainPath;
        }
        
        public GridFlowLayoutNodeRoomType GetRoomType(Vector3 worldPosition)
        {
            var layoutNode = WorldCoordToLayoutNode(worldPosition);
            GridFlowLayoutNodeRoomType roomType = GridFlowLayoutNodeRoomType.Unknown;

            if (layoutNode != null)
            {
                var domainData = layoutNode.GetDomainData<GridFlowTilemapDomainData>();
                if (domainData != null)
                {
                    roomType = domainData.RoomType;
                }
            }

            return roomType;
        }

        public string GetPathName(Vector3 worldPosition)
        {
            var layoutNode = WorldCoordToLayoutNode(worldPosition);
            return layoutNode != null ? layoutNode.pathName : "";
        }
        
        public bool GetPathInfo(Vector3 worldPosition, out string pathName, out int pathIndex, out int pathLength)
        {
            var layoutNode = WorldCoordToLayoutNode(worldPosition);
            if (layoutNode == null)
            {
                pathName = "";
                pathIndex = -1;
                pathLength = -1;
                return false;
            }

            pathName = layoutNode.pathName;
            pathIndex = layoutNode.pathIndex;
            pathLength = layoutNode.pathLength;
            return true;
        }
        
        public FlowLayoutGraphNode GetLayoutNode(IntVector2 layoutNodeCoord)
        {
            if (!nodesByCoord.ContainsKey(layoutNodeCoord)) return null;
            return nodesByCoord[layoutNodeCoord];
        }

        /// <summary>
        /// Get all the tiles that belong to the layout node
        /// </summary>
        /// <param name="layoutNodeCoord"></param>
        /// <param name="onlyFreeTiles">will return only walkable tiles that are free. Use false if you want to decorate everything, true for gameplay logic</param>
        /// <returns></returns>
        public FlowTilemapCell[] GetLayoutNodeTile(IntVector2 layoutNodeCoord, bool onlyFreeTiles)
        {
            Dictionary<IntVector2, List<FlowTilemapCell>> lookup = onlyFreeTiles ? freeTilesByNode : tilesByNode;
            return lookup.ContainsKey(layoutNodeCoord) ? lookup[layoutNodeCoord].ToArray() : new FlowTilemapCell[0];
        }

        public Vector3 TileCoordToWorldCoord(IntVector2 tileCoord)
        {
            var basePosition = transform.position;
            return basePosition + Vector3.Scale(new Vector3(tileCoord.x + 0.5f, 0, tileCoord.y + 0.5f), gridSize);
        }


        public FlowLayoutGraphNode WorldCoordToLayoutNode(Vector3 worldPosition)
        {
            var tile = WorldCoordToTile(worldPosition);
            if (tile == null) return null;

            return GetLayoutNode(tile.NodeCoord);
        }

        
        public FlowTilemapCell WorldCoordToTile(Vector3 worldPosition)
        {
            if (tilemap == null) return null;

            var basePosition = transform.position;
            var tileCoordF = (worldPosition - basePosition);

            var tileX = Mathf.FloorToInt(tileCoordF.x / gridSize.x);
            var tileY = Mathf.FloorToInt(tileCoordF.z / gridSize.z);

            return tilemap.Cells.GetCell(tileX, tileY);
        }

        void GenerateTileLookup()
        {
            foreach (var node in graph.Nodes)
            {
                var coord = GetNodeCoord(node);
                nodesByCoord[coord] = node;
            }

            foreach (var cell in tilemap.Cells)
            {
                if (cell.CellType == FlowTilemapCellType.Floor)
                {
                    var nodeCoord = cell.NodeCoord;
                    if (!freeTilesByNode.ContainsKey(nodeCoord))
                    {
                        freeTilesByNode.Add(nodeCoord, new List<FlowTilemapCell>());
                    }

                    if (cell.Item == DungeonUID.Empty)
                    {
                        freeTilesByNode[nodeCoord].Add(cell);
                    }

                    if (!tilesByNode.ContainsKey(nodeCoord))
                    {
                        tilesByNode.Add(nodeCoord, new List<FlowTilemapCell>());
                    }

                    tilesByNode[nodeCoord].Add(cell);
                }
            }

            // Filter walkable paths on the free tiles (some free tile patches may be blocked by overlays like tree lines)
            var nodeKeys = new List<IntVector2>(freeTilesByNode.Keys);
            foreach (var nodeCoord in nodeKeys)
            {
                freeTilesByNode[nodeCoord] = FilterWalkablePath(freeTilesByNode[nodeCoord]);
            }
        }

        List<FlowTilemapCell> FilterWalkablePath(List<FlowTilemapCell> cells)
        {
            var unreachable = new HashSet<IntVector2>();
            var cellsByCoord = new Dictionary<IntVector2, FlowTilemapCell>();

            foreach (var cell in cells)
            {
                unreachable.Add(cell.TileCoord);
                cellsByCoord[cell.TileCoord] = cell;
            }

            var queue = new Queue<FlowTilemapCell>();
            foreach (var cell in cells)
            {
                if (cell.MainPath)
                {
                    unreachable.Remove(cell.TileCoord);
                    queue.Enqueue(cell);
                }
            }

            var childOffsets = new int[]
            {
                -1, 0,
                1, 0,
                0, -1,
                0, 1
            };

            while (queue.Count > 0)
            {
                var cell = queue.Dequeue();
                var coord = cell.TileCoord;
                for (int i = 0; i < 4; i++)
                {
                    var cx = coord.x + childOffsets[i * 2 + 0];
                    var cy = coord.y + childOffsets[i * 2 + 1];
                    var childCoord = new IntVector2(cx, cy);
                    if (unreachable.Contains(childCoord))
                    {
                        var canTraverse = true;
                        var childCell = cellsByCoord[childCoord];
                        if (childCell.Overlay != null && childCell.Overlay.tileBlockingOverlay)
                        {
                            canTraverse = false;
                        }

                        if (canTraverse)
                        {
                            unreachable.Remove(childCoord);
                            queue.Enqueue(cellsByCoord[childCoord]);
                        }
                    }
                }
            }


            // Grab all the cells that are not in the unreachable list
            var result = new List<FlowTilemapCell>();

            foreach (var cell in cells)
            {
                if (!unreachable.Contains(cell.TileCoord))
                {
                    result.Add(cell);
                }
            }

            return result;
        }

        IntVector2 GetNodeCoord(FlowLayoutGraphNode node)
        {
            var coordF = node.coord;
            return new IntVector2(Mathf.RoundToInt(coordF.x), Mathf.RoundToInt(coordF.y));
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\InfinityCaves\InfinityCaveChunkBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.Infinity.Caves
{
	public static class InfinityCaveChunkMarkerNames
    {
        public static readonly string GroundBlock = "GroundBlock";
        public static readonly string WallBlock = "WallBlock";
        public static readonly string RockBlock = "RockBlock";
    }

	public class InfinityCaveChunkBuilder : DungeonBuilder {

        InfinityCaveChunkConfig chunkConfig;
        InfinityCaveChunkModel chunkModel;

		public override void BuildDungeon(DungeonConfig config, DungeonModel model)
		{
			base.BuildDungeon(config, model);

			chunkConfig = config as InfinityCaveChunkConfig;
			chunkModel = model as InfinityCaveChunkModel;
			chunkModel.Config = chunkConfig;

			// Generate the city layout and save it in a model.   No markers are emitted here. 
			GenerateLevelLayout();
		}
        
		public override void EmitMarkers()
		{
			base.EmitMarkers();

			EmitLevelMarkers();

			ProcessMarkerOverrideVolumes();
		}
        
		void GenerateLevelLayout()
        {
            int w = Mathf.RoundToInt(chunkConfig.chunkSize.x);
            int h = Mathf.RoundToInt(chunkConfig.chunkSize.z);

            var baseChunkCoord = MathUtils.ToIntVector(MathUtils.Divide(chunkConfig.chunkPosition, chunkConfig.chunkSize));
            var world = new bool[w * 3, h * 3];

            for (int cdx = -1; cdx <= 1; cdx++)
            {
                for (int cdz = -1; cdz <= 1; cdz++)
                {
                    var chunkCoord = baseChunkCoord + new IntVector(cdx, 0, cdz);
                    var chunkSeed = chunkCoord.GetHashCode();
                    var random = new System.Random(chunkSeed);
                    var sx = (cdx + 1) * w;
                    var sz = (cdz + 1) * h;
                    for (int x = sx; x < sx + w; x++)
                    {
                        for (int z = sz; z < sz + h; z++)
                        {
                            world[x, z] = random.NextFloat() < 0.5f;
                        }
                    }
                }
            }

            for (int i = 0; i < chunkConfig.iterations; i++)
            {
                world = ApplyAutomata(world);
            }

            chunkModel.tileStates = new MazeTileState[w, h];
            for (int x = 0; x < w; x++)
            {
                for (int y = 0; y < h; y++)
                {
                    bool occupied = world[w + x, h + y];
                    var cellType = occupied ? MazeTileState.Rock : MazeTileState.Empty;
                    if (occupied)
                    {
                        // Check if we have an empty space nearby so we can upgrade this to a wall
                        for (int dx = -1; dx <= 1; dx++)
                        {
                            for (int dy = -1; dy <= 1; dy++)
                            {
                                //if (dx == 0 && dy == 0) continue;
                                var cx = w + x + dx;
                                var cy = h + y + dy;
                                var neighborEmpty = !world[cx, cy];
                                if (neighborEmpty)
                                {
                                    cellType = MazeTileState.Wall;
                                    break;
                                }
                            }
                            if (cellType == MazeTileState.Wall) break;
                        }
                    }
                    chunkModel.tileStates[x, y] = cellType;
                }
            }
        }

        bool[,] ApplyAutomata(bool[,] world)
        {
            var w = world.GetLength(0);
            var h = world.GetLength(1);

            var result = new bool[w, h];
            for (int x = 0; x < w; x++)
            {
                for (int y = 0; y < h; y++)
                {
                    var rocks = 0;
                    for (int dx = -1; dx <= 1; dx++)
                    {
                        for (int dy = -1; dy <= 1; dy++)
                        {
                            var cx = Mathf.Clamp(x + dx, 0, w - 1);
                            var cy = Mathf.Clamp(y + dy, 0, w - 1);
                            if (world[cx, cy])
                            {
                                rocks++;
                            }
                        }
                    }
                    result[x, y] = (rocks >= chunkConfig.neighborRocks);
                }
            }
            return result;
        }

		void EmitLevelMarkers()
        {
            var gridSize = new Vector3(chunkConfig.gridSize.x, 0, chunkConfig.gridSize.y);
            int w = Mathf.RoundToInt(chunkConfig.chunkSize.x);
            int h = Mathf.RoundToInt(chunkConfig.chunkSize.z);
            int sx = Mathf.RoundToInt(chunkConfig.chunkPosition.x);
            int sz = Mathf.RoundToInt(chunkConfig.chunkPosition.z);

            for (int x = 0; x < w; x++)
            {
                for (int z = 0; z < h; z++)
                {
                    var position = Vector3.Scale(new Vector3(sx + x + 0.5f, 0, sz + z + 0.5f), gridSize);
                    var markerTransform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
                    string markerName = "";
                    var state = chunkModel.tileStates[x, z];
                    if (state == MazeTileState.Rock)
                    {
                        markerName = InfinityCaveChunkMarkerNames.RockBlock;
                    }
                    else if (state == MazeTileState.Wall)
                    {
                        markerName = InfinityCaveChunkMarkerNames.WallBlock;
                    }
                    else if (state == MazeTileState.Empty)
                    {
                        markerName = InfinityCaveChunkMarkerNames.GroundBlock;
                    }
                    EmitMarker(markerName, markerTransform, new IntVector(sx + x, 0, sz + z), -1);
                }
            }
        } 

	}
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\InfinityCaves\InfinityCaveChunkConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.Infinity.Caves
{
	public class InfinityCaveChunkConfig : InfinityDungeonConfig
    {
        public Vector2 gridSize = new Vector2(4, 4);
        public int iterations = 4;
        public int neighborRocks = 5;

        public override Vector3 GetLogicalCoord(Vector3 p)
        {
            return MathUtils.Divide(p, new Vector3(gridSize.x, 1, gridSize.y));
        }

        public override bool BuildAlongX() { return true; }
        public override bool BuildAlongY() { return false; }
        public override bool BuildAlongZ() { return true; }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\InfinityCaves\InfinityCaveChunkModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Infinity.Caves
{
	public enum MazeTileState {
		Empty,
        Rock,
        Wall
	}

	public class InfinityCaveChunkModel : DungeonModel {
		[HideInInspector]
		public InfinityCaveChunkConfig Config;

		[HideInInspector]
		public MazeTileState[,] tileStates;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Isaac\IsaacDungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Builders.Isaac
{
    public class IsaacDungeonBuilder : DungeonBuilder
    {

        IsaacDungeonConfig isaacConfig;
        IsaacDungeonModel isaacModel;

        new System.Random random;


        List<IsaacRoom> rooms = new List<IsaacRoom>();
        List<IsaacDoor> doors = new List<IsaacDoor>();

        /// <summary>
        /// Builds the dungeon layout.  In this method, you should build your dungeon layout and save it in your model file
        /// No markers should be emitted here.   (EmitMarkers function will be called later by the engine to do that)
        /// </summary>
        /// <param name="config">The builder configuration</param>
        /// <param name="model">The dungeon model that the builder will populate</param>
        public override void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            base.BuildDungeon(config, model);

            random = new System.Random((int)config.Seed);

            // We know that the dungeon prefab would have the appropriate config and models attached to it
            // Cast and save it for future reference
            isaacConfig = config as IsaacDungeonConfig;
            isaacModel = model as IsaacDungeonModel;
            isaacModel.config = isaacConfig;

            // Generate the city layout and save it in a model.   No markers are emitted here. 
            GenerateLevelLayout();
        }

        /// <summary>
        /// Override the builder's emit marker function to emit our own markers based on the layout that we built
        /// You should emit your markers based on the layout you have saved in the model generated previously
        /// When the user is designing the theme interactively, this function will be called whenever the graph state changes,
        /// so the theme engine can populate the scene (BuildDungeon will not be called if there is no need to rebuild the layout again)
        /// </summary>
        public override void EmitMarkers()
        {
            base.EmitMarkers();
            EmitLevelMarkers();
            ProcessMarkerOverrideVolumes();
        }

        struct LevelGrowthNode
        {
            public IsaacRoom room;
            public int moveDirection;
        }

        IntVector[] directions = new IntVector[] {
                new IntVector(1, 0, 0),
                new IntVector(0, 0, 1),
                new IntVector(-1, 0, 0),
                new IntVector(0, 0, -1),
            };

        void GenerateLevelLayout()
        {
            var queue = new Queue<LevelGrowthNode>();
            var visited = new HashSet<IntVector>();

            var roomFactory = new IsaacRoomFactory();
            rooms.Clear();
            doors.Clear();

            var start = new LevelGrowthNode();
            start.room = roomFactory.CreateRoom(IntVector.Zero);
            start.moveDirection = 0;
            rooms.Add(start.room);

            queue.Enqueue(start);
            visited.Add(start.room.position);

            var numRooms = random.Range(isaacConfig.minRooms, isaacConfig.maxRooms);
            bool isSpawnRoom = true;
            while (queue.Count > 0)
            {
                var top = queue.Dequeue();
                if (isSpawnRoom)
                {
                    // in the spawn room.  Spawn on all 4 sides
                    for (int d = 0; d < 4; d++)
                    {
                        AddNextRoomNode(roomFactory, queue, visited, numRooms, top.room, d, isaacConfig.spawnRoomBranchProbablity);
                    }
                    isSpawnRoom = false;
                }
                else
                {
                    // Grow forward
                    AddNextRoomNode(roomFactory, queue, visited, numRooms, top.room, top.moveDirection, isaacConfig.growForwardProbablity);

                    // Grow sideways
                    AddNextRoomNode(roomFactory, queue, visited, numRooms, top.room, (top.moveDirection + 1) % 4, isaacConfig.growSidewaysProbablity);
                    AddNextRoomNode(roomFactory, queue, visited, numRooms, top.room, (top.moveDirection + 3) % 4, isaacConfig.growSidewaysProbablity);
                }

                if (rooms.Count >= numRooms)
                {
                    break;
                }
            }

            // Generate the tile layout of the rooms
            var layoutBuilder = GetComponent<IsaacRoomLayoutBuilder>();
            foreach (var room in rooms)
            {
                GenerateRoomLayout(layoutBuilder, room);
            }

            isaacModel.rooms = rooms.ToArray();
            isaacModel.doors = doors.ToArray();
            rooms.Clear();
            doors.Clear();
        } 

        void AddNextRoomNode(IsaacRoomFactory roomFactory, 
                Queue<LevelGrowthNode> queue, HashSet<IntVector> visited, int maxRooms, 
                IsaacRoom parentRoom, int direction, float probability)
        {
            if (random.NextFloat() > probability) return;
            if (rooms.Count >= maxRooms) return;

            var nextPosition = parentRoom.position + directions[direction];
            if (!visited.Contains(nextPosition))
            {
                var nextRoom = roomFactory.CreateRoom(nextPosition);
                rooms.Add(nextRoom);
                var nextNode = new LevelGrowthNode();
                nextNode.room = nextRoom;
                nextNode.moveDirection = direction;
                queue.Enqueue(nextNode);
                visited.Add(nextPosition);

                // Create a door between the two rooms
                ConnectRoomsWithDoors(parentRoom, nextRoom);
            }
            else
            {
                // See if we can connect to the other room
                // first make sure we don't already have a connection between the two
                var nextRoom = GetRoomAt(nextPosition);
                if (!ContainsDoorBetween(parentRoom.roomId, nextRoom.roomId))
                {
                    float loopTest = random.NextFloat();
                    if (loopTest < isaacConfig.cycleProbability)
                    {
                        // Connect the two rooms together
                        if (nextRoom != null)
                        {
                            // Create a door between the two rooms
                            ConnectRoomsWithDoors(parentRoom, nextRoom);
                        }
                    }
                }
            }
        }


        void ConnectRoomsWithDoors(IsaacRoom roomA, IsaacRoom roomB)
        {
            // Create a door between the two rooms
            roomA.adjacentRooms.Add(roomB.roomId);
            roomB.adjacentRooms.Add(roomA.roomId);
            float doorPositionRatio = random.NextFloat();
            CreateDoor(roomA, roomB, doorPositionRatio);
        }

        IsaacRoom GetRoomAt(IntVector position)
        {
            foreach (var room in rooms)
            {
                if (room.position.Equals(position))
                {
                    return room;
                }
            }
            return null;
        }

        bool ContainsDoorBetween(int roomA, int roomB)
        {
            foreach (var door in doors)
            {
                if (door.roomA == roomA && door.roomB == roomB) return true;
                if (door.roomA == roomB && door.roomB == roomA) return true;
            }
            return false;
        }

        void CreateDoor(IsaacRoom roomA, IsaacRoom roomB, float ratio)
        {
            var door = new IsaacDoor();
            door.roomA = roomA.roomId;
            door.roomB = roomB.roomId;
            door.ratio = ratio;
            doors.Add(door);

            // Create the door tile
            var roomWidth = isaacConfig.roomWidth;
            var roomHeight = isaacConfig.roomHeight;
            bool horizontal = (roomA.position.z - roomB.position.z) == 0; // Are the two room horizontal
            var size = horizontal ? isaacConfig.roomHeight : isaacConfig.roomWidth;
            var location1D = Mathf.FloorToInt(size * door.ratio);

            var leftRoom = roomA;
            var rightRoom = roomB;
            if (horizontal && leftRoom.position.x > rightRoom.position.x)
            {
                // Swap
                leftRoom = roomB;
                rightRoom = roomA;
            }
            else if (!horizontal && leftRoom.position.z > rightRoom.position.z)
            {
                // Swap
                leftRoom = roomB;
                rightRoom = roomA;
            }


            IntVector leftRoomDoor;
            IntVector rightRoomDoor;

            if (horizontal)
            {
                leftRoomDoor = new IntVector(roomWidth, 0, location1D);
                rightRoomDoor = new IntVector(-1, 0, location1D);
            }
            else
            {
                leftRoomDoor = new IntVector(location1D, 0, roomHeight);
                rightRoomDoor = new IntVector(location1D, 0, -1);
            }

            leftRoom.doorPositions.Add(leftRoomDoor);
            rightRoom.doorPositions.Add(rightRoomDoor);
        }

        bool IsWall(int x, int z, IsaacRoomLayout layout)
        {
            var center = IsaacBuilderUtils.GetTileAt(x, z, layout);
            if (center.tileType == IsaacRoomTileType.Floor) return false;
            for (int dx = -1; dx <= 1; dx++)
            {
                for (int dz = -1; dz <= 1; dz++)
                {
                    if (dx == 0 && dz == 0) continue;
                    var cell = IsaacBuilderUtils.GetTileAt(x + dx, z + dz, layout);
                    if (cell.tileType == IsaacRoomTileType.Floor)
                    {
                        // Contains an adjacent floor tile
                        return true;
                    }
                }
            }
            return false;
        }

        void GenerateRoomLayout(IsaacRoomLayoutBuilder layoutBuilder, IsaacRoom room)
        {
            IsaacRoomLayout layout;
            if (layoutBuilder == null)
            {
                layout = GenerateEmptyRoomLayout();
            }
            else
            {
                layout = layoutBuilder.GenerateLayout(room, random, isaacConfig.roomWidth, isaacConfig.roomHeight);
            }
            room.layout = layout;
        }

        IsaacRoomLayout GenerateEmptyRoomLayout()
        {
            var layout = new IsaacRoomLayout();
            layout.InitializeTiles(isaacConfig.roomWidth, isaacConfig.roomHeight, IsaacRoomTileType.Floor);
            return layout;
        }
        
        void EmitLevelMarkers()
        {
            var tileSize = new Vector3(isaacConfig.tileSize.x, 0, isaacConfig.tileSize.y);
            var roomSizeWorld = new IntVector(isaacConfig.roomWidth, 0, isaacConfig.roomHeight) * tileSize;
            var roomPadding = new Vector3(isaacConfig.roomPadding.x, 0, isaacConfig.roomPadding.y);
            foreach (var room in isaacModel.rooms)
            {
                var roomBasePosition = room.position * (roomSizeWorld + roomPadding);
                var roomWidth = room.layout.Tiles.GetLength(0);
                var roomHeight = room.layout.Tiles.GetLength(1);
                
                for (int x = -1; x < roomWidth + 1; x++)
                {
                    for (int z = -1; z < roomHeight + 1; z++)
                    {
                        var tilePosition = new IntVector(x, 0, z);
                        var tileOffset = tilePosition * tileSize;
                        var markerPosition = roomBasePosition + tileOffset;
                        var transformation = Matrix4x4.TRS(markerPosition, Quaternion.identity, Vector3.one);
                        var tile = IsaacBuilderUtils.GetTileAt(x, z, room.layout);
                        if (tile.tileType == IsaacRoomTileType.Floor)
                        {
                            EmitMarker(IsaacDungeonMarkerNames.Ground, transformation, tilePosition, room.roomId);
                        }
                        else if (IsaacBuilderUtils.ContainsDoorAt(x, z, room))
                        {
                            EmitMarker(IsaacDungeonMarkerNames.ST_DOOR2D, transformation, tilePosition, room.roomId);
                            EmitMarker(IsaacDungeonMarkerNames.Door, transformation, tilePosition, room.roomId);
                        }
                        else if (IsWall(x, z, room.layout))
                        {
                            EmitMarker(IsaacDungeonMarkerNames.ST_WALL2D, transformation, tilePosition, room.roomId);
                            EmitMarker(IsaacDungeonMarkerNames.Wall, transformation, tilePosition, room.roomId);
                        }
                    }
                }
                
            }
        }
    }

    class IsaacRoomFactory
    {
        int idCounter = 0;

        public IsaacRoom CreateRoom(IntVector position)
        {
            var room = new IsaacRoom();
            room.roomId = idCounter++;
            room.position = position;
            return room;
        }

    }
    
    public static class IsaacDungeonMarkerNames {
        public static readonly string Ground = "Ground";
        public static readonly string Door = "Door";
        public static readonly string Wall = "Wall";
        
        public static readonly string ST_DOOR2D = "Door2D";
        public static readonly string ST_WALL2D = "Wall2D";
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Isaac\IsaacDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Isaac
{
    public class IsaacDungeonConfig : DungeonConfig
    {
        public int minRooms;
        public int maxRooms;

        public int roomWidth = 10;
        public int roomHeight = 6;

        public Vector2 tileSize = new Vector2(1, 1);
        public Vector2 roomPadding = new Vector2(1, 1);

        public float growForwardProbablity = 0.75f;
        public float growSidewaysProbablity = 0.25f;

        public float spawnRoomBranchProbablity = 0.75f;
        public float cycleProbability = 1.0f;
        
        public bool Mode2D = false;
        
        public override bool IsMode2D()
        {
            return Mode2D;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Isaac\IsaacDungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System;
using System.Collections.Generic;

namespace DungeonArchitect.Builders.Isaac
{
    [Serializable]
    public class IsaacRoom
    {
        [HideInInspector]
        public int roomId;

        [HideInInspector]
        public IntVector position;

        [HideInInspector]
        public IsaacRoomLayout layout;

        [HideInInspector]
        public List<int> adjacentRooms = new List<int>();

        [HideInInspector]
        public List<IntVector> doorPositions = new List<IntVector>();
    }

    [Serializable]
    public class IsaacDoor
    {
        [HideInInspector]
        public int roomA;

        [HideInInspector]
        public int roomB;

        [HideInInspector]
        public float ratio = 0.5f;
    }

    [Serializable]
    public class IsaacRoomLayout
    {
        [HideInInspector]
        public IsaacRoomTile[,] Tiles = new IsaacRoomTile[0, 0];

        public void InitializeTiles(int width, int height, IsaacRoomTileType tileType)
        {
            Tiles = new IsaacRoomTile[width, height];
            for (int x = 0; x < width; x++)
            {
                for (int z = 0; z < height; z++)
                {
                    var tile = new IsaacRoomTile();
                    tile.tileType = tileType;
                    Tiles[x, z] = tile;
                }
            }
        }
    }

    [Serializable]
    public class IsaacRoomTile
    {
        public IsaacRoomTileType tileType;
    }

    public enum IsaacRoomTileType
    {
        Floor,
        Door,
        Empty
    }

    public class IsaacDungeonModel : DungeonModel
    {
        [HideInInspector]
        public IsaacDungeonConfig config;

        [HideInInspector]
        public IsaacRoom[] rooms;

        [HideInInspector]
        public IsaacDoor[] doors;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Mario\MarioDungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Builders.Mario
{
	public static class MarioDungeonMarkerNames
    {
        public static readonly string Ground = "Ground";
        public static readonly string WallFront = "WallFront";
        public static readonly string WallBack = "WallBack";
        public static readonly string WallSide = "WallSide";
        public static readonly string BackgroundGround = "BG Ground";
        public static readonly string BackgroundCeiling = "BG Ceiling";
        public static readonly string BackgroundWall = "BG Wall";
        public static readonly string Stair = "Stair";
        public static readonly string Corridor = "Corridor";
    }

	public class MarioDungeonBuilder : DungeonBuilder {

		MarioDungeonConfig marioConfig;
		MarioDungeonModel marioModel;

		new System.Random random;

		/// <summary>
		/// Builds the dungeon layout.  In this method, you should build your dungeon layout and save it in your model file
		/// No markers should be emitted here.   (EmitMarkers function will be called later by the engine to do that)
		/// </summary>
		/// <param name="config">The builder configuration</param>
		/// <param name="model">The dungeon model that the builder will populate</param>
		public override void BuildDungeon(DungeonConfig config, DungeonModel model)
		{
			base.BuildDungeon(config, model);

			random = new System.Random((int)config.Seed);

			// We know that the dungeon prefab would have the appropriate config and models attached to it
			// Cast and save it for future reference
			marioConfig = config as MarioDungeonConfig;
			marioModel = model as MarioDungeonModel;
			marioModel.Config = marioConfig;

			// Generate the city layout and save it in a model.   No markers are emitted here. 
			GenerateLevelLayout();
		}

		/// <summary>
		/// Override the builder's emit marker function to emit our own markers based on the layout that we built
		/// You should emit your markers based on the layout you have saved in the model generated previously
		/// When the user is designing the theme interactively, this function will be called whenever the graph state changes,
		/// so the theme engine can populate the scene (BuildDungeon will not be called if there is no need to rebuild the layout again)
		/// </summary>
		public override void EmitMarkers()
		{
			base.EmitMarkers();

			EmitLevelMarkers();

			ProcessMarkerOverrideVolumes();
		}

		void GenerateLevelLayout() {
			var tiles = new List<MarioTile> ();

			marioModel.levelWidth = random.Next (marioConfig.minLength, marioConfig.maxLength);

            bool addingGap = false;
            int targetGapDistance = 0;
            int currentGapDistance = 0;
            int currentNonGapDistance = 0;

            int y = 0;
            for (int x = 0; x < marioModel.levelWidth; x++)
            {
                var position = new IntVector(x, y, 0);

                if (!addingGap)
                {
                    if (x >= 2)
                    {
                        bool changeHeight = random.NextFloat() < marioConfig.heightVariationProbablity;
                        if (changeHeight)
                        {
                            bool moveUp = random.NextFloat() < 0.5f;
                            y += moveUp ? 1 : -1;
                        }
                    }

                    // Create a tile here

                    var tile = new MarioTile();
                    tile.position = position;
                    tile.tileType = MarioTileType.Ground;
                    tiles.Add(tile);

                    currentNonGapDistance++;

                    if (currentNonGapDistance >= marioConfig.minNonGap)
                    {
                        // Check if we need to add a gap
                        addingGap = random.NextFloat() < marioConfig.gapProbability;
                        if (addingGap)
                        {
                            currentGapDistance = 0;
                            targetGapDistance = random.Next(marioConfig.minGap, marioConfig.maxGap);
                        }
                    }
                }
                else
                {
                    bool corridor = targetGapDistance > marioConfig.maxJumpTileDistance;
                    // We are adding a gap
                    var tile = new MarioTile();
                    tile.position = position;
                    tile.tileType = corridor ? MarioTileType.Corridor : MarioTileType.Gap;
                    tiles.Add(tile);

                    currentGapDistance++;
                    if (currentGapDistance >= targetGapDistance)
                    {
                        addingGap = false;
                        currentNonGapDistance = 0;
                    }
                }

			}

            // Perform post process cleanup
            for (int i = 0; i < tiles.Count; i++)
            {
                var tile = tiles[i];
                var prevTile = i > 0 ? tiles[i - 1] : null;
                var nextTile = i + 1 < tiles.Count ? tiles[i + 1] : null;

                // Fix single tile pits (to avoid two stairs intersecting with each other moving up and down the pit)
                if (prevTile != null && nextTile != null)
                {
                    if (prevTile.position.y == nextTile.position.y && prevTile.position.y != tile.position.y)
                    {
                        tile.position.y = prevTile.position.y;
                    }
                }
            }


            // Emit chunk markers
            bool[] chunkOccupied = new bool[tiles.Count];
            for (int i = 0; i < tiles.Count; i++)
            {
                var chunkMarkers = new List<string>();
                foreach (var chunk in marioConfig.chunkMarkers)
                {
                    int distance = chunk.numTiles;
                    if (distance > 0)
                    {
                        var valid = true;
                        for (int j = i; j < tiles.Count && j < i + distance; j++)
                        {
                            var tile = tiles[j];
                            if (tile.tileType != MarioTileType.Ground) valid = false;
                            if (chunkOccupied[j]) valid = false;

                            var prevTile = j > 0 ? tiles[j - 1] : null;
                            if (prevTile != null && prevTile.position.y != tile.position.y) valid = false;
                            var nextTile = j + 1 < tiles.Count ? tiles[j + 1] : null;
                            if (nextTile != null && nextTile.position.y != tile.position.y) valid = false;


                            if (!valid) break;
                        }

                        if (i + distance >= tiles.Count)
                        {
                            valid = false;
                        }

                        if (valid)
                        {
                            var emitMarker = random.NextFloat() < chunk.probablity;
                            if (emitMarker)
                            {
                                chunkMarkers.Add(chunk.markerName);

                                for (int j = i; j < tiles.Count && j < i + distance; j++)
                                {
                                    chunkOccupied[j] = true;
                                }
                            }
                        }
                    }
                }
                tiles[i].chunkMarkers = chunkMarkers.ToArray();
            }

            marioModel.tiles = tiles.ToArray();
		}

        

		void EmitLevelMarkers()
        {
            var gridSize = marioConfig.gridSize;
            var tileMap = new Dictionary<int, MarioTile>();
            var levelWidth = marioModel.tiles.Length;
            var heights = new int[levelWidth];

            foreach (var tile in marioModel.tiles)
            {
                if (tile.tileType == MarioTileType.Ground || tile.tileType == MarioTileType.Corridor)
                {
                    var worldPosition = tile.position * gridSize;
                    var markerTransform = Matrix4x4.TRS(worldPosition, Quaternion.identity, Vector3.one);
                    string markerName = tile.tileType == MarioTileType.Ground ? MarioDungeonMarkerNames.Ground : MarioDungeonMarkerNames.Corridor;
                    EmitMarker(markerName, markerTransform, tile.position, -1);
                }

                tileMap.Add(tile.position.x, tile);
                heights[tile.position.x] = tile.tileType == MarioTileType.Ground ? tile.position.y : marioConfig.minY;
			}
            
            // Emit the custom chunk markers
            foreach (var tile in marioModel.tiles)
            {
                foreach (var markerName in tile.chunkMarkers)
                {
                    var worldPosition = tile.position * gridSize;
                    var markerTransform = Matrix4x4.TRS(worldPosition, Quaternion.identity, Vector3.one);
                    EmitMarker(markerName, markerTransform, tile.position, -1);
                }
            }

            for (int x = 0; x < marioModel.levelWidth; x++)
            {
                for (int z = marioConfig.minDepth; z <= marioConfig.maxDepth; z++)
                {
                    // Insert the background ground
                    {
                        var positionI = new IntVector(x, marioConfig.minY, z);
                        var positionF = positionI * gridSize;
                        var markerTransform = Matrix4x4.TRS(positionF, Quaternion.identity, Vector3.one);
                        EmitMarker(MarioDungeonMarkerNames.BackgroundGround, markerTransform, positionI, -1);
                    }

                    // Insert the background ceiling
                    {
                        var positionI = new IntVector(x, marioConfig.maxY + 1, z);
                        var positionF = positionI * gridSize;
                        var markerTransform = Matrix4x4.TRS(positionF, Quaternion.Euler(180, 0, 0), Vector3.one);
                        EmitMarker(MarioDungeonMarkerNames.BackgroundCeiling, markerTransform, positionI, -1);
                    }
                }

                // Insert the background walls (back)
                for (int y = marioConfig.minY; y <= marioConfig.maxY; y++)
                {
                    var positionI = new IntVector(x, y, marioConfig.maxDepth);
                    var positionF = positionI * gridSize;
                    positionF.z += gridSize.z / 2.0f;
                    var markerTransform = Matrix4x4.TRS(positionF, Quaternion.identity, Vector3.one);
                    EmitMarker(MarioDungeonMarkerNames.BackgroundWall, markerTransform, positionI, -1);
                }

                // Insert the side walls
                if (x + 1 < heights.Length)
                {
                    int minY = Mathf.Min(heights[x], heights[x + 1]);
                    int maxY = Mathf.Max(heights[x], heights[x + 1]);
                    
                    for (int y = minY; y < maxY; y++)
                    {
                        var positionI = new IntVector(x, y, 0);
                        var positionF = positionI * gridSize;
                        positionF.x += gridSize.x / 2.0f;
                        var markerTransform = Matrix4x4.TRS(positionF, Quaternion.Euler(0, 90, 0), Vector3.one);
                        EmitMarker(MarioDungeonMarkerNames.WallSide, markerTransform, positionI, -1);
                    }

                    // Insert stairs
                    var heightDifference = maxY - minY;
                    if (heightDifference > 0)
                    {
                        // Make sure we have ground tiles on both the sides
                        if (tileMap[x].tileType != MarioTileType.Gap && tileMap[x + 1].tileType != MarioTileType.Gap)
                        {
                            string markerName = MarioDungeonMarkerNames.Stair;
                            if (heightDifference > 1)
                            {
                                markerName += heightDifference.ToString();
                            }

                            IntVector positionI = new IntVector(x, heights[x], 0);
                            Quaternion rotation = Quaternion.identity;
                            if (heights[x] > heights[x + 1])
                            {
                                positionI.x++;
                                positionI.y = heights[x + 1];
                                rotation = Quaternion.Euler(0, 180, 0);
                            }
                            var positionF = positionI * gridSize;
                            var markerTransform = Matrix4x4.TRS(positionF, rotation, Vector3.one);
                            EmitMarker(markerName, markerTransform, positionI, -1);
                        }
                    }
                }
                
            }
            
            for (int z = marioConfig.minDepth; z <= marioConfig.maxDepth; z++)
            {
                for (int y = marioConfig.minY; y <= marioConfig.maxY; y++)
                {
                    // Insert the background walls (left)
                    {
                        int x = 0;
                        var positionI = new IntVector(x, y, z);
                        var positionF = positionI * gridSize;
                        positionF.x -= gridSize.x / 2.0f;
                        var markerTransform = Matrix4x4.TRS(positionF, Quaternion.Euler(0, -90, 0), Vector3.one);
                        EmitMarker(MarioDungeonMarkerNames.BackgroundWall, markerTransform, positionI, -1);
                    }
                    {
                        int x = marioModel.levelWidth;
                        var positionI = new IntVector(x, y, z);
                        var positionF = positionI * gridSize;
                        positionF.x -= gridSize.x / 2.0f;
                        var markerTransform = Matrix4x4.TRS(positionF, Quaternion.Euler(0, 90, 0), Vector3.one);
                        EmitMarker(MarioDungeonMarkerNames.BackgroundWall, markerTransform, positionI, -1);
                    }
                }
            }

            // Insert the front / back walls
            foreach (var tile in marioModel.tiles)
            {
                if (tile.tileType == MarioTileType.Ground)
                {
                    // Insert front walls
                    for (int y = marioConfig.minY; y < tile.position.y; y++)
                    {
                        var positionI = tile.position;
                        positionI.y = y;
                        var positionF = positionI * gridSize;
                        positionF -= new Vector3(0, 0, gridSize.z / 2.0f);
                        var markerTransform = Matrix4x4.TRS(positionF, Quaternion.identity, Vector3.one);
                        EmitMarker(MarioDungeonMarkerNames.WallFront, markerTransform, positionI, -1);
                    }

                    // insert back wall
                    {
                        var positionI = tile.position;
                        var positionF = positionI * gridSize;
                        positionF += new Vector3(0, 0, gridSize.z / 2.0f);
                        var markerTransform = Matrix4x4.TRS(positionF, Quaternion.identity, Vector3.one);
                        EmitMarker(MarioDungeonMarkerNames.WallBack, markerTransform, positionI, -1);
                    }

                }
            }
		} 

	}
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Mario\MarioDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Mario
{
    [System.Serializable]
    public class MarioDungeonLevelChunkRule
    {
        public int numTiles = 5;
        public string markerName = "LevelChunk5x";
        public float probablity = 0.5f;
    }

	public class MarioDungeonConfig : DungeonConfig {
		public int minLength = 20;  
		public int maxLength = 25;

        public int minY = -2;
        public int maxY = 20;
        public int minDepth = -4;
        public int maxDepth = 15;

        public int minGap = 2;
        public int maxGap = 6;

        public int minNonGap = 4;

        public int maxStairHeight = 1;
        public float heightVariationProbablity = 0.1f;

        public float gapProbability = 0.1f;

        public int maxJumpTileDistance = 1;

        public Vector3 gridSize = new Vector3(4, 2, 4);

        public MarioDungeonLevelChunkRule[] chunkMarkers;
        
        public bool Mode2D = false;
        
        public override bool IsMode2D()
        {
            return Mode2D;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Mario\MarioDungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Mario
{
	public enum MarioTileType {
		Ground,
        Corridor,
        Gap
	}

	public class MarioTile {
		public IntVector position;
		public MarioTileType tileType;
        public string[] chunkMarkers;
    }

	public class MarioDungeonModel : DungeonModel {

		[HideInInspector]
		public MarioDungeonConfig Config;

		[HideInInspector]
		public MarioTile[] tiles;

        [HideInInspector]
        public int levelWidth;


    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Mario\MarioDungeonSpatialConstraints.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Builders.Mario.SpatialConstraints
{
    public class MarioDungeonSpatialConstraints : SpatialConstraintProcessor
    {
        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var gridConfig = context.config as MarioDungeonConfig;

            var domain = base.GetDomain(context);
            domain.gridSize = (gridConfig != null) ? gridConfig.gridSize : Vector3.one;
            return domain;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Maze\MazeDungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Builders.Maze
{
	public static class MazeDungeonMarkerNames
    {
        public static readonly string GroundBlock = "GroundBlock";
        public static readonly string WallBlock = "WallBlock";
    }

	public class MazeDungeonBuilder : DungeonBuilder {

		MazeDungeonConfig MazeConfig;
		MazeDungeonModel MazeModel;

		new System.Random random;

		/// <summary>
		/// Builds the dungeon layout.  In this method, you should build your dungeon layout and save it in your model file
		/// No markers should be emitted here.   (EmitMarkers function will be called later by the engine to do that)
		/// </summary>
		/// <param name="config">The builder configuration</param>
		/// <param name="model">The dungeon model that the builder will populate</param>
		public override void BuildDungeon(DungeonConfig config, DungeonModel model)
		{
			base.BuildDungeon(config, model);

			random = new System.Random((int)config.Seed);

			// We know that the dungeon prefab would have the appropriate config and models attached to it
			// Cast and save it for future reference
			MazeConfig = config as MazeDungeonConfig;
			MazeModel = model as MazeDungeonModel;
			MazeModel.Config = MazeConfig;

			// Generate the city layout and save it in a model.   No markers are emitted here. 
			GenerateLevelLayout();
		}

		/// <summary>
		/// Override the builder's emit marker function to emit our own markers based on the layout that we built
		/// You should emit your markers based on the layout you have saved in the model generated previously
		/// When the user is designing the theme interactively, this function will be called whenever the graph state changes,
		/// so the theme engine can populate the scene (BuildDungeon will not be called if there is no need to rebuild the layout again)
		/// </summary>
		public override void EmitMarkers()
		{
			base.EmitMarkers();

			EmitLevelMarkers();

			ProcessMarkerOverrideVolumes();
		}

        bool IsVisited(bool[,] visited, int x, int y)
        {
            if (x < 0 || y < 0 || x >= visited.GetLength(0) || y >= visited.GetLength(1)) return true;
            return visited[x, y];
        }

        bool CanDigToPoint(IntVector2 point, bool[,] visited)
        {
            if (IsVisited(visited, point.x, point.y))
            {
                // Already visited
                return false;
            }

            int neighborPathways = 0;
            neighborPathways += IsVisited(visited, point.x - 1, point.y + 0) ? 1 : 0;
            neighborPathways += IsVisited(visited, point.x + 1, point.y + 0) ? 1 : 0;
            neighborPathways += IsVisited(visited, point.x + 0, point.y + 1) ? 1 : 0;
            neighborPathways += IsVisited(visited, point.x + 0, point.y - 1) ? 1 : 0;
            /*
            neighborPathways += IsVisited(visited, point.x - 1, point.y + 1) ? 1 : 0;
            neighborPathways += IsVisited(visited, point.x + 1, point.y + 1) ? 1 : 0;
            neighborPathways += IsVisited(visited, point.x - 1, point.y - 1) ? 1 : 0;
            neighborPathways += IsVisited(visited, point.x + 1, point.y - 1) ? 1 : 0;
            */

            return neighborPathways <= 1;
        }

        bool GetNextNeighbor(IntVector2 currentPoint, out IntVector2 nextPoint, bool[,] visited)
        {
            var offsets = new List<IntVector2>
            {
                new IntVector2(-1, 0),
                new IntVector2(1, 0),
                new IntVector2(0, -1),
                new IntVector2(0, 1)
            };

            while (offsets.Count > 0)
            {
                int i = random.Next() % offsets.Count;
                var offset = offsets[i];
                offsets.RemoveAt(i);

                if (CanDigToPoint(currentPoint + offset, visited))
                {
                    nextPoint = currentPoint + offset;
                    return true;
                }
            }

            nextPoint = currentPoint;
            return false;
            
        }

		void GenerateLevelLayout()
        {
            MazeConfig.mazeWidth = Mathf.Max(MazeConfig.mazeWidth, 6);
            MazeConfig.mazeHeight = Mathf.Max(MazeConfig.mazeHeight, 6);

            int w = MazeConfig.mazeWidth;
            int h = MazeConfig.mazeHeight;

            var visited = new bool[MazeConfig.mazeWidth, MazeConfig.mazeHeight];
            for (int x = 0; x < w; x++)
            {
                for (int y = 0; y < h; y++)
                {
                    //bool boundary = (x == 0 || y == 0 || x == w - 1 || y == h - 1);
                    visited[x, y] = false;
                }
            }

            var stack = new Stack<IntVector2>();
            {
                var startPoint = new IntVector2(0, 2 + random.Next() % (MazeConfig.mazeHeight - 4));
                visited[startPoint.x, startPoint.y] = true;
                stack.Push(startPoint);
            }

            while (stack.Count > 0)
            {
                var currentPoint = stack.Peek();
                IntVector2 nextPoint;
                if (GetNextNeighbor(currentPoint, out nextPoint, visited))
                {
                    visited[nextPoint.x, nextPoint.y] = true;
                    stack.Push(nextPoint);
                }
                else
                {
                    stack.Pop();
                }
            }

            // Fill in the model
            MazeModel.tileStates = new MazeTileState[w, h];
            for (int x = 0; x < w; x++)
            {
                for (int y = 0; y < h; y++)
                {
                    MazeModel.tileStates[x, y] = visited[x, y] ? MazeTileState.Empty : MazeTileState.Blocked;
                }
            }
        }
        
        protected override LevelMarkerList CreateMarkerListObject(DungeonConfig config)
        {
            var mazeConfig = config as MazeDungeonConfig;
            if (mazeConfig != null)
            {
                var bucketSize = Mathf.Max(mazeConfig.gridSize.x, mazeConfig.gridSize.y) * 2;
                bucketSize = Mathf.Max(0.1f, bucketSize);
                return new SpatialPartionedLevelMarkerList(bucketSize);
            }
            else
            {
                return base.CreateMarkerListObject(config);
            }
        }
        
		void EmitLevelMarkers()
        {
            var gridSize = new Vector3(MazeConfig.gridSize.x, 0, MazeConfig.gridSize.y);
            int w = MazeConfig.mazeWidth;
            int h = MazeConfig.mazeHeight;

            for (int x = 0; x < w; x++)
            {
                for (int y = 0; y < h; y++)
                {
                    var position = Vector3.Scale(new Vector3(x + 0.5f, 0, y + 0.5f), gridSize);
                    var markerTransform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
                    var markerName = MazeModel.tileStates[x, y] == MazeTileState.Blocked
                            ? MazeDungeonMarkerNames.WallBlock
                            : MazeDungeonMarkerNames.GroundBlock;
                    EmitMarker(markerName, markerTransform, new IntVector(x, 0, y), -1);
                }
            }

        } 

	}
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Maze\MazeDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Maze
{
	public class MazeDungeonConfig : DungeonConfig {
		public int mazeWidth = 20;  
		public int mazeHeight = 25;
        
        public Vector2 gridSize = new Vector2(4, 4);
        
        public bool Mode2D = false;
        
        public override bool IsMode2D()
        {
	        return Mode2D;
        }
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Maze\MazeDungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Maze
{
	public enum MazeTileState {
		Empty,
        Blocked
	}

	public class MazeDungeonModel : DungeonModel {

		[HideInInspector]
		public MazeDungeonConfig Config;

		[HideInInspector]
		public MazeTileState[,] tileStates;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Maze\MazeDungeonSpatialConstraints.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Builders.Maze
{
    public class MazeDungeonSpatialConstraints : SpatialConstraintProcessor
    {
        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var gridConfig = context.config as MazeDungeonConfig;

            var gridSize2D = (gridConfig != null) ? gridConfig.gridSize : Vector2.one;
            var gridSize = new Vector3(gridSize2D.x, 0, gridSize2D.y);
            
            var domain = base.GetDomain(context);
            domain.gridSize = gridSize;
            return domain;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SimpleCity\SimpleCityDungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Builders.SimpleCity
{
    public static class SimpleCityDungeonMarkerNames
    {
        public static readonly string House = "House";
        public static readonly string Park = "Park";
        public static readonly string Road_X = "Road_X";
        public static readonly string Road_T = "Road_T";
        public static readonly string Road_Corner = "Road_Corner";
        public static readonly string Road_S = "Road_S";
        public static readonly string Road_E = "Road_E";
        public static readonly string Road = "Road";

        public static readonly string CityWall = "CityWall";
        public static readonly string CityDoor = "CityDoor";
        public static readonly string CityGround = "CityGround";
        public static readonly string CornerTower = "CornerTower";
        public static readonly string CityWallPadding = "CityWallPadding";
    }

    public class SimpleCityDungeonBuilder : DungeonBuilder
    {
        SimpleCityDungeonConfig cityConfig;
        SimpleCityDungeonModel cityModel;

        new System.Random random;
        /// <summary>
        /// Builds the dungeon layout.  In this method, you should build your dungeon layout and save it in your model file
        /// No markers should be emitted here.   (EmitMarkers function will be called later by the engine to do that)
        /// </summary>
        /// <param name="config">The builder configuration</param>
        /// <param name="model">The dungeon model that the builder will populate</param>
        public override void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            base.BuildDungeon(config, model);

            random = new System.Random((int)config.Seed);

            // We know that the dungeon prefab would have the appropriate config and models attached to it
            // Cast and save it for future reference
            cityConfig = config as SimpleCityDungeonConfig;
            cityModel = model as SimpleCityDungeonModel;
            cityModel.Config = cityConfig;

            // Generate the city layout and save it in a model.   No markers are emitted here. 
            GenerateCityLayout();
        }

        /// <summary>
        /// Override the builder's emit marker function to emit our own markers based on the layout that we built
        /// You should emit your markers based on the layout you have saved in the model generated previously
        /// When the user is designing the theme interactively, this function will be called whenever the graph state changes,
        /// so the theme engine can populate the scene (BuildDungeon will not be called if there is no need to rebuild the layout again)
        /// </summary>
        public override void EmitMarkers()
        {
            base.EmitMarkers();
            EmitCityMarkers();
            EmitBoundaryMarkers();
            ProcessMarkerOverrideVolumes();
        }

        delegate void InsertHouseDelegate();

        /// <summary>
        /// Generate a layout and save it in the model
        /// </summary>
        void GenerateCityLayout()
        {
            cityConfig.roadWidth = Mathf.Max(1, cityConfig.roadWidth);
            var cityWidth = random.Range(cityConfig.minSize, cityConfig.maxSize);
            var cityLength = random.Range(cityConfig.minSize, cityConfig.maxSize);
            var roadWidth = cityConfig.roadWidth;

            cityModel.CityWidth = cityWidth;
            cityModel.CityHeight = cityLength;

            {
                cityModel.Cells = new SimpleCityCell[cityWidth, cityLength];

                for (int x = 0; x < cityWidth; x++)
                {
                    for (int z = 0; z < cityLength; z++)
                    {
                        var cell = new SimpleCityCell();
                        cell.Position = new IntVector(x, 0, z);
                        cell.CellType = SimpleCityCellType.House;
                        cell.Rotation = GetRandomRotation();
                        cityModel.Cells[x, z] = cell;
                    }
                }
            }


            // Build a road network by removing some houses 
            // First build roads along the edge of the map
            for (int x = 0; x < cityWidth; x++)
            {
                MakeRoad(x, 0, true);
                MakeRoad(x, cityLength - roadWidth, true);
            }
            for (int z = 0; z < cityLength; z++)
            {
                MakeRoad(0, z, false);
                MakeRoad(cityWidth - roadWidth, z, false);
            }

            // Create roads in-between
            for (int x = GetRandomBlockSize() + 1; x < cityWidth; x += GetRandomBlockSize() + 1)
            {
                if (cityWidth - x <= 2 * roadWidth) continue;
                for (int z = 0; z < cityLength; z++)
                {
                    MakeRoad(x, z, false);
                }
            }
            for (int z = GetRandomBlockSize() + 1; z < cityLength; z += GetRandomBlockSize() + 1)
            {
                if (cityLength - z <= 2 * roadWidth) continue;
                for (int x = 0; x < cityWidth; x++)
                {
                    MakeRoad(x, z, true);
                }
            }

			RemoveRoadEdges();
			

            // Insert bigger houses 
            for (int x = 0; x < cityWidth; x++)
            {
                for (int z = 0; z < cityLength; z++)
                {
                    foreach (var blockDimension in cityConfig.customBlockDimensions)
                    {
                        bool bProcess = random.NextFloat() < blockDimension.probability;
                        if (!bProcess) continue;

                        int BlockWidth = blockDimension.sizeX;
                        int BlockHeight = blockDimension.sizeZ;
                        
                        InsertHouseDelegate InsertHouse = delegate() {
                            if (CanContainBiggerHouse(x, z, BlockWidth, BlockHeight))
                            {
                                if (random.NextFloat() < cityConfig.biggerHouseProbability)
                                {
                                    InsertBiggerHouse(x, z, BlockWidth, BlockHeight, 0, blockDimension.markerName);
                                }
                            }
                        };


                        InsertHouseDelegate InsertHouse90 = delegate ()
                        {
                            // Try the 90 degrees rotated version
                            if (CanContainBiggerHouse(x, z, BlockHeight, BlockWidth))
                            {
                                if (random.NextFloat() < cityConfig.biggerHouseProbability)
                                {
                                    InsertBiggerHouse(x, z, BlockHeight, BlockWidth, 90, blockDimension.markerName);
                                }
                            }
                        };

                        if (random.NextFloat() < 0.5f)
                        {
                            InsertHouse();
                            InsertHouse90();
                        }
                        else
                        {
                            InsertHouse90();
                            InsertHouse();
                        }

                    }
                    
                }
            }


            for (int x = 0; x < cityWidth; x++)
            {
                for (int z = 0; z < cityLength; z++)
                {
                    var cell = cityModel.Cells[x, z];
                    if (cell.CellType == SimpleCityCellType.House)
                    {
                        FaceHouseTowardsRoad(cell);
                    }
                }
            }


            // Create padding cells

            var padding = cityConfig.cityWallPadding;
            var paddedCells = new List<SimpleCityCell>();

            for (int p = 1; p <= padding; p++)
            {
                var currentPadding = p;

                var sx = -currentPadding;
                var sz = -currentPadding;
                var ex = cityWidth + currentPadding - 1;
                var ez = cityLength + currentPadding - 1;

                // Fill it with city wall padding marker
                for (int x = sx; x < ex; x++)
                {
                    SimpleCityCellType cellType = SimpleCityCellType.CityWallPadding;
                    
                    paddedCells.Add(CreateCell(x, sz, cellType));
                    paddedCells.Add(CreateCell(x, ez, cellType));
                }

                for (int z = sz; z < ez; z++)
                {
                    SimpleCityCellType cellType = SimpleCityCellType.CityWallPadding;

                    paddedCells.Add(CreateCell(sx, z, cellType));
                    paddedCells.Add(CreateCell(ex, z, cellType));
                }
            }
            cityModel.WallPaddingCells = paddedCells.ToArray();
        }

		void RemoveRoadEdge(int x, int z)
		{
			if (!IsStraightRoad(x, z)) {
				// Nothing to remove
				return;
			}

			var RoadsToRemove = new HashSet<IntVector>();
			RoadsToRemove.Add(new IntVector(x, 0, z));
			int index = x - 1;
			while (IsStraightRoad(index, z)) {
				RoadsToRemove.Add(new IntVector(index, 0, z));
				index--;
			}
			index = x + 1;
			while (IsStraightRoad(index, z)) {
				RoadsToRemove.Add(new IntVector(index, 0, z));
				index++;
			}

			index = z - 1;
			while (IsStraightRoad(x, index)) {
				RoadsToRemove.Add(new IntVector(x, 0, index));
				index--;
			}
			index = z + 1;
			while (IsStraightRoad(x, index)) {
				RoadsToRemove.Add(new IntVector(x, 0, index));
				index++;
			}

			foreach (IntVector Position in RoadsToRemove) {
				SimpleCityCell Cell = cityModel.Cells[Position.x, Position.z];
				Cell.CellType = SimpleCityCellType.House;
			}

		}

		bool IsStraightRoad(int x, int z) {
			if (GetCellType(x, z) != SimpleCityCellType.Road) {
				return false;
			}

			bool bTop = GetCellType(x, z - 1) == SimpleCityCellType.Road;
			bool bBottom = GetCellType(x, z + 1) == SimpleCityCellType.Road;
			bool bLeft = GetCellType(x - 1, z) == SimpleCityCellType.Road;
			bool bRight = GetCellType(x + 1, z) == SimpleCityCellType.Road;

			bool bHorizontal = bLeft && bRight;
			bool bVertical = bTop && bBottom;

			int Adjacent = 0;
			if (bTop) Adjacent++;
			if (bBottom) Adjacent++;
			if (bLeft) Adjacent++;
			if (bRight) Adjacent++;

			if (Adjacent != 2) return false;

			return bHorizontal || bVertical;
		}

		void RemoveRoadEdges() {
			int Width = cityModel.CityWidth;
			int Length = cityModel.CityHeight;

			for (int x = 0; x < Width; x++) {
				for (int z = 0; z < Length; z++) {
					if (IsStraightRoad(x, z)) {
						bool bRemove = random.NextFloat() < cityConfig.roadEdgeRemovalProbability;
						if (bRemove) {
							RemoveRoadEdge(x, z);
						}
					}
				}
			}
			/*
			// Remove the isolated road cells
			for (int x = 0; x < Width; x++) {
				for (int z = 0; z < Length; z++) {
					if (GetCellType(x, z) == SimpleCityCellType.Road) {
						int Adjacent = 0;
						if (GetCellType(x, z - 1) == SimpleCityCellType.Road) Adjacent++;
						if (GetCellType(x, z + 1) == SimpleCityCellType.Road) Adjacent++;
						if (GetCellType(x - 1, z) == SimpleCityCellType.Road) Adjacent++;
						if (GetCellType(x + 1, z) == SimpleCityCellType.Road) Adjacent++;
						if (Adjacent == 0) {
							// No adjacent roads connecting to this road cell. remove it
							SimpleCityCell Cell = demoModel.Cells[x, z];
							Cell.CellType = SimpleCityCellType.House;
						}
					}
				}
			}
			*/
		}

        SimpleCityCell CreateCell(int x, int z, SimpleCityCellType cellType)
        {
            var cell = new SimpleCityCell();
            cell.Position = new IntVector(x, 0, z);
            cell.CellType = cellType;
            cell.Rotation = Quaternion.identity;
            return cell;
        }

        SimpleCityCellType GetCellType(int x, int z) {
            if (x < 0 || x >= cityModel.Cells.GetLength(0) ||
                    z < 0 || z >= cityModel.Cells.GetLength(1)) {
                return SimpleCityCellType.Empty;
            }
            return cityModel.Cells[x, z].CellType;
        }

        void FaceHouseTowardsRoad(SimpleCityCell cell) {
            int x = cell.Position.x;
            int z = cell.Position.z;

            bool roadLeft = GetCellType(x - 1, z) == SimpleCityCellType.Road;
            bool roadRight = GetCellType(x + 1, z) == SimpleCityCellType.Road;
            bool roadTop = GetCellType(x, z - 1) == SimpleCityCellType.Road;
            bool roadBottom = GetCellType(x, z + 1) == SimpleCityCellType.Road;
            
            if (!roadLeft && !roadRight && !roadTop && !roadBottom) {
                // No roads nearby. promote to park
                cell.CellType = SimpleCityCellType.Park;
                cell.Rotation = Quaternion.Euler(0, 90 * (random.Next() % 4), 0);
                return;
            }

            float angle = 0;
            if (roadLeft) angle = 0;
            else if (roadRight) angle = 180;
            else if (roadTop) angle = 270;
            else if (roadBottom) angle = 90;

            cell.Rotation = Quaternion.Euler(0, angle, 0);
        }

        /// <summary>
        /// Make sure the 2x2 grid is occupied by 4 1x1 houses, so we can replace theme with a single bigger house
        /// </summary>
        /// <param name="x"></param>
        /// <param name="z"></param>
        /// <returns></returns>
        bool CanContainBiggerHouse(int x, int z, int w, int h)
        {
            int cityWidth = cityModel.Cells.GetLength(0);
            int cityLength = cityModel.Cells.GetLength(1);
            for (int dx = 0; dx < w; dx++)
            {
                for (int dz = 0; dz < h; dz++)
                {
                    if (x + dx >= cityWidth || z + dz >= cityLength)
                    {
                        return false;
                    }

                    var cell = cityModel.Cells[x + dx, z + dz];
                    if (cell.CellType != SimpleCityCellType.House)
                    {
                        return false;
                    }
                }
            }

            // The house can fit in this area.
            // Make sure this house is connected to the road
            bool connectedToRoad = IsConnectedToRoad(x, z, w, h);
            return connectedToRoad ;
        }
        
        bool IsConnectedToRoad(int x, int z, int w, int h)
        {
            int cityWidth = cityModel.Cells.GetLength(0);
            int cityLength = cityModel.Cells.GetLength(1);

            var samplePoints = new List<IntVector>();
            for (int dx = 0; dx < w; dx++)
            {
                int[] dz = new int[] { z - 1, z + h };
                for (int dzi = 0; dzi < 2; dzi++)
                {
                    int xx = x + dx;
                    int zz = dz[dzi];
                    samplePoints.Add(new IntVector(xx, 0, zz));
                }
            }
            
            for (int dz = 0; dz < w; dz++)
            {
                int[] dx = new int[] { x - 1, x + w };
                for (int dxi = 0; dxi < 2; dxi++)
                {
                    int xx = dx[dxi];
                    int zz = z + dz;
                    samplePoints.Add(new IntVector(xx, 0, zz));
                }
            }

            foreach (var samplePoint in samplePoints)
            {
                int xx = samplePoint.x;
                int zz = samplePoint.z;
                if (xx < 0 || xx >= cityWidth || zz < 0 || zz >= cityLength)
                {
                    continue;
                }

                var cell = cityModel.Cells[xx, zz];
                if (cell.CellType == SimpleCityCellType.Road)
                {
                    // Connected to a road
                    return true;
                }
            }
            
            // No adjacent road cells found
            return false;
        }
        /// <summary>
        /// Replaces the 4 1x1 smaller houses with a single 2x2 bigger house.  Assumes that there are 4 houses in x,z to x+1,z+1
        /// </summary>
        /// <param name="x"></param>
        /// <param name="z"></param>
        void InsertBiggerHouse(int x, int z, int w, int h, float Angle, string markerName)
        {
            for (int dx = 0; dx < w; dx++)
            {
                for (int dz = 0; dz < h; dz++)
                {
                    var cell = cityModel.Cells[x + dx, z + dz];
                    if (dx == 0 && dz == 0)
                    {
                        cell.CellType = SimpleCityCellType.UserDefined;
                        cell.Rotation = Quaternion.Euler(0, Angle, 0);
                        cell.BlockSize = new Vector3(w, 0, h);
                        cell.MarkerNameOverride = markerName;
                    }
                    else
                    {
                        // Make these cells empty, as they will be occupied by the bigger house and we don't want any markers here
                        cell.CellType = SimpleCityCellType.Empty;
                    }
                }
            }
        }

        /// <summary>
        /// Turns a house cell into a road
        /// </summary>
        /// <param name="cell"></param>
        void MakeRoad(int x, int z, bool horizontal)
        {
            var dx = horizontal ? 0 : 1;
            var dz = horizontal ? 1 : 0;
            for (int d = 0; d < cityConfig.roadWidth; d++)
            {
                var ix = x + d * dx;
                var iz = z + d * dz;
                ix = Mathf.Clamp(ix, 0, cityModel.CityWidth - 1);
                iz = Mathf.Clamp(iz, 0, cityModel.CityHeight - 1);
                var cell = cityModel.Cells[ix, iz];
                cell.CellType = SimpleCityCellType.Road;
                cell.Rotation = Quaternion.identity;
            }
        }

        /// <summary>
        /// Emit marker points so that the theme can decorate the scene layout that we just built
        /// </summary>
        void EmitCityMarkers()
        {
            var basePosition = transform.position;
            var cells = cityModel.Cells;
            var width = cells.GetLength(0);
            var length = cells.GetLength(1);
            var cellSize = new Vector3(cityConfig.CellSize.x, 0, cityConfig.CellSize.y);

            for (int x = 0; x < width; x++)
            {
                for (int z = 0; z < length; z++)
                {
                    var cell = cells[x, z];
                    string markerName = "Unknown";

                    Quaternion rotation = Quaternion.identity;
                    var worldPosition = cell.Position * cellSize + basePosition;

                    if (cell.CellType == SimpleCityCellType.House)
                    {
                        markerName = SimpleCityDungeonMarkerNames.House;
                        rotation = cell.Rotation;
                    }
                    else if (cell.CellType == SimpleCityCellType.UserDefined)
                    {
                        markerName = cell.MarkerNameOverride;
                        worldPosition += Vector3.Scale(cell.BlockSize / 2.0f - new Vector3(0.5f, 0, 0.5f), cellSize);
                        rotation = cell.Rotation;
                    }
                    else if (cell.CellType == SimpleCityCellType.Park)
                    {
                        markerName = SimpleCityDungeonMarkerNames.Park;
                        rotation = cell.Rotation;
                    }
                    else if (cell.CellType == SimpleCityCellType.Road)
                    {
                        float angle = 0;
                        markerName = RoadBeautifier.GetRoadMarkerName(x, z, cells, out angle);
                        rotation = Quaternion.Euler(0, angle, 0);
                    }

                    var markerTransform = Matrix4x4.TRS(worldPosition, rotation, Vector3.one);
                    EmitMarker(markerName, markerTransform, cell.Position, -1);

                    // Emit the generic road marker
                    if (cell.CellType == SimpleCityCellType.Road)
                    {
                        EmitMarker(SimpleCityDungeonMarkerNames.Road, markerTransform, cell.Position, -1);
                    }
                }
            }
        }

        void EmitBoundaryMarkers()
        {
            var config = cityModel.Config;
            var cells = cityModel.Cells;

            var padding = config.cityWallPadding;
            var doorSize = config.cityDoorSize;

            var width = cells.GetLength(0);
            var length = cells.GetLength(1);

            var cellSize = new Vector3(config.CellSize.x, 0, config.CellSize.y);
            for (int p = 1; p <= padding; p++)
            {

                var currentPadding = p;

                var sx = -currentPadding;
                var sz = -currentPadding;
                var ex = width + currentPadding - 1;
                var ez = length + currentPadding - 1;

                if (currentPadding == padding)
                {
                    var halfDoorSize = doorSize / 2.0f;
                    // Insert markers along the 4 wall sides
                    for (float x = sx; x < ex; x++)
                    {
                        if ((int)x == (int)((sx + ex) / 2 - halfDoorSize))
                        {
                            EmitDoorMarker(cellSize, x + halfDoorSize, sz, 0);
                            EmitDoorMarker(cellSize, x + halfDoorSize, ez, 180);
                            x += halfDoorSize;
                            continue;
                        }
                        EmitWallMarker(cellSize, x + 0.5f, sz, 0);
                        EmitWallMarker(cellSize, x + 0.5f, ez, 180);
                    }

                    for (float z = sz; z < ez; z++)
                    {
                        if ((int)z == (int)((sz + ez) / 2 - halfDoorSize))
                        {
                            EmitDoorMarker(cellSize, sx, z + halfDoorSize, 90);
                            EmitDoorMarker(cellSize, ex, z + halfDoorSize, 270);
                            z += halfDoorSize;
                            continue;
                        }
                        EmitWallMarker(cellSize, sx, z + 0.5f, 90);
                        EmitWallMarker(cellSize, ex, z + 0.5f, 270);
                    }


                    EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CornerTower, sx, sz, 0);
                    EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CornerTower, ex + 0.5f, sz, 0);
                    EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CornerTower, sx, ez + 0.5f, 0);
                    EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CornerTower, ex + 0.5f, ez + 0.5f, 0);
                }
                else
                {
                    // Fill it with city wall padding marker
                    for (float x = sx; x < ex; x++)
                    {
                        EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CityWallPadding, x + 0.5f, sz, 0);
                        EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CityWallPadding, x + 0.5f, ez + 0.5f, 180);
                    }

                    for (float z = sz; z < ez; z++)
                    {
                        EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CityWallPadding, sx, z + 0.5f, 90);
                        EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CityWallPadding, ex + 0.5f, z + 0.5f, 270);
                    }
                }
            }

            // Emit a ground marker since the city builder doesn't emit any ground.  
            // The theme can add a plane here if desired (won't be needed if building on a landscape)
            EmitGroundMarker(width, length, cellSize);

        }

        void EmitWallMarker(Vector3 cellSize, float x, float z, float angle)
        {
            EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CityWall, x, z, angle);
        }

        void EmitDoorMarker(Vector3 cellSize, float x, float z, float angle)
        {
            EmitMarkerAt(cellSize, SimpleCityDungeonMarkerNames.CityDoor, x, z, angle);
        }

        void EmitGroundMarker(int sizeX, int sizeZ, Vector3 cellSize)
        {
            var position = Vector3.Scale(new Vector3(sizeX, 0, sizeZ) / 2.0f, cellSize) + transform.position;
            var scale = new Vector3(sizeX, 1, sizeZ);
            var trans = Matrix4x4.TRS(position, Quaternion.identity, scale);
            EmitMarker(SimpleCityDungeonMarkerNames.CityGround, trans, IntVector.Zero, -1);
        }

        void EmitMarkerAt(Vector3 cellSize, string markerName, float x, float z, float angle)
        {
            var worldPosition = Vector3.Scale(new Vector3(x, 0, z), cellSize) + transform.position;
            var rotation = Quaternion.Euler(0, angle, 0);
            var transformation = Matrix4x4.TRS(worldPosition, rotation, Vector3.one);
            var gridPosition = new IntVector((int)x, 0, (int)z); // Optionally provide where this marker is in the grid position
            EmitMarker(markerName, transformation, gridPosition, -1);
        }

        Quaternion GetRandomRotation()
        {
            // Randomly rotate in steps of 90
            var angle = random.Next(0, 4) * 90;
            return Quaternion.Euler(0, angle, 0);
        }

        int GetRandomBlockSize()
        {
            return random.Next(cityConfig.minBlockSize, cityConfig.maxBlockSize + 1);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SimpleCity\SimpleCityDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.SimpleCity
{
    [System.Serializable]
    public struct CityBlockDimension
    {
        [Tooltip(@"If this block is inserted, this marker name take from the theme file")]
        public string markerName;

        [Tooltip(@"The width of the block, in grid coordinates.  E.g. 2 would take up 2 blocks")]
        public int sizeX;

        [Tooltip(@"The length of the block, in grid coordinates.  E.g. 2 would take up 2 blocks")]
        public int sizeZ;

        [Tooltip(@"The chance of this block appearing.  0 - No chance, 1 - Every time.   0.5 = 50% chance of appearing")]
        public float probability;
    }

    public class SimpleCityDungeonConfig : DungeonConfig
    {
        public Vector2 CellSize = new Vector2(4, 4);

        public int minSize = 15;
        public int maxSize = 20;

        public int minBlockSize = 2;
        public int maxBlockSize = 4;

        public float biggerHouseProbability = 0;

        public int cityWallPadding = 1;
        public int cityDoorSize = 1;

		public float roadEdgeRemovalProbability = 0;

        public CityBlockDimension[] customBlockDimensions;

        public int roadWidth = 1;
        
        public bool Mode2D = false;
        
        public override bool IsMode2D()
        {
            return Mode2D;
        }
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SimpleCity\SimpleCityDungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.SimpleCity
{

    public enum SimpleCityCellType
    {
        Road,
        House,
        Park,
        CityWallPadding,
        UserDefined,
        Empty
    }

    public class SimpleCityCell
    {
        public IntVector Position;
        public SimpleCityCellType CellType;
        public Quaternion Rotation;
        public Vector3 BlockSize = new Vector3(1, 0, 1);
        public string MarkerNameOverride;
    }

    public class SimpleCityDungeonModel : DungeonModel
    {
        [HideInInspector]
        public SimpleCityCell[,] Cells = new SimpleCityCell[0, 0];

        [HideInInspector]
        public SimpleCityCell[] WallPaddingCells;

        [HideInInspector]
        public SimpleCityDungeonConfig Config;

        [HideInInspector]
        public int CityWidth;

        [HideInInspector]
        public int CityHeight;

    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SimpleCity\SpatialConstraintProcessorSimpleCity3D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Builders.SimpleCity.SpatialConstraints
{
    public class SpatialConstraintProcessorSimpleCity3D : SpatialConstraintProcessor
    {
        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var cityConfig = context.config as SimpleCityDungeonConfig;
            var cellSize = cityConfig.CellSize;

            var domain = base.GetDomain(context);
            domain.gridSize = new Vector3(cellSize.x, 0, cellSize.y);
            return domain;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Snap\SnapBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Snap.Impl;
using DungeonArchitect.Frameworks.Snap;
using DungeonArchitect.Grammar;
using DungeonArchitect.Themeing;
using RNode = DungeonArchitect.RuntimeGraphs.RuntimeGraphNode<DungeonArchitect.Grammar.GrammarRuntimeGraphNodeData>;

namespace DungeonArchitect.Builders.Snap
{

    public class SnapBuilder : DungeonBuilder
    {
        SnapConfig snapConfig;
        SnapModel snapModel;
        
        new System.Random random;
        ModuleBuildNode buildNode;
        
        /// <summary>
        /// Builds the dungeon layout.  In this method, you should build your dungeon layout and save it in your model file
        /// No markers should be emitted here.   (EmitMarkers function will be called later by the engine to do that)
        /// </summary>
        /// <param name="config">The builder configuration</param>
        /// <param name="model">The dungeon model that the builder will populate</param>
        public override void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            base.BuildDungeon(config, model);
            buildNode = null;
            random = new System.Random((int)config.Seed);
            markers.Clear();

            // We know that the dungeon prefab would have the appropriate config and models attached to it
            // Cast and save it for future reference
            snapConfig = config as SnapConfig;
            snapModel = model as SnapModel;

            if (snapConfig == null)
            {
                Debug.LogError("No snap config script found in dungeon game object");
                return;
            }

            if (snapModel == null)
            {
                Debug.LogError("No snap model script found in dungeon game object");
                return;
            }

            if (snapConfig.snapFlow == null)
            {
                Debug.LogError("No dungeon flow asset defined in the config");
                return;
            }

            // Generate the module info list
            var ModuleInfos = new List<ModuleInfo>();
            {
                var RegisteredModules = new HashSet<SnapModuleEntry>(snapConfig.Modules);

                foreach (var RegisteredModule in RegisteredModules)
                {
                    if (RegisteredModule.module != null)
                    {
                        var moduleInfo = GenerateModuleInfo(RegisteredModule);
                        ModuleInfos.Add(moduleInfo);
                    }
                }
            }

            var dungeonBasePosition = (transform != null) ? transform.position : Vector3.zero;

            var StartNode = new ModuleGrowthNode();
            StartNode.IncomingModuleDoorIndex = -1;
            StartNode.startNode = true;
            StartNode.ModuleTransform = Matrix4x4.TRS(dungeonBasePosition, Quaternion.identity, Vector3.one);

            var OccupiedBounds = new HashSet<Bounds>();

            var LayoutBuildState = new SnapLayoutBuildState();
            LayoutBuildState.ModuleInfoList = ModuleInfos;

            // Build the dungeon flow graph

            var processorSettings = new GraphGrammarProcessorSettings();
            processorSettings.seed = (int)config.Seed;
            processorSettings.runGraphGenerationScripts = snapConfig.runGraphGenerationScripts;
            var processor = new GraphGrammarProcessor(snapConfig.snapFlow, processorSettings);
            processor.Build();
            var levelGraph = processor.Grammar.ResultGraph;
            var startGraphNode = GrammarRuntimeGraphUtils.FindStartNode(levelGraph);

            // Build the main branch
            buildNode = BuildLayoutRecursive(StartNode, ref OccupiedBounds, startGraphNode, LayoutBuildState);
        }
        
        public override bool IsThemingSupported() { return false; }

        // This is called by the builders that do not support theming
        public override void SpawnManagedObjects(DungeonSceneProvider sceneProvider, IDungeonSceneObjectInstantiator objectInstantiator) {
            snapModel.ResetModel();
            markers.Clear();

            if (buildNode == null)
            {
                return;
            }

            sceneProvider.OnDungeonBuildStart();

            // Spawn the modules and register them in the model
            {
                var spawnedModuleList = new List<SnapModuleInstance>();
                TraverseTree(buildNode, delegate (ModuleBuildNode Node)
                {
                    // Spawn a module at this location
                    ModuleInfo moduleInfo = Node.Module;

                    var templateInfo = new GameObjectDungeonThemeItem();
                    templateInfo.Template = moduleInfo.ModuleTemplate.module;
                    //templateInfo.NodeId = moduleInfo.ModuleGuid.ToString();
                    templateInfo.NodeId = Node.ModuleInstanceID;
                    templateInfo.Offset = Matrix4x4.identity;
                    templateInfo.affectsNavigation = true;
                    templateInfo.StaticState = DungeonThemeItemStaticMode.Unchanged;

                    Node.spawnedModule = sceneProvider.AddGameObject(templateInfo, Node.AttachmentConfig.AttachedModuleTransform, objectInstantiator);

                    // Register this in the model
                    var snapModule = new SnapModuleInstance();
                    snapModule.InstanceID = Node.ModuleInstanceID;
                    snapModule.WorldTransform = Node.AttachmentConfig.AttachedModuleTransform;
                    snapModule.WorldBounds = Node.AttachmentConfig.AttachedModuleWorldBounds;
                    spawnedModuleList.Add(snapModule);
                });
                snapModel.modules = spawnedModuleList.ToArray();
            }

            // Generate the list of connections
            {
                var connectionList = new List<SnapModuleConnection>();
                TraverseTree(buildNode, delegate (ModuleBuildNode Node)
                {
                    if (Node.Parent != null)
                    {
                        var Connection = new SnapModuleConnection();
                        Connection.ModuleAInstanceID = Node.ModuleInstanceID;
                        Connection.DoorAIndex = Node.AttachmentConfig.AttachedModuleDoorIndex;

                        Connection.ModuleBInstanceID = Node.Parent.ModuleInstanceID;
                        Connection.DoorBIndex = Node.IncomingDoorIndex;

                        connectionList.Add(Connection);
                    }
                });
                snapModel.connections = connectionList.ToArray();
            }
            
            sceneProvider.OnDungeonBuildStop();

            FixupDoorStates(buildNode);
        }

        T GetArrayEntry<T>(int index, T[] array) where T : class
        {
            if (index < 0 || index >= array.Length)
            {
                return null;
            }

            return array[index];
        }

        void FixupDoorStates(ModuleBuildNode rootNode)
        {
            var moduleConnections = new Dictionary<GameObject, SnapConnection[]>();
            TraverseTree(rootNode, delegate (ModuleBuildNode node)
            {
                if (!moduleConnections.ContainsKey(node.spawnedModule))
                {
                    var connections = node.spawnedModule.GetComponentsInChildren<SnapConnection>();
                    moduleConnections.Add(node.spawnedModule, connections);
                }
            });

            // Set everything to wall
            foreach (var connections in moduleConnections.Values)
            {
                foreach (var connection in connections)
                {
                    connection.UpdateDoorState(SnapConnectionState.Wall);
                }
            }

            var stack = new Stack<ModuleBuildNode>();
            stack.Push(rootNode);
            while (stack.Count > 0)
            {
                ModuleBuildNode top = stack.Pop();
                if (top == null) continue;
                ModuleBuildNode parent = top.Parent;
                if (parent != null)
                {
                    if (top.spawnedModule != null && parent.spawnedModule != null)
                    {
                        int ParentDoorIndex = top.IncomingDoorIndex;
                        int TopDoorIndex = top.AttachmentConfig.AttachedModuleDoorIndex;
                        var parentConnection = GetArrayEntry<SnapConnection>(ParentDoorIndex, moduleConnections[parent.spawnedModule]);
                        var topConnection = GetArrayEntry<SnapConnection>(TopDoorIndex, moduleConnections[top.spawnedModule]);

                        if (parentConnection != null)
                        {
                             parentConnection.UpdateDoorState(SnapConnectionState.Door);
                        }
                        if (topConnection != null)
                        {
                            topConnection.UpdateDoorState(snapConfig.hideDuplicateDoors 
                                ? SnapConnectionState.None
                                : SnapConnectionState.Door);
                        }
                    }
                }

                foreach (var extension in top.Extensions)
                {
                    stack.Push(extension);
                }
            }
        }

        
        delegate void VisitTreeNodeDelegate(ModuleBuildNode Node);
        void TraverseTree(ModuleBuildNode RootNode, VisitTreeNodeDelegate VisitTreeNode)
        {
            var stack = new Stack<ModuleBuildNode>();
            stack.Push(RootNode);
            
            while (stack.Count > 0)
            {
                ModuleBuildNode Top = stack.Pop();
                if (Top == null) continue;

                VisitTreeNode(Top);

                // Add children
                foreach (ModuleBuildNode Extension in Top.Extensions)
                {
                    stack.Push(Extension);
                }
            }
        }


        static void CalculateOccupiedBounds(ModuleBuildNode Node, List<Bounds> OccupiedBounds)
        {
            if (Node == null) return;
            OccupiedBounds.Add(Node.AttachmentConfig.AttachedModuleWorldBounds);

            foreach (var ChildNode in Node.Extensions)
            {
                CalculateOccupiedBounds(ChildNode, OccupiedBounds);
            }
        }

        protected virtual Bounds GetBounds(GameObject target)
        {
            return SnapUtils.GetSnapModuleBounds(target);
        }
        
        ModuleInfo GenerateModuleInfo(SnapModuleEntry modulePrefab)
        {
            var moduleInfo = new ModuleInfo();
            moduleInfo.ModuleTemplate = modulePrefab;
            moduleInfo.ModuleGuid = System.Guid.NewGuid();
            moduleInfo.Bounds = GetBounds(modulePrefab.module);

            // Find the transform of the doors
            SnapUtils.FindConnectionTransforms(modulePrefab.module, out moduleInfo.ConnectionTransforms, out moduleInfo.ConnectionCategory);

            return moduleInfo;
        }

        void DebugLog(string name, ref Matrix4x4 Transform)
        {
            Debug.Log(string.Format(@"{0}: Pos:{1} | Rot:{2} | Scl:{3}", 
                name,
                Matrix.GetTranslation(ref Transform),
                Matrix.GetRotation(ref Transform).eulerAngles,
                Matrix.GetScale(ref Transform)));
        }

        protected virtual Matrix4x4[] FindAttachmentTransforms(ref Matrix4x4 ParentModuleTransform, ref Matrix4x4 IncomingDoorTransform, ref Matrix4x4 AttachmentDoorTransform)
        {
            return SnapUtils.FindAttachmentTransforms(ref ParentModuleTransform, ref IncomingDoorTransform, ref AttachmentDoorTransform);
        }

        Bounds GetModulePrefabBounds(GameObject prefab, Bounds bounds)
        {
            if (prefab == null)
            {
                return bounds;
            }

            return new Bounds( bounds.center - prefab.transform.position, bounds.extents * 2);
        }

        bool FindAttachmentConfiguration(ModuleInfo TargetModule, ModuleInfo IncomingModule, ref Matrix4x4 IncomingModuleTransform,
	            int IncomingDoorIndex, HashSet<Bounds> OccupiedBounds, ref SnapAttachmentConfiguration OutAttachmentConfig)
        {
            int TargetNumDoors = TargetModule.ConnectionTransforms.Length;
            //if (IncomingDoorIndex >= TargetNumDoors) return false;

            if (IncomingDoorIndex < 0 || IncomingModule == null)
            {
                OutAttachmentConfig.AttachedModule = TargetModule;
                OutAttachmentConfig.AttachedModuleDoorIndex = random.Range(0, TargetNumDoors - 1);
                OutAttachmentConfig.AttachedModuleWorldBounds = GetModulePrefabBounds(TargetModule.ModuleTemplate.module, TargetModule.Bounds);
                OutAttachmentConfig.AttachedModuleTransform = IncomingModuleTransform;
                return true;
            }

            //if (IncomingDoorIndex >= TargetNumDoors) return false;
            Matrix4x4 IncomingDoorTransform = IncomingModule.ConnectionTransforms[IncomingDoorIndex];
            string IncomingDoorCategory = IncomingModule.ConnectionCategory[IncomingDoorIndex];

            bool bFoundValid = false;
            int[] ShuffledIndices = MathUtils.GetShuffledIndices(TargetNumDoors, random);
            for (int si = 0; si < ShuffledIndices.Length; si++)
            {
                int Index = ShuffledIndices[si];
                string AttachmentDoorCategory = TargetModule.ConnectionCategory[Index];
                if (AttachmentDoorCategory != IncomingDoorCategory)
                {
                    // The doors do not fit
                    continue;
                }

                Matrix4x4 AttachmentDoorTransform = TargetModule.ConnectionTransforms[Index];

                // Align the module with a door that fits the incoming door
                Matrix4x4[] ModuleTransforms = FindAttachmentTransforms(ref IncomingModuleTransform, ref IncomingDoorTransform, ref AttachmentDoorTransform);

                foreach (var ModuleTransform in ModuleTransforms)
                {
                    if (!snapConfig.RotateModulesToFit)
                    {
                        // Rotation is not allowed. Check if we rotated the module
                        Matrix4x4 ModuleTransformCopy = ModuleTransform;
                        var moduleRotation = Matrix.GetRotation(ref ModuleTransformCopy);
                        if (Mathf.Abs(moduleRotation.eulerAngles.y) > 0.1f)
                        {
                            // Module was rotated
                            continue;
                        }
                    }

                    {
                        // Calculate the bounds of the module 
                        Bounds ModuleWorldBounds = GetModulePrefabBounds(TargetModule.ModuleTemplate.module, TargetModule.Bounds);
                        ModuleWorldBounds = MathUtils.TransformBounds(ModuleTransform, ModuleWorldBounds);
                        Bounds ContractedModuleWorldBounds = ExpandBounds(ModuleWorldBounds, -1 * (snapConfig.CollisionTestContraction + 1e-4f));

                        // Check if this module would intersect with any of the existing modules
                        bool bIntersects = false;
                        foreach (var OccupiedBound in OccupiedBounds)
                        {
                            if (ContractedModuleWorldBounds.Intersects(OccupiedBound))
                            {
                                // intersects. Do not spawn a module here
                                bIntersects = true;
                                break;
                            }
                        }
                        if (bIntersects)
                        {
                            continue;
                        }

                        // We found a valid module. Use this
                        OutAttachmentConfig.AttachedModule = TargetModule;
                        OutAttachmentConfig.AttachedModuleDoorIndex = Index;
                        OutAttachmentConfig.AttachedModuleWorldBounds = ModuleWorldBounds;
                        OutAttachmentConfig.AttachedModuleTransform = ModuleTransform;
                        bFoundValid = true;
                        break;
                    }
                }
            }

	        return bFoundValid;
        }

        int[] FindFilteredModuleList(List<ModuleInfo> ModuleInfoList, string category)
        {
            var indices = new List<int>();
            for (int i = 0; i < ModuleInfoList.Count; i++)
            {
                var moduleInfo = ModuleInfoList[i];
                if (moduleInfo.ModuleTemplate.category == category)
                {
                    indices.Add(i);
                }
            }

            return indices.ToArray();
        }

        public override void DebugDrawGizmos()
        {
            if (snapModel != null)
            {
                foreach (var module in snapModel.modules)
                {
                    Gizmos.color = Color.yellow;
                    Gizmos.DrawWireCube(module.WorldBounds.center, module.WorldBounds.size);
                }
            }
        }

        public override void DebugDraw()
        {
            if (snapModel == null)
            {
                snapModel = model as SnapModel;
            }
            if (snapModel == null)
            {
                return;
            }

            var moduleLookup = new Dictionary<string, SnapModuleInstance>();
            foreach (var module in snapModel.modules)
            {
                moduleLookup.Add(module.InstanceID, module);
            }

            foreach (var connection in snapModel.connections)
            {
                if (moduleLookup.ContainsKey(connection.ModuleAInstanceID) 
                    && moduleLookup.ContainsKey(connection.ModuleBInstanceID))
                {
                    var moduleA = moduleLookup[connection.ModuleAInstanceID];
                    var moduleB = moduleLookup[connection.ModuleBInstanceID];
                    if (moduleA != null && moduleB != null)
                    {
                        var start = moduleA.WorldBounds.center;
                        var end = moduleB.WorldBounds.center;

                        Debug.DrawLine(start, end, Color.red, 0, false);
                    }
                }
            }

        }

        Bounds ExpandBounds(Bounds bounds, float amount)
        {
            amount *= 0.5f;
            var extents = bounds.extents;
            extents += new Vector3(amount, amount, amount);
            extents.x = Mathf.Max(extents.x, 0.0f);
            extents.y = Mathf.Max(extents.y, 0.0f);
            extents.z = Mathf.Max(extents.z, 0.0f);

            bounds.extents = extents;
            return bounds;
        }
        
        ModuleBuildNode BuildLayoutRecursive(ModuleGrowthNode GrowthNode, ref HashSet<Bounds> _OccupiedBounds, RNode graphNode, SnapLayoutBuildState RecursiveState) 
        {
            RecursiveState.NumTries++;
            if (RecursiveState.NumTries >= snapConfig.MaxProcessingPower)
            {
                return null;
            }

            if (graphNode == null || graphNode.Payload == null || graphNode.Payload.nodeType == null)
            {
                return null;
            }

            ModuleGrowthNode Top = GrowthNode;

            // Pick a door from this module to extend
            ModuleBuildNode BestBuildNode = null;

            HashSet<Bounds> OccupiedBounds = new HashSet<Bounds>(_OccupiedBounds);

            int[] ModuleListIndices;
            ModuleListIndices = FindFilteredModuleList(RecursiveState.ModuleInfoList, graphNode.Payload.nodeType.nodeName);
            MathUtils.Shuffle(ModuleListIndices, random);

            for (int si = 0; si < ModuleListIndices.Length; si++)
            {
                int Index = ModuleListIndices[si];

                ModuleInfo Module = RecursiveState.ModuleInfoList[Index];

                var AttachmentConfig = new SnapAttachmentConfiguration();
                if (!FindAttachmentConfiguration(Module, Top.IncomingModule, ref Top.ModuleTransform, Top.IncomingModuleDoorIndex, OccupiedBounds, ref AttachmentConfig))
                {
                    continue;
                }

                var  BuildNode = new ModuleBuildNode();
                BuildNode.AttachmentConfig = AttachmentConfig;
                BuildNode.IncomingDoorIndex = Top.IncomingModuleDoorIndex;
                BuildNode.Module = Module;

                // We found a valid module. Use this
                {
                    Bounds contractedModuleWorldBounds = ExpandBounds(AttachmentConfig.AttachedModuleWorldBounds, -1 * snapConfig.CollisionTestContraction);
                    OccupiedBounds.Add(contractedModuleWorldBounds);
                }

                int AttachmentDoorIndex = AttachmentConfig.AttachedModuleDoorIndex;

                var childGraphNodes = graphNode.Outgoing.ToArray();

                bool allChildrenFound = true;
                foreach (var childGraphNode in childGraphNodes)
                {
                    ModuleBuildNode ChildBuildNode = null;
                    HashSet<Bounds> ChildOccupiedBounds = null;

                    // Extend from this door further
                    var ExtensionDoorIndices = MathUtils.GetShuffledIndices(Module.ConnectionTransforms.Length, random);
                    for (int ExtensionDoorIndexRef = 0; ExtensionDoorIndexRef < ExtensionDoorIndices.Length; ExtensionDoorIndexRef++)
                    {
                        int ExtensionDoorIndex = ExtensionDoorIndices[ExtensionDoorIndexRef];
                        if (ExtensionDoorIndex == AttachmentDoorIndex && Top.IncomingModuleDoorIndex != -1)
                        {
                            // Don't want to extend from the door we came in through
                            continue;
                        }

                        /////////////////////////// TODO; Handle child occupied bounds

                        // Grow this branch further
                        var NextNode = new ModuleGrowthNode();
                        NextNode.IncomingModuleDoorIndex = ExtensionDoorIndex;
                        NextNode.ModuleTransform = AttachmentConfig.AttachedModuleTransform;
                        NextNode.IncomingModule = Module;
                        var ExtensionOccupiedBounds = new HashSet<Bounds>(OccupiedBounds);
                        ModuleBuildNode ExtensionNode = BuildLayoutRecursive(NextNode, ref ExtensionOccupiedBounds, childGraphNode, RecursiveState);

                        if (ExtensionNode != null)
                        {
                            ChildBuildNode = ExtensionNode;
                            ChildOccupiedBounds = ExtensionOccupiedBounds;
                            break;
                        }
                    }

                    if (ChildBuildNode != null)
                    {
                        // We cannot grow the child branches
                        ChildBuildNode.Parent = BuildNode;
                        BuildNode.Extensions.Add(ChildBuildNode);

                        OccupiedBounds = ChildOccupiedBounds;
                    }
                    else
                    {
                        allChildrenFound = false;
                        break;
                    }
                }

                if (allChildrenFound)
                {
                    BestBuildNode = BuildNode;
                    _OccupiedBounds = OccupiedBounds;
                    break;
                }
            }

            return BestBuildNode;
        }
    }


    namespace Impl
    {
        class ModuleInfo
        {
            /// <summary>
            /// The prefab template of the module
            /// </summary>
            public SnapModuleEntry ModuleTemplate;

            /// <summary>
            ///  A unique ID assigned to this actor module (unique to the prefab). Will be different on each build
            /// </summary>
            public System.Guid ModuleGuid;

            /// <summary>
            /// The bounds of the prefab
            /// </summary>
            public Bounds Bounds;

            /// <summary>
            /// The local transforms of each SnapConnection child actor in the module actor
            /// </summary>
            public Matrix4x4[] ConnectionTransforms;


            public string[] ConnectionCategory;
        }

        class SnapAttachmentConfiguration
        {
            public ModuleInfo AttachedModule;
            public int AttachedModuleDoorIndex;
            public Bounds AttachedModuleWorldBounds;
            public Matrix4x4 AttachedModuleTransform;
        }

        class ModuleGrowthNode
        {
            public ModuleGrowthNode()
            {
                IncomingModuleDoorIndex = -1;
                startNode = false;
                ModuleTransform = Matrix4x4.identity;
            }

            public Matrix4x4 ModuleTransform;
            public ModuleInfo IncomingModule;
            public int IncomingModuleDoorIndex;
            public bool startNode;
        }

        class ModuleBuildNode
        {

                public static string GenerateModuleInstanceID(System.Guid ModuleGuid)
                {
                    return "NODE-SNAPMOD-" + ModuleGuid.ToString();
                }

            public ModuleBuildNode()
            {
                ModuleInstanceID = GenerateModuleInstanceID(System.Guid.NewGuid());
                IncomingDoorIndex = -1;
                DepthFromLeaf = 1;
            }

            public string ModuleInstanceID;
            public ModuleInfo Module;
            public int IncomingDoorIndex;
            public SnapAttachmentConfiguration AttachmentConfig;
            public int DepthFromLeaf;
            public List<ModuleBuildNode> Extensions = new List<ModuleBuildNode>();
            public ModuleBuildNode Parent;

            /// <summary>
            /// Reference to the spawned module. This will be set later
            /// </summary>
            public GameObject spawnedModule = null;     
        };

        class SnapLayoutBuildState
        {
            public SnapLayoutBuildState()
            {
                bSafetyBailOut = false;
                NumTries = 0;
                bFoundBestBuild = false;
            }

            /**
            Searching a dense tree can lead to billions of possibilities
            If this flag is set, the search bails out early to avoid a hang
            */
            public bool bSafetyBailOut;
            public int NumTries;
            public bool bFoundBestBuild;
            public List<ModuleInfo> ModuleInfoList = new List<ModuleInfo>();
        };
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Snap\SnapConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Grammar;
using UnityEngine.Serialization;

namespace DungeonArchitect.Builders.Snap
{
    [System.Serializable]
    public class SnapModuleEntry
    {
        [SerializeField]
        public GameObject module = null;

        [SerializeField]
        public string category = "";
    }

    public class SnapConfig : DungeonConfig
    {
        /// <summary>
        /// Specify the list of modules here.  These modules would be stitched together to create your level
        /// </summary>
        [Tooltip(@"Specify the list of modules here.  These modules would be stitched together to create your level")]
        public SnapModuleEntry[] Modules;

        [FormerlySerializedAs("dungeonFlow")] [Tooltip(@"Dungeon flow assets allow you to design layouts for your dungeons using graph grammar")]
        public SnapFlowAsset snapFlow;

        /// <summary>
        /// Grammar production rule graphs can be built using user specified scripts.  Check this if they
        /// should be re-run (and hence regenerate the graph) while processing the graph grammar
        /// </summary>
        [Tooltip(@"Grammar production rule graphs can be built using user specified scripts.  Check this if they should be re-run (and hence regenerate the graph) while processing the graph grammar")]
        public bool runGraphGenerationScripts = false;

        /// <summary>
        /// 
        /// </summary>
        [Tooltip(@"")]
        public bool RotateModulesToFit = true;

        /// <summary>
        /// When modules are stitched together, the builder makes sure they do not overlap.  This parameter is used to 
        /// control the tolerance level.  If set to 0, even the slightest overlap with a nearby module would not create an adjacent module
        /// Leaving to a small number like 100, would tolerate an overlap with nearby module by 100 unreal units.
        /// Adjust this depending on your art asset
        /// </summary>
        [Tooltip(@"When modules are stitched together, the builder makes sure they do not overlap.  This parameter is used to 
	 control the tolerance level.  If set to 0, even the slightest overlap with a nearby module would not create an adjacent module
	 Leaving to a small number like 100, would tolerate an overlap with nearby module by 100 unreal units.
	 Adjust this depending on your art asset")]
        public float CollisionTestContraction = 1;

        [Tooltip(@"When two modules connect, we'll have two copies of the door from each room.   Enable this flag to hide one of the doors.
	 Sometimes, you might not want to do this (e.g. in a 2D tilemap)")]
        public bool hideDuplicateDoors = true;
        
        /// <summary>
        /// Sometimes, the search space is too large (with billions of possibilities) and if a valid path cannot be easily found
        /// (e.g. due to existing occluded geometry) the search would take too long.  This value makes sure the build doesn't
        /// hang and bails out early with the best result it has found till that point.
        /// Increase the value to have better quality result in those cases. Decrease if you notice the build taking too long
        /// or if build speed is a priority (e.g. if you are building during runtime).   A good value is ~1000000
        /// </summary>
        [Tooltip(@"Sometimes, the search space is too large (with billions of possibilities) and if a valid path cannot be easily found
	(e.g. due to existing occluded geometry) the search would take too long.  This value makes sure the build doesn't
	hang and bails out early with the best result it has found till that point.
	Increase the value to have better quality result in those cases. Decrease if you notice the build taking too long
	or if build speed is a priority (e.g. if you are building during runtime).   A good value is ~1000000")]
        public int MaxProcessingPower = 1000000;
        
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Snap\SnapModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Snap
{

    [System.Serializable]
    public class SnapModuleInstance
    {
        /// <summary>
        /// The instance id of the module
        /// </summary>
        public string InstanceID;

        public Matrix4x4 WorldTransform;

        public Bounds WorldBounds;
    }

    [System.Serializable]
    public class SnapModuleConnection
    {
        /// <summary>
        /// The instance ID of the spawned module (See ModuleInstance structure)
        /// </summary>
        public string ModuleAInstanceID;

        /// <summary>
        /// The index of the door(see ModuleInfo structure)
        /// </summary>
        public int DoorAIndex;

        /// <summary>
        /// The instance ID of the spawned module (See ModuleInstance structure)
        /// </summary>
        public string ModuleBInstanceID;

        /// <summary>
        /// The index of the door(see ModuleInfo structure)
        /// </summary>
        public int DoorBIndex;
    }

    public class SnapModel : DungeonModel
    {
        [HideInInspector]
        public SnapModuleInstance[] modules;

        [HideInInspector]
        public SnapModuleConnection[] connections;


        public override void ResetModel()
        {
            modules = new SnapModuleInstance[0];
            connections = new SnapModuleConnection[0];
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Snap\SnapQuery.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Frameworks.Snap;
using UnityEngine;

namespace DungeonArchitect.Builders.Snap
{
    [System.Serializable]
    public struct SnapQueryModuleInfo
    {
        [SerializeField]
        public SnapModuleInstance instanceInfo;

        [SerializeField]
        public GameObject moduleGameObject;

        [SerializeField]
        public SnapQueryConnectionInfo[] connections;
    }

    [System.Serializable]
    public struct SnapQueryConnectionInfo
    {
        [SerializeField]
        public GameObject connectionGameObject;

        [SerializeField]
        public bool isDoor;
    }

    public class SnapQuery : DungeonQuery
    {
        [HideInInspector]
        [SerializeField]
        public SnapQueryModuleInfo[] modules;

        public override void OnPostDungeonBuild()
        {
            var snapModel = GetComponent<SnapModel>();
            // Build the module game object mapping
            var instanceMap = new Dictionary<string, SnapModuleInstance>();
            foreach (var instance in snapModel.modules)
            {
                instanceMap[instance.InstanceID] = instance;
            }

            var moduleList = new List<SnapQueryModuleInfo>();
            var dungeonItemList = FindObjectsOfType<DungeonSceneProviderData>();
            foreach (var dungeonItem in dungeonItemList)
            {
                var instanceId = dungeonItem.NodeId;
                if (!instanceMap.ContainsKey(instanceId)) continue;

                var moduleInfo = new SnapQueryModuleInfo();
                moduleInfo.instanceInfo = instanceMap[instanceId];
                moduleInfo.moduleGameObject = dungeonItem.gameObject;

                // Build the doors 
                var parent = dungeonItem.gameObject;
                var numChildren = parent.transform.childCount;
                var connections = new List<SnapQueryConnectionInfo>();
                for (int i = 0; i < numChildren; i++)
                {
                    var child = parent.transform.GetChild(i);
                    var connectionComponent = child.gameObject.GetComponent<SnapConnection>();
                    if (connectionComponent != null)
                    {
                        var connectionInfo = new SnapQueryConnectionInfo();
                        bool valid = true;
                        if (connectionComponent.doorObject.activeInHierarchy)
                        {
                            connectionInfo.connectionGameObject = connectionComponent.doorObject;
                            connectionInfo.isDoor = true;
                        }
                        else if (connectionComponent.wallObject.activeInHierarchy)
                        {
                            connectionInfo.connectionGameObject = connectionComponent.wallObject;
                            connectionInfo.isDoor = false;
                        }
                        else
                        {
                            valid = false;
                        }

                        if (valid)
                        {
                            connections.Add(connectionInfo);
                        }
                    }
                }
                moduleInfo.connections = connections.ToArray();

                moduleList.Add(moduleInfo);
            }
            modules = moduleList.ToArray();
        }

        public override void Release()
        {
            modules = System.Array.Empty<SnapQueryModuleInfo>();
        }

        public bool GetModuleInfo(Vector3 position, out SnapQueryModuleInfo outModule)
        {
            foreach (var module in modules)
            {
                if (module.instanceInfo.WorldBounds.Contains(position))
                {
                    outModule = module;
                    return true;
                }
            }
            outModule = new SnapQueryModuleInfo();
            return false;
        }

        public GameObject GetModuleGameObject(Vector3 position)
        {
            SnapQueryModuleInfo moduleInfo;
            if (GetModuleInfo(position, out moduleInfo))
            {
                return moduleInfo.moduleGameObject;
            }
            return null;
        }

        public GameObject[] GetModuleIncomingDoors(Vector3 position)
        {
            var doorObjects = new List<GameObject>();
            SnapQueryModuleInfo moduleInfo;
            if (GetModuleInfo(position, out moduleInfo))
            {
                var snapModel = GetComponent<SnapModel>();
                if (snapModel != null && moduleInfo.connections != null)
                {
                    foreach (var door in snapModel.connections)
                    {
                        if (door.ModuleBInstanceID == moduleInfo.instanceInfo.InstanceID)
                        {
                            var doorIndex = door.DoorBIndex;
                            if (doorIndex >= 0 && doorIndex < moduleInfo.connections.Length)
                            {
                                var connection = moduleInfo.connections[doorIndex];
                                if (connection.isDoor)
                                {
                                    doorObjects.Add(connection.connectionGameObject);
                                }
                            }
                        }
                    }
                }
            }
            
            return doorObjects.ToArray();
        }

        public GameObject[] GetModuleOutgoingDoors(Vector3 position)
        {
            var doorObjects = new List<GameObject>();
            SnapQueryModuleInfo moduleInfo;
            if (GetModuleInfo(position, out moduleInfo))
            {
                var snapModel = GetComponent<SnapModel>();
                if (snapModel != null && moduleInfo.connections != null)
                {
                    foreach (var door in snapModel.connections)
                    {
                        if (door.ModuleAInstanceID == moduleInfo.instanceInfo.InstanceID)
                        {
                            var doorIndex = door.DoorAIndex;
                            if (doorIndex >= 0 && doorIndex < moduleInfo.connections.Length)
                            {
                                var connection = moduleInfo.connections[doorIndex];
                                if (connection.isDoor)
                                {
                                    doorObjects.Add(connection.connectionGameObject);
                                }

                            }
                        }
                    }
                }
            }
            return doorObjects.ToArray();
        }

        public GameObject[] GetModuleDoors(Vector3 position)
        {
            var doors = new List<GameObject>();
            doors.AddRange(GetModuleIncomingDoors(position));
            doors.AddRange(GetModuleOutgoingDoors(position));
            return doors.ToArray();
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SnapGridFlow\SnapGridFlowBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Components;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Frameworks.Snap;
using DungeonArchitect.Themeing;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Builders.SnapGridFlow
{
    public class SnapGridFlowBuilder : DungeonBuilder
    {
        new System.Random random;
        bool buildSuccess = false;
        
        public override bool IsThemingSupported()
        {
            return true;
        }

        public override bool DestroyDungeonOnRebuild()
        {
            return true;
        }

        public override void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            base.BuildDungeon(config, model);
            random = new System.Random((int)config.Seed);
            markers.Clear();

            // We know that the dungeon prefab would have the appropriate config and models attached to it
            // Cast and save it for future reference
            var sgfConfig = config as SnapGridFlowConfig;
            var sgfModel = model as SnapGridFlowModel;

            if (sgfConfig == null)
            {
                Debug.LogError("No snap config script found in dungeon game object");
                return;
            }

            if (sgfModel == null)
            {
                Debug.LogError("No snap model script found in dungeon game object");
                return;
            }

            {
                string errorMessage = "";
                if (!sgfConfig.HasValidConfig(ref errorMessage))
                {
                    Debug.LogError(errorMessage);
                    return;
                }
            }

            SgfModuleNode[] snapModules = null;
            FlowLayoutGraph layoutGraph = null;
            var numRetriesLeft = sgfConfig.numGraphRetries;
            buildSuccess = false;
            while (!buildSuccess && numRetriesLeft > 0) {
                var domainExtensions = new FlowDomainExtensions();
                var snapDomainExtension = domainExtensions.GetExtension<SnapGridFlowDomainExtension>();
                snapDomainExtension.ModuleDatabase = sgfConfig.moduleDatabase;

                var execGraph = sgfConfig.flowGraph.execGraph;
                if (execGraph == null || execGraph.resultNode == null)
                {
                    Debug.LogError("Invalid flow exec graph");
                    return;
                }
                
                FlowExecutor executor = new FlowExecutor();
                FlowExecNodeOutputRegistry nodeOutputRegistry;
                
                //var sw = System.Diagnostics.Stopwatch.StartNew();
                if (!executor.Execute(execGraph, random, domainExtensions, numRetriesLeft, out nodeOutputRegistry))
                {
                    Debug.LogError("Failed to produce graph");
                    return;
                }
                //Debug.Log("Time elapsed: " + (sw.ElapsedMilliseconds / 1000.0f) + " s");
                
                numRetriesLeft = Mathf.Max(0, numRetriesLeft - executor.RetriesUsed);

                var execResult = nodeOutputRegistry.Get(execGraph.resultNode.Id);
                if (execResult == null || execResult.State == null)
                {
                    Debug.LogError("Invalid flow exec result");
                    return;
                }

                var execState = execResult.State;
                layoutGraph = execState.GetState<FlowLayoutGraph>();
                
                if (layoutGraph == null)
                {
                    Debug.LogError("Invalid layout graph state");
                    return;
                }

                var boundsAsset = sgfConfig.moduleDatabase.ModuleBoundsAsset;
                var chunkSize = boundsAsset.chunkSize;
                var baseYOffset = chunkSize.y * 0.5f - boundsAsset.doorOffsetY;

                var settings = new SgfLayoutModuleResolverSettings();
                settings.Seed = (int)config.Seed;
                settings.BaseTransform = transform.localToWorldMatrix * Matrix4x4.Translate(new Vector3(0, baseYOffset, 0));
                settings.LayoutGraph = layoutGraph;
                settings.ModuleDatabase = sgfConfig.moduleDatabase;
                settings.MaxResolveFrames = sgfConfig.maxResolverFrames;
                settings.NonRepeatingRooms = sgfConfig.nonRepeatingRooms;

                sgfModel.layoutGraph = layoutGraph;
                sgfModel.snapModules = new SgfModuleNode[0];

                buildSuccess = SgfLayoutModuleResolver.Resolve(settings, out snapModules);
                if (buildSuccess)
                {
                    sgfModel.snapModules = snapModules;
                }
            }
        }

        public override void SpawnManagedObjects(DungeonSceneProvider sceneProvider, IDungeonSceneObjectInstantiator objectInstantiator)
        {
            var sgfModel = model as SnapGridFlowModel;
            if (sgfModel == null)
            {
                return;
            }

            var snapModules = sgfModel.snapModules;
            var layoutGraph = sgfModel.layoutGraph;
            
            if (buildSuccess && snapModules != null && layoutGraph != null)
            {
                // Spawn the module prefabs
                sceneProvider.OnDungeonBuildStart();

                // Spawn the modules and register them in the model
                foreach (var moduleInfo in snapModules)
                {
                    if (moduleInfo.ModuleDBItem == null || moduleInfo.ModuleDBItem.ModulePrefab == null)
                    {
                        continue;
                    }

                    var templateInfo = new GameObjectDungeonThemeItem();
                    templateInfo.Template = moduleInfo.ModuleDBItem.ModulePrefab.gameObject;
                    templateInfo.NodeId = moduleInfo.ModuleInstanceId.ToString();
                    templateInfo.Offset = Matrix4x4.identity;
                    templateInfo.StaticState = DungeonThemeItemStaticMode.Unchanged;
                    templateInfo.externallyManaged = true;

                    var moduleGameObject = sceneProvider.AddGameObject(templateInfo, moduleInfo.WorldTransform, objectInstantiator);
                    moduleInfo.SpawnedModule = moduleGameObject.GetComponent<SnapGridFlowModule>();

                    var spawnedConnections = moduleInfo.SpawnedModule.GetComponentsInChildren<SnapConnection>();

                    var doorInfoValid = spawnedConnections.Length == moduleInfo.Doors.Length;
                    Debug.Assert(doorInfoValid);
                    if (doorInfoValid)
                    {
                        for (var doorIdx = 0; doorIdx < moduleInfo.Doors.Length; doorIdx++)
                        {
                            moduleInfo.Doors[doorIdx].SpawnedDoor = spawnedConnections[doorIdx];
                        }
                    }
                }

                sceneProvider.OnDungeonBuildStop();

                FixupDoorStates(snapModules, layoutGraph);

                //SpawnItems(snapModules, sceneProvider, objectInstantiator);
            }
            else
            {
                Debug.LogError("Cannot build snap graph. Retries exhausted. Try adjusting your flow graph or increasing the num retries parameter");
            }

            Cleanup(snapModules);
        }

        public override void EmitMarkers()
        {
            base.EmitMarkers();
            
            var sgfModel = model as SnapGridFlowModel;
            var snapModules = sgfModel != null ? sgfModel.snapModules : null;
            SpawnItems(snapModules);
        }

        private void SpawnItems(SgfModuleNode[] modules)
        {
            //var levelMarkers = new LevelMarkerList();
            var sgfConfig = config as SnapGridFlowConfig;
            if (sgfConfig == null)
            {
                Debug.LogError("No snap config script found in dungeon game object");
                return;
            }
            
            Markers.Clear();
            random = new System.Random((int)sgfConfig.Seed);
            
            foreach (var module in modules)
            {
                if (module == null || module.SpawnedModule == null) continue;
                
                var placeableMarkers = new List<PlaceableMarker>(module.SpawnedModule.GetComponentsInChildren<PlaceableMarker>());
                MathUtils.Shuffle(placeableMarkers, random);
                
                foreach (var item in module.LayoutNode.items)
                {
                    if (item == null) continue;
                    
                    PlaceableMarker bestMarker = null;
                    foreach (var markerInfo in placeableMarkers)
                    {
                        if (markerInfo.supportedMarkers == null) continue;
                        
                        var supportedMarkers = new List<string>(markerInfo.supportedMarkers);
                        if (supportedMarkers.Contains(item.markerName))
                        {
                            bestMarker = markerInfo;
                            break;
                        }
                    }

                    if (bestMarker != null)
                    {
                        placeableMarkers.Remove(bestMarker);

                        var flowItemMetadata = new FlowItemMetadata
                        {
                            itemId = item.itemId,
                            itemType = item.type,
                            referencedItems = item.referencedItemIds.ToArray(),
                            parentTransform = sgfConfig.spawnItemsUnderRoomPrefabs ? bestMarker.transform.parent : null
                        };

                        var themeMarkerEntry = new PropSocket
                        {
                            SocketType = item.markerName,
                            Transform = bestMarker.transform.localToWorldMatrix,
                            metadata = flowItemMetadata
                        };
                        Markers.Add(themeMarkerEntry);
                    }
                    else
                    {
                        Debug.LogWarning($"Cannot spawn item: {item.markerName}. Make sure you have a placeable marker in the module prefab");
                    }
                }
            }
            
            /*
            // Run the theme engine
            if (levelMarkers.Count > 0)
            {
                var dungeon = GetComponent<Dungeon>();
                if (dungeon != null)
                {
                    var itemSpawnListeners = new List<DungeonItemSpawnListener>();
                    itemSpawnListeners.Add(GetComponent<FlowItemMetadataHandler>());
                    itemSpawnListeners.AddRange(GetComponents<DungeonItemSpawnListener>());
                    
                    var context = new DungeonThemeExecutionContext();
                    context.builder = this;
                    context.config = config;
                    context.model = model;
                    context.spatialConstraintProcessor = null;
                    context.themeOverrideVolumes = new ThemeOverrideVolume[0];
                    context.sceneProvider = sceneProvider;
                    context.objectSpawner = new SyncDungeonSceneObjectSpawner();
                    context.objectInstantiator = objectInstantiator;
                    context.spawnListeners = itemSpawnListeners.ToArray();

                    var themeEngine = new DungeonThemeEngine(context);
                    themeEngine.ApplyTheme(levelMarkers, dungeon.GetThemeAssets());
                }
                else
                {
                    Debug.LogError("Invalid dungeon reference");
                }
            }
            */
        }
        
        public override void OnDestroyed()
        {
            base.OnDestroyed();
            
            var sgfModel = GetComponent<SnapGridFlowModel>();
            if (sgfModel != null)
            {
                sgfModel.layoutGraph = new FlowLayoutGraph();
                sgfModel.snapModules = new SgfModuleNode[0];
            }
        }

        private void Cleanup(SgfModuleNode[] modules)
        {
            // Disable Bounds rendering
            foreach (var module in modules)
            {
                if (module.SpawnedModule != null)
                {
                    module.SpawnedModule.drawBounds = false;
                    
                    // Hide the debug data of the placeable markers
                    var placeableMarkers = module.SpawnedModule.GetComponentsInChildren<PlaceableMarker>();
                    foreach (var placeableMarker in placeableMarkers)
                    {
                        if (placeableMarker != null)
                        {
                            placeableMarker.drawDebugVisuals = false;
                        }
                    }
                }
            }
        }

        private void FixupDoorStates(SgfModuleNode[] snapModules, FlowLayoutGraph layoutGraph)
        {
            var graphQuery = new FlowLayoutGraphQuery(layoutGraph);

            foreach (var moduleInfo in snapModules)
            { 
                var moduleComponent = moduleInfo.SpawnedModule;
                if (moduleComponent == null) continue;
                var connectionComponents = moduleComponent.gameObject.GetComponentsInChildren<SnapConnection>();
                
                for (var doorIdx = 0; doorIdx < moduleInfo.Doors.Length; doorIdx++)
                {
                    var doorInfo = moduleInfo.Doors[doorIdx];
                    doorInfo.SpawnedDoor = connectionComponents[doorIdx];

                    bool foundDoor = false;
                    GameObject spawnedObject = null;
                    
                    bool containsLock = false;
                    FlowItem lockItem = null;
                    
                    if (doorInfo.CellInfo.connectionIdx != -1)
                    {
                        var link = graphQuery.GetLink(doorInfo.CellInfo.linkId);
                        if (link != null)
                        {
                            if (link.state.type != FlowLayoutGraphLinkType.Unconnected)
                            {
                                if (link.source == moduleInfo.ModuleInstanceId)
                                {
                                    // Check if we have a lock here
                                    if (link.state.items != null)
                                    {
                                        foreach (var item in link.state.items)
                                        {
                                            if (item.type == FlowGraphItemType.Lock)
                                            {
                                                containsLock = true;
                                                lockItem = item;
                                                // TODO: Setup Key-Lock metadata
                                            }
                                        }
                                    }

                                    if (containsLock)
                                    {
                                        spawnedObject = doorInfo.SpawnedDoor.UpdateDoorState(SnapConnectionState.DoorLocked, lockItem.markerName);
                                    }
                                    else if (link.state.type == FlowLayoutGraphLinkType.OneWay)
                                    {
                                        spawnedObject = doorInfo.SpawnedDoor.UpdateDoorState(SnapConnectionState.DoorOneWay);
                                    }
                                    else
                                    {
                                        spawnedObject = doorInfo.SpawnedDoor.UpdateDoorState(SnapConnectionState.Door);
                                    }
                                }
                                else
                                {
                                    // Hide the other door so we don't have duplicates.
                                    spawnedObject = doorInfo.SpawnedDoor.UpdateDoorState(SnapConnectionState.None);
                                }
                                
                                foundDoor = true;
                            }
                        }
                    }

                    if (!foundDoor)
                    {
                        spawnedObject = doorInfo.SpawnedDoor.UpdateDoorState(SnapConnectionState.Wall);
                    }

                    if (spawnedObject != null)
                    {
                        if (containsLock && lockItem != null)
                        {
                            var metaDataComponent = spawnedObject.GetComponent<FlowItemMetadataComponent>();
                            if (metaDataComponent == null)
                            {
                                metaDataComponent = spawnedObject.AddComponent<FlowItemMetadataComponent>();
                            }

                            metaDataComponent.itemType = FlowGraphItemType.Lock;
                            metaDataComponent.itemId = lockItem.itemId.ToString();
                            var referencesIds = new List<string>();
                            foreach (var lockRefId in lockItem.referencedItemIds)
                            {
                                referencesIds.Add(lockRefId.ToString());
                            }
                            metaDataComponent.referencedItemIds = referencesIds.ToArray();
                        }
                        else
                        {
                            var metaDataComponent = spawnedObject.GetComponent<FlowItemMetadataComponent>();
                            if (metaDataComponent != null)
                            {
                                DungeonUtils.DestroyObject(metaDataComponent);
                            }
                        }
                    }
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SnapGridFlow\SnapGridFlowConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using UnityEngine;

namespace DungeonArchitect.Builders.SnapGridFlow
{
    public class SnapGridFlowConfig : DungeonConfig
    {
        public SnapGridFlowAsset flowGraph;
        public SnapGridFlowModuleDatabase moduleDatabase;
        
        [Tooltip(@"If the flow graph cannot converge to a solution, retry again this many times.  Usually a dungeon converges within 1-10 tries, depending on how you've designed the flow graph")]
        public int numGraphRetries = 100;

        [Tooltip(@"Items spawned using the SpawnItem node will be placed under their individual room prefabs. This is useful for spawning NPCs under their respective rooms so they can be hidden when the room goes too far away (using visibility graph). However, you'll need to take care of de-parenting the player prefab and placing it back in the root so it doesn't get hidden when the spawn room is streamed out as you move in the dungeon. Check the sample for more info")]
        public bool spawnItemsUnderRoomPrefabs = false;

        [Tooltip(@"The max processing power allotted to the module resolver")]
        public int maxResolverFrames = 10000;
        
        [Tooltip(@"The system tries to not repeat a module within the last few room depths specified below")]
        public int nonRepeatingRooms = 3;
        
        public override bool HasValidConfig(ref string errorMessage)
        {
            if (flowGraph == null)
            {
                errorMessage = "Flow Graph asset is not assigned";
                return false;
            }
            
            if (moduleDatabase == null)
            {
                errorMessage = "Module Database asset is not assigned";
                return false;
            }

            return true;
        }
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SnapGridFlow\SnapGridFlowDebugComponent.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect;
using UnityEngine;

namespace DungeonArchitect.Builders.SnapGridFlow.DebugVisuals
{
    public class SnapGridFlowDebugComponent : MonoBehaviour
    {
        public Dungeon dungeon;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SnapGridFlow\SnapGridFlowDebugVisualizer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D;
using DungeonArchitect.SxEngine;
using UnityEngine;

namespace DungeonArchitect.Builders.SnapGridFlow.DebugVisuals
{
    [ExecuteInEditMode]
    public class SnapGridFlowDebugVisualizer : DungeonEventListener
    {
        private SxWorld world;
        public float offsetY = 3;
        public float nodeRadius = 1.5f;
        
        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            var debugDraw = (dungeon != null) ? dungeon.debugDraw : false;

            if (debugDraw)
            {
                var sgfModel = model as SnapGridFlowModel;
                BuildVisualization(sgfModel.layoutGraph, dungeon);
            }
        }

        public override void OnDungeonDestroyed(Dungeon dungeon)
        {
            DestroyVisualization(dungeon);
            
            if (world != null)
            {
                world.Clear();
            }
        }
        
        void BuildVisualization(FlowLayoutGraph graph, Dungeon dungeon)
        {
            if (graph == null) return;
            var t = dungeon.transform;
            
            // Update the position of the nodes
            {
                var sgfConfig = GetComponent<SnapGridFlowConfig>();
                if (sgfConfig.moduleDatabase != null && sgfConfig.moduleDatabase.ModuleBoundsAsset != null)
                {
                    var chunkSize = sgfConfig.moduleDatabase.ModuleBoundsAsset.chunkSize;
                    foreach (var node in graph.Nodes)
                    {
                        var nodePos = Vector3.Scale(node.coord, chunkSize) + new Vector3(0, offsetY, 0);
                        node.position = t.TransformPoint(nodePos);
                        foreach (var subNode in node.MergedCompositeNodes)
                        {
                            var localSubNodePos = Vector3.Scale(subNode.coord, chunkSize) + new Vector3(0, offsetY, 0);
                            subNode.position = t.TransformPoint(localSubNodePos);
                        }
                    }
                }
            }

            world = new SxWorld();
            var buildSettings = SxLayout3DWorldBuilder.BuildSettings.Create();
            buildSettings.MergedNodeMaterial = SxMaterialRegistry.Get<SxFlowMergedNodeMaterialZWrite>();
            buildSettings.ItemMaterial = SxMaterialRegistry.Get<SxFlowItemMaterialZWrite>();

            var renderSettings = new FlowLayout3DRenderSettings(nodeRadius);
            SxLayout3DWorldBuilder.Build(world, graph, buildSettings, renderSettings);

            DestroyVisualization(dungeon);
            
            var visualizer = new FlowLayoutGraphUnityVisualizer();
            var visualizerGameObject = visualizer.Build(world);
            var debugComponent = visualizerGameObject.AddComponent<SnapGridFlowDebugComponent>();
            debugComponent.dungeon = dungeon;
        }

        void DestroyVisualization(Dungeon dungeon)
        {
            var debugComponents = FindObjectsOfType<SnapGridFlowDebugComponent>();
            var gameObjectsToDestroy = new List<GameObject>();
            foreach (var debugComponent in debugComponents)
            {
                if (debugComponent == null) continue;
                if (debugComponent.dungeon == dungeon)
                {
                    gameObjectsToDestroy.Add(debugComponent.gameObject);
                }
            }
            
            foreach (var obj in gameObjectsToDestroy)
            {
                if (obj == null) continue;
                DungeonUtils.DestroyObject(obj);
            }
        }
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SnapGridFlow\SnapGridFlowModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using UnityEngine;

namespace DungeonArchitect.Builders.SnapGridFlow
{
    public class SnapGridFlowModel : DungeonModel
    {
        [HideInInspector]
        [NonSerialized]
        public FlowLayoutGraph layoutGraph;
        
        [HideInInspector]
        [NonSerialized]
        public SgfModuleNode[] snapModules;
        
        public override void ResetModel()
        {
            layoutGraph = null;
            snapModules = new SgfModuleNode[0];
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SnapGridFlow\SnapGridFlowQuery.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Builders.SnapGridFlow
{
    [System.Serializable]
    public struct SGFQueryModuleInfo
    {
        [SerializeField] 
        public DungeonUID ModuleInstanceId;

        [SerializeField] 
        public Bounds bounds;
    }

    public class SnapGridFlowQuery : DungeonQuery
    {

        [HideInInspector]
        public SGFQueryModuleInfo[] modules;

        private SnapGridFlowModel sgfModel;

        public override void OnPostDungeonBuild()
        {
            sgfModel = GetComponent<SnapGridFlowModel>();
            if (sgfModel == null)
            {
                return;
            }

            var moduleInfoList = new List<SGFQueryModuleInfo>();
            foreach (var node in sgfModel.snapModules)
            {
                var module = node.SpawnedModule;
                
                var info = new SGFQueryModuleInfo();
                info.ModuleInstanceId = node.ModuleInstanceId;
                {
                    var moduleBounds = module.moduleBounds;
                    var boxSize = Vector3.Scale(moduleBounds.chunkSize, MathUtils.ToVector3(module.numChunks));
                    var extent = boxSize * 0.5f;
                    var center = extent;
                    var localBounds = new Bounds(center, boxSize);
                    var localToWorld = module.transform.localToWorldMatrix;
                    info.bounds = MathUtils.TransformBounds(localToWorld, localBounds);
                }
                moduleInfoList.Add(info);
            }

            modules = moduleInfoList.ToArray();
        }

        public override void Release()
        {
            modules = Array.Empty<SGFQueryModuleInfo>();
            sgfModel = null;
        }

        public bool IsValid()
        {
            return modules != null && modules.Length > 0;
        }
        
        SnapGridFlowModel GetModel()
        {
            if (sgfModel == null)
            {
                sgfModel = GetComponent<SnapGridFlowModel>();
            }

            return sgfModel;
        }
        
        public SgfModuleNode GetRoomNodeAtLocation(Vector3 position)
        {
            var instanceId = DungeonUID.Empty;
            foreach (var info in modules)
            {
                var bounds = info.bounds;
                if (bounds.Contains(position))
                {
                    instanceId = info.ModuleInstanceId;
                    break;
                }
            }

            if (instanceId == DungeonUID.Empty)
            {
                return null;
            }

            var model = GetModel();
            if (model == null || model.snapModules == null)
            {
                return null;
            }

            foreach (var node in model.snapModules)
            {
                if (node.ModuleInstanceId == instanceId)
                {
                    return node;
                }
            }

            return null;
        }
        
        public SgfModuleDoor[] GetDoorsInRoomNode(Vector3 position)
        {
            var roomNode = GetRoomNodeAtLocation(position);
            if (roomNode == null || roomNode.SpawnedModule == null)
            {
                return null;
            }

            return roomNode.Doors;
        }
        
        public GameObject GetRoomGameObject(Vector3 position)
        {
            var roomNode = GetRoomNodeAtLocation(position);
            if (roomNode == null || roomNode.SpawnedModule == null)
            {
                return null;
            }

            return roomNode.SpawnedModule.gameObject;
        }

        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SnapGridFlow\SnapGridFlowVisibilityGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using DungeonArchitect.Utils;
using DungeonArchitect.Visibility;
using DungeonArchitect.Visibility.Impl;
using UnityEngine;

namespace DungeonArchitect.Builders.SnapGridFlow
{
    public class SnapGridFlowVisibilityGraph : DungeonEventListener
    {
        public int visibilityDepth = 1;
        public Transform[] trackedObjects;
        
        private VisibilityGraph visibilityGraph = new VisibilityGraph();


        void Update()
        {
            UpdateVisibility();
        }
        
        private void UpdateVisibility() {
            if (trackedObjects.Length == 0)
            {
                // Disable the updates when we don't have any objects to track
                return;
            }
            
            var trackedPositions = new List<Vector3>();
            if (trackedObjects != null)
            {
                foreach (var trackedObject in trackedObjects)
                {
                    if (trackedObject != null)
                    {
                        trackedPositions.Add(trackedObject.position);
                    }
                }
            }

            visibilityGraph.UpdateVisibility(trackedPositions.ToArray());
        }

        private void BuildVisibilityGraph(SnapGridFlowModel model)
        {
            visibilityGraph.Clear();
            visibilityGraph.VisibilityDepth = visibilityDepth;
            
            if (model != null && model.snapModules != null && model.layoutGraph != null)
            {
                var modules = new Dictionary<DungeonUID, SgfModuleNode>();
                var visibilityNodes = new Dictionary<DungeonUID, VisibilityGraphNode>();
                
                foreach (var moduleInfo in model.snapModules)
                {
                    if (moduleInfo == null || moduleInfo.SpawnedModule == null) continue;
                    modules[moduleInfo.ModuleInstanceId] = moduleInfo;
                    
                    var visibilityNode = new GameObjectVisibilityGraphNode(moduleInfo.SpawnedModule.gameObject);
                    visibilityGraph.RegisterNode(visibilityNode);
                    visibilityNodes[moduleInfo.ModuleInstanceId] = visibilityNode;
                }
                
                foreach (var link in model.layoutGraph.Links)
                {
                    if (visibilityNodes.ContainsKey(link.source) && visibilityNodes.ContainsKey(link.destination))
                    {
                        var source = visibilityNodes[link.source];
                        var dest = visibilityNodes[link.destination];
                        
                        source.AddConnection(dest);
                        dest.AddConnection(source);
                    }
                }
            }
        }

        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            BuildVisibilityGraph(model as SnapGridFlowModel);
        }

        public override void OnDungeonDestroyed(Dungeon dungeon)
        {
            visibilityGraph.Clear();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Snap_SideScroller\SnapSideScrollerBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Utils;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

namespace DungeonArchitect.Builders.Snap.SideScroller
{
    public class SnapSideScrollerBuilder : SnapBuilder
    {
        protected override Matrix4x4[] FindAttachmentTransforms(ref Matrix4x4 ParentModuleTransform, ref Matrix4x4 IncomingDoorTransform, ref Matrix4x4 AttachmentDoorTransform)
        {
            var result = new List<Matrix4x4>();

            // Calculate the translation
            {
                Vector3 DesiredOffset;
                Vector3 IncomingDoorPosition = Matrix.GetTranslation(ref IncomingDoorTransform);
                IncomingDoorPosition = ParentModuleTransform.MultiplyPoint3x4(IncomingDoorPosition);
                Vector3 ClampTarget = IncomingDoorPosition;

                Vector3 LocalDoorPosition = Matrix.GetTranslation(ref AttachmentDoorTransform);
                DesiredOffset = ClampTarget - LocalDoorPosition;
                result.Add(Matrix4x4.TRS(DesiredOffset, Quaternion.identity, Vector3.one));
            }

            // Calculate the translation
            {
                Vector3 DesiredOffset;
                Vector3 IncomingDoorPosition = Matrix.GetTranslation(ref IncomingDoorTransform);
                IncomingDoorPosition = ParentModuleTransform.MultiplyPoint3x4(IncomingDoorPosition);
                Vector3 ClampTarget = IncomingDoorPosition;

                Vector3 LocalDoorPosition = Matrix.GetTranslation(ref AttachmentDoorTransform);
                LocalDoorPosition.x *= -1;
                DesiredOffset = ClampTarget - LocalDoorPosition;
                result.Add(Matrix4x4.TRS(DesiredOffset, Quaternion.identity, new Vector3(-1, 1, 1)));
            }

            return result.ToArray();
        }

        protected override Bounds GetBounds(GameObject target)
        {
            var tilemap = target.GetComponentInChildren<Tilemap>();
            var grid = target.GetComponentInChildren<UnityEngine.Grid>();
            if (tilemap != null && grid != null)
            {
                var cellSize = grid.cellSize;
                var worldOrigin = Vector3.Scale(cellSize,tilemap.origin);
                
                var worldSize = Vector3.Scale(cellSize,tilemap.size);
                worldSize.z = 1;
                
                var worldCenter = worldOrigin + worldSize * 0.5f;
                worldCenter.z = 0;
                return new Bounds(worldCenter, worldSize);
            }
            return base.GetBounds(target);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SpatialPartition\BSPDungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.BSP
{

    public static class BSPDungeonMarkerNames
    {
        public static readonly string GroundRoom = "GroundRoom";
        public static readonly string GroundCorridor = "GroundCorridor";
        public static readonly string Door = "Door";
        public static readonly string WallRoom = "WallRoom";
        public static readonly string WallCorridor = "WallCorridor";
        public static readonly string WallSeparator = "WallSeparator";
    }

    // Non-serialized node class, unlike the serialized version. This is easier to work with but cannot be serialized.
    // These objects will finally be converted to the serialized version BSPNode and saved in the model.  
    // Use the BSPDungeonGraphQuery to traverse the serialized graph when loaded from disk
    class BSPNodeObject
    {
        public Rectangle bounds;
        public BSPNodeObject[] children = new BSPNodeObject[0];
        public BSPNodeObject parent;
        public DungeonUID id = DungeonUID.NewUID();
        public int depthFromRoot;
        public int padding;
		public bool horizontalSplit = false;
        //public bool customRoom;
		//public string customRoomId;
		public Color debugColor = Color.blue;
		public bool discarded = false;

		public List<BSPNodeObject> connectedRooms = new List<BSPNodeObject>();

        public NodeConnection[] subtreeLeafConnections = new NodeConnection[0];

        public Rectangle PaddedBounds
        {
            get
            {
                return Rectangle.ExpandBounds(bounds, -1 * padding);
            }
        }

        /// <summary>
        /// This function assumes that the cell is big enough to split. 
        /// Make sure to call CanSplit function before calling this
        /// </summary>
		public void Split(float splitRatio, System.Random random)
        {
			if (bounds.Width == bounds.Length) {
				horizontalSplit = random.NextFloat () < 0.5f;
			} 
			else {
				horizontalSplit = (bounds.Width > bounds.Length);
			}

			int totalSize = horizontalSplit ? bounds.Width : bounds.Length;
            
            int left = Mathf.RoundToInt(totalSize * splitRatio);
            int right = totalSize - left;

            var child0 = new BSPNodeObject();
            child0.parent = this;
            child0.padding = padding;
            child0.depthFromRoot = depthFromRoot + 1;

            var child1 = new BSPNodeObject();
            child1.parent = this;
            child1.padding = padding;
            child1.depthFromRoot = depthFromRoot + 1;

            var loc0 = bounds.Location;
            var size0 = bounds.Size;

            var loc1 = bounds.Location;
            var size1 = bounds.Size;

			if (horizontalSplit)
            {
                size0.x = left;

                loc1.x += left;
                size1.x = right;
            }
            else
            {
                size0.z = left;

                loc1.z += left;
                size1.z = right;
            }

            child0.bounds = new Rectangle(loc0, size0);
            child1.bounds = new Rectangle(loc1, size1);
            
            children = new BSPNodeObject[] { child0, child1 };
        }

        /// <summary>
        /// Check if it is required to split this node.  This happens if the size is greater than the max allowed room size.
        /// In that case a split is required
        /// </summary>
        /// <param name="maxSize"></param>
        /// <returns></returns>
        public bool MustSplit(int maxSize)
        {
            // Make sure that if we split the largest side, the two smaller sides are still big enough
            float largeSide = Mathf.Max(bounds.Width, bounds.Length);
            return largeSide > maxSize;
        }

        public bool CanSplit(int minSize)
        {
            // Make sure that if we split the largest side, the two smaller sides are still big enough
            float largeSide = Mathf.Max(bounds.Width, bounds.Length);
            return largeSide / 2 >= minSize;
        }

    }

	enum BSPNodeDirection {
		Left,
		Right,
		Top,
		Bottom
	}

	public class BSPDungeonBuilder : DungeonBuilder {

        BSPDungeonConfig bspConfig;
        BSPDungeonModel bspModel;

		new System.Random random;

		/// <summary>
		/// Builds the dungeon layout.  In this method, you should build your dungeon layout and save it in your model file
		/// No markers should be emitted here.   (EmitMarkers function will be called later by the engine to do that)
		/// </summary>
		/// <param name="config">The builder configuration</param>
		/// <param name="model">The dungeon model that the builder will populate</param>
		public override void BuildDungeon(DungeonConfig config, DungeonModel model)
		{
			base.BuildDungeon(config, model);

			random = new System.Random((int)config.Seed);

			// We know that the dungeon prefab would have the appropriate config and models attached to it
			// Cast and save it for future reference
			bspConfig = config as BSPDungeonConfig;
            bspModel = model as BSPDungeonModel;
            bspModel.Config = bspConfig;

			// Generate the level layout and save it in a model.   No markers are emitted here. 
			GenerateLevelLayout();
		}

        public override void OnDestroyed() {
            base.OnDestroyed();
            if (model != null)
            {
                model.ResetModel();
            }
        }

		/// <summary>
		/// Override the builder's emit marker function to emit our own markers based on the layout that we built
		/// You should emit your markers based on the layout you have saved in the model generated previously
		/// When the user is designing the theme interactively, this function will be called whenever the graph state changes,
		/// so the theme engine can populate the scene (BuildDungeon will not be called if there is no need to rebuild the layout again)
		/// </summary>
		public override void EmitMarkers()
		{
			base.EmitMarkers();

			EmitLevelMarkers();
            
			ProcessMarkerOverrideVolumes();
		}

		void GenerateLevelLayout() {
            var rootNode = new BSPNodeObject();
            rootNode.bounds = new Rectangle(0, 0, bspConfig.dungeonWidth, bspConfig.dungeonLength);
            rootNode.padding = bspConfig.roomPadding;
            rootNode.depthFromRoot = 0;

            BuildDungeonGraph(rootNode);

            ConnectDoors(rootNode);


            GenerateCustomRooms(rootNode);

            DiscardExtraRooms(rootNode);

            SerializeGraph(rootNode);
        }
        
        void DebugRoomLayout(BSPNodeObject rootNode)
        {
			var edgeRooms = new List<BSPNodeObject>();
			FindBoundaryEdgeRooms(rootNode.children[1], BSPNodeDirection.Left, edgeRooms);

			foreach (var room in edgeRooms)
			{
				room.debugColor = Color.red;
			}
        }

        BSPNodeObject GetCornerSubtreeNode(BSPNodeObject node, bool left) {
            if (node.children == null || node.children.Length == 0)
            {
                return node;
            }

            var child = left ? node.children[0] : node.children[1];
            return GetCornerSubtreeNode(child, left);
        }
            
		void GenerateCustomRooms(BSPNodeObject rootNode)
		{
            
		}

        void DiscardExtraRooms(BSPNodeObject rootNode)
        {
            TraverseTree(rootNode, n => n.discarded = true);

            FlagConnectedLeafNodes(rootNode);

            int numNodes = 0;
            TraverseTree(rootNode, n => numNodes++);

            int maxTries = numNodes;
            int numTries = 0;

            while (ConnectActiveSubtrees(rootNode) && numTries <= maxTries)
            {
                numTries++;
            }

        }

        void FlagConnectedLeafNodes(BSPNodeObject node) 
        {
            if (node.depthFromRoot >= bspConfig.randomKillDepthStart)
            {
                return;
            }

            foreach (var connection in node.subtreeLeafConnections)
            {
                TraverseParentBranch(connection.Room0, n => n.discarded = false);
                TraverseParentBranch(connection.Room1, n => n.discarded = false);
            }

            foreach (var child in node.children)
            {
                FlagConnectedLeafNodes(child);
            }
        }

        bool ConnectActiveSubtrees(BSPNodeObject node) {
            bool stateModified = false;

            foreach (var child in node.children)
            {
                stateModified |= ConnectActiveSubtrees(child);
            }

            if (node.discarded)
            {
                return stateModified;
            }

            bool bothChildrenActive = (node.children.Length == 2 && !node.children[0].discarded && !node.children[1].discarded);

            if (bothChildrenActive)
            {
                foreach (var connection in node.subtreeLeafConnections)
                {
                    //connection.Room0.discarded = false;
                    //connection.Room1.discarded = false;
                    TraverseParentBranch(connection.Room0, n => {
                        if (n.discarded) {
                            n.discarded = false;
                            stateModified = true;
                        }
                    });
                    TraverseParentBranch(connection.Room1, n => {
                        if (n.discarded) {
                            n.discarded = false;
                            stateModified = true;
                        }
                    });
                }
            }

            return stateModified;
        }


        void DiscardSubtree(BSPNodeObject node) {
            TraverseTree(node, n => n.discarded = true);
        }

        void TraverseTree(BSPNodeObject node, System.Action<BSPNodeObject> visit) {
            // traverse the children
            foreach (var child in node.children)
            {
                TraverseTree(child, visit);
            }

            visit(node);
        }

        void TraverseParentBranch(BSPNodeObject node, System.Action<BSPNodeObject> visit) {
            if (node == null)
            {
                return;
            }

            visit(node);

            TraverseParentBranch(node.parent, visit);
        }

        void ConnectDoors(BSPNodeObject node)
		{
			if (node.discarded || node.children == null) return;

			// Connect the children
			foreach (var child in node.children) {
				ConnectDoors(child);
			}

            // Connect the siblings
            if (node.children.Length == 2) {
                node.subtreeLeafConnections = ConnectPartitions(node.children [0], node.children [1], node.horizontalSplit);
            }

        }


        NodeConnection[] GetConnectionCandidates(BSPNodeObject[] leftRooms, BSPNodeObject[] rightRooms) {
            var connections = new List<NodeConnection>();

            foreach (var leftRoom in leftRooms)
            {
                foreach (var rightRoom in rightRooms)
                {
                    // Connect left and right together
                    var intersection = Rectangle.Intersect(leftRoom.bounds, rightRoom.bounds);
                    var minIntersection = bspConfig.roomPadding * 2;
                    if (intersection.Size.x > minIntersection || intersection.Size.z > minIntersection)
                    {
                        var connection = new NodeConnection(leftRoom, rightRoom, bspConfig.roomPadding);
                        connections.Add(connection);
                    }
                }
            }

            return connections.ToArray();
        }

        void Shuffle(List<BSPNodeObject> nodes) {
            for (int i = 0; i < nodes.Count; i++)
            {
                int j = random.Next() % nodes.Count;
                var temp = nodes[j];
                nodes[j] = nodes[i];
                nodes[i] = temp;
            }
        }

        NodeConnection[] ConnectPartitions(BSPNodeObject leftPartition, BSPNodeObject rightPartition, bool horizontalSplit) {
            var connections = new List<NodeConnection>();

			if (leftPartition.discarded || rightPartition.discarded)
			{
                return connections.ToArray();
			}
			
			var leftRooms = new List<BSPNodeObject>();
			var rightRooms = new List<BSPNodeObject>();

			if (horizontalSplit)
			{
				FindBoundaryEdgeRooms(leftPartition, BSPNodeDirection.Right, leftRooms);
				FindBoundaryEdgeRooms(rightPartition, BSPNodeDirection.Left, rightRooms);
			}
			else   // Vertical split
			{
				// Left = bottom partition
				// Right = top partition
				FindBoundaryEdgeRooms(leftPartition, BSPNodeDirection.Top, leftRooms);
				FindBoundaryEdgeRooms(rightPartition, BSPNodeDirection.Bottom, rightRooms);
			}

			// Connect the two rooms together
			if (leftRooms.Count == 0 || rightRooms.Count == 0)
            {
                return connections.ToArray();
			}

            Shuffle(leftRooms);
            Shuffle(rightRooms);

			bool roomsConnected = false;
			foreach (var leftRoom in leftRooms)
			{
				// First check if any of the right rooms are connected
				foreach (var rightRoom in rightRooms)
				{
					if (leftRoom.connectedRooms.Contains(rightRoom))
					{
						roomsConnected = true;
						break;
					}
				}

				foreach (var rightRoom in rightRooms)
				{
					if (leftRoom.connectedRooms.Contains(rightRoom))
					{
						// Already connected
						continue;
					}

					bool shouldConnectRooms = true;
					if (roomsConnected)
					{
						// rooms are already connected along this edge.  Check if can loop
						shouldConnectRooms = random.NextFloat() < bspConfig.loopingProbability;
					}

					if (shouldConnectRooms)
					{
						// Connect left and right together
						var intersection = Rectangle.Intersect(leftRoom.bounds, rightRoom.bounds);
						var minIntersection = bspConfig.roomPadding * 2;
						if (intersection.Size.x > minIntersection || intersection.Size.z > minIntersection)
						{
							// These two rooms can connect
							leftRoom.connectedRooms.Add(rightRoom);
							rightRoom.connectedRooms.Add(leftRoom);
							roomsConnected = true;

                            var connection = new NodeConnection(leftRoom, rightRoom, bspConfig.roomPadding);
                            connections.Add(connection);
						}
					}

				}
            }

            return connections.ToArray();
		}

		void FindBoundaryEdgeRooms(BSPNodeObject node, BSPNodeDirection direction, List<BSPNodeObject> result) {
			if (node.discarded)
			{
				return;
			}

			bool hasChildren = (node.children != null && node.children.Length > 0);
			if (!hasChildren)
			{
				result.Add(node);
				return;
			}

			if (node.horizontalSplit)
			{
				if (direction == BSPNodeDirection.Left)
				{
					FindBoundaryEdgeRooms(node.children[0], direction, result);
				}
				else if (direction == BSPNodeDirection.Right)
				{
					FindBoundaryEdgeRooms(node.children[1], direction, result);
				}
				else
				{
					FindBoundaryEdgeRooms(node.children[0], direction, result);
					FindBoundaryEdgeRooms(node.children[1], direction, result);
				}
			}
			else  // Vertical split
			{
				if (direction == BSPNodeDirection.Bottom)
				{
					FindBoundaryEdgeRooms(node.children[0], direction, result);
				}
				else if (direction == BSPNodeDirection.Top)
				{
					FindBoundaryEdgeRooms(node.children[1], direction, result);
				}
				else
				{
					FindBoundaryEdgeRooms(node.children[0], direction, result);
					FindBoundaryEdgeRooms(node.children[1], direction, result);
				}
			}
		}

        void BuildDungeonGraph(BSPNodeObject node)
        {
            int targetMinRoomSize = bspConfig.minRoomSize + bspConfig.roomPadding * 2;
            int targetMaxRoomSize = bspConfig.maxRoomSize + bspConfig.roomPadding * 2;

            if (!node.CanSplit(targetMinRoomSize))
            {
                // Node is too small to split further
                return;
            }

            bool shouldSplit;
            if (node.MustSplit(targetMaxRoomSize))
            {
                shouldSplit = true;
            }
            else
            {
                // Check if the aspect ratio would be correct after a split

                // Use a probability to decide if we split
                shouldSplit = random.NextFloat() < bspConfig.smallerRoomProbability;
                
            }

            if (shouldSplit)
            {
                float splitRatio = 0.5f;
                bool unevenSplit = random.NextFloat() < bspConfig.unevenSplitProbability;
                if (unevenSplit)
                {
                    int sizeToSplit = Mathf.Max(node.bounds.Width, node.bounds.Length);

                    int allowedSplitDistance = sizeToSplit - 2 * targetMinRoomSize;
                    if (allowedSplitDistance > 0)
                    {
                        float allowedSplitRatio = allowedSplitDistance / (float)sizeToSplit;
                        var randomValue = random.NextFloat();    // get a random value between 0..1
                        randomValue = randomValue * 2 - 1;  // transform to -1..1

                        // From 0.5, we are going to move the split either to the left or right by half of the allowed ratio (-1..1 * halfAllowedSplitRatio)
                        splitRatio = 0.5f + randomValue * allowedSplitRatio / 2.0f;
                    }
                }
                node.Split(splitRatio, random);
            }

            // Process the children
            foreach (var child in node.children)
            {
                BuildDungeonGraph(child);
            }
        }
        

        void EmitLevelMarkers()
        {
            var gridSize3D = new Vector3(bspConfig.gridSize.x, 0, bspConfig.gridSize.y);
            foreach (var node in bspModel.nodes)
            {
                if (node.discarded) continue;
                // Draw the ground tiles
                if (node.children.Length == 0)
                {
                    var paddedBounds = node.paddedBounds;
                    for (int x = 0; x < paddedBounds.Size.x; x++)
                    {
                        for (int z = 0; z < paddedBounds.Size.z; z++)
                        {
                            Vector3 position = Vector3.Scale(new Vector3(paddedBounds.Location.x + x + 0.5f, 0, paddedBounds.Location.z + z + 0.5f), gridSize3D);
                            
                            var transform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
                            EmitMarker(BSPDungeonMarkerNames.GroundRoom, transform, new IntVector(x, 0, z), -1);
                        }
                    }
                }
            }

            var doorPositions = new HashSet<IntVector>();

            foreach (var connection in bspModel.connections)
            {
                var offset = connection.doorFacingX ? new Vector3(0, 0, 0.5f) : new Vector3(0.5f, 0, 0);
                var pos0 = connection.doorPosition0;
                var pos1 = connection.doorPosition1;
                var pos0F = pos0.ToVector3();
                var pos1F = pos1.ToVector3();

                // Emit the doors
                {
                    Vector3 worldPos0 = Vector3.Scale(pos0F + offset, gridSize3D);
                    Vector3 worldPos1 = Vector3.Scale(pos1F + offset, gridSize3D);
                    float angle0 = connection.doorFacingX ? 90 : 0;
                    float angle1 = connection.doorFacingX ? 270 : 180;

                    Matrix4x4 transform;

                    transform = Matrix4x4.TRS(worldPos0, Quaternion.Euler(0, angle0, 0), Vector3.one);
                    EmitMarker(BSPDungeonMarkerNames.Door, transform, pos0, -1);

                    transform = Matrix4x4.TRS(worldPos1, Quaternion.Euler(0, angle1, 0), Vector3.one);
                    EmitMarker(BSPDungeonMarkerNames.Door, transform, pos1, -1);

                    doorPositions.Add(pos0);
                    doorPositions.Add(pos1);
                }

                int x0 = Mathf.Min(pos0.x, pos1.x);
                int x1 = Mathf.Max(pos0.x, pos1.x);
                int z0 = Mathf.Min(pos0.z, pos1.z);
                int z1 = Mathf.Max(pos0.z, pos1.z);

                if (x0 == x1) z1--;
                if (z0 == z1) x1--;

                // Draw the corridor ground tiles
                for (int x = x0; x <= x1; x++)
                {
                    for (int z = z0; z <= z1; z++)
                    {
                        var doorGroundPosition = Vector3.Scale(new Vector3(x + 0.5f, 0, z + 0.5f), gridSize3D);
                        var transform = Matrix4x4.TRS(doorGroundPosition, Quaternion.identity, Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.GroundCorridor, transform, new IntVector(x, 0, z), -1);
                    }
                }

                // Draw the corridor walls
                if (x0 == x1)
                {
                    for (int z = z0; z <= z1; z++)
                    {
                        var worldPos = Vector3.Scale(new Vector3(x0, 0, z + 0.5f), gridSize3D);
                        var transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 90, 0), Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.WallCorridor, transform, new IntVector(x0, 0, z), -1);

                        worldPos = Vector3.Scale(new Vector3(x0 + 1, 0, z + 0.5f), gridSize3D);
                        transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 270, 0), Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.WallCorridor, transform, new IntVector(x1, 0, z), -1);
                    }
                }
                else
                {
                    for (int x = x0; x <= x1; x++)
                    {
                        var worldPos = Vector3.Scale(new Vector3(x + 0.5f, 0, z0), gridSize3D);
                        var transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 0, 0), Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.WallCorridor, transform, new IntVector(x, 0, z0), -1);

                        worldPos = Vector3.Scale(new Vector3(x + 0.5f, 0, z0 + 1), gridSize3D);
                        transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 180, 0), Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.WallCorridor, transform, new IntVector(x, 0, z1), -1);
                    }
                }
            }

            foreach (var node in bspModel.nodes)
            {
                if (node.discarded || node.children.Length > 0)
                {
                    continue;
                }

                var loc = node.paddedBounds.Location;
                var size = node.paddedBounds.Size;
                int x0 = loc.x;
                int x1 = loc.x + size.x;
                int z0 = loc.z;
                int z1 = loc.z + size.z;

                // Emit he walls 
                {
                    for (int x = x0; x < x1; x++)
                    {
                        if (!doorPositions.Contains(new IntVector(x, 0, z0)))
                        {
                            var worldPos = Vector3.Scale(new Vector3(x + 0.5f, 0, z0), gridSize3D);
                            var transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 0, 0), Vector3.one);
                            EmitMarker(BSPDungeonMarkerNames.WallRoom, transform, new IntVector(x, 0, z0), -1);
                        }

                        if (!doorPositions.Contains(new IntVector(x, 0, z1)))
                        {
                            var worldPos = Vector3.Scale(new Vector3(x + 0.5f, 0, z1), gridSize3D);
                            var transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 180, 0), Vector3.one);
                            EmitMarker(BSPDungeonMarkerNames.WallRoom, transform, new IntVector(x, 0, z1), -1);
                        }
                    }

                    for (int z = z0; z < z1; z++)
                    {

                        if (!doorPositions.Contains(new IntVector(x0, 0, z)))
                        {
                            var worldPos = Vector3.Scale(new Vector3(x0, 0, z + 0.5f), gridSize3D);
                            var transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 90, 0), Vector3.one);
                            EmitMarker(BSPDungeonMarkerNames.WallRoom, transform, new IntVector(x0, 0, z), -1);
                        }

                        if (!doorPositions.Contains(new IntVector(x1, 0, z)))
                        {
                            var worldPos = Vector3.Scale(new Vector3(x1, 0, z + 0.5f), gridSize3D);
                            var transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 270, 0), Vector3.one);
                            EmitMarker(BSPDungeonMarkerNames.WallRoom, transform, new IntVector(x1, 0, z), -1);
                        }
                    }
                }

                // Emit the wall separators
                {
                    for (int x = x0; x <= x1; x++)
                    {
                        var worldPos = Vector3.Scale(new Vector3(x, 0, z0), gridSize3D);
                        var transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 0, 0), Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.WallSeparator, transform, new IntVector(x, 0, z0), -1);

                        worldPos = Vector3.Scale(new Vector3(x, 0, z1), gridSize3D);
                        transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 0, 0), Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.WallSeparator, transform, new IntVector(x, 0, z1), -1);
                    }

                    for (int z = z0 + 1; z <= z1 - 1; z++)
                    {
                        var worldPos = Vector3.Scale(new Vector3(x0, 0, z), gridSize3D);
                        var transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 0, 0), Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.WallSeparator, transform, new IntVector(x0, 0, z), -1);

                        worldPos = Vector3.Scale(new Vector3(x1, 0, z), gridSize3D);
                        transform = Matrix4x4.TRS(worldPos, Quaternion.Euler(0, 0, 0), Vector3.one);
                        EmitMarker(BSPDungeonMarkerNames.WallSeparator, transform, new IntVector(x1, 0, z), -1);
                    }
                }
            }

        }

        void SerializeGraph(BSPNodeObject rootNode)
        {
            var serializedNodes = new List<BSPNode>();
            var serializedConnections = new List<BSPNodeConnection>();

            SerializeGraph(rootNode, serializedNodes, serializedConnections);

            bspModel.nodes = serializedNodes.ToArray();
            bspModel.connections = serializedConnections.ToArray();

            bspModel.rootNode = rootNode.id;
        }

        void SerializeGraph(BSPNodeObject node, List<BSPNode> serializedNodes, List<BSPNodeConnection> serializedConnections)
        {
			if (node == null)
			{
				return;
			}

            var serializedNode = new BSPNode();
            serializedNode.id = node.id;
            serializedNode.bounds = node.bounds;
            serializedNode.paddedBounds = node.PaddedBounds;
            serializedNode.depthFromRoot = node.depthFromRoot;
			serializedNode.debugColor = node.debugColor;
			serializedNode.discarded = node.discarded;
            
            if (node.parent != null)
            {
                serializedNode.parent = node.parent.id;
            }

            var childIds = new List<DungeonUID>();
            foreach (var child in node.children)
            {
				if (child != null)
				{
					childIds.Add(child.id);
				}
            }
            serializedNode.children = childIds.ToArray();
            
			var connectedIds = new List<DungeonUID>();
			foreach (var connectedRoom in node.connectedRooms)
			{
				connectedIds.Add(connectedRoom.id);
			}
			serializedNode.connectedRooms = connectedIds.ToArray();

            var subtreeLeafConnections = new List<BSPNodeConnection>();
            foreach (var connection in node.subtreeLeafConnections)
            {
                var serializedConnection = new BSPNodeConnection();
                serializedConnection.room0 = connection.Room0.id;
                serializedConnection.room1 = connection.Room1.id;
                serializedConnection.doorPosition0 = connection.DoorPosition0;
                serializedConnection.doorPosition1 = connection.DoorPosition1;
                serializedConnection.doorFacingX = connection.DoorFacingX;
                subtreeLeafConnections.Add(serializedConnection);

                if (!connection.Room0.discarded && !connection.Room1.discarded)
                {
                    serializedConnections.Add(serializedConnection);
                }
            }
            serializedNode.subtreeLeafConnections = subtreeLeafConnections.ToArray();
            
			serializedNodes.Add(serializedNode);

            // Serialize the children
            foreach (var child in node.children)
            {
                SerializeGraph(child, serializedNodes, serializedConnections);
            }
        }

        public override void DebugDraw()
        {
            if (!bspModel) return;

            var gridSize3D = new Vector3(bspConfig.gridSize.x, 0, bspConfig.gridSize.y);
			var graphQuery = bspModel.CreateGraphQuery();
            var discardedColor = new Color(0, 0, 0, 0.35f);
            var debugTextItems = new List<DebugTextItem>();
            int debugDoorIndex = 0;
            foreach (var node in bspModel.nodes)
            {
                if (!node.discarded) 
                {
                    //continue;
                }
                //DebugDrawUtils.DrawBounds(node.bounds, Color.green, gridSize3D, false);

                // Draw the room
                if (node.children.Length == 0)
                {
                    // only render leaf nodes
                    var paddedBounds = node.paddedBounds;
                    var color = node.discarded ? discardedColor : node.debugColor;
                    DebugDrawUtils.DrawBounds(paddedBounds, color, gridSize3D, false);

                }

                var connectionColor = Color.red;

                bool renderedDoors = false;
				// Draw the connected rooms
				//foreach (var connectedNodeId in node.connectedRooms)
                foreach (var leafConnection in node.subtreeLeafConnections)
                {
                    var room0 = graphQuery.GetNode(leafConnection.room0);
                    var room1 = graphQuery.GetNode(leafConnection.room1);
					//var connectedNode = graphQuery.GetNode(connectedNodeId);
					var intersection = Rectangle.Intersect(room0.bounds, room1.bounds);
					var center = intersection.Center();
                    var centerF = IntVector.ToV3(center);
                    var centerWorld = Vector3.Scale(centerF, gridSize3D);
					var offsetStart = Vector3.zero;
					var offsetEnd = Vector3.zero;
					var padding = bspConfig.roomPadding;

                    var doorOffset0 = Vector3.zero;
                    var doorOffset1 = Vector3.zero;

                    var textOffset = Vector3.zero;

					if (intersection.Size.x > 0)
					{
						offsetStart.z -= padding;
						offsetEnd.z += padding;

                        doorOffset0.x -= 0.0f;
                        doorOffset1.x += 1.0f;

                        textOffset.x -= 1;
                        textOffset.z += 1.0f;
					}
					else
					{
						offsetStart.x -= padding;
                        offsetEnd.x += padding;

                        doorOffset0.z -= 0.0f;
                        doorOffset1.z += 1.0f;

                        textOffset.x -= 0.25f;
					}

                    offsetStart = Vector3.Scale(offsetStart, gridSize3D);
                    offsetEnd = Vector3.Scale(offsetEnd, gridSize3D);

                    doorOffset0 = Vector3.Scale(doorOffset0, gridSize3D);
                    doorOffset1 = Vector3.Scale(doorOffset1, gridSize3D);

                    textOffset = Vector3.Scale(textOffset, gridSize3D);

                    bool discarded = (room0.discarded || room1.discarded);
                    var doorColor = discarded ? discardedColor : connectionColor;
                    Debug.DrawLine(centerWorld + offsetStart + doorOffset0, centerWorld + offsetEnd + doorOffset0, doorColor);
                    Debug.DrawLine(centerWorld + offsetStart + doorOffset1, centerWorld + offsetEnd + doorOffset1, doorColor);

                    if (!discarded)
                    {
                        var debugText = new DebugTextItem();
                        debugText.position = centerWorld + textOffset;
                        debugText.color = Color.black;
                        debugText.message = "" + (char)('A' + debugDoorIndex);
                        debugTextItems.Add(debugText);

                        renderedDoors = true;
                    }
				}

                if (renderedDoors)
                {
                    debugDoorIndex++;
                }
            }

            var debugText3D = GetComponent<DebugText3D>();
            if (debugText3D != null)
            {
                debugText3D.items = debugTextItems.ToArray();
            }
        }
    }

    class NodeConnection {
        BSPNodeObject room0;
        public BSPNodeObject Room0
        {
            get
            {
                return room0;
            }
        }

        BSPNodeObject room1;
        public BSPNodeObject Room1
        {
            get
            {
                return room1;
            }
        }
        
        bool doorFacingX;
        public bool DoorFacingX
        {
            get { return doorFacingX; }
        }

        IntVector doorPosition0;
        public IntVector DoorPosition0
        {
            get { return doorPosition0; }
            set { doorPosition0 = value; }
        }

        IntVector doorPosition1;
        public IntVector DoorPosition1
        {
            get { return doorPosition1; }
            set { doorPosition1 = value; }
        }

        public NodeConnection(BSPNodeObject room0, BSPNodeObject room1, int padding) {
            this.room0 = room0;
            this.room1 = room1;

            var intersection = Rectangle.Intersect(room0.bounds, room1.bounds);
            var center = intersection.Center();
            if (intersection.Size.x > 0)
            {
                doorPosition0 = center + new IntVector(0, 0, padding);
                doorPosition1 = center - new IntVector(0, 0, padding);
                doorFacingX = false;
            }
            else
            {
                doorPosition0 = center + new IntVector(padding, 0, 0);
                doorPosition1 = center - new IntVector(padding, 0, 0);
                doorFacingX = true;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SpatialPartition\BSPDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.BSP
{
    [System.Serializable]
    public struct BSPRoomCategory
    {
        public string category;
        public int width;
        public int length;
        public int minOccurance;
        public int maxOccurance;
        public Color debugColor;
    }

    public class BSPDungeonConfig : DungeonConfig {
        public Vector2 gridSize = new Vector2(4, 4);

        /// <summary>
        /// The width of the dungeon in tile coords
        /// </summary>
        public int dungeonWidth = 32;
        
        /// <summary>
        /// The length of the dungeon in tile coords
        /// </summary>
        public int dungeonLength = 24;


        public int minRoomSize = 3;
        public int maxRoomSize = 8;

        /// <summary>
        /// Larger split probability will create small rooms close to the minRoomSize
        /// Smaller values will create larger rooms closers to the max room size since they are not split further
        /// </summary>
        public float smallerRoomProbability = 0.5f;

        public float unevenSplitProbability = 0.0f;
        
        public int roomPadding = 1;

        public float loopingProbability = 0;

        public int randomKillDepthStart = 3;
        public float randomKillProbability = 0.2f;

        public float minAspectRatio = 0.7f;

        public BSPRoomCategory[] customRooms;
        
        public bool Mode2D = false;
        
        public override bool IsMode2D()
        {
            return Mode2D;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SpatialPartition\BSPDungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Builders.BSP
{
    [System.Serializable]
    public struct BSPNode
    {
        public DungeonUID id;
        public Rectangle bounds;
        public Rectangle paddedBounds;
        public int depthFromRoot;
        public string roomCategory;

        public DungeonUID parent;
        public DungeonUID[] children;

        public DungeonUID[] connectedRooms;

        public BSPNodeConnection[] subtreeLeafConnections;

        public Color debugColor;
        public bool discarded;
    }

    [System.Serializable]
    public struct BSPNodeConnection
    {
        public DungeonUID room0; 
        public DungeonUID room1;

        public IntVector doorPosition0;
        public IntVector doorPosition1;

        public bool doorFacingX;
    }

    public class BSPDungeonGraphQuery
    {
        DungeonUID rootNode;
        Dictionary<DungeonUID, BSPNode> nodeMap;

        public BSPDungeonGraphQuery(DungeonUID rootNode, BSPNode[] nodes)
        {
            this.rootNode = rootNode;
            nodeMap = new Dictionary<DungeonUID, BSPNode>();
            foreach (var node in nodes)
            {
                nodeMap.Add(node.id, node);
            }
        }

        public BSPNode RootNode
        {
            get { return GetNode(rootNode); }
        }

        public BSPNode GetNode(DungeonUID nodeId)
        {
            return nodeMap[nodeId];
        }

        public BSPNode[] GetChildren(DungeonUID nodeId)
        {
            var children = new List<BSPNode>();
            var node = GetNode(nodeId);
            foreach (var childId in node.children)
            {
                children.Add(GetNode(childId));
            }
            return children.ToArray();
        }

        public BSPNode GetParent(DungeonUID nodeId)
        {
            var node = GetNode(nodeId);
            return GetNode(node.parent);
        }
    }

    public class BSPDungeonModel : DungeonModel {

		[HideInInspector]
		public BSPDungeonConfig Config;

        [HideInInspector]
        public DungeonUID rootNode;
        
		[HideInInspector]
        public BSPNode[] nodes;

        [HideInInspector]
        public BSPNodeConnection[] connections;
        
        public BSPDungeonGraphQuery CreateGraphQuery()
        {
            return new BSPDungeonGraphQuery(rootNode, nodes);
        }

        public override void ResetModel() 
        { 
            nodes = new BSPNode[0];
            connections = new BSPNodeConnection[0];
            rootNode = DungeonUID.Empty;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Dungeon.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using UnityEngine;
using System.Linq;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.Themeing;
using DungeonArchitect.SpatialConstraints;
using Random = UnityEngine.Random;

namespace DungeonArchitect
{
    /// <summary>
    /// The main dungeon behavior that manages the creation and destruction of dungeons
    /// </summary>
	[ExecuteInEditMode]
	public class Dungeon : MonoBehaviour {
        /// <summary>
        /// List of themes assigned to this dungeon
        /// </summary>
        public List<Graph> dungeonThemes;

        public MarkerGeneratorAsset[] patterns = Array.Empty<MarkerGeneratorAsset>();
	        
        /// <summary>
        /// Draw debug data
        /// </summary>
        public bool debugDraw = false;

        DungeonConfig config;
        PooledDungeonSceneProvider sceneProvider;
        DungeonBuilder dungeonBuilder;
        DungeonModel dungeonModel;
        DungeonQuery dungeonQuery;
        DungeonSceneObjectSpawner objectSpawner;

        /// <summary>
        /// Active model used by the dungeon
        /// </summary>
		public DungeonModel ActiveModel {
			get {
				if (dungeonModel == null) {
					dungeonModel = GetComponent<DungeonModel> ();
				}
				return dungeonModel;
			}
		}

        /// <summary>
        /// Flag to check if the layout has been built.  
        /// This is used to quickly reapply the theme after the theme graph has been modified,
        /// without rebuilding the layout, if it has already been built
        /// </summary>
		public bool IsLayoutBuilt {
			get {
                if (dungeonBuilder == null)
                {
                    return false;
                }
                return dungeonBuilder.IsLayoutBuilt;
			}
		}

        //[SerializeField]
        LevelMarkerList markers = new LevelMarkerList();
        public LevelMarkerList Markers
        {
            get { return markers; }
        }


        /// <summary>
        /// Flag to rebuild the dungeon. Set this to true if you want to rebuild it in the next update
        /// </summary>
		bool requestedRebuild = false;

		public DungeonConfig Config {
			get {
				if (config == null) {
					config = GetComponent<DungeonConfig> ();
				}
				return config;
			}
		}

        void Awake() {
            Initialize();
		}
        

		void Initialize() {
			if (config == null) {
				config = GetComponent<DungeonConfig> ();
			}
			
			if (sceneProvider == null) {
				sceneProvider = GetComponent<PooledDungeonSceneProvider> ();
			}
			
			if (dungeonBuilder == null) {
				dungeonBuilder = GetComponent<DungeonBuilder> ();
			}

			if (dungeonQuery == null)
			{
				dungeonQuery = GetComponent<DungeonQuery>();
			}

			if (dungeonModel == null) {
				dungeonModel = GetComponent<DungeonModel> ();
			}
		}

        public List<DungeonThemeData> GetThemeAssets()
        {
            var themes = new List<DungeonThemeData>();
            foreach (var themeGraph in dungeonThemes)
            {
                DungeonThemeData theme = new DungeonThemeData();
                theme.BuildFromGraph(themeGraph);
                themes.Add(theme);
            }
            return themes;
        }

        
        /// <summary>
        /// Builds the complete dungeon (layout and visual phase)
        /// </summary>
		public void Build() {
            Build(new RuntimeDungeonSceneObjectInstantiator());
        }


        /// <summary>
        /// Set the seed of the dungeon.  The seed determines the layout of the dungeon.
        /// Change this number to get a different layout.
        /// Use the same seed to get the same dungeon  
        /// </summary>
        /// <param name="seed"></param>
        public void SetSeed(int seed)
        {
	        Config.Seed = (uint) seed;
        }
        
        /// <summary>
        /// Randomizes the seed to generate a new dungeon layout
        /// </summary>
        public void RandomizeSeed()
        {
	        SetSeed(Mathf.RoundToInt(Random.value * int.MaxValue));
        }
        
        /// <summary>
        /// Randomizes the seed to generate a new dungeon layout
        /// </summary>
        public void RandomizeSeed(System.Random randomStream)
        {
	        SetSeed(Mathf.RoundToInt(randomStream.NextFloat() * int.MaxValue));
        }
        
        public void Build(IDungeonSceneObjectInstantiator objectInstantiator)
        {
	        if (dungeonBuilder.DestroyDungeonOnRebuild())
	        {
		        DestroyDungeon();
	        }
	        
            NotifyPreBuild();

            Initialize();
			dungeonModel.ResetModel();

			dungeonBuilder.BuildDungeon(config, dungeonModel);
            markers = dungeonBuilder.Markers;

            if (dungeonQuery != null)
            {
	            dungeonQuery.OnPostLayoutBuild();
            }
            
			NotifyPostLayoutBuild();

			// Spawn the scene objects
			dungeonBuilder.SpawnManagedObjects(sceneProvider, objectInstantiator);
            if (dungeonBuilder.IsThemingSupported())
            {
                ApplyTheme(objectInstantiator);
            }

            if (dungeonQuery != null)
            {
	            dungeonQuery.OnPostDungeonBuild();
            }

            // Build the navigation
            var navigation = GetComponent<DungeonRuntimeNavigation>();
            if (navigation != null)
            {
                navigation.BuildNavMesh();
            }

            NotifyPostBuild();
        }

        private void ApplyPatternMatchers()
        {
	        if (patterns == null || dungeonBuilder == null || dungeonBuilder.Markers == null)
	        {
		        return;
	        }

	        var random = new System.Random(config != null ? (int)config.Seed : 0);
	        bool processed = false;
	        var markerList = dungeonBuilder.Markers.GetMarkerList();
	        foreach (var patternAsset in patterns)
	        {
		        foreach (var pattern in patternAsset.patterns)
		        {
			        var processor = dungeonBuilder.CreateMarkerGenProcessor();
			        if (processor == null)
			        {
				        continue;
			        }

			        if (processor.Process(pattern, markerList, random, out var newMarkerList))
			        {
				        markerList = newMarkerList;
				        processed = true;
			        }

			        processor.Release();
		        }
	        }

	        if (processed)
	        {
		        dungeonBuilder.Markers.Set(markerList);
	        }
        }

        private void EmitMarkers()
        {
	        if (dungeonBuilder == null || !dungeonBuilder.IsThemingSupported())
	        {
		        return;
	        }
	        
	        // Emit markers defined by this builder
	        dungeonBuilder.EmitMarkers();

	        // Emit markers defined by the users (by attaching implementation of DungeonMarkerEmitter behaviors)
	        dungeonBuilder.EmitCustomMarkers();

	        ApplyPatternMatchers();
            
	        NotifyMarkersEmitted(dungeonBuilder.Markers);
        }
        
        /// <summary>
        /// Runs the theming engine over the existing layout to rebuild the game objects from the theme file.  
        /// The layout is not built in this stage
        /// </summary>
        public void ApplyTheme(IDungeonSceneObjectInstantiator objectInstantiator) {
	        if (dungeonBuilder == null)
	        {
		        return;
	        }
	        
	        EmitMarkers();
	        
            var themes = GetThemeAssets();
            var themeContext = CreateThemeExecutionContext(objectInstantiator);
            var themeEngine = new DungeonThemeEngine(themeContext);
            themeEngine.ApplyTheme(dungeonBuilder.Markers, themes);
        }

        DungeonThemeExecutionContext CreateThemeExecutionContext(IDungeonSceneObjectInstantiator objectInstantiator)
        {
            var context = new DungeonThemeExecutionContext();
            context.builder = dungeonBuilder;
            context.config = config;
            context.model = dungeonModel;
            context.spatialConstraintProcessor = GetComponent<SpatialConstraintProcessor>();
            context.sceneProvider = GetComponent<DungeonSceneProvider>();
            context.objectInstantiator = objectInstantiator;
            context.spawnListeners = GetComponents<DungeonItemSpawnListener>().ToArray();

            var builder = GetComponent<DungeonBuilder>();
            if (builder.asyncBuild)
            {
                var buildPosition = (builder.asyncBuildStartPosition != null) ? builder.asyncBuildStartPosition.position : Vector3.zero;
                objectSpawner = new AsyncDungeonSceneObjectSpawner(builder.maxBuildTimePerFrame, buildPosition);
            }
            else
            {
                objectSpawner = new SyncDungeonSceneObjectSpawner();
            }

            context.objectSpawner = objectSpawner;

            var themeOverrides = new List<ThemeOverrideVolume>();
            var dungeon = GetComponent<Dungeon>();

            // Process the theme override volumes
            var volumes = GameObject.FindObjectsOfType<ThemeOverrideVolume>();
            foreach (var volume in volumes)
            {
                if (volume.dungeon != dungeon)
                {
                    continue;
                }
                themeOverrides.Add(volume);
            }
            context.themeOverrideVolumes = themeOverrides.ToArray();

            return context;
        }

        DungeonEventListener[] GetListeners() {
			var listeners = GetComponents<DungeonEventListener>();

			var enabledListeners = from listener in listeners
					where listener.enabled
					select listener;

			return enabledListeners.ToArray();
		}

		void NotifyPostLayoutBuild() {
			// Notify all listeners of the post build event
			foreach (var listener in GetListeners()) {
				listener.OnPostDungeonLayoutBuild(this, ActiveModel);
			}
		}

        void NotifyPreBuild()
        {
            // Notify all listeners of the post build event
            foreach (var listener in GetListeners())
            {
                listener.OnPreDungeonBuild(this, ActiveModel);
            }
        }

        void NotifyPostBuild() {
			// Notify all listeners of the post build event
			foreach (var listener in GetListeners()) {
				listener.OnPostDungeonBuild(this, ActiveModel);
			}
		}

        void NotifyMarkersEmitted(LevelMarkerList markers)
        {
            // Notify all listeners of the post build event
            foreach (var listener in GetListeners())
            {
                if (listener == null) continue;
                listener.OnDungeonMarkersEmitted(this, ActiveModel, markers);
            }
        }

        void NotifyPreDungeonDestroy()
        {
            // Notify all listeners that the dungeon is destroyed
            foreach (var listener in GetListeners())
            {
                listener.OnPreDungeonDestroy(this);
            }
        }

        void NotifyDungeonDestroyed() {
			// Notify all listeners that the dungeon is destroyed
			foreach (var listener in GetListeners()) {
				listener.OnDungeonDestroyed(this);
			}
		}

        /// <summary>
        /// Destroys the dungeon
        /// </summary>
		public void DestroyDungeon() {
            NotifyPreDungeonDestroy();
            
            var itemList = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
            var dungeonItems = new List<GameObject>();
            foreach (var item in itemList)
            {
                if (item == null) continue;
                if (item.dungeon == this)
                {
                    dungeonItems.Add(item.gameObject);
                }
            }
			foreach(var item in dungeonItems) {
				if (Application.isPlaying) {
					Destroy(item);
				} else {
					DestroyImmediate(item);
				}
			}
            
            if (objectSpawner != null)
            {
                objectSpawner.Destroy();
                objectSpawner = null;
            }

            // Build the navigation
            var navigation = GetComponent<DungeonRuntimeNavigation>();
            if (navigation != null) {
                navigation.DestroyNavMesh();
            }

            if (dungeonQuery != null)
            {
	            dungeonQuery.Release();
            }
            
            if (dungeonModel != null) {
				dungeonModel.ResetModel();
			}

			if (dungeonBuilder != null) {
				dungeonBuilder.OnDestroyed();
			}

			NotifyDungeonDestroyed();
		}

		/// <summary>
		/// Requests the dungeon to be rebuilt in the next update phase
		/// </summary>
		public void RequestRebuild() {
			requestedRebuild = true;
		}

		public virtual void Update() {
			if (dungeonModel == null) return;
			
			if (requestedRebuild) {
				requestedRebuild = false;
				Build();
            }
            if (debugDraw)
            {
                DebugDraw();
            }

            if (objectSpawner != null)
            {
                objectSpawner.Tick();
            }
        }

		void OnGUI()
        {
        }

		void DebugDraw() {
            if (dungeonBuilder != null)
            {
                dungeonBuilder.DebugDraw();
            }
        }

        void OnDrawGizmosSelected()
        {
            if (debugDraw && dungeonBuilder != null)
            {
                dungeonBuilder.DebugDrawGizmos();
            }
        }

	}
	
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\DungeonBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using DungeonArchitect.MarkerGenerator.Processor;
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect
{

    /// <summary>
    /// Builds the layout of the dungeon and emits markers around the layout
    /// Implement this class to create your own builder
    /// </summary>
	[ExecuteInEditMode]
    public abstract class DungeonBuilder : MonoBehaviour
    {
        protected DungeonConfig config;
        protected PMRandom nrandom;
        protected PMRandom random;
        protected DungeonModel model;
        protected LevelMarkerList markers = new LevelMarkerList();
        protected Blackboard blackboard = new Blackboard();

        public bool asyncBuild = false;
        public long maxBuildTimePerFrame = 32;
        public Transform asyncBuildStartPosition;

        private bool isLayoutBuilt = false;
        public bool IsLayoutBuilt
        {
            get
            {
                {
                    // Hot code reload sometimes invalidates the model.  
                    if (random == null) return false;
                }
                return isLayoutBuilt;
            }
        }

        public LevelMarkerList Markers
        {
            get { return markers; }
        }

        public DungeonModel Model
        {
            get { return model; }
        }

        public Blackboard Blackboard
        {
            get { return blackboard; }
        }

        /// <summary>
        /// Builds the dungeon layout
        /// </summary>
        /// <param name="config">The builder configuration</param>
        /// <param name="model">The dungeon model that the builder will populate</param>
        public virtual void BuildDungeon(DungeonConfig config, DungeonModel model)
        {
            this.config = config;
            this.model = model;

            nrandom = new PMRandom(config.Seed);
            random = new PMRandom(config.Seed);

            markers = CreateMarkerListObject(config);

            isLayoutBuilt = true;
        }
        
        protected virtual LevelMarkerList CreateMarkerListObject(DungeonConfig config)
        {
            return new SpatialPartionedLevelMarkerList(8);
        }

		public virtual void OnDestroyed() {
            ClearSockets();
            isLayoutBuilt = false;
        }


        public virtual bool IsThemingSupported() { return true; }

        public virtual bool DestroyDungeonOnRebuild() { return false; }
        
        // This is called by the builders that do not support theming
        //public virtual void BuildNonThemedDungeon(DungeonSceneProvider sceneProvider, IDungeonSceneObjectInstantiator objectInstantiator) { }

        public virtual void SpawnManagedObjects(DungeonSceneProvider sceneProvider, IDungeonSceneObjectInstantiator objectInstantiator)
        {
        }
        
        public virtual void DebugDraw()
        {
        }

        public virtual void DebugDrawGizmos()
        {
        }

        protected void ClearSockets()
        {
            markers.Clear();
        }

        /// <summary>
        /// Emit markers defined by this builder
        /// </summary>
        public virtual void EmitMarkers()
        {
            ClearSockets();
        }

        /// <summary>
        /// Emit markers defined by the user (implementation of DungeonMarkerEmitter)
        /// </summary>
        public void EmitCustomMarkers()
        {
            var emitters = GetComponents<DungeonMarkerEmitter>();
            foreach (var emitter in emitters)
            {
                emitter.EmitMarkers(this);
            }
        }

        public PropSocket EmitMarker(string SocketType, Matrix4x4 transform, IntVector gridPosition, int cellId)
        {
            return EmitMarker(SocketType, transform, gridPosition, cellId, null);
        }

        public PropSocket EmitMarker(string SocketType, Matrix4x4 transform, IntVector gridPosition, int cellId, object metadata)
        {
            return markers.EmitMarker(SocketType, transform, gridPosition, cellId, metadata);
        }

        public void EmitMarker(string SocketType, Matrix4x4 _transform, int count, Vector3 InterOffset, IntVector gridPosition, int cellId, Vector3 LogicalToWorldScale)
        {
            EmitMarker(SocketType, _transform, count, InterOffset, gridPosition, cellId, LogicalToWorldScale, null);
        }

        public void EmitMarker(string SocketType, Matrix4x4 _transform, int count, Vector3 InterOffset, IntVector gridPosition, int cellId, Vector3 LogicalToWorldScale, object metadata)
        {
            markers.EmitMarker(SocketType, _transform, count, InterOffset, gridPosition, cellId, LogicalToWorldScale, metadata);
        }

        /// <summary>
        /// Implementations should override this so that the new logical scale and position is set based on the volume's transformation
        /// </summary>
        /// <param name="volume"></param>
        /// <param name="newPositionOnGrid"></param>
        /// <param name="newSizeOnGrid"></param>
        public virtual void OnVolumePositionModified(Volume volume, out IntVector newPositionOnGrid, out IntVector newSizeOnGrid)
        {
            newPositionOnGrid = MathUtils.ToIntVector(volume.transform.position);
            newSizeOnGrid = MathUtils.ToIntVector(volume.transform.localScale);
        }

        protected void ProcessMarkerOverrideVolumes()
        {
			var dungeon = GetComponent<Dungeon>();
            // Process the theme override volumes
            var replacementVolumes = GameObject.FindObjectsOfType<MarkerReplaceVolume>();
            foreach (var replacementVolume in replacementVolumes)
            {
				if (replacementVolume.dungeon == dungeon) {
					// Fill up the prop sockets with the defined mesh data 
					for (int i = 0; i < markers.Count; i++) {
						PropSocket socket = markers[i];
						var socketPosition = Matrix.GetTranslation (ref socket.Transform);
						if (replacementVolume.GetBounds ().Contains (socketPosition)) {
							foreach (var replacementEntry in replacementVolume.replacements) {
								if (socket.SocketType == replacementEntry.fromMarker) {
									socket.SocketType = replacementEntry.toMarker;
								}
							}
						}
					}
				}
            }
        }

        public virtual IMarkerGenProcessor CreateMarkerGenProcessor()
        {
            return null;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\DungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Base dungeon configuration.  Create your own implementation of this configuration based on your dungeon builder's needs
    /// </summary>
	public class DungeonConfig : MonoBehaviour {
        [Tooltip(@"Change this number to completely change the layout of your level")]
        public uint Seed = 0;

        public virtual bool HasValidConfig(ref string errorMessage)
        {
            return true;
        }

        public virtual bool IsMode2D()
        {
            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\DungeonEventListener.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{

	/// <summary>
	/// Listen to various dungeon events during the build and destroy phase
	/// </summary>
	public class DungeonEventListener : MonoBehaviour {
		/// <summary>
        /// Called after the layout is built in memory, but before the markers are emitted
		/// </summary>
		/// <param name="model">The dungeon model</param>
		public virtual void OnPostDungeonLayoutBuild(Dungeon dungeon, DungeonModel model) {}

        /// <summary>
        /// Called after all the markers have been emitted for the level (but before the theming engine is run on those markers)
        /// This gives you an opportunity to modify the markers 
        /// </summary>
        /// <param name="dungeon"></param>
        /// <param name="model"></param>
        public virtual void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers) { }

        /// <summary>
        /// Called before the dungeon is built
        /// </summary>
        /// <param name="model">The dungeon model</param>
        public virtual void OnPreDungeonBuild(Dungeon dungeon, DungeonModel model) { }

        /// <summary>
        /// Called after the dungeon is completely built
        /// </summary>
        /// <param name="model">The dungeon model</param>
		public virtual void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model) {}

        /// <summary>
        /// Called after the dungeon is destroyed
        /// </summary>
        /// <param name="model">The dungeon model</param>
        public virtual void OnPreDungeonDestroy(Dungeon dungeon) { }

        /// <summary>
        /// Called after the dungeon is destroyed
        /// </summary>
        /// <param name="model">The dungeon model</param>
        public virtual void OnDungeonDestroyed(Dungeon dungeon) {}
	}
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\DungeonMarkerEmitter.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Marker Emitters let you emit your own markers anywhere in the map.  Implement this class and add it to the Dungeon object
    /// to add your own markers right after the dungeon layout is created
    /// </summary>
    public class DungeonMarkerEmitter : MonoBehaviour {
        /// <summary>
        /// Called by the dungeon object right after the dungeon is created
        /// </summary>
        /// <param name="builder">reference to the builder object used to build the dungeon</param>
        public virtual void EmitMarkers(DungeonBuilder builder)
        {
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\DungeonModel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Abstract dungeon model.  Create your own implementation of the model depending on your builder's needs
    /// </summary>
	//[System.Serializable]
	public abstract class DungeonModel : MonoBehaviour
	{
        void Reset()
        {
            ResetModel();
        }

        public virtual void ResetModel() { }

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\DungeonPaintMode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Manage the editor paint mode so you can paint the layout of you dungeon.
    /// You should implement your own paint mode depending on your dungeon builder's 
    /// data structures and requirements
    /// </summary>
	public abstract class DungeonPaintMode : MonoBehaviour {
		private Dungeon dungeon;
		private DungeonModel dungeonModel;
		private DungeonConfig dungeonConfig;
		private DungeonToolData dungeonToolData;

        /// <summary>
        /// Gets the configuration of the dungeon
        /// </summary>
        /// <returns></returns>
		public DungeonConfig GetDungeonConfig() {
			if (dungeonConfig == null) {
				dungeonConfig = GetSiblingComponent<DungeonConfig>();
			}
			return dungeonConfig;
		}

        /// <summary>
        /// Gets the model used by the owning dungeon
        /// </summary>
        /// <returns></returns>
        public DungeonModel GetDungeonModel()
        {
			if (dungeonModel == null) {
				dungeonModel = GetSiblingComponent<DungeonModel>();
			}
			return dungeonModel;
		}

        /// <summary>
        /// Gets the owning dungeon
        /// </summary>
        /// <returns>The owning dungeon</returns>
        public Dungeon GetDungeon()
        {
			if (dungeon == null) {
				dungeon = GetSiblingComponent<Dungeon>();
			}
			return dungeon;
		}

        public DungeonToolData GetToolData()
        {
	        if (dungeonToolData == null) {
		        dungeonToolData = GetSiblingComponent<DungeonToolData>();
	        }
	        return dungeonToolData;
        }

        
		public T GetSiblingComponent<T>() {
			var parentTransform = gameObject.transform.parent;
			if (parentTransform != null && parentTransform.gameObject != null) {
				var dungeonGO = parentTransform.gameObject;
				return dungeonGO.GetComponent<T>();
			}
			return default(T);
		}
	}
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\DungeonQuery.cs:
 using UnityEngine;

namespace DungeonArchitect
{
    public class DungeonQuery : MonoBehaviour
    {
        public virtual void OnPostLayoutBuild()
        {
        }

        public virtual void OnPostDungeonBuild()
        {
        }
        
        public virtual void Release()
        {
        }
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\DungeonToolData.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System;
using System.Collections.Generic;

namespace DungeonArchitect
{
    /// <summary>
    /// Tool Data represented by the grid based builder
    /// </summary>
    [Serializable]
    public class DungeonToolData : MonoBehaviour
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Utils\DungeonUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect;

namespace DungeonArchitect
{
    public class DungeonUtils
    {

        public static List<GameObject> GetDungeonObjects(Dungeon dungeon)
        {
            var result = new List<GameObject>();

            var components = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
            foreach (var component in components)
            {
                if (component.dungeon == dungeon)
                {
                    result.Add(component.gameObject);
                }
            }

            return result;
        }

        public static void DestroyObject(Object go)
        {
            if (Application.isPlaying)
            {
                Object.Destroy(go);
            }
            else
            {
                Object.DestroyImmediate(go);
            }
        }

        public static Bounds GetDungeonBounds(Dungeon dungeon)
        {
            var dungeonObjects = GetDungeonObjects(dungeon);
            var bounds = new Bounds();
            bool first = true;
            foreach (var gameObject in dungeonObjects)
            {
                var renderers = gameObject.GetComponentsInChildren<Renderer>();
                foreach (var renderer in renderers)
                {
                    if (first)
                    {
                        bounds = renderer.bounds;
                        first = false;
                    }
                    else
                    {
                        bounds.Encapsulate(renderer.bounds);
                    }
                }
            }

            return bounds;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Utils\LevelMarkerList.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect
{
    public class LevelMarkerList : IEnumerable<PropSocket>
    {
        protected List<PropSocket> markers = new List<PropSocket>();
        protected int _SocketIdCounter = 0;
        public bool AllowDuplicateMarkers = true;

        public IEnumerator<PropSocket> GetEnumerator()
        {
            return markers.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return markers.GetEnumerator();
        }

        public virtual void Add(PropSocket marker)
        {
            markers.Add(marker);
        }

        public virtual void AddRange(PropSocket[] markerList)
        {
            markers.AddRange(markerList);
        }

        public virtual void Remove(PropSocket marker)
        {
            markers.Remove(marker);
        }

        public virtual void Clear()
        {
            _SocketIdCounter = 0;
            markers.Clear();
        }
        
        public PropSocket[] GetMarkerList()
        {
            return markers.ToArray();
        }

        public int GetNextSocketId()
        {
            return ++_SocketIdCounter;
        }

        public PropSocket this[int index]
        {
            get
            {
                return markers[index];
            }
        }

        public int Count
        {
            get
            {
                return markers.Count;
            }
        }

        public virtual IEnumerable<PropSocket> GetMarkersInSearchArea(Vector2 center, float radius)
        {
            return markers;
        }

        public PropSocket EmitMarker(string SocketType, Matrix4x4 transform, IntVector gridPosition, int cellId)
        {
            return EmitMarker(SocketType, transform, gridPosition, cellId, null);
        }

        public PropSocket EmitMarker(string SocketType, Matrix4x4 transform, IntVector gridPosition, int cellId, object metadata)
        {
            PropSocket socket = new PropSocket();
            socket.Id = GetNextSocketId();
            socket.SocketType = SocketType;
            socket.Transform = transform;
            socket.gridPosition = gridPosition;
            socket.cellId = cellId;
            socket.metadata = metadata;
            Add(socket);
            return socket;
        }

        public void EmitMarker(string SocketType, Matrix4x4 _transform, int count, Vector3 InterOffset, IntVector gridPosition, int cellId, Vector3 LogicalToWorldScale)
        {
            EmitMarker(SocketType, _transform, count, InterOffset, gridPosition, cellId, LogicalToWorldScale, null);
        }

        public void EmitMarker(string SocketType, Matrix4x4 _transform, int count, Vector3 InterOffset, IntVector gridPosition, int cellId, Vector3 LogicalToWorldScale, object metadata)
        {
            var iposition = new IntVector(gridPosition.x, gridPosition.y, gridPosition.z);
            var ioffset = new IntVector(
                Mathf.RoundToInt(InterOffset.x / LogicalToWorldScale.x),
                Mathf.RoundToInt(InterOffset.y / LogicalToWorldScale.y),
                Mathf.RoundToInt(InterOffset.z / LogicalToWorldScale.z)
            );
            Matrix4x4 transform = Matrix.Copy(_transform);
            var position = Matrix.GetTranslation(ref transform);

            for (int i = 0; i < count; i++)
            {
                EmitMarker(SocketType, transform, iposition, cellId, metadata);
                position += InterOffset;
                iposition += ioffset;
                transform = Matrix.Copy(transform);
                Matrix.SetTranslation(ref transform, position);
            }
        }

        public void Set(PropSocket[] markerList)
        {
            Clear();
            foreach (var marker in markerList)
            {
                Add(marker);
            }
        }
    }

    public class SpatialPartionedLevelMarkerList : LevelMarkerList
    {
        private float partitionCellSize = 4.0f;
        private Dictionary<IntVector2, List<PropSocket>> buckets = new Dictionary<IntVector2, List<PropSocket>>();

        public SpatialPartionedLevelMarkerList(float partitionCellSize)
        {
            this.partitionCellSize = partitionCellSize;
        }

        IntVector2 GetBucketCoord(PropSocket marker)
        {
            var position = Matrix.GetTranslation(ref marker.Transform);
            return GetBucketCoord(position.x, position.z);
        }

        IntVector2 GetBucketCoord(Vector2 position)
        {
            return GetBucketCoord(position.x, position.y);
        }

        IntVector2 GetBucketCoord(float x, float z)
        {
            int ix = Mathf.FloorToInt(x / partitionCellSize);
            int iy = Mathf.FloorToInt(z / partitionCellSize);
            return new IntVector2(ix, iy);
        }

        public override void Add(PropSocket marker)
        {
            var partitionCoord = GetBucketCoord(marker);
            if (!buckets.ContainsKey(partitionCoord))
            {
                buckets.Add(partitionCoord, new List<PropSocket>());
            }

            var bucket = buckets[partitionCoord];
            bool shouldInsert = true;
            if (!AllowDuplicateMarkers)
            {
                foreach (var bucketMarker in bucket)
                {
                    if (bucketMarker.SocketType == marker.SocketType)
                    {
                        if (bucketMarker.Transform.Equals(marker.Transform))
                        {
                            shouldInsert = false;
                            break;
                        }
                    }
                }
            }

            if (shouldInsert)
            {
                base.Add(marker);
                bucket.Add(marker);
            }
        }

        public override void Remove(PropSocket marker)
        {
            base.Remove(marker);

            var partitionCoord = GetBucketCoord(marker);
            if (buckets.ContainsKey(partitionCoord))
            {
                buckets[partitionCoord].Remove(marker);
            }
        }

        public override IEnumerable<PropSocket> GetMarkersInSearchArea(Vector2 center, float radius)
        {
            var extent = new Vector2(radius, radius);
            var start = GetBucketCoord(center - extent);
            var end = GetBucketCoord(center + extent);

            var searchSpace = new List<PropSocket>();
            for (int x = start.x; x <= end.x; x++)
            {
                for (int y = start.y; y <= end.y; y++)
                {
                    var key = new IntVector2(x, y);
                    if (buckets.ContainsKey(key))
                    {
                        searchSpace.AddRange(buckets[key]);
                    }
                }
            }
            return searchSpace;
        }

        public override void Clear()
        {
            base.Clear();
            buckets.Clear();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\Blackboard.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Utils
{
    /// <summary>
    /// A blackboard holds global data that can be shared across multiple scripts
    /// </summary>
    public class Blackboard
    {
        private BlackboardDatabase<int> intEntries = new BlackboardDatabase<int>(0);
        public BlackboardDatabase<int> IntEntries
        {
            get { return intEntries; }
        }
        private BlackboardDatabase<float> floatEntries = new BlackboardDatabase<float>(0.0f);
        public BlackboardDatabase<float> FloatEntries
        {
            get { return floatEntries; }
        }
        private BlackboardDatabase<string> stringEntries = new BlackboardDatabase<string>("");
        public BlackboardDatabase<string> StringEntries
        {
            get { return stringEntries; }
        }
        private BlackboardDatabase<Vector3> vectorEntries = new BlackboardDatabase<Vector3>(Vector3.zero);
        public BlackboardDatabase<Vector3> VectorEntries
        {
            get { return vectorEntries; }
        }
        private BlackboardDatabase<IntVector> intVectorEntries = new BlackboardDatabase<IntVector>(IntVector.Zero);
        public BlackboardDatabase<IntVector> IntVectorEntries
        {
            get { return intVectorEntries; }
        }
    }

    
    public class BlackboardDatabase<T>
    {
        T defaultValue;
        Dictionary<string, T> database = new Dictionary<string, T>();

        public BlackboardDatabase(T defaultValue)
        {
            this.defaultValue = defaultValue;
        }

        public void SetValue(string key, T value) {
            database[key] = value;
        }

        public T GetValue(string key)
        {
            if (!database.ContainsKey(key))
            {
                return defaultValue;
            }
            return database[key];
        }
        
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\ColorUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Utils
{
    public class ColorUtils
    {
        public static Color BrightenColor(Color color, float saturationMultiplier, float brightnessMultiplier)
        {
            float H, S, V;
            Color.RGBToHSV(color, out H, out S, out V);
            S *= saturationMultiplier;
            V = Mathf.Clamp01(V * brightnessMultiplier);

            return Color.HSVToRGB(H, S, V);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\DataUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Runtime.InteropServices;
using UnityEngine;

namespace DungeonArchitect.Utils
{
    [StructLayout(LayoutKind.Explicit), Serializable]
    public struct DungeonUID : IComparable, 
        IComparable<DungeonUID>,
        IEquatable<DungeonUID>
    {
        [FieldOffset(0)] 
        public System.Guid Guid;

        [FieldOffset(0), SerializeField] private Int32 A;
        [FieldOffset(4), SerializeField] private Int32 B;
        [FieldOffset(8), SerializeField] private Int32 C;
        [FieldOffset(12), SerializeField] private Int32 D;

        public static DungeonUID NewUID()
        {
            return new DungeonUID()
            {
                Guid = System.Guid.NewGuid()
            };
        }

        public static readonly DungeonUID Empty = new DungeonUID()
        {
            Guid = System.Guid.Empty
        };

        public static bool operator==(DungeonUID a, DungeonUID b)
        {
            //return a.Guid == b.Guid;
            return a.A == b.A &&
                   a.B == b.B &&
                   a.C == b.C && 
                   a.D == b.D;
        }
        
        public static bool operator!=(DungeonUID a, DungeonUID b)
        {
            //return a.Guid != b.Guid;
            return a.A != b.A ||
                   a.B != b.B ||
                   a.C != b.C || 
                   a.D != b.D;
        }

        public bool Equals(DungeonUID other)
        {
            //return other.Guid.Equals(Guid);
            return A == other.A &&
                   B == other.B &&
                   C == other.C && 
                   D == other.D;
        }

        public override bool Equals(object obj)
        {
            if (obj == null) return false;
            if (obj is DungeonUID)
            {
                var other = (DungeonUID)obj;
                return A == other.A &&
                       B == other.B &&
                       C == other.C && 
                       D == other.D;
            }

            return false;
        }

        public bool IsValid()
        {
            return Guid != System.Guid.Empty;
        }
        
        public int CompareTo(object obj)
        {
            if (obj == null) return -1;
            if (obj is DungeonUID)
            {
                return ((DungeonUID) obj).Guid.CompareTo(Guid);
            }

            if (obj is System.Guid)
            {
                return ((System.Guid) obj).CompareTo(Guid);
            }

            return -1;
        }

        public int CompareTo(DungeonUID other)
        {
            return other.Guid.CompareTo(Guid);
        }
        
        public override int GetHashCode()
        {
            return Guid.GetHashCode();
        }

        public override string ToString()
        {
            return Guid.ToString();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\DebugDrawUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Utils
{
    /// <summary>
    /// Helper functions to draw debug information of the dungeon layout in the scene view 
    /// </summary>
    public class DebugDrawUtils
    {

        public static void DrawBounds(Rectangle bounds, Color color, Vector3 gridScale, bool mode2D)
        {
            var x0 = bounds.Left * gridScale.x;
            var x1 = bounds.Right * gridScale.x;
            var z0 = bounds.Front * gridScale.z;
            var z1 = bounds.Back * gridScale.z;
            var y = bounds.Location.y * gridScale.y;
            DrawLine(new Vector3(x0, y, z0), new Vector3(x1, y, z0), color, 0, false, mode2D);
            DrawLine(new Vector3(x1, y, z0), new Vector3(x1, y, z1), color, 0, false, mode2D);
            DrawLine(new Vector3(x1, y, z1), new Vector3(x0, y, z1), color, 0, false, mode2D);
            DrawLine(new Vector3(x0, y, z1), new Vector3(x0, y, z0), color, 0, false, mode2D);
        }

        public static void DrawBounds(Bounds bounds, Color color)
        {
            var min = bounds.min;
            var max = bounds.max;
            var x0 = min.x;
            var x1 = max.x;
            var y0 = min.y;
            var y1 = max.y;
            var z0 = min.z;
            var z1 = max.z;
            
            
            Debug.DrawLine(new Vector3(x0, y0, z0), new Vector3(x1, y0, z0), color, 0, false);
            Debug.DrawLine(new Vector3(x0, y1, z0), new Vector3(x1, y1, z0), color, 0, false);
            Debug.DrawLine(new Vector3(x0, y0, z1), new Vector3(x1, y0, z1), color, 0, false);
            Debug.DrawLine(new Vector3(x0, y1, z1), new Vector3(x1, y1, z1), color, 0, false);
            
            Debug.DrawLine(new Vector3(x0, y0, z0), new Vector3(x0, y1, z0), color, 0, false);
            Debug.DrawLine(new Vector3(x1, y0, z0), new Vector3(x1, y1, z0), color, 0, false);
            Debug.DrawLine(new Vector3(x0, y0, z1), new Vector3(x0, y1, z1), color, 0, false);
            Debug.DrawLine(new Vector3(x1, y0, z1), new Vector3(x1, y1, z1), color, 0, false);
            
            Debug.DrawLine(new Vector3(x0, y0, z0), new Vector3(x0, y0, z1), color, 0, false);
            Debug.DrawLine(new Vector3(x1, y0, z0), new Vector3(x1, y0, z1), color, 0, false);
            Debug.DrawLine(new Vector3(x0, y1, z0), new Vector3(x0, y1, z1), color, 0, false);
            Debug.DrawLine(new Vector3(x1, y1, z0), new Vector3(x1, y1, z1), color, 0, false);
        }

        public static void DrawPoint(Vector3 position, Color color, bool mode2D)
        {
            var start = position;
            var end = start + new Vector3(0, 0.2f, 0);
            DrawLine(start, end, color, 0, false, mode2D);
        }

        static Vector3 FlipFor2D(Vector3 v)
        {
            return new Vector3(v.x, v.z, v.y);
        }

        public static void DrawLine(Vector3 start, Vector3 end, Color color, float duration, bool depthTest, bool mode2D)
        {
            if (mode2D)
            {
                start = FlipFor2D(start);
                end = FlipFor2D(end);
            }

            Debug.DrawLine(start, end, color, duration, depthTest);
        }
        static Vector3 GetPointOnCircle(float angle)
        {
            float radians = angle * Mathf.Deg2Rad;
            return new Vector3(Mathf.Cos(radians), 0, Mathf.Sin(radians));
        }

        public static void DrawCircle(Vector3 center, float radius, Color color)
        {
            DrawCircle(center, radius, color, 1.0f);
        }

        public static void DrawCircle(Vector3 center, float radius, Color color, float segmentMultiplier)
        {
            float perimeter = Mathf.PI * 2 * radius;
            float constSegmentMultiplier = 3;
            int segments = Mathf.RoundToInt(Mathf.Sqrt(perimeter) * segmentMultiplier * constSegmentMultiplier);
            segments = Mathf.Max(segments, 3);  // minimum 3 segments for a triangle

            float angle = 0;
            float angleSteps = 360.0f / segments;
            for (int i = 0; i <= segments; i++)
            {
                float nextAngle = angle + angleSteps;
                var start = center + GetPointOnCircle(angle) * radius;
                var end = center + GetPointOnCircle(nextAngle) * radius;
                angle = nextAngle;

                Debug.DrawLine(start, end, color);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\DebugText3D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect {

    [System.Serializable]
    public struct DebugTextItem {
        public string message;
        public Vector3 position;
        public Color color;
    }

    public class DebugText3D : MonoBehaviour {
        [HideInInspector]
        public DebugTextItem[] items;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\Extensions.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Extensions
{
    public static class DungeonExtensions
    {
        public static bool IsValid(this System.Guid guid)
        {
            return guid != System.Guid.Empty;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\InstanceCache.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using UnityEngine;
using System.Collections.Generic;
using System.Reflection;

namespace DungeonArchitect.Utils
{
    /// <summary>
    /// Caches instances by their name so they can be reused when needed again instead of recreating it
    /// </summary>
    public class InstanceCache
    {
        readonly Dictionary<string, ScriptableObject> instanceByType = new Dictionary<string, ScriptableObject>();
        /// <summary>
        /// Retrieves the instance of the specified ScriptableObject type name. If none exists, a new one is created and stored
        /// </summary>
        /// <param name="typeName">The typename of the ScriptableObject</param>
        /// <returns>The cached instance of the specified ScriptableObject typename</returns>
        public ScriptableObject GetInstance(string typeName)
        {
            if (string.IsNullOrEmpty(typeName))
            {
                return null;
            }
            
            if (!instanceByType.ContainsKey(typeName))
            {
                var type = System.Type.GetType(typeName);
                if (type == null)
                {
                    // Search all assemblies
                    foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
                    {
                        type = asm.GetType(typeName);
                        if (type != null)
                        {
                            break;
                        }
                    }
                }
                var obj = ScriptableObject.CreateInstance(type);
                instanceByType.Add(typeName, obj);
            }
            return instanceByType[typeName];
        }

        public void Clear()
        {
            foreach (var entry in instanceByType)
            {
                var obj = entry.Value;
                if (obj != null)
                {
                    ObjectUtils.DestroyObject(obj);
                }
            }
            instanceByType.Clear();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\KeyValueData.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Utils
{
    [System.Serializable]
    public class KeyValueDataEntryBase {
        [SerializeField] public string key;
        public virtual object GetValue() { return null; }
        public virtual void SetValue(object value) { }
    }

    [System.Serializable]
    public class KeyValueDataEntryTyped<T> : KeyValueDataEntryBase
    {
        [SerializeField] public T value;
        public override object GetValue() { return value; }
        public override void SetValue(object value) { this.value = (T)value; }
    }

    [System.Serializable] public class KeyValueDataEntryFloat : KeyValueDataEntryTyped<float> { }
    [System.Serializable] public class KeyValueDataEntryInt : KeyValueDataEntryTyped<int> { }
    [System.Serializable] public class KeyValueDataEntryString : KeyValueDataEntryTyped<string> { }
    [System.Serializable] public class KeyValueDataEntryVector3 : KeyValueDataEntryTyped<Vector3> { }
    [System.Serializable] public class KeyValueDataEntryVector2 : KeyValueDataEntryTyped<Vector2> { }

    [System.Serializable]
    public class KeyValueData
    {
        [SerializeField] List<KeyValueDataEntryFloat> dataFloat = new List<KeyValueDataEntryFloat>();
        [SerializeField] List<KeyValueDataEntryInt> dataInt = new List<KeyValueDataEntryInt>();
        [SerializeField] List<KeyValueDataEntryString> dataString = new List<KeyValueDataEntryString>();
        [SerializeField] List<KeyValueDataEntryVector3> dataVector3 = new List<KeyValueDataEntryVector3>();
        [SerializeField] List<KeyValueDataEntryVector2> dataVector2 = new List<KeyValueDataEntryVector2>();

        // Getters
        public bool GetFloat(string key, ref float value) { return GetValue(dataFloat, key, ref value); }
        public bool GetInt(string key, ref int value) { return GetValue(dataInt, key, ref value); }
        public bool GetString(string key, ref string value) { return GetValue(dataString, key, ref value); }
        public bool GetVector3(string key, ref Vector3 value) { return GetValue(dataVector3, key, ref value); }
        public bool GetVector2(string key, ref Vector2 value) { return GetValue(dataVector2, key, ref value); }
        

        // Setters
        public void Set(string key, float value) { SetValue(dataFloat, key, value); }
        public void Set(string key, int value) { SetValue(dataInt, key, value); }
        public void Set(string key, string value) { SetValue(dataString, key, value); }
        public void Set(string key, Vector3 value) { SetValue(dataVector3, key, value); }
        public void Set(string key, Vector2 value) { SetValue(dataVector2, key, value); }


        private void SetValue<T>(List<T> data, string key, object value) where T : KeyValueDataEntryBase, new()
        {
            foreach (var entry in data)
            {
                if (entry is T)
                {
                    if (entry.key == key)
                    {
                        entry.SetValue(value);
                        return;
                    }
                }
            }

            var item = new T();
            item.key = key;
            item.SetValue(value);
            data.Add(item);
        }

        private bool GetValue<TEntry, TValue>(List<TEntry> data, string key, ref TValue value) where TEntry : KeyValueDataEntryBase
        {
            foreach (var entry in data)
            {
                if (entry.key == key)
                {
                    object objValue = entry.GetValue();
                    if (objValue is TValue)
                    {
                        value = (TValue)entry.GetValue();
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
            }

            return false;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\MathUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Utils
{
    /// <summary>
    /// Various math utility functions
    /// </summary>
    public class MathUtils
    {
        /// <summary>
        /// Copies the rectangle object
        /// </summary>
        /// <param name="other">The object to copy</param>
        /// <returns>The copied object</returns>
        public static Rectangle Copy(Rectangle other)
        {
            return new Rectangle(other.X, other.Z, other.Width, other.Length);
        }

        /// <summary>
        /// Divides two vector3 objects
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns>The divided vector</returns>
		public static Vector3 Divide(Vector3 a, Vector3 b) {
			return new Vector3(
				a.x / b.x,
				a.y / b.y,
				a.z / b.z
				);
		}

        /// <summary>
        /// Converts an IntVector to a Vector3
        /// </summary>
        /// <param name="v">the input int vector</param>
        /// <returns></returns>
		public static Vector3 ToVector3(IntVector v) {
			return new Vector3(v.x, v.y, v.z);
		}
        
        public static Vector3 ToVector3(Vector3Int v) {
	        return new Vector3(v.x, v.y, v.z);
        }
        
        public static Vector2 ToVector2(Vector2Int v) {
	        return new Vector2(v.x, v.y);
        }

        
        public static Vector4 ToVector4(Vector3 v, float w) {
	        return new Vector4(v.x, v.y, v.z, w);
        }

        /// <summary>
        /// Converts the world coordinates to grid coordinates
        /// </summary>
        /// <param name="WorldCoord">The world cooridnate</param>
        /// <param name="GridCellSize">The grid cell size</param>
        /// <returns>The resulting grid coordinate</returns>
		public static IntVector WorldToGrid(Vector3 WorldCoord, Vector3 GridCellSize) {
			return ToIntVector(Divide (WorldCoord, GridCellSize));
		}

        /// <summary>
        /// Converts the grid coordinate to world coordinate
        /// </summary>
        /// <param name="GridCellSize">The grid cell size</param>
        /// <param name="v">The input grid coordinate</param>
        /// <returns>The resulting world coordinate</returns>
        public static Vector3 GridToWorld(Vector3 GridCellSize, IntVector v)
        {
			return GridToWorld(GridCellSize, ToVector3(v));
		}

        /// <summary>
        /// Converts the grid coordinate to world coordinate
        /// </summary>
        /// <param name="GridCellSize">The grid cell size</param>
        /// <param name="v">The input grid coordinate</param>
        /// <returns>The resulting world coordinate</returns>
        public static Vector3 GridToWorld(Vector3 GridCellSize, Vector3 v)
        {
			return Vector3.Scale (GridCellSize, v);
		}

        /// <summary>
        /// Converts an IntVector to a Vector3, with the XYZ components floored
        /// </summary>
        /// <param name="v">The input Vector3 to convert</param>
        /// <returns>The corresponding IntVector, floored in each component</returns>
		public static IntVector ToIntVector(Vector3 v) {
			return new IntVector(
				Mathf.FloorToInt(v.x),
				Mathf.FloorToInt(v.y),
				Mathf.FloorToInt(v.z)
				);
		}

        public static Vector3Int FloorToVector3Int(Vector3 v) {
	        return new Vector3Int(
		        Mathf.FloorToInt(v.x),
		        Mathf.FloorToInt(v.y),
		        Mathf.FloorToInt(v.z)
	        );
        }

        public static Vector3Int RoundToVector3Int(Vector3 v) {
	        return new Vector3Int(
		        Mathf.RoundToInt(v.x),
		        Mathf.RoundToInt(v.y),
		        Mathf.RoundToInt(v.z)
	        );
        }

        
        public static Vector2Int RoundToVector2Int(Vector3 v) {
	        return new Vector2Int(
		        Mathf.RoundToInt(v.x),
		        Mathf.RoundToInt(v.y)
	        );
        }
        
        public static Vector3 V3FloorToInt(Vector3 v)
        {
            return new Vector3(
                Mathf.FloorToInt(v.x),
                Mathf.FloorToInt(v.y),
                Mathf.FloorToInt(v.z));
        }
        public static Vector3 V3RoundToInt(Vector3 v)
        {
            return new Vector3(
                Mathf.RoundToInt(v.x),
                Mathf.RoundToInt(v.y),
                Mathf.RoundToInt(v.z));
        }

        public static Vector3 ComponentMin(Vector3 a, Vector3 b)
        {
	        return new Vector3(
		        Mathf.Min(a.x, b.x),
		        Mathf.Min(a.y, b.y),
		        Mathf.Min(a.z, b.z)
	        );
        }

        public static Vector3 ComponentMax(Vector3 a, Vector3 b)
        {
	        return new Vector3(
		        Mathf.Max(a.x, b.x),
		        Mathf.Max(a.y, b.y),
		        Mathf.Max(a.z, b.z)
	        );
        }

        /// <summary>
        /// Rounds to an IntVector, with the XYZ components rounded to the nearest int
        /// </summary>
        /// <param name="v">The input Vector3 to convert</param>
        /// <returns>The rounded IntVector</returns>
		public static IntVector RoundToIntVector(Vector3 v) {
			return new IntVector(
				Mathf.RoundToInt(v.x),
				Mathf.RoundToInt(v.y),
				Mathf.RoundToInt(v.z)
				);
		}

        /// <summary>
        /// Snaps the position to the nearest grid cell location
        /// </summary>
        /// <param name="position">The position to snap</param>
        /// <param name="gridCellSize">The size of the grid cell</param>
        /// <returns>The snapped position</returns>
		public static Vector3 SnapToGrid(Vector3 position, Vector3 gridCellSize) {
			return SnapToGrid(position, gridCellSize, true);
		}

        /// <summary>
        /// Snaps the position to the nearest grid cell location
        /// </summary>
        /// <param name="position">The position to snap</param>
        /// <param name="gridCellSize">The size of the grid cell</param>
        /// <param name="useRounding">Flag to indicate if rounding is to be used.  Uses floor if false</param>
        /// <returns>The snapped position</returns>
        public static Vector3 SnapToGrid(Vector3 position, Vector3 gridCellSize, bool useRounding)
        {
			Vector3 gridPosition;
			if (useRounding) {
				gridPosition = new Vector3(
					Mathf.RoundToInt(position.x / gridCellSize.x),
					Mathf.RoundToInt(position.y / gridCellSize.y),
					Mathf.RoundToInt(position.z / gridCellSize.z));
			} else {
				gridPosition = new Vector3(
					Mathf.FloorToInt(position.x / gridCellSize.x),
					Mathf.FloorToInt(position.y / gridCellSize.y),
					Mathf.FloorToInt(position.z / gridCellSize.z));
				//gridPosition += Vector3.one;
			}
			return Vector3.Scale(gridPosition, gridCellSize);
		}

        /// <summary>
        /// Checks if the two rectangles intersect
        /// </summary>
        /// <param name="outer">The outer rect</param>
        /// <param name="inner">The inner rect</param>
        /// <returns>True if they intersect, false otherwise</returns>
		public static bool Intersects(Rect a, Rect b) {
            bool notIntersecting = (a.xMin > b.xMax || a.xMax < b.xMin || a.yMin > b.yMax || a.yMax < b.yMin);
            return !notIntersecting;
		}
		
        public static Vector2 ClosestPointOnRect(Rect rect, Vector2 p)
        {
            var result = new Vector2();
            result.x = Mathf.Clamp(p.x, rect.xMin, rect.xMax);
            result.y = Mathf.Clamp(p.y, rect.yMin, rect.yMax);
            return result;
        }


        public static Rect ExpandRect(Rect bounds, float amount)
        {
            var rect = new Rect(bounds);
            rect.x -= amount;
            rect.y -= amount;
            rect.width += amount * 2;
            rect.height += amount * 2;
            return rect;
        }


        public static Vector3 ClampToRect(Vector3 position, Rect bounds)
        {
	        var pos2D = new Vector2(position.x, position.z);
	        pos2D = ClampToRect(pos2D, bounds);
	        return new Vector3(pos2D.x, position.y, pos2D.y);
        }
        
        public static Vector2 ClampToRect(Vector2 position, Rect bounds)
        {
            var result = position;
            result.x = Mathf.Clamp(result.x, bounds.x, bounds.x + bounds.width);
            result.y = Mathf.Clamp(result.y, bounds.y, bounds.y + bounds.height);
            return result;
        }

		/// <summary>
		/// Flips the coordinates for 2D mode
		/// </summary>
		/// <param name="bounds">Bounds.</param>
		public static void FlipYZ(ref Bounds bounds) {
			bounds.size = FlipYZ (bounds.size);
			var center = FlipYZ (bounds.center);
			center.y = 0;
			bounds.center = center;
		}

		/// <summary>
		/// Flips the coordinates for 2D mode
		/// </summary>
		/// <returns>The Y.</returns>
		/// <param name="bounds">Bounds.</param>
		public static Vector3 FlipYZ(Vector3 bounds) {
			var z = bounds.z;
			bounds.z = bounds.y;
			bounds.y = z;
			return bounds;
		}

		/// <summary>
		/// Flips the coordinates for 2D mode
		/// </summary>
		/// <returns>The Y.</returns>
		/// <param name="bounds">Bounds.</param>
		public static IntVector FlipYZ(IntVector bounds) {
			var z = bounds.z;
			bounds.z = bounds.y;
			bounds.y = z;
			return bounds;
		}

        public static void Abs(ref Vector3 v)
        {
            v.x = Mathf.Abs(v.x);
            v.y = Mathf.Abs(v.y);
            v.z = Mathf.Abs(v.z);
        }

		/// <summary>
		/// Flag to indicate an invalid location
		/// </summary>
		public static readonly int INVALID_LOCATION = -1000000;


		public static void Swap<T>(ref T a, ref T b)
		{
			T t = a;
			a = b;
			b = t;
		}
        
        public static void Shuffle<T>(List<T> Array, System.Random Random)
        {
            int Count = Array.Count;
            for (int i = 0; i < Count; i++)
            {
                int j = Random.Range(0, Count - 1);
                T Temp = Array[i];
                Array[i] = Array[j];
                Array[j] = Temp;
            }
        }

        public static void Shuffle<T>(T[] Array, System.Random Random)
        {
            int Count = Array.Length;
            for (int i = 0; i < Count; i++)
            {
                int j = Random.Range(0, Count - 1);
                T Temp = Array[i];
                Array[i] = Array[j];
                Array[j] = Temp;
            }
        }

        public static int[] GetShuffledIndices(int Count, System.Random Random)
        {
            var Indices = new List<int>();
            for (int i = 0; i < Count; i++)
            {
                Indices.Add(i);
            }

            Shuffle(Indices, Random);
            return Indices.ToArray();
        }

        public static Bounds TransformBounds(Matrix4x4 transform, Bounds bounds)
        {
            var vertices = new Vector3[8];
            var center = bounds.center;
            var extents = bounds.extents;

            vertices[0] = center + new Vector3(extents.x, extents.y, extents.z);
            vertices[1] = center + new Vector3(extents.x, extents.y, -extents.z);
            vertices[2] = center + new Vector3(extents.x, -extents.y, extents.z);
            vertices[3] = center + new Vector3(extents.x, -extents.y, -extents.z);
            vertices[4] = center + new Vector3(-extents.x, extents.y, extents.z);
            vertices[5] = center + new Vector3(-extents.x, extents.y, -extents.z);
            vertices[6] = center + new Vector3(-extents.x, -extents.y, extents.z);
            vertices[7] = center + new Vector3(-extents.x, -extents.y, -extents.z);

            for (int i = 0; i < 8; i++)
            {
                vertices[i] = transform.MultiplyPoint3x4(vertices[i]);
            }

            var newBounds = new Bounds(vertices[0], Vector3.zero);
            for (int i = 1; i < 8; i++) { 
                newBounds.Encapsulate(vertices[i]);
            }
            
            return newBounds;
        }

        public static Bounds TransformBoundsX(Matrix4x4 transform, Bounds localBounds)
        {

            var center = transform * localBounds.center;
            
            // transform the local extents' axes
            var extents = localBounds.extents;
            var axisX = transform * new Vector3(extents.x, 0, 0);
            var axisY = transform * new Vector3(0, extents.y, 0);
            var axisZ = transform * new Vector3(0, 0, extents.z);

            // sum their absolute value to get the world extents
            extents.x = Mathf.Abs(axisX.x) + Mathf.Abs(axisY.x) + Mathf.Abs(axisZ.x);
            extents.y = Mathf.Abs(axisX.y) + Mathf.Abs(axisY.y) + Mathf.Abs(axisZ.y);
            extents.z = Mathf.Abs(axisX.z) + Mathf.Abs(axisY.z) + Mathf.Abs(axisZ.z);

            return new Bounds { center = center, extents = extents };
        }

        public static bool V3Equals(Vector3 a, Vector3 b)
        {
            return V3Equals(a, b, 1e-6f);
        }

        public static bool V3Equals(Vector3 a, Vector3 b, float threshold)
        {
            return Vector3.Magnitude(a - b) < threshold;
        }

        public static byte ToByte(float value01)
        {
            return (byte)Mathf.RoundToInt(Mathf.Clamp01(value01) * 255);
        }

        public static Vector3 ReflectVector(Vector3 direction, Vector3 normal)
        {
	        return direction - 2 * Vector3.Dot(direction, normal) * normal;
        }

        public static bool RayPlaneIntersection(Ray ray, Plane plane, out float distance)
        {
	        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection
	        var denominator = Vector3.Dot(ray.direction, plane.normal);
	        if (Mathf.Abs(denominator) < 1e-6f)
	        {
		        distance = 0;
		        return false;
	        }

	        var p0 = plane.normal * plane.distance;
	        var l0 = ray.origin;
	        distance = Vector3.Dot(p0 - l0, plane.normal) / denominator;
	        return distance >= 0;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\Matrix.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;


namespace DungeonArchitect.Utils
{
	public class Matrix {
		public static Vector3 GetTranslation(ref Matrix4x4 matrix) {
			Vector3 translate;
			translate.x = matrix.m03;
			translate.y = matrix.m13;
			translate.z = matrix.m23;
			return translate;
		}
		
		public static Vector3 GetTranslationDivW(ref Matrix4x4 matrix)
		{
			float w = matrix.m33;
			Vector3 translate;
			translate.x = matrix.m03 / w;
			translate.y = matrix.m13 / w;
			translate.z = matrix.m23 / w;
			return translate;
		}

		public static void SetTranslation(ref Matrix4x4 matrix, Vector3 translate) {
			matrix.m03 = translate.x;
			matrix.m13 = translate.y;
			matrix.m23 = translate.z;
		}

        
		public static void SetTransform(out Matrix4x4 transform, Vector3 position, Quaternion rotation, Vector3 scale) {
			transform = Matrix4x4.TRS(position, rotation, scale);
		}
		
		public static Quaternion GetRotation(ref Matrix4x4 matrix) {
			Vector3 forward;
			forward.x = matrix.m02;
			forward.y = matrix.m12;
			forward.z = matrix.m22;
			
			Vector3 upwards;
			upwards.x = matrix.m01;
			upwards.y = matrix.m11;
			upwards.z = matrix.m21;

            if (forward == Vector3.zero)
            {
                return Quaternion.identity;
            }
			return Quaternion.LookRotation(forward, upwards);
		}

		public static Vector3 GetScale(ref Matrix4x4 matrix) {
            return matrix.lossyScale;
		}
		
		public static void DecomposeMatrix(ref Matrix4x4 matrix, out Vector3 localPosition, out Quaternion localRotation, out Vector3 localScale) {
			localPosition = GetTranslation(ref matrix);
			localRotation = GetRotation(ref matrix);
			localScale = GetScale(ref matrix);
		}
		
		public static void SetTransformFromMatrix(Transform transform, ref Matrix4x4 matrix) {
			transform.localPosition = GetTranslation(ref matrix);
			transform.localRotation = GetRotation(ref matrix);
			transform.localScale = GetScale(ref matrix);
		}

		public static Matrix4x4 Copy(Matrix4x4 In) {
			return In * Matrix4x4.identity;
		}

		public static Matrix4x4 FromGameTransform(Transform t) {
			return Matrix4x4.TRS(t.position, t.rotation, t.localScale);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\MetaAttribute.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect
{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class MetaAttribute : System.Attribute
    {
        public string displayText;
        public MetaAttribute(string displayText)
        {
            this.displayText = displayText;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\ObjectUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Utils
{
    public class ObjectUtils
    {
        public static void DestroyObject(Object go)
        {
            if (Application.isPlaying)
            {
                Object.Destroy(go);
            }
            else
            {
                Object.DestroyImmediate(go);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\PMRandom.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;

namespace DungeonArchitect.Utils
{
    /// <summary>
    /// A random stream based on normal distribution. Also support uniform distsribution
    /// </summary>
    public class PMRandom
    {
        const int A = 16807;
        const int M = 2147483647;
        
        uint seed = 0;
        Random random = new Random();
		public Random UniformRandom {
			get {
				return random;
			}
		}


        /// <summary>
        /// Creates a new random stream with seed 0
        /// </summary>
		public PMRandom() 
		{ 
			Initialize(0);
		}

        /// <summary>
        /// Creates a new random stream with the specified seed
        /// </summary>
        /// <param name="seed">The seed to initialize the random stream</param>
        public PMRandom(uint seed)
        {
			Initialize(seed);
        }

        /// <summary>
        /// Initializes the stream with the given seed
        /// </summary>
        /// <param name="seed"></param>
		public void Initialize(uint seed) {
			this.seed = seed;
			random = new Random((int)this.seed);
		}

        // http://stackoverflow.com/a/218600
        /// <summary>
        /// Gets the next random number from a uniform distribution
        /// </summary>
        /// <returns>Random number from a uniform stream</returns>
        public float NextGaussianFloat()
        {
            double u1 = random.NextDouble(); //these are uniform(0,1) random doubles
            double u2 = random.NextDouble();
            double randStdNormal = Math.Sqrt(-2.0 * Math.Log(u1)) *
                         Math.Sin(2.0 * Math.PI * u2); //random normal(0,1)

            return (float)randStdNormal;
        }

        /// <summary>
        /// Gets the next random number from a uniform distribution
        /// </summary>
        /// <param name="mean">The mean used for the normal distribution</param>
        /// <param name="stdDev">The standard deviation used for the normal distribution</param>
        /// <returns>The resulting random number from the normal distributed random stream</returns>
        public float NextGaussianFloat(float mean, float stdDev)
        {
            return mean + stdDev * NextGaussianFloat(); 
        }

        public UnityEngine.Vector2 RandomPointOnCircle()
        {
            float angle = GetNextUniformFloat() * UnityEngine.Mathf.PI * 2;
            return new UnityEngine.Vector2(UnityEngine.Mathf.Cos(angle), UnityEngine.Mathf.Sin(angle));
        }

        /// <summary>
        /// Gets a random number from the uniformly distributed stream
        /// </summary>
        /// <returns></returns>
        public float GetNextUniformFloat()
        {
			return (float)random.NextDouble();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\RandomExtensions.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

/// <summary>
/// Extends System.Random with gamedev based utility functions
/// </summary>
public static class RandomExtensions {
	
	public static float NextFloat(this System.Random random)
	{
		return (float)random.NextDouble();
	}

	public static Vector3 OnUnitSphere(this System.Random random) {
		var z = (float)random.NextDouble() * 2 - 1;
		var rxy = Mathf.Sqrt(1 - z*z);
		var phi = (float)random.NextDouble() * 2 * Mathf.PI;
		var x = rxy * Mathf.Cos(phi);
		var y = rxy * Mathf.Sin(phi);
		return new Vector3(x, y, z);
	}
	
	public static float Range(this System.Random random, float a, float b) {
		return a + NextFloat(random) * (b - a);
	}

    /// <summary>
    /// Random number between &gt= a and &lt= b
    /// </summary>
    /// <param name="random"></param>
    /// <param name="a"></param>
    /// <param name="b"></param>
    /// <returns></returns>
	public static int Range(this System.Random random, int a, int b) {
		return Mathf.RoundToInt(a + NextFloat(random) * (b - a));
	}

	public static float value(this System.Random random) {
		return NextFloat(random);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\RenderUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;


namespace DungeonArchitect.Utils
{
    public class TexturedMaterialInstances
    {
        Shader shader = null;
        public TexturedMaterialInstances(Shader shader)
        {
            this.shader = shader;
        }

        Dictionary<Texture2D, Material> materialsByTexture = new Dictionary<Texture2D, Material>();
        public Material GetMaterial(Texture2D texture)
        {
            if (!materialsByTexture.ContainsKey(texture))
            {
                var material = new Material(shader);
                material.mainTexture = texture;

                materialsByTexture[texture] = material;
            }
            return materialsByTexture[texture];
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\ScriptInstanceCache.cs:
 using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Utils
{
    public class ScriptInstanceCache<T> where T : ScriptableObject
    {
        private Dictionary<string, T> _scriptCache = new Dictionary<string, T>();

        public T GetScript(string typePath)
        {
            T script = null;
            if (_scriptCache.ContainsKey(typePath))
            {
                script = _scriptCache[typePath];
            }

            if (script == null)
            {
                var type = System.Type.GetType(typePath);
                if (type != null && type.IsSubclassOf(typeof(T)))
                {
                    var obj = ScriptableObject.CreateInstance(type); 
                    script = obj as T;
                }

                if (script != null)
                {
                    _scriptCache[typePath] = script;
                }
            }

            return script;
        }
        
        public void Release()
        {
            foreach (var entry in _scriptCache)
            {
                if (entry.Value != null)
                {
                    if (Application.isPlaying)
                    {
                        Object.Destroy(entry.Value);
                    }
                    else
                    {
                        Object.DestroyImmediate(entry.Value);
                    }
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\SmoothValue.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Utils
{
    public abstract class SmoothValue<T>
    {
        protected T targetValue;
        protected T currentValue;
        protected float t = 0;

        public float TimeToArrive = 0.4f;
        public bool HasArrived => t >= 1;
        
        public T Value
        {
            get => currentValue;
            set
            {
                targetValue = value;
                t = 0;
            }
        }

        public T TargetValue => targetValue;

        protected SmoothValue(T value)
        {
            Set(value);
        }

        public void Set(T value)
        {
            currentValue = value;
            targetValue = value;
            t = 0;
        }
        
        public void Update(float deltaTime)
        {
            if (t < 1)
            {
                t += deltaTime / TimeToArrive;
                t = Mathf.Clamp01(t);

                PerformLerp();
            }
        }

        protected abstract void PerformLerp();
    }

    public class SmoothValueFloat : SmoothValue<float>
    {
        public SmoothValueFloat(float value) : base(value) { }
        protected override void PerformLerp()
        {
            currentValue = Mathf.Lerp(currentValue, targetValue, t);
        }
    }
    
    public class SmoothValueVector3 : SmoothValue<Vector3>
    {
        public SmoothValueVector3(Vector3 value) : base(value) { }
        protected override void PerformLerp()
        {
            currentValue = Vector3.Lerp(currentValue, targetValue, t);
        }
    }
    
    public class SmoothValueVector2 : SmoothValue<Vector2>
    {
        public SmoothValueVector2(Vector2 value) : base(value) { }
        protected override void PerformLerp()
        {
            currentValue = Vector2.Lerp(currentValue, targetValue, t);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\StackSystem.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;

namespace DungeonArchitect.Utils
{
    public class StackSystem<TState, TStaticState, TSharedState, TResult>
        where TSharedState : new()
    {   
        protected TStaticState staticState;

        private Stack<TState> stack = new Stack<TState>();
        private bool running = false;
        private bool foundResult = false;
        private TResult result;
        private TSharedState sharedState = new TSharedState();

        public delegate void ExecuteFrameDelegate(TState top, TStaticState staticState, TSharedState sharedState, StackSystem<TState, TStaticState, TSharedState, TResult> stackSystem);

        public StackSystem(TStaticState staticState)
        {
            this.staticState = staticState;
        }

        public TSharedState SharedState => sharedState;
        
        public bool Running
        {
            get => running;
        }

        public bool FoundResult
        {
            get => foundResult;
        }

        public TResult Result
        {
            get => result;
        }

        public Stack<TState> Stack
        {
            get => stack;
        }

        public void Initialize(TState state)
        {
            stack.Push(state);
            running = true;
        }

        public void PushFrame(TState state)
        {
            stack.Push(state);
        }

        public void FinalizeResult(TResult result)
        {
            running = false;
            foundResult = true;
            this.result = result;
        }

        public void Halt()
        {
            running = false;
        }

        public void ExecuteStep(ExecuteFrameDelegate executeFrame)
        {
            if (stack.Count == 0)
            {
                running = false;
            }

            if (!running)
            {
                return;
            }

            var top = stack.Pop();
            if (executeFrame != null)
            {
                executeFrame.Invoke(top, staticState, sharedState, this);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\GrammarNodeType.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Grammar
{
    public class GrammarNodeType : ScriptableObject
    {
        [SerializeField]
        public string nodeName;

        [SerializeField]
        public string description;

        [SerializeField]
        public Color nodeColor = new Color(0.2f, 0.3f, 0.3f);

        [SerializeField]
        [HideInInspector]
        public bool wildcard = false;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\GrammarProductionRule.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Grammar
{
    [System.Serializable]
    public class GrammarProductionRule : ScriptableObject
    {
        [SerializeField]
        public string ruleName;

        [HideInInspector]
        [SerializeField]
        public GrammarGraph LHSGraph;

        [HideInInspector]
        [SerializeField]
        public List<WeightedGrammarGraph> RHSGraphs = new List<WeightedGrammarGraph>();
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\SnapFlowAsset.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Grammar
{
    [System.Serializable]
    public class SnapFlowAsset : ScriptableObject
    {
        [HideInInspector]
        [SerializeField]
        public GrammarExecGraph executionGraph;

        [HideInInspector]
        [SerializeField]
        public GrammarProductionRule[] productionRules;

        [HideInInspector]
        [SerializeField]
        public GrammarNodeType[] nodeTypes;

        [HideInInspector]
        [SerializeField]
        public GrammarNodeType wildcardNodeType;

        [HideInInspector]
        [SerializeField]
        public GrammarGraph resultGraph;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\WeightedGrammarGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Grammar
{
    [System.Serializable]
    public class WeightedGrammarGraph : ScriptableObject
    {
        [SerializeField]
        public float weight;

        [SerializeField]
        [HideInInspector]
        public GrammarGraph graph;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\Graph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Linq;
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Graphs
{
    /// <summary>
    /// An ID provider for graph objects
    /// </summary>
    [Serializable]
    public class IndexCounter
    {
        [SerializeField]
        int index = 0;

        public int GetNext()
        {
            index++;
            return index;
        }
    }
    
    /// <summary>
    /// Theme Graph data structure holds all the theme nodes and their connections
    /// </summary>
    [Serializable]
    public class Graph : ScriptableObject
    {
        [SerializeField]
        IndexCounter indexCounter;
        public DungeonArchitect.Graphs.IndexCounter IndexCounter
        {
            get { return indexCounter; }
        }

        [SerializeField]
        IndexCounter topZIndex;

        [SerializeField]
        List<GraphNode> nodes;
        /// <summary>
        /// List of graph nodes
        /// </summary>
        public List<GraphNode> Nodes
        {
            get
            {
                return nodes;
            }
        }

        [SerializeField]
        List<GraphLink> links;

        /// <summary>
        /// List of graph links connecting the nodes
        /// </summary>
        public List<GraphLink> Links
        {
            get
            {
                return links;
            }
        }

        /// <summary>
        /// The z index of the top most node
        /// </summary>
        public IndexCounter TopZIndex
        {
            get
            {
                return topZIndex;
            }
        }
        
        public virtual void OnEnable()
        {
            //hideFlags = HideFlags.HideAndDontSave;
            if (IndexCounter == null)
            {
                indexCounter = new IndexCounter();
            }
            if (topZIndex == null)
            {
                topZIndex = new IndexCounter();
            }
            if (nodes == null)
            {
                nodes = new List<GraphNode>();
            }
            if (links == null)
            {
                links = new List<GraphLink>();
            }

            // Remove any null nodes
            for (int i = 0; i < nodes.Count; )
            {
                if (nodes[i] == null)
                {
                    nodes.RemoveAt(i);
                }
                else
                {
                    i++;
                }
            }
        }

        /// <summary>
        /// Gets the node by it's id
        /// </summary>
        /// <param name="id">The ID of the node</param>
        /// <returns>The retrieved node.  null if node with this id doesn't exist</returns>
        public GraphNode GetNode(string id)
        {
            var result = from node in Nodes
                         where node.Id == id
                         select node;

            return (result.Count() > 0) ? result.Single() : null;
        }

        /// <summary>
        /// Get all nodes of the specified type
        /// </summary>
        /// <typeparam name="T">The type of nodes to retrieve. Should be a subclass of GraphNode</typeparam>
        /// <returns>List of all the nodes of the specified type</returns>
        public T[] GetNodes<T>() where T : GraphNode
        {
            var targetNodes = new List<T>();
            foreach (var node in nodes)
            {
                if (node is T)
                {
                    targetNodes.Add(node as T);
                }
            }
            return targetNodes.ToArray();
        }

        public T _CreateLinkInstance<T>() where T : GraphLink
        {
            T link = ScriptableObject.CreateInstance<T>();
            link.Id = IndexCounter.GetNext();
            link.Graph = this;
            Links.Add(link);
            return link;
        }
                
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphCamera.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using UnityEngine;

namespace DungeonArchitect.Graphs
{
    /// <summary>
    /// A camera that manages the graph editor's viewport
    /// </summary>
    [Serializable]
    public class GraphCamera
    {
        float maxAllowedZoom = 6.0f;
        public float MaxAllowedZoom
        {
            get { return maxAllowedZoom; }
            set { maxAllowedZoom = value; }
        }

        [SerializeField]
        Vector2 position = Vector2.zero;
        /// <summary>
        /// Position of the camera
        /// </summary>
        public Vector2 Position
        {
            get
            {
                return position;
            }
            set
            {
                position = value;
            }
        }

        public Vector2 ScreenOffset = Vector2.zero;

        [SerializeField]
		float zoomLevel = 1;
        /// <summary>
        /// Zoom scale of the graph camera
        /// </summary>
        public float ZoomLevel
        {
            get
            {
				return zoomLevel;
            }
            set
            {
				zoomLevel = value;
            }
        }

        /// <summary>
        /// Pan the camera along the specified delta value
        /// </summary>
        /// <param name="x">Delta value to move along the X value</param>
        /// <param name="y">Delta value to move along the Y value</param>
        public void Pan(int x, int y)
        {
            Pan(new Vector2(x, y));
        }

        /// <summary>
        /// Pan the camera along the specified delta value
        /// </summary>
        /// <param name="delta">The delta offset to move the camera to</param>
        public void Pan(Vector2 delta)
        {
			position += delta * zoomLevel;
        }

        /// <summary>
        /// Handles the user mouse and keyboard input 
        /// </summary>
        /// <param name="e"></param>
        public void HandleInput(Event e)
        {
			// Handle zooming
			if (e.type == EventType.ScrollWheel) {
				// Grab the original position under the mouse so we can restore it after the zoom
				var originalGraphPosition = ScreenToWorld(e.mousePosition);

				float zoomMultiplier = 0.1f;
				zoomMultiplier *= Mathf.Sign(e.delta.y);
				zoomLevel = Mathf.Clamp(zoomLevel * (1 + zoomMultiplier), 1, maxAllowedZoom);

				var newGraphPosition = ScreenToWorld (e.mousePosition);
				position += originalGraphPosition - newGraphPosition;
			}

            // Handle pan
            int dragButton1 = 1;
            int dragButton2 = 2;
            if (e.type == EventType.MouseDrag && (e.button == dragButton1 || e.button == dragButton2))
            {
                if (e.delta.magnitude < 150)
                {
                    Pan(-e.delta);
                }
            }
        }

        /// <summary>
        /// Converts world coordinates (in the graph view) into Screen coordinates (relative to the editor window)
        /// </summary>
        /// <param name="worldCoord">The world cooridnates of the graph view</param>
        /// <returns>The screen cooridnates relative to the editor window</returns>
        public Vector2 WorldToScreen(Vector2 worldCoord)
        {
            return (worldCoord - position) / zoomLevel + ScreenOffset;
        }

        /// <summary>
        /// Converts the Screen coordinates (of the editor window) into the graph's world coordinate
        /// </summary>
        /// <param name="screenCoord"></param>
        /// <returns>The world coordinates in the graph view</returns>
        public Vector2 ScreenToWorld(Vector2 screenCoord)
        {
            screenCoord -= ScreenOffset;

            return screenCoord * zoomLevel + position; 
        }

        /// <summary>
        /// Converts world coordinates (in the graph view) into Screen coordinates (relative to the editor window)
        /// </summary>
        /// <param name="worldCoord">The world cooridnates of the graph view</param>
        /// <returns>The screen cooridnates relative to the editor window</returns>
        public Rect WorldToScreen(Rect worldCoord)
        {
            var screen = worldCoord;
            screen.position = WorldToScreen(worldCoord.position);
            screen.size = worldCoord.size / zoomLevel;
            return screen;
        }

        /// <summary>
        /// Converts the Screen coordinates (of the editor window) into the graph's world coordinate
        /// </summary>
        /// <param name="screenCoord"></param>
        /// <returns>The world coordinates in the graph view</returns>
        public Rect ScreenToWorld(Rect screenCoord)
        {
            var world = screenCoord;
            world.position = ScreenToWorld(screenCoord.position);
            world.size = screenCoord.size * ZoomLevel;
            return world;
        }



        /// <summary>
        /// Moves the camera so most of the nodes are visible
        /// </summary>
        /// <param name="graph">The graph to query</param>
        /// <param name="editorBounds">The bounds of the editor window</param>
        public void FocusOnBestFit(Graph graph, Rect editorBounds)
        {
            if (graph == null) return;
            if (graph.Nodes.Count > 0)
            {
                var graphVisibleSize = editorBounds.size * zoomLevel;
                Vector2 average = Vector2.zero;
                foreach (var node in graph.Nodes)
                {
                    if (node == null) continue;
                    average += node.Bounds.center;
                }
                average /= graph.Nodes.Count;
                position = average - graphVisibleSize / 2.0f;
            }
            else
            {
                position = Vector3.zero;
                zoomLevel = 1.0f;
            }
        }

        /// <summary>
        /// Moves the camera to the specified node
        /// </summary>
        /// <param name="node">The node to focus on</param>
        /// <param name="editorBounds">The bounds of the editor window</param>
        public void FocusOnNode(GraphNode node, Rect editorBounds)
		{
			var graphVisibleSize = editorBounds.size * zoomLevel;
            var nodePosition = node.Bounds.center;
			position = nodePosition - graphVisibleSize / 2.0f;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphLink.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Graphs
{
    /// <summary>
    /// A graph link is a directional connection between two graph nodes
    /// </summary>
    [System.Serializable]
    public class GraphLink : ScriptableObject
    {
        [SerializeField]
        int id;
        /// <summary>
        /// The ID of the link
        /// </summary>
        public int Id
        {
            get
            {
                return id;
            }
            set
            {
                id = value;
                UpdateName();
            }
        }

        [SerializeField]
        GraphPin input;
        /// <summary>
        /// The input pin this link originates from
        /// </summary>
        public GraphPin Input
        {
            get
            {
                return input;
            }
            set
            {
                input = value;
            }
        }

        [SerializeField]
        GraphPin output;
        /// <summary>
        /// The output pin this link points to
        /// </summary>
        public GraphPin Output
        {
            get
            {
                return output;
            }
            set
            {
                output = value;
            }
        }

        [SerializeField]
        Graph graph;
        /// <summary>
        /// The graph this link belongs to
        /// </summary>
        public Graph Graph
        {
            get
            {
                return graph;
            }
            set
            {
                graph = value;
            }
        }

        public void OnEnable()
        {
            hideFlags = HideFlags.HideInHierarchy;
            UpdateName();
        }

        void UpdateName()
        {
            this.name = "Link_" + id;
        }


        /// <summary>
        /// Determines the spring strength of the link.  
        /// It reduces as it gets smaller to draw good looking link at any distance
        /// </summary>
        /// <returns></returns>
        public float GetTangentStrength()
        {
            var distance = (output.WorldPosition - input.WorldPosition).magnitude;
            var tangentStrength = Mathf.Min(output.TangentStrength, distance / 2.0f);
            return tangentStrength;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Graphs
{
    /// <summary>
    /// Represents a graph node in the theme graph.  This is the base class for all graph nodes
    /// </summary>
    [System.Serializable]
    public class GraphNode : ScriptableObject
    {
        [SerializeField]
        [HideInInspector]
		protected string id;
        /// <summary>
        /// The ID of the graph node
        /// </summary>
        public string Id
        {
            get
            {
                return id;
            }
			set { id = value; }
        }

        [SerializeField]
        [HideInInspector]
        protected string caption;
        /// <summary>
        /// The caption label of the node. It is up to the implementation to draw this label, if needed
        /// </summary>
        public string Caption
        {
            get
            {
                return caption;
            }
            set
            {
                caption = value;
            }
        }

        [SerializeField]
        [HideInInspector]
        protected Rect bounds = new Rect(10, 10, 120, 120);
        /// <summary>
        /// The bounds of the node
        /// </summary>
        public Rect Bounds
        {
            get
            {
                return bounds;
            }
            set
            {
                bounds = value;
            }
        }

        [SerializeField]
        [HideInInspector]
        protected bool canBeDeleted = true;
        public bool CanBeDeleted
        {
            get { return canBeDeleted; }
        }

        [SerializeField]
        [HideInInspector]
        protected bool canBeSelected = true;
        public bool CanBeSelected
        {
            get { return canBeSelected; }
        }

        [SerializeField]
        [HideInInspector]
        protected bool canBeMoved = true;
        public bool CanBeMoved
        {
            get { return canBeMoved; }
        }

        [SerializeField]
        [HideInInspector]
        protected bool selected = false;
        /// <summary>
        /// Flag to indicate if the node has been selected
        /// </summary>
        public bool Selected
        {
            get
            {
                return selected;
            }
            set
            {
                if (canBeSelected)
                {
                    selected = value;
                }
                else
                {
                    selected = false;
                }
            }
        }

        /// <summary>
        /// The size of the node
        /// </summary>
        public Vector2 Size
        {
            get { return bounds.size; }
            set
            {
                bounds.size = value;
            }
        }

        /// <summary>
        /// The position of the node
        /// </summary>
        public Vector2 Position
        {
            get { return bounds.position; }
            set
            {
                bounds.position = value;
            }
        }

        [SerializeField]
        [HideInInspector]
        protected int zIndex;
        /// <summary>
        /// The Z-index of the node.  It determines if the node is on top of other nodes
        /// </summary>
        public int ZIndex
        {
            get
            {
                return zIndex;
            }
            set
            {
                zIndex = value;
            }
        }

        [SerializeField]
        [HideInInspector]
        protected List<GraphPin> inputPins;
        /// <summary>
        /// List of input pins owned by this node
        /// </summary>
        public GraphPin[] InputPins
        {
            get
            {
                return inputPins != null ? inputPins.ToArray() : new GraphPin[0];
            }
        }

        [SerializeField]
        [HideInInspector]
        protected List<GraphPin> outputPins;
        /// <summary>
        /// List of output pins owned by this node
        /// </summary>
        public GraphPin[] OutputPins
        {
            get
            {
                return outputPins != null ? outputPins.ToArray() : new GraphPin[0];
            }
        }

        /// <summary>
        /// Gets the first output pin. Returns null if no output pins are defined
        /// </summary>
        public GraphPin OutputPin
        {
            get
            {
                if (outputPins == null || outputPins.Count == 0) return null;
                return outputPins[0];
            }
        }

        /// <summary>
        /// Gets the first input pin. Returns null if no input pins are defined
        /// </summary>
        public GraphPin InputPin
        {
            get
            {
                if (inputPins == null || inputPins.Count == 0) return null;
                return inputPins[0];
            }
        }

        [SerializeField]
        [HideInInspector]
        protected Graph graph;

        /// <summary>
        /// The graph that owns this node
        /// </summary>
        public Graph Graph
        {
            get
            {
                return graph;
            }
        }

        public virtual void OnEnable()
        {
            hideFlags = HideFlags.HideInHierarchy;
        }

		public virtual void Initialize(string id, Graph graph)
        {
            this.id = id;
            this.graph = graph;
        }

        /// <summary>
        /// Called when the node is copied.  
        /// The implementations should implement copy here (e.g. deep / shallow copy depending on implementation)
        /// </summary>
        /// <param name="node"></param>
        public virtual void CopyFrom(GraphNode node)
        {
            if (node != null)
            {
                caption = node.Caption;
                this.bounds = node.Bounds;
            }
        }

        protected void UpdateName(string prefix)
        {
            this.name = prefix + id;
        }

        private bool dragging = false;
        public bool Dragging
        {
            get { return dragging; }
            set { dragging = value; }
        }

        /// <summary>
        /// Creates a pin with the specified configuration
        /// </summary>
        /// <param name="pinType">The type of pin (input / output)</param>
        /// <param name="position">The position of the pin, relative to the node bounds</param>
        /// <param name="boundsOffset">The bounds of the pin, relative to the position</param>
        /// <param name="tangent">The tangent of the pin.  Links connected to the pin would come out from this direction</param>
        protected GraphPin CreatePin(GraphPinType pinType, Vector2 position, Rect boundsOffset, Vector2 tangent)
        {
            return CreatePinOfType<GraphPin>(pinType, position, boundsOffset, tangent);
        }

        protected T CreatePinOfType<T>(GraphPinType pinType) where T : GraphPin
        {
            return CreatePinOfType<T>(pinType, Vector2.zero, Rect.zero, Vector2.zero);
        }

        protected T CreatePinOfType<T>(GraphPinType pinType, Vector2 position, Rect boundsOffset, Vector2 tangent) where T : GraphPin
        {
            var pin = CreateInstance<T>();
            pin.PinType = pinType;
            pin.Node = this;
            pin.Position = position;
            pin.BoundsOffset = boundsOffset;
            pin.Tangent = tangent;
            if (pinType == GraphPinType.Input)
            {
                pin.name = this.name + "_InputPin";
                if (inputPins == null)
                {
                    inputPins = new List<GraphPin>();
                }
                inputPins.Add(pin);
            }
            else
            {
                pin.name = this.name + "_OutputPin";
                if (outputPins == null)
                {
                    outputPins = new List<GraphPin>();
                }
                outputPins.Add(pin);
            }
            return pin;
        }

        /// <summary>
        /// Gets the list of parent graph nodes
        /// </summary>
        /// <returns>List of parent graph nodes</returns>
        public GraphNode[] GetParentNodes()
        {
            var parents = new List<GraphNode>();
            if (InputPins.Length > 0)
            {
                foreach (var link in InputPins[0].GetConntectedLinks())
                {
                    if (link != null && link.Output != null && link.Output.Node != null)
                    {
                        parents.Add(link.Output.Node);
                    }
                }
            }
            return parents.ToArray();
        }

        /// <summary>
        /// Gets the list of child nodes
        /// </summary>
        /// <returns>List of child nodes</returns>
        public GraphNode[] GetChildNodes()
        {
            var children = new List<GraphNode>();
            if (OutputPins.Length > 0)
            {
                foreach (var link in OutputPins[0].GetConntectedLinks())
                {
                    if (link != null && link.Input != null && link.Input.Node != null)
                    {
                        children.Add(link.Input.Node);
                    }
                }
            }
            return children.ToArray();
        }

        /// <summary>
        /// Moves the node by the specified delta
        /// </summary>
        /// <param name="delta">The delta offset to move the node by</param>
        public void DragNode(Vector2 delta)
        {
            Position += delta;
        }
        
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphPin.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Graphs
{
    /// <summary>
    /// The graph pin type
    /// </summary>
    public enum GraphPinType
    {
        Input,
        Output,
        Unknown
    }

    /// <summary>
    /// The state of the mouse input on a pin
    /// </summary>
    public enum GraphPinMouseState
    {
        Hover,
        Clicked,
        None
    }

    /// <summary>
    /// A pin is used to connect a link to a node
    /// </summary>
    [System.Serializable]
    public class GraphPin : ScriptableObject
    {
        GraphPinMouseState clickState = GraphPinMouseState.None;
        /// <summary>
        /// The state of the mouse input on this pin
        /// </summary>
        public GraphPinMouseState ClickState
        {
            get
            {
                return clickState;
            }
            set
            {
                clickState = value;
            }
        }

        [SerializeField]
        GraphPinType pinType;

        /// <summary>
        /// The type of this pin
        /// </summary>
        public GraphPinType PinType
        {
            get
            {
                return pinType;
            }
            set
            {
                pinType = value;
            }
        }

        public delegate void OnPinLinksDestroyed(GraphPin pin);

        /// <summary>
        /// Notifies whenever the pin is destroyed
        /// </summary>
        public event OnPinLinksDestroyed PinLinksDestroyed;

        /// <summary>
        /// The node this pin belongs to
        /// </summary>
        [SerializeField]
        GraphNode node;

        /// <summary>
        /// The owning graph node
        /// </summary>
        public GraphNode Node
        {
            get
            {
                return node;
            }
            set
            {
                node = value;
            }
        }

        [SerializeField]
        Vector2 position = new Vector2();
        /// <summary>
        /// The position of the graph pin, relative to the owning node's position
        /// </summary>
        public Vector2 Position
        {
            get
            {
                return position;
            }
            set
            {
                position = value;
            }
        }

        /// <summary>
        /// The world position of the pin
        /// </summary>
        public Vector2 WorldPosition
        {
            get
            {
                if (node != null)
                {
                    return position + node.Position;
                }
                else
                {
                    return position;
                }
            }
        }

        [SerializeField]
        Rect boundsOffset = new Rect(0, 0, 20, 20);
        /// <summary>
        /// The bounds of the pin, relative to the node's position
        /// </summary>
        public Rect BoundsOffset
        {
            get
            {
                return boundsOffset;
            }
            set
            {
                boundsOffset = value;
            }
        }

        [SerializeField]
        Vector2 tangent = new Vector2();
        /// <summary>
        /// The tangent of the pin.  Links connected to this pin would come in or out from this direction
        /// </summary>
        public Vector2 Tangent
        {
            get
            {
                return tangent;
            }
            set
            {
                tangent = value;
            }
        }

        [SerializeField]
        float tangentStrength = 50;
        /// <summary>
        /// The spring strength of the link connected to this pin
        /// </summary>
        public float TangentStrength
        {
            get
            {
                return tangentStrength;
            }
            set
            {
                tangentStrength = value;
            }
        }

        public void OnEnable()
        {
            hideFlags = HideFlags.HideInHierarchy;
        }

        /// <summary>
        /// Gets all the links connected to this pin
        /// </summary>
        /// <returns>The connected links.</returns>
        public GraphLink[] GetConntectedLinks()
        {
            var result = new List<GraphLink>();
            if (node != null && node.Graph != null)
            {
                foreach (var link in node.Graph.Links)
                {
                    if (link == null)
                    {
                        continue;
                    }
                    if (link.Input == this || link.Output == this)
                    {
                        result.Add(link);
                    }
                }
            }
            return result.ToArray();
        }

        /// <summary>
        /// Checks if a point is inside the pin
        /// </summary>
        /// <param name="worldPoint">The point to test in world coordinates</param>
        /// <returns>true, if inside the bounds of this pin, false otherwise</returns>
        public virtual bool ContainsPoint(Vector2 worldPoint)
        {
            return GetWorldBounds().Contains(worldPoint);
        }

        /// <summary>
        /// Gets the bounds of the pin, in world coordinates
        /// </summary>
        /// <returns>The bounds of the pin, in world coordinates</returns>
        Rect GetWorldBounds()
        {
            var position = this.WorldPosition + boundsOffset.position;
            var bounds = new Rect(position.x, position.y, boundsOffset.size.x, boundsOffset.size.y);
            return bounds;
        }

        /// <summary>
        /// Gets the bounds of the pin, relative to the node position
        /// </summary>
        /// <returns>The bounds of the pin, relative to the node position</returns>
        public Rect GetBounds()
        {
            var position = this.Position + boundsOffset.position;
            var bounds = new Rect(position.x, position.y, boundsOffset.size.x, boundsOffset.size.y);
            return bounds;
        }

        public void NotifyPinLinksDestroyed()
        {
            if (PinLinksDestroyed != null)
            {
                PinLinksDestroyed(this);
            }
        }

        bool requestLinkDeletionInitiated = false;
        public bool RequestLinkDeletionInitiated
        {
            get { return requestLinkDeletionInitiated; }
            set { requestLinkDeletionInitiated = value; }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphSchema.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Graphs
{
    /// <summary>
    /// The graph schema defines the rules of the theme graph
    /// </summary>
    public class GraphSchema
    {
        /// <summary>
        /// Checks if a link between the two nodes can be created
        /// </summary>
        /// <param name="output">The pin from which the link originates and goes out</param>
        /// <param name="input">The pin where the link points to</param>
        /// <returns>true, if the link is allowed, false otherwise</returns>
        public virtual bool CanCreateLink(GraphPin output, GraphPin input)
        {
            string errorMessage;
            return CanCreateLink(output, input, out errorMessage);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="output">The pin from which the link originates and goes out</param>
        /// <param name="input">The pin where the link points to</param>
        /// <param name="errorMessage"></param>
        /// <returns>true, if the link is allowed, false otherwise</returns>
        public virtual bool CanCreateLink(GraphPin output, GraphPin input, out string errorMessage)
        {
            errorMessage = "";
            if (output == null || input == null)
            {
                errorMessage = "Invalid connection";
                return false;
            }
            if (output.PinType != GraphPinType.Output || input.PinType != GraphPinType.Input)
            {
                errorMessage = "Not Allowed";
                return false;
            }

            // Make sure we don't already have this connection
            foreach (var link in output.GetConntectedLinks())
            {
                if (link.Input == input)
                {
                    errorMessage = "Not Allowed: Already connected";
                    return false;
                }
            }

            return true;
        }

        public virtual bool CanDestroyNode(GraphNode node)
        {
            return true;
        }

        public virtual T TryCreateLink<T>(Graph graph, GraphPin output, GraphPin input) where T : GraphLink
        {
            T link = graph._CreateLinkInstance<T>();
            link.Input = input;
            link.Output = output;
            return link;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Graphs
{
    /// <summary>
    /// Theme graph utility functions
    /// </summary>
    public class GraphUtils
    {
        private static GraphNode[] GetDirectionalNodes(GraphPin pin, bool isIncoming)
        {
            var result = new List<GraphNode>();
            var hostNode = pin.Node;
            if (hostNode && hostNode.Graph)
            {
                var graph = hostNode.Graph;
                foreach (var link in graph.Links)
                {
                    if (isIncoming && link.Input == pin)
                    {
                        var otherNode = link.Output.Node;
                        result.Add(otherNode);
                    }
                    else if (!isIncoming && link.Output == pin)
                    {
                        var otherNode = link.Input.Node;
                        result.Add(otherNode);
                    }
                }
            }
            return result.ToArray();
        }

        private static GraphNode[] GetDirectionalNodes(GraphNode hostNode, bool isIncoming)
        {
            var result = new List<GraphNode>();
            if (hostNode && hostNode.Graph)
            {
                var graph = hostNode.Graph;
                foreach (var link in graph.Links)
                {
                    if (isIncoming && link.Input.Node == hostNode)
                    {
                        var otherNode = link.Output.Node;
                        result.Add(otherNode);
                    }
                    else if (!isIncoming && link.Output.Node == hostNode)
                    {
                        var otherNode = link.Input.Node;
                        result.Add(otherNode);
                    }
                }
            }
            return result.ToArray();
        }

        /// <summary>
        /// Test if the graph link lies within the rectangle
        /// </summary>
        /// <param name="outer">The rect to test against</param>
        /// <param name="link">The link to test the intersection</param>
        /// <returns>True if intersects, false otherwise</returns>
        public static bool Intersects(Rect outer, GraphLink link) {
            if (link == null || link.Input == null || link.Output == null) return false;

            var p0 = link.Input.WorldPosition;
            var p1 = link.Output.WorldPosition;

            if (outer.Contains(p0) || outer.Contains(p1)) {
                return true;
            }
			
            var x0 = outer.position.x;
            var x1 = outer.position.x + outer.size.x;
            var y0 = outer.position.y;
            var y1 = outer.position.y + outer.size.y;

            var outside = 
                (p0.x < x0 && p1.x < x0) ||
                (p0.x > x1 && p1.x > x1) ||
                (p0.y < y0 && p1.y < y0) ||
                (p0.y > y1 && p1.y > y1);

            return !outside;
        }

        public static GraphNode[] GetIncomingNodes(GraphPin pin)
        {
            return GetDirectionalNodes(pin, true);
        }

        public static GraphNode[] GetOutgoingNodes(GraphPin pin)
        {
            return GetDirectionalNodes(pin, false);
        }

        public static GraphNode[] GetIncomingNodes(GraphNode node)
        {
            return GetDirectionalNodes(node, true);
        }

        public static GraphNode[] GetOutgoingNodes(GraphNode node)
        {
            return GetDirectionalNodes(node, false);
        }


    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\SxActor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.SxEngine.Utils;
using UnityEngine;

namespace DungeonArchitect.SxEngine
{
    public class SxActor : ISxSceneNode
    {
        private List<SxActorComponent> components = new List<SxActorComponent>();
        
        private SxTransform worldTransform = SxTransform.identity;
        public SxTransform WorldTransform
        {
            get => worldTransform;
            set => worldTransform = value;
        }
        
        public SxWorld World;
        private List<ISxSceneNode> children = new List<ISxSceneNode>();
        public ISxSceneNode[] Children
        {
            get => children.ToArray();
        }
        
        public SxActorComponent[] Components
        {
            get => components.ToArray();
        }

        public ISxSceneNode Parent { get; set; }
        
        public T AddComponent<T>() where T : SxActorComponent, new()
        {
            var component = new T();
            components.Add(component);
            return component;
        }

        public virtual void Draw(SxRenderContext context, Matrix4x4 accumWorldTransform, SxRenderCommandList renderCommandList)
        {
            foreach (var component in components)
            {
                var componentWorldTransform = accumWorldTransform * component.RelativeTransform;
                component.Draw(context, componentWorldTransform, renderCommandList);
            }
        }
        
        public virtual void Tick(SxRenderContext context, float deltaTime)
        {
            foreach (var component in components)
            {
                if (component.RequiresTick)
                {
                    component.Tick(context, deltaTime);
                }
            }
        }

        public void AddChild(ISxSceneNode child)
        {
            if (!children.Contains(child))
            {
                children.Add(child);
                child.Parent = this;
            }
        }

        public void RemoveChild(ISxSceneNode child)
        {
            children.Remove(child);
        }

        public void RemoveAllChildren()
        {
            children.Clear();
        }
        
        public virtual void Destroy()
        {
            World.DestroyActor(this);
        }

        public Vector3 Position
        {
            get => worldTransform.Positon;
            set => worldTransform.Positon = value;
        }
        
        public Quaternion Rotation
        {
            get => worldTransform.Rotation;
            set => worldTransform.Rotation = value;
        }

        public Vector3 Scale
        {
            get => worldTransform.Scale;
            set => worldTransform.Scale = value;
        }
    }

    public abstract class SxActorComponent
    {
        public bool RequiresTick = true;
        public bool Visible = true;
        public Matrix4x4 RelativeTransform = Matrix4x4.identity;
            
        public void Draw(SxRenderContext context, Matrix4x4 accumWorldTransform, SxRenderCommandList renderCommandList)
        {
            if (Visible)
            {
                DrawImpl(context, accumWorldTransform, renderCommandList);
            }
        }

        protected virtual void DrawImpl(SxRenderContext context, Matrix4x4 accumWorldTransform, SxRenderCommandList renderCommandList)
        {
            
        }
        
        public virtual void Tick(SxRenderContext context, float deltaTime)
        {
        }

        public virtual void Destroy()
        {
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\SxWorld.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.SxEngine
{
    public class SxWorld
    {
        private SxSceneGraph sceneGraph = new SxSceneGraph();

        public SxRootSceneNode RootNode
        {
            get => sceneGraph.RootNode;
        }
        
        public virtual void Draw(SxRenderContext context, SxRenderCommandList renderCommandList)
        {
            var visited = new HashSet<ISxSceneNode>();
            DrawRecursive(context, sceneGraph.RootNode, Matrix4x4.identity, visited, renderCommandList);
        }
        
        void DrawRecursive(SxRenderContext context, ISxSceneNode node, Matrix4x4 incomingWorldTransform, HashSet<ISxSceneNode> visited,
                SxRenderCommandList renderCommandList)
        {
            if (visited.Contains(node))
            {
                return;
            }

            visited.Add(node);

            var accumulatedWorldTransform = incomingWorldTransform * node.WorldTransform.Matrix;
            node.Draw(context, accumulatedWorldTransform, renderCommandList);
            
            // Iterate the children
            foreach (var childNode in node.Children)
            {
                DrawRecursive(context, childNode, accumulatedWorldTransform, visited, renderCommandList);
            }
        }
        
        public void Tick(SxRenderContext context, float deltaTime)
        {
            sceneGraph.IterateNodes((node) => node.Tick(context, deltaTime));
        }

        public void Clear()
        {
            sceneGraph.IterateNodes((node) =>
            {
                if (node is SxActor)
                {
                    DestroyActorImpl(node as SxActor);
                }
            });
            
            sceneGraph.RootNode.RemoveAllChildren();
        }

        public T SpawnActor<T>(bool addToRoot) where T : SxActor, new()
        {
            var actor = new T
            {
                World = this
            };

            if (addToRoot)
            {
                sceneGraph.RootNode.AddChild(actor);
            }

            return actor;
        }

        public T[] GetActorsOfType<T>() where T : SxActor
        {
            var result = new List<T>();
            sceneGraph.IterateNodes(node =>
            {
                if (node is T)
                {
                    result.Add(node as T);
                }
            });
            return result.ToArray();
        }
        
        public void DestroyActor(SxActor actor)
        {
            DestroyActorImpl(actor);
            
            // remove from the scene graph
            sceneGraph.Remove(actor);
        }

        private void DestroyActorImpl(SxActor actor)
        {
            foreach (var component in actor.Components)
            {
                component.Destroy();
            }
        }
        
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\UIPlatform.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI
{
    public interface UIPlatform
    {
        // Inspector
        void ShowObjectProperty(object obj);
        void ShowObjectProperties(object[] obj);

        // Asset management
        string GetAssetPath(object obj);
        void MarkAssetDirty(object obj);
        void AddObjectToAsset(Object objectToAdd, Object assetObject);

        // Menu
        IContextMenu CreateContextMenu();
        UIDragDrop DragDrop { get; }

        double timeSinceStartup { get; }
        string clipboardText { get; set; }
        Event CurrentEvent { get; }
    }

    public interface IContextMenu
    {
        void AddItem(string path, ContextMenuFunction func);
        void AddItem(string path, ContextMenuFunctionUserData func, object userData);
        void AddSeparator(string path);
        void Show();
    }

    public enum UIDragDropVisualMode
    {
        None,
        Copy,
        Generic,
        Move,
        Reject
    }
    
    public interface UIDragDrop
    {
        void PrepareStartDrag();
        void StartDrag(string title);
        void SetVisualMode(UIDragDropVisualMode visualMode);
        void AcceptDrag();
    }

    public delegate void ContextMenuFunction();
    public delegate void ContextMenuFunctionUserData(object userData);


    public class NullPlatform : UIPlatform
    {
        public void ShowObjectProperty(object obj)
        {
        }

        public void ShowObjectProperties(object[] obj)
        {
        }

        public string GetAssetPath(object obj)
        {
            return "";
        }

        public void MarkAssetDirty(object obj)
        {
        }

        public void AddObjectToAsset(Object objectToAdd, Object assetObject)
        {
        }

        public IContextMenu CreateContextMenu()
        {
            return null;
        }

        public UIDragDrop DragDrop { get { return null; } }

        public double timeSinceStartup { get { return 0; } }
        public string clipboardText
        {
            get
            {
                return "";
            }
            set
            {
            }
        }

        public Event CurrentEvent { get => Event.current; }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\UIRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
namespace DungeonArchitect.UI
{
    public interface UIRenderer
    {
        void BeginGroup(Rect bounds);
        void EndGroup();
        bool Button(Rect bounds, GUIContent content, GUIStyle style);
        bool Button(Rect bounds, string text, GUIStyle style);
        bool Button(Rect bounds, string text);
        void Box(Rect bounds, string text);
        void Box(Rect bounds, GUIContent content);
        void Box(Rect bounds, GUIContent content, GUIStyle style);
        bool Toggle(Rect bounds, bool value, string text);
        bool Toggle(Rect bounds, bool value, string text, GUIStyle style);
        void Label(Rect bounds, string text, GUIStyle style);
        void Label(Rect bounds, GUIContent content, GUIStyle style);
        Vector2 BeginScrollView(Rect bounds, Vector2 scrollPosition, Rect viewRect);
        void DrawTexture(Rect bounds, Texture texture);
        void DrawTexture(Rect bounds, Texture texture, ScaleMode scaleMode, bool alphaBlend, Color color);
        void EndScrollView(bool handleScrollWheel);
        void BeginGUI();
        void EndGUI();
        void DrawLine(Vector3 v0, Vector3 v1);
        void DrawLine(Color color, Vector3 v0, Vector3 v1);
        void DrawLines(Color color, Vector3[] lineSegments);
        void DrawPolyLine(params Vector3[] points);
        void DrawPolyLine(Color color, params Vector3[] points);
        void DrawAAPolyLine(float thickness, params Vector3[] points);
        void DrawAAPolyLine(float thickness, Color color, params Vector3[] points);
        void DrawAAPolyLine(Texture2D texture, float thickness, params Vector3[] points);
        void DrawAAPolyLine(Texture2D texture, float thickness, Color color, params Vector3[] points);
        void DrawBezier(Vector3 startPos, Vector3 endPos, Vector3 startTangent, Vector3 endTangent, Color lineColor, Texture2D texture, float lineThickness);
        void DrawAAConvexPolygon(params Vector3[] points);
        void DrawAAConvexPolygon(Color color, params Vector3[] points);
        void DrawRect(Rect bounds, Color color);
        void AddCursorRect(Rect bounds, UICursorType cursorType);
        object GetResource<T>(string path);
        Color color { get; set; }
        Color backgroundColor { get; set; }

        UIStyleManager StyleManager { get; }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\UIStyleManager.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI
{
    public interface UIStyleManager
    {
        GUIStyle GetToolbarButtonStyle();
        GUIStyle GetButtonStyle();
        GUIStyle GetBoxStyle();
        GUIStyle GetLabelStyle();
        GUIStyle GetBoldLabelStyle();
        Font GetFontStandard();
        Font GetFontBold();
        Font GetFontMini();
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\UISystem.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.UI
{
    public delegate void OnWidgetFocus(IWidget widget);
    public delegate void OnWidgetLostFocus(IWidget widget);
    public delegate void OnDragEvent();

    public abstract class UISystem
    {
        public IWidget FocusedWidget { get; private set; }

        public bool IsDragDrop { get; private set; }

        public IWidget Layout { get; private set; }

        public UIPlatform Platform { get; private set; }
        public UIStyleManager StyleManager { get; private set; }
        public UIUndoSystem Undo { get; private set; }
        
        public abstract bool SupportsDragDrop { get; }
        
        public UISystem()
        {
            Platform = CreatePlatformInstance();
            StyleManager = CreateStyleManagerInstance();
            Undo = CreateUndoSystemInstance();

            FocusedWidget = null;
            IsDragDrop = false;
            Layout = new NullWidget();
        }

        protected abstract UIPlatform CreatePlatformInstance();
        protected abstract UIStyleManager CreateStyleManagerInstance();
        protected abstract UIUndoSystem CreateUndoSystemInstance();

        public void Draw(UIRenderer uiRenderer)
        {
            if (Layout != null)
            {
                Layout.Draw(this, uiRenderer);
            }
        }

        public void Update(Rect bounds)
        {
            if (Layout != null)
            {
                Layout.UpdateWidget(this, bounds);
            }
        }

        public void SetLayout(IWidget layout)
        {
            this.Layout = layout;
        }

        public void ClearLayout()
        {
            Layout = new NullWidget();
        }
        
        public void RequestFocus(IWidget widget)
        {
            GUI.FocusControl("");
            // Notify that the old widget has lost focus
            if (FocusedWidget != null)
            {
                FocusedWidget.LostFocus();
                if (WidgetLostFocus != null)
                {
                    WidgetLostFocus.Invoke(FocusedWidget);
                }
            }

            FocusedWidget = widget;
            if (FocusedWidget != null)
            {
                FocusedWidget.OnFocus();
                if (WidgetFocused != null)
                {
                    WidgetFocused.Invoke(FocusedWidget);
                }
            }
        }

        public void SetDragging(bool dragging)
        {
            if (IsDragDrop == dragging) return;

            IsDragDrop = dragging;
            if (IsDragDrop)
            {
                if (DragStart != null)
                {
                    DragStart.Invoke();
                }
            }
            else
            {
                if (DragEnd != null)
                {
                    DragEnd.Invoke();
                }
            }
        }

        public event OnWidgetFocus WidgetFocused;
        public event OnWidgetLostFocus WidgetLostFocus;
        public event OnDragEvent DragStart;
        public event OnDragEvent DragEnd;
    }


    public enum UICursorType
    {
        Normal,
        ResizeHorizontal,
        ResizeVertical,
        Link,
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\UIUndoSystem.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.UI
{
    public delegate void UIUndoRedoDelegate(UISystem uiSystem);
    public interface UIUndoSystem
    {
        void RecordObject(object obj, string name);
        void RegisterCreatedObjectUndo(object obj, string name);
        void DestroyObjectImmediate(object obj);
        void RegisterCompleteObjectUndo(object obj, string name);
        event UIUndoRedoDelegate UndoRedoPerformed;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\VisibilityGraph\VisibilityGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Visibility
{
    public class VisibilityGraph
    {
        public int VisibilityDepth { get; set; } = 1;

        private List<VisibilityGraphNode> nodes = new List<VisibilityGraphNode>();

        struct VisibilitySearchState
        {
            public VisibilityGraphNode Node;
            public int Depth;
        }
        
        public void RegisterNode(VisibilityGraphNode node)
        {
            Debug.Assert(!nodes.Contains(node));
            nodes.Add(node);
            node.Initialize();
        }

        public void Clear()
        {
            nodes.Clear();
        }

        public void UpdateVisibility(Vector3[] trackedObjects)
        {
            var visibleNodes = GetVisibleNodes(trackedObjects);
            foreach (var node in nodes)
            {
                bool visible = visibleNodes.Contains(node);
                node.SetVisible(visible);
            }
        }

        
        private HashSet<VisibilityGraphNode> GetVisibleNodes(Vector3[] trackedObjects)
        {
            var visibleNodes = new HashSet<VisibilityGraphNode>();
            if (trackedObjects.Length == 0)
            {
                return visibleNodes;
            }

            var startNodes = new HashSet<VisibilityGraphNode>();
            foreach (var trackedObjectPosition in trackedObjects)
            {
                foreach (var node in nodes)
                {
                    if (node.Bounds.Contains(trackedObjectPosition))
                    {
                        startNodes.Add(node);
                        break;
                    }
                }
            }

            if (VisibilityDepth == 0)
            {
                return startNodes;
            }
            
            // Grow out from the start nodes
            var queue = new Queue<VisibilitySearchState>();
            foreach (var startNode in startNodes)
            {
                var state = new VisibilitySearchState();
                state.Node = startNode;
                state.Depth = 0;
                queue.Enqueue(state);
            }

            while (queue.Count > 0)
            {
                var state = queue.Dequeue();
                visibleNodes.Add(state.Node);
                
                // Add the children
                if (state.Depth < VisibilityDepth)
                {
                    foreach (var childNode in state.Node.ConnectedNodes)
                    {
                        if (!visibleNodes.Contains(childNode))
                        {
                            var childState = new VisibilitySearchState();
                            childState.Node = childNode;
                            childState.Depth = state.Depth + 1;
                            queue.Enqueue(childState);
                        }
                    }
                }
            }

            return visibleNodes;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\VisibilityGraph\VisibilityGraphNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace DungeonArchitect.Visibility
{
    public abstract class VisibilityGraphNode
    {
        private Bounds bounds;
        private bool _visible = true;
        private HashSet<VisibilityGraphNode> connectedNodes = new HashSet<VisibilityGraphNode>();

        public VisibilityGraphNode[] ConnectedNodes
        {
            get => connectedNodes.ToArray();
        }
        
        public Bounds Bounds
        {
            get => bounds;
        }
        
        public void Initialize()
        {
            bounds = CalculateBounds();
        }
        
        public void AddConnection(VisibilityGraphNode node)
        {
            if (node == null || node == this) return;
            
            connectedNodes.Add(node);
        }

        public virtual bool IsVisible()
        {
            return _visible;
        }

        public void SetVisible(bool visible)
        {
            if (IsVisible() != visible)
            {
                _visible = visible;
                SetVisibleImpl(visible);
            }
        }
        
        public abstract void SetVisibleImpl(bool visible);
        public abstract Bounds CalculateBounds();
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Collections\BVTree.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Collections
{
	/// <summary>
	/// A tree of bounding volumes.
	/// </summary>
	public class BVTree
	{
		private static readonly Node.CompareX XComparer = new Node.CompareX();
		private static readonly Node.CompareY YComparer = new Node.CompareY();
		private static readonly Node.CompareZ ZComparer = new Node.CompareZ();

		/// <summary>
		/// Nodes in the tree
		/// </summary>
		private Node[] nodes;

		/// <summary>
		/// Initializes a new instance of the <see cref="BVTree"/> class.
		/// </summary>
		/// <param name="verts">A set of vertices.</param>
		/// <param name="polys">A set of polygons composed of the vertices in <c>verts</c>.</param>
		/// <param name="nvp">The maximum number of vertices per polygon.</param>
		/// <param name="cellSize">The size of a cell.</param>
		/// <param name="cellHeight">The height of a cell.</param>
		public BVTree(PolyVertex[] verts, PolyMesh.Polygon[] polys, int nvp, float cellSize, float cellHeight)
		{
			nodes = new Node[polys.Length * 2];
			var items = new List<Node>();

			for (int i = 0; i < polys.Length; i++)
			{
				PolyMesh.Polygon p = polys[i];

				Node temp;
				temp.Index = i;
				temp.Bounds.Min = temp.Bounds.Max = verts[p.Vertices[0]];

				for (int j = 1; j < nvp; j++)
				{
					int vi = p.Vertices[j];
					if (vi == PolyMesh.NullId)
						break;

					var v = verts[vi];
					PolyVertex.ComponentMin(ref temp.Bounds.Min, ref v, out temp.Bounds.Min);
					PolyVertex.ComponentMax(ref temp.Bounds.Max, ref v, out temp.Bounds.Max);
				}

				temp.Bounds.Min.Y = (int)Math.Floor((float)temp.Bounds.Min.Y * cellHeight / cellSize);
				temp.Bounds.Max.Y = (int)Math.Ceiling((float)temp.Bounds.Max.Y * cellHeight / cellSize);

				items.Add(temp);
			}

			Subdivide(items, 0, items.Count, 0);
		}

		/// <summary>
		/// Gets the number of nodes in the tree.
		/// </summary>
		public int Count
		{
			get
			{
				return nodes.Length;
			}
		}

		/// <summary>
		/// Gets the node at a specified index.
		/// </summary>
		/// <param name="index">The index.</param>
		/// <returns>The node at the index.</returns>
		public Node this[int index]
		{
			get
			{
				return nodes[index];
			}
		}

		/// <summary>
		/// Calculates the bounding box for a set of bounding boxes.
		/// </summary>
		/// <param name="items">The list of all the bounding boxes.</param>
		/// <param name="minIndex">The first bounding box in the list to get the extends of.</param>
		/// <param name="maxIndex">The last bounding box in the list to get the extends of.</param>
		/// <param name="bounds">The extends of all the bounding boxes.</param>
		private static void CalcExtends(List<Node> items, int minIndex, int maxIndex, out PolyBounds bounds)
		{
			bounds = items[minIndex].Bounds;

			for (int i = minIndex + 1; i < maxIndex; i++)
			{
				Node it = items[i];
				PolyVertex.ComponentMin(ref it.Bounds.Min, ref bounds.Min, out bounds.Min);
				PolyVertex.ComponentMax(ref it.Bounds.Max, ref bounds.Max, out bounds.Max);
			}
		}

		/// <summary>
		/// Determine whether the bounding x, y, or z axis contains the longest distance 
		/// </summary>
		/// <param name="x">Length of bounding x-axis</param>
		/// <param name="y">Length of bounding y-axis</param>
		/// <param name="z">Length of bounding z-axis</param>
		/// <returns>Returns the a specific axis (x, y, or z)</returns>
		private static int LongestAxis(int x, int y, int z)
		{
			int axis = 0;
			int max = x;

			if (y > max)
			{
				axis = 1;
				max = y;
			}

			if (z > max)
				axis = 2;

			return axis;
		}

		/// <summary>
		/// Subdivides a list of bounding boxes until it is a tree.
		/// </summary>
		/// <param name="items">A list of bounding boxes.</param>
		/// <param name="minIndex">The first index to consider (recursively).</param>
		/// <param name="maxIndex">The last index to consier (recursively).</param>
		/// <param name="curNode">The current node to look at.</param>
		/// <returns>The current node at the end of each method.</returns>
		private int Subdivide(List<Node> items, int minIndex, int maxIndex, int curNode)
		{
			int numIndex = maxIndex - minIndex;
			int curIndex = curNode;

			int oldNode = curNode;
			curNode++;

			//Check if the current node is a leaf node
			if (numIndex == 1)
				nodes[oldNode] = items[minIndex];
			else
			{
				PolyBounds bounds;
				CalcExtends(items, minIndex, maxIndex, out bounds);
				nodes[oldNode].Bounds = bounds;

				int axis = LongestAxis((int)(bounds.Max.X - bounds.Min.X), (int)(bounds.Max.Y - bounds.Min.Y), (int)(bounds.Max.Z - bounds.Min.Z));

				switch (axis)
				{
					case 0:
						items.Sort(minIndex, numIndex, XComparer);
						break;
					case 1:
						items.Sort(minIndex, numIndex, YComparer);
						break;
					case 2:
						items.Sort(minIndex, numIndex, ZComparer);
						break;
					default:
						break;
				}

				int splitIndex = minIndex + (numIndex / 2);

				curNode = Subdivide(items, minIndex, splitIndex, curNode);
				curNode = Subdivide(items, splitIndex, maxIndex, curNode);

				int escapeIndex = curNode - curIndex;
				nodes[oldNode].Index = -escapeIndex;
			}

			return curNode;
		}

		/// <summary>
		/// The data stored in a bounding volume node.
		/// </summary>
		public struct Node
		{
			/// <summary>
			/// The bounding box of the node.
			/// </summary>
			public PolyBounds Bounds;

			/// <summary>
			/// The index of this node in a <see cref="BVTree"/>.
			/// </summary>
			public int Index;

			/// <summary>
			/// An <see cref="IComparer{T}"/> implementation that only compares two <see cref="Node"/>s on the X axis.
			/// </summary>
			public class CompareX : IComparer<Node>
			{
				/// <summary>
				/// Compares two nodes's bounds on the X axis.
				/// </summary>
				/// <param name="x">A node.</param>
				/// <param name="y">Another node.</param>
				/// <returns>A negative value if a is less than b; 0 if they are equal; a positive value of a is greater than b.</returns>
				public int Compare(Node x, Node y)
				{
					if (x.Bounds.Min.X < y.Bounds.Min.X)
						return -1;

					if (x.Bounds.Min.X > y.Bounds.Min.X)
						return 1;

					return 0;
				}
			}

			/// <summary>
			/// An <see cref="IComparer{T}"/> implementation that only compares two <see cref="Node"/>s on the Y axis.
			/// </summary>
			public class CompareY : IComparer<Node>
			{
				/// <summary>
				/// Compares two nodes's bounds on the Y axis.
				/// </summary>
				/// <param name="x">A node.</param>
				/// <param name="y">Another node.</param>
				/// <returns>A negative value if a is less than b; 0 if they are equal; a positive value of a is greater than b.</returns>
				public int Compare(Node x, Node y)
				{
					if (x.Bounds.Min.Y < y.Bounds.Min.Y)
						return -1;

					if (x.Bounds.Min.Y > y.Bounds.Min.Y)
						return 1;

					return 0;
				}
			}

			/// <summary>
			/// An <see cref="IComparer{T}"/> implementation that only compares two <see cref="Node"/>s on the Z axis.
			/// </summary>
			public class CompareZ : IComparer<Node>
			{
				/// <summary>
				/// Compares two nodes's bounds on the Z axis.
				/// </summary>
				/// <param name="x">A node.</param>
				/// <param name="y">Another node.</param>
				/// <returns>A negative value if a is less than b; 0 if they are equal; a positive value of a is greater than b.</returns>
				public int Compare(Node x, Node y)
				{
					if (x.Bounds.Min.Z < y.Bounds.Min.Z)
						return -1;

					if (x.Bounds.Min.Z > y.Bounds.Min.Z)
						return 1;

					return 0;
				}
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\Agent.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Crowds
{
	/// <summary>
	/// A crowd agent is a unit that moves across the navigation mesh
	/// </summary>
	public class Agent : IEquatable<Agent>
	{

		#region Fields

		/// <summary>
		/// The maximum number of corners a crowd agent will look ahead in the path
		/// </summary>
		private const int AgentMaxCorners = 4;
		public const int AgentMaxNeighbors = 6;

		private bool active;
		private AgentState state;
		private bool partial;
		private PathCorridor corridor;
		private LocalBoundary boundary;
		public float topologyOptTime;
		private CrowdNeighbor[] neighbors;	//size = CROWDAGENT_MAX_NEIGHBOURS
		private int numNeis;
		public float DesiredSpeed;

		private Vector3 currentPos;
		public Vector3 Disp;
		public Vector3 DesiredVel;
		public Vector3 NVel;
		public Vector3 Vel;

		public AgentParams Parameters;

		public Vector3[] CornerVerts;	//size = CROWDAGENT_MAX_CORNERS
		public int[] CornerFlags;		//size = CROWDAGENT_MAX_CORNERS
		public int[] CornerPolys;		//size = CROWDAGENT_MAX_CORNERS

		private int numCorners;

		private TargetState targetState;
		public int TargetRef;
		private Vector3 targetPos;
		public int TargetPathqRef;
		public bool TargetReplan;
		public float TargetReplanTime;
		
		int agentIndex;
		
		public int AgentIndex {
			get {
				return agentIndex;
			}
		}
		#endregion

		#region Constructors

		public Agent(int maxPath, int agentIndex)
		{
			this.agentIndex = agentIndex;
			active = false;
			corridor = new PathCorridor(maxPath);
			boundary = new LocalBoundary();
			neighbors = new CrowdNeighbor[AgentMaxNeighbors];
			CornerVerts = new Vector3[AgentMaxCorners];
			CornerFlags = new int[AgentMaxCorners];
			CornerPolys = new int[AgentMaxCorners];
		}

		#endregion

		#region Properties

		public bool IsActive
		{
			get
			{
				return active;
			}

			set
			{
				active = value;
			}
		}

		public bool IsPartial
		{
			get
			{
				return partial;
			}

			set
			{
				partial = value;
			}
		}

		public AgentState State
		{
			get
			{
				return state;
			}

			set
			{
				state = value;
			}
		}

		public Vector3 Position
		{
			get
			{
				return currentPos;
			}

			set
			{
				currentPos = value;
			}
		}

		public LocalBoundary Boundary
		{
			get
			{
				return boundary;
			}
		}

		public PathCorridor Corridor
		{
			get
			{
				return corridor;
			}
		}

		public CrowdNeighbor[] Neighbors
		{
			get
			{
				return neighbors;
			}
		}

		public int NeighborCount
		{
			get
			{
				return numNeis;
			}

			set
			{
				numNeis = value;
			}
		}

		public TargetState TargetState
		{
			get
			{
				return targetState;
			}

			set
			{
				targetState = value;
			}
		}

		public Vector3 TargetPosition
		{
			get
			{
				return targetPos;
			}

			set
			{
				targetPos = value;
			}
		}

		public int CornerCount
		{
			get
			{
				return numCorners;
			}

			set
			{
				numCorners = value;
			}
		}

		#endregion

		#region Methods

		/// <summary>
		/// Update the position after a certain time 'dt'
		/// </summary>
		/// <param name="dt">Time that passed</param>
		public void Integrate(float dt)
		{
			//fake dyanmic constraint
			float maxDelta = Parameters.MaxAcceleration * dt;
			Vector3 dv = NVel - Vel;
			float ds = dv.Length();
			if (ds > maxDelta)
				dv = dv * (maxDelta / ds);
			Vel = Vel + dv;

			//integrate
			if (Vel.Length() > 0.0001f)
				currentPos = currentPos + Vel * dt;
			else
				Vel = new Vector3(0, 0, 0);
		}

		public void Reset(int reference, Vector3 nearest)
		{
			this.corridor.Reset(reference, nearest);
			this.boundary.Reset();
			this.partial = false;

			this.topologyOptTime = 0;
			this.TargetReplanTime = 0;
			this.numNeis = 0;

			this.DesiredVel = new Vector3(0.0f, 0.0f, 0.0f);
			this.NVel = new Vector3(0.0f, 0.0f, 0.0f);
			this.Vel = new Vector3(0.0f, 0.0f, 0.0f);
			this.currentPos = nearest;

			this.DesiredSpeed = 0;

			if (reference != 0)
				this.state = AgentState.Walking;
			else
				this.state = AgentState.Invalid;

			this.TargetState = TargetState.None;
		}

		/// <summary>
		/// Change the move target
		/// </summary>
		/// <param name="reference">The polygon reference</param>
		/// <param name="pos">The target's coordinates</param>
		public void RequestMoveTargetReplan(int reference, Vector3 pos)
		{
			//initialize request
			this.TargetRef = reference;
			this.targetPos = pos;
			this.TargetPathqRef = PathQueue.Invalid;
			this.TargetReplan = true;
			if (this.TargetRef != 0)
				this.TargetState = TargetState.Requesting;
			else
				this.TargetState = TargetState.Failed;
		}

		/// <summary>
		/// Request a new move target
		/// </summary>
		/// <param name="reference">The polygon reference</param>
		/// <param name="pos">The target's coordinates</param>
		/// <returns>True if request met, false if not</returns>
		public bool RequestMoveTarget(int reference, Vector3 pos)
		{
			if (reference == 0)
				return false;

			//initialize request
			this.TargetRef = reference;
			this.targetPos = pos;
			this.TargetPathqRef = PathQueue.Invalid;
			this.TargetReplan = false;
			if (this.TargetRef != 0)
				this.targetState = TargetState.Requesting;
			else
				this.targetState = TargetState.Failed;

			return true;
		}

		/// <summary>
		/// Request a new move velocity
		/// </summary>
		/// <param name="vel">The agent's velocity</param>
		public void RequestMoveVelocity(Vector3 vel)
		{
			//initialize request
			this.TargetRef = 0;
			this.targetPos = vel;
			this.TargetPathqRef = PathQueue.Invalid;
			this.TargetReplan = false;
			this.targetState = TargetState.Velocity;
		}

		/// <summary>
		/// Reset the move target of an agent
		/// </summary>
		public void ResetMoveTarget()
		{
			//initialize request
			this.TargetRef = 0;
			this.targetPos = new Vector3(0.0f, 0.0f, 0.0f);
			this.TargetPathqRef = PathQueue.Invalid;
			this.TargetReplan = false;
			this.targetState = TargetState.None;
		}

		/// <summary>
		/// Modify the agent parameters
		/// </summary>
		/// <param name="parameters">The new parameters</param>
		public void UpdateAgentParameters(AgentParams parameters)
		{
			this.Parameters = parameters;
		}

		public static bool operator ==(Agent left, Agent right)
		{
			if (Object.ReferenceEquals(left, null) && Object.ReferenceEquals(right, null)) {
				return true;
			}
			if (Object.ReferenceEquals(left, null) || Object.ReferenceEquals(right, null)) {
				return false;
			}
			return left.Equals(right);
		}

		public static bool operator !=(Agent left, Agent right)
		{
			return !(left == right);
		}

		public bool Equals(Agent other)
		{
			//TODO find a way to actually compare for equality.
			//return object.ReferenceEquals(this, other);

			if (Object.ReferenceEquals(other, null)) return false;
			return agentIndex == other.AgentIndex;
		}

		public override bool Equals(object obj)
		{
			var other = obj as Agent;
			if (other != null)
				return this.Equals(other);

			return false;
		}

		public override int GetHashCode()
		{
			return agentIndex;
		}

		public override string ToString()
		{
			//TODO write an actual ToString.
			return base.ToString();
		}

		#endregion
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\Crowd.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using SharpNav.Collections.Generic;
using SharpNav.Geometry;
using SharpNav.Pathfinding;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Crowds
{
	/// <summary>
	/// The Crowd class manages pathfinding for multiple agents simulatenously.
	/// </summary>
	public class Crowd
	{
		/// <summary>
		/// The maximum number of crowd avoidance configurations supported by the crowd manager
		/// </summary>
		private const int AgentMaxObstacleAvoidanceParams = 8;

		/// <summary>
		/// The maximum number of neighbors that a crowd agent can take into account for steering decisions
		/// </summary>
		private const int AgentMaxNeighbours = Agent.AgentMaxNeighbors;

		/// <summary>
		/// The maximum number of corners a crowd agent will look ahead in the path
		/// </summary>
		private const int AgentMaxCorners = 4;

		private const int MaxItersPerUpdate = 100;

		private int maxAgents;
		private Agent[] agents;
		//private Agent[] activeAgents;
		private AgentAnimation[] agentAnims; 

		private PathQueue pathq;

		private ObstacleAvoidanceQuery.ObstacleAvoidanceParams[] obstacleQueryParams;
		private ObstacleAvoidanceQuery obstacleQuery;

		private ProximityGrid<Agent> grid;

		private int[] pathResult;
		private int maxPathResult;

		private Vector3 ext;

		//private float maxAgentRadius;

		private int velocitySampleCount;

		private NavMeshQuery navQuery;

		/// <summary>
		/// Initializes a new instance of the <see cref="Crowd" /> class.
		/// </summary>
		/// <param name="maxAgents">The maximum agents allowed</param>
		/// <param name="maxAgentRadius">The maximum radius for an agent</param>
		/// <param name="navMesh">The navigation mesh</param>
		public Crowd(int maxAgents, float maxAgentRadius, ref TiledNavMesh navMesh)
		{
			this.maxAgents = maxAgents;
			//this.maxAgentRadius = maxAgentRadius;

			this.ext = new Vector3(maxAgentRadius * 2.0f, maxAgentRadius * 1.5f, maxAgentRadius * 2.0f);

			//initialize proximity grid
			this.grid = new ProximityGrid<Agent>(maxAgents * 4, maxAgentRadius * 3);

			//allocate obstacle avoidance query
			this.obstacleQuery = new ObstacleAvoidanceQuery(6, 8);

			//initialize obstancle query params
			this.obstacleQueryParams = new ObstacleAvoidanceQuery.ObstacleAvoidanceParams[AgentMaxObstacleAvoidanceParams];
			for (int i = 0; i < this.obstacleQueryParams.Length; i++)
			{
				this.obstacleQueryParams[i].VelBias = 0.4f;
				this.obstacleQueryParams[i].WeightDesVel = 2.0f;
				this.obstacleQueryParams[i].WeightCurVel = 0.75f;
				this.obstacleQueryParams[i].WeightSide = 0.75f;
				this.obstacleQueryParams[i].WeightToi = 2.5f;
				this.obstacleQueryParams[i].HorizTime = 2.5f;
				this.obstacleQueryParams[i].GridSize = 33;
				this.obstacleQueryParams[i].AdaptiveDivs = 7;
				this.obstacleQueryParams[i].AdaptiveRings = 2;
				this.obstacleQueryParams[i].AdaptiveDepth = 5;
			}

			//allocate temp buffer for merging paths
			this.maxPathResult = 256;
			this.pathResult = new int[this.maxPathResult];

			this.pathq = new PathQueue(maxPathResult, 4096, ref navMesh);

			this.agents = new Agent[maxAgents];
			//this.activeAgents = new Agent[maxAgents];
			this.agentAnims = new AgentAnimation[maxAgents];

			for (int i = 0; i < maxAgents; i++)
			{
				this.agents[i] = new Agent(maxPathResult, i);
			}

			for (int i = 0; i < maxAgents; i++)
			{
				this.agentAnims[i].Active = false;
			}

			//allocate nav mesh query
			this.navQuery = new NavMeshQuery(navMesh, 512);
		}

		public ObstacleAvoidanceQuery.ObstacleAvoidanceParams GetObstacleAvoidanceParams(int idx)
		{
			if (idx >= 0 && idx < AgentMaxObstacleAvoidanceParams)
				return obstacleQueryParams[idx];

			return new ObstacleAvoidanceQuery.ObstacleAvoidanceParams();
		}

		public void SetObstacleAvoidanceParams(int idx, ObstacleAvoidanceQuery.ObstacleAvoidanceParams parameters)
		{
			if (idx >= 0 && idx < AgentMaxObstacleAvoidanceParams)
				obstacleQueryParams[idx] = parameters;
		}

		public int GetAgentCount()
		{
			return maxAgents;
		}

		public Agent GetAgent(int idx)
		{
			if (idx < 0 || idx >= maxAgents)
				return null;

			return agents[idx];
		}

		/// <summary>
		/// Add an agent to the crowd.
		/// </summary>
		/// <param name="pos">The agent's position</param>
		/// <param name="parameters">The settings</param>
		/// <returns>The id of the agent (-1 if there is no empty slot)</returns>
		public int AddAgent(Vector3 pos, AgentParams parameters)
		{
			//find empty slot
			int idx = -1;
			for (int i = 0; i < maxAgents; i++)
			{
				if (!agents[i].IsActive)
				{
					idx = i;
					break;
				}
			}

			if (idx == -1)
				return -1;

			agents[idx].UpdateAgentParameters(parameters);

			//find nearest position on the navmesh and place the agent there
			NavPoint nearest;
			navQuery.FindNearestPoly(ref pos, ref ext, out nearest);
			/*if (status == false)
			{
				nearest = pos;
				reference = 0;
			}*/

			agents[idx].Reset(nearest.Polygon, nearest.Position);
			agents[idx].IsActive = true;

			return idx;
		}

		/// <summary>
		/// The agent is deactivated and will no longer be processed. It can still be reused later.
		/// </summary>
		/// <param name="index">The agent's id</param>
		/// <returns>A value indicating whether the agent was successfully removed.</returns>
		public bool RemoveAgent(int index)
		{
			if (index < 0 || index >= maxAgents)
				return false;

			agents[index].IsActive = false;
			return true;
		}

		/// <summary>
		/// The crowd contains active and inactive agents. Only add all the active agents to a separate array.
		/// </summary>
		/// <param name="agents">The array of active agents</param>
		/// <returns>The number of active agents</returns>
		public int GetActiveAgents(Agent[] agents)
		{
			int n = 0;
			for (int i = 0; i < agents.Length; i++)
			{
				if (!agents[i].IsActive)
					continue;

				if (n < maxAgents)
					agents[n++] = agents[i];
			}

			return n;
		}

		/// <summary>
		/// Get the agent's index in the array
		/// </summary>
		/// <param name="agent">The agent</param>
		/// <returns>The index</returns>
		public int GetAgentIndex(Agent agent)
		{
			for (int i = 0; i < agents.Length; i++)
			{
				if (agents[i] == agent)
					return i;
			}

			return -1;
		}

		/// <summary>
		/// Update the crowd pathfinding periodically 
		/// </summary>
		/// <param name="dt">Th time until the next update</param>
		public void Update(float dt)
		{
			velocitySampleCount = 0;

			int numAgents = GetActiveAgents(agents);

			//check that all agents have valid paths
			CheckPathValidity(agents, numAgents, dt);
			
			//update async move requests and path finder
			UpdateMoveRequest();

			//optimize path topology
			UpdateTopologyOptimization(agents, numAgents, dt);

			//register agents to proximity grid
			grid.Clear();
			for (int i = 0; i < numAgents; i++)
			{
				Agent a = agents[i];

				Vector3 p = a.Position;
				float r = a.Parameters.Radius;
				grid.AddItem(a, p.X - r, p.Z - r, p.X + r, p.Z + r);
			}

			//get nearby navmesh segments and agents to collide with
			for (int i = 0; i < numAgents; i++)
			{
				if (agents[i].State != AgentState.Walking)
					continue;

				//update the collision boundary after certain distance has passed or if it has become invalid
				float updateThr = agents[i].Parameters.CollisionQueryRange * 0.25f;
				if (Vector3Extensions.Distance2D(agents[i].Position, agents[i].Boundary.Center) > updateThr * updateThr || !agents[i].Boundary.IsValid(navQuery))
				{
					agents[i].Boundary.Update(agents[i].Corridor.GetFirstPoly(), agents[i].Position, agents[i].Parameters.CollisionQueryRange, navQuery);
				}

				//query neighbour agents
				agents[i].NeighborCount = GetNeighbours(agents[i].Position, agents[i].Parameters.Height, agents[i].Parameters.CollisionQueryRange, agents[i], agents[i].Neighbors, AgentMaxNeighbours, agents, grid);

				for (int j = 0; j < agents[i].NeighborCount; j++)
					agents[i].Neighbors[j].Index = GetAgentIndex(agents[agents[i].Neighbors[j].Index]);
			}

			//find the next corner to steer to
			for (int i = 0; i < numAgents; i++)
			{
				if (agents[i].State != AgentState.Walking)
					continue;
				if (agents[i].TargetState == TargetState.None ||
					agents[i].TargetState == TargetState.Velocity)
					continue;

				//find corners for steering
				agents[i].CornerCount = agents[i].Corridor.FindCorners(
					agents[i].CornerVerts, agents[i].CornerFlags, agents[i].CornerPolys, AgentMaxCorners, navQuery);

				//check to see if the corner after the next corner is directly visible 
				if (((agents[i].Parameters.UpdateFlags & UpdateFlags.OptimizeVis) != 0) && agents[i].CornerCount > 0)
				{
					Vector3 target = agents[i].CornerVerts[Math.Min(1, agents[i].CornerCount - 1)];
					agents[i].Corridor.OptimizePathVisibility(target, agents[i].Parameters.PathOptimizationRange, navQuery);
				}
			}

			//trigger off-mesh connections (depends on corners)
			for (int i = 0; i < numAgents; i++)
			{
				if (agents[i].State != AgentState.Walking)
					continue;
				if (agents[i].TargetState == TargetState.None ||
					agents[i].TargetState == TargetState.Velocity)
					continue;

				//check
				float triggerRadius = agents[i].Parameters.Radius * 2.25f;
				if (OverOffmeshConnection(agents[i], triggerRadius))
				{
					//prepare to off-mesh connection
					int idx = i;
					
					//adjust the path over the off-mesh connection
					int[] refs = new int[2];
					if (agents[i].Corridor.MoveOverOffmeshConnection(agents[i].CornerPolys[agents[i].CornerCount - 1], refs, ref agentAnims[idx].StartPos, ref agentAnims[idx].EndPos, navQuery))
					{
						agentAnims[idx].InitPos = agents[i].Position;
						agentAnims[idx].PolyRef = refs[1];
						agentAnims[idx].Active = true;
						agentAnims[idx].T = 0.0f;
						agentAnims[idx].TMax = (Vector3Extensions.Distance2D(agentAnims[idx].StartPos, agentAnims[idx].EndPos)
							/ agents[i].Parameters.MaxSpeed) * 0.5f;

						agents[i].State = AgentState.Offmesh;
						agents[i].CornerCount = 0;
						agents[i].NeighborCount = 0;
						continue;
					}
				}
			}

			//calculate steering
			for (int i = 0; i < numAgents; i++)
			{
				if (agents[i].State != AgentState.Walking)
					continue;
				if (agents[i].TargetState == TargetState.None)
					continue;

				Vector3 dvel = new Vector3(0, 0, 0);

				if (agents[i].TargetState == TargetState.Velocity)
				{
					dvel = agents[i].TargetPosition;
					agents[i].DesiredSpeed = agents[i].TargetPosition.Length();
				}
				else
				{
					//calculate steering direction
					if ((agents[i].Parameters.UpdateFlags & UpdateFlags.AnticipateTurns) != 0)
						CalcSmoothSteerDirection(agents[i], ref dvel);
					else
						CalcStraightSteerDirection(agents[i], ref dvel);

					//calculate speed scale, which tells the agent to slowdown at the end of the path
					float slowDownRadius = agents[i].Parameters.Radius * 2;
					float speedScale = GetDistanceToGoal(agents[i], slowDownRadius) / slowDownRadius;

					agents[i].DesiredSpeed = agents[i].Parameters.MaxSpeed;
					dvel = dvel * (agents[i].DesiredSpeed * speedScale);
				}

				//separation
				if ((agents[i].Parameters.UpdateFlags & UpdateFlags.Separation) != 0)
				{
					float separationDist = agents[i].Parameters.CollisionQueryRange;
					float invSeparationDist = 1.0f / separationDist;
					float separationWeight = agents[i].Parameters.SeparationWeight;

					float w = 0;
					Vector3 disp = new Vector3(0, 0, 0);

					for (int j = 0; j < agents[i].NeighborCount; j++)
					{
						Agent nei = agents[agents[i].Neighbors[j].Index];

						Vector3 diff = agents[i].Position - nei.Position;
						diff.Y = 0;

						float distSqr = diff.LengthSquared();
						if (distSqr < 0.00001f)
							continue;
						if (distSqr > separationDist * separationDist)
							continue;
						float dist = (float)Math.Sqrt(distSqr);
						float weight = separationWeight * (1.0f - (dist * invSeparationDist) * (dist * invSeparationDist));

						disp = disp + diff * (weight / dist);
						w += 1.0f;
					}

					if (w > 0.0001f)
					{
						//adjust desired veloctiy
						dvel = dvel + disp * (1.0f / w);

						//clamp desired velocity to desired speed
						float speedSqr = dvel.LengthSquared();
						float desiredSqr = agents[i].DesiredSpeed * agents[i].DesiredSpeed;
						if (speedSqr > desiredSqr)
							dvel = dvel * (desiredSqr / speedSqr);
					}
				}

				//set the desired velocity
				agents[i].DesiredVel = dvel;
			}

			//velocity planning
			for (int i = 0; i < numAgents; i++)
			{
				if (agents[i].State != AgentState.Walking)
					continue;

				if ((agents[i].Parameters.UpdateFlags & UpdateFlags.ObstacleAvoidance) != 0)
				{
					this.obstacleQuery.Reset();

					//add neighhbors as obstacles
					for (int j = 0; j < agents[i].NeighborCount; j++)
					{
						Agent nei = agents[agents[i].Neighbors[j].Index];
						obstacleQuery.AddCircle(nei.Position, nei.Parameters.Radius, nei.Vel, nei.DesiredVel);
					}

					//append neighbour segments as obstacles
					for (int j = 0; j < agents[i].Boundary.SegCount; j++)
					{
						LocalBoundary.Segment s = agents[i].Boundary.Segs[j];
						if (Triangle3.Area2D(agents[i].Position, s.Start, s.End) < 0.0f)
							continue;
						obstacleQuery.AddSegment(s.Start, s.End);
					}

					//sample new safe velocity
					bool adaptive = true;
					int ns = 0;

					ObstacleAvoidanceQuery.ObstacleAvoidanceParams parameters = obstacleQueryParams[agents[i].Parameters.ObstacleAvoidanceType];

					if (adaptive)
					{
						ns = obstacleQuery.SampleVelocityAdaptive(agents[i].Position, agents[i].Parameters.Radius, agents[i].DesiredSpeed, agents[i].Vel, agents[i].DesiredVel, ref agents[i].NVel, parameters);
					}
					else
					{
						ns = obstacleQuery.SampleVelocityGrid(agents[i].Position, agents[i].Parameters.Radius, agents[i].DesiredSpeed, agents[i].Vel, agents[i].DesiredVel, ref agents[i].NVel, parameters);
					}

					this.velocitySampleCount += ns;
				}
				else
				{
					//if not using velocity planning, new velocity is directly the desired velocity
					agents[i].NVel = agents[i].DesiredVel;
				}
			}

			//integrate
			for (int i = 0; i < numAgents; i++)
			{
				Agent ag = agents[i];

				if (ag.State != AgentState.Walking)
					continue;

				ag.Integrate(dt);
			}

			//handle collisions
			const float COLLISION_RESOLVE_FACTOR = 0.7f;

			for (int iter = 0; iter < 4; iter++)
			{
				for (int i = 0; i < numAgents; i++)
				{
					int idx0 = GetAgentIndex(agents[i]);

					if (agents[i].State != AgentState.Walking)
						continue;

					agents[i].Disp = new Vector3(0, 0, 0);

					float w = 0;

					for (int j = 0; j < agents[i].NeighborCount; j++)
					{
						Agent nei = agents[agents[i].Neighbors[j].Index];
						int idx1 = GetAgentIndex(nei);

						Vector3 diff = agents[i].Position - nei.Position;
						diff.Y = 0;

						float dist = diff.LengthSquared();
						if (dist > (agents[i].Parameters.Radius + nei.Parameters.Radius) * (agents[i].Parameters.Radius + nei.Parameters.Radius))
							continue;
						dist = (float)Math.Sqrt(dist);
						float pen = (agents[i].Parameters.Radius + nei.Parameters.Radius) - dist;
						if (dist < 0.0001f)
						{
							//agents on top of each other, try to choose diverging separation directions
							if (idx0 > idx1)
								diff = new Vector3(-agents[i].DesiredVel.Z, 0, agents[i].DesiredVel.X);
							else
								diff = new Vector3(agents[i].DesiredVel.Z, 0, -agents[i].DesiredVel.X);
							pen = 0.01f;
						}
						else
						{
							pen = (1.0f / dist) * (pen * 0.5f) * COLLISION_RESOLVE_FACTOR;
						}

						agents[i].Disp = agents[i].Disp + diff * pen;

						w += 1.0f;
					}

					if (w > 0.0001f)
					{
						float iw = 1.0f / w;
						agents[i].Disp = agents[i].Disp * iw;
					}
				}

				for (int i = 0; i < numAgents; i++)
				{
					if (agents[i].State != AgentState.Walking)
						continue;

					//move along navmesh
					agents[i].Corridor.MovePosition(agents[i].Position, navQuery);

					//get valid constrained position back
					agents[i].Position = agents[i].Corridor.Pos;

					//if not using path, truncate the corridor to just one poly
					if (agents[i].TargetState == TargetState.None ||
						agents[i].TargetState == TargetState.Velocity)
					{
						agents[i].Corridor.Reset(agents[i].Corridor.GetFirstPoly(), agents[i].Position);
						agents[i].IsPartial = false;
					}
				}

				//update agents using offmesh connections
				for (int i = 0; i < maxAgents; i++)
				{
					if (!agentAnims[i].Active)
						continue;

					agentAnims[i].T += dt;
					if (agentAnims[i].T > agentAnims[i].TMax)
					{
						//reset animation
						agentAnims[i].Active = false;

						//prepare agent for walking
						agents[i].State = AgentState.Walking;

						continue;
					}

					//update position
					float ta = agentAnims[i].TMax * 0.15f;
					float tb = agentAnims[i].TMax;
					if (agentAnims[i].T < ta)
					{
						float u = MathHelper.Normalize(agentAnims[i].T, 0.0f, ta);
						Vector3 lerpOut;
						Vector3.Lerp(ref agentAnims[i].InitPos, ref agentAnims[i].StartPos, u, out lerpOut);
						agents[i].Position = lerpOut;
					}
					else
					{
						float u = MathHelper.Normalize(agentAnims[i].T, ta, tb);
						Vector3 lerpOut;
						Vector3.Lerp(ref agentAnims[i].StartPos, ref agentAnims[i].EndPos, u, out lerpOut);
						agents[i].Position = lerpOut;
					}

					agents[i].Vel = new Vector3(0, 0, 0);
					agents[i].DesiredVel = new Vector3(0, 0, 0);
				}
			}
		}

		/// <summary>
		/// Change the move requests for all the agents
		/// </summary>
		public void UpdateMoveRequest()
		{
			const int PATH_MAX_AGENTS = 8;
			Agent[] queue = new Agent[PATH_MAX_AGENTS];
			int numQueue = 0;
			Status status;

			//fire off new requests
			for (int i = 0; i < maxAgents; i++)
			{
				if (!agents[i].IsActive)
					continue;
				if (agents[i].State == AgentState.Invalid)
					continue;
				if (agents[i].TargetState == TargetState.None || agents[i].TargetState == TargetState.Velocity)
					continue;

				if (agents[i].TargetState == TargetState.Requesting)
				{
					int[] path = agents[i].Corridor.Path;
					int npath = agents[i].Corridor.PathCount;

					const int MAX_RES = 32;
					Vector3 reqPos = new Vector3();
					int[] reqPath = new int[MAX_RES];
					int reqPathCount = 0;

					//quick search towards the goal
					const int MAX_ITER = 20;
					navQuery.InitSlicedFindPath(new NavPoint(path[0], agents[i].Position), new NavPoint(agents[i].TargetRef, agents[i].TargetPosition));
					int tempInt = 0;
					navQuery.UpdateSlicedFindPath(MAX_ITER, ref tempInt);
					status = Status.Failure;
					if (agents[i].TargetReplan)
					{
						//try to use an existing steady path during replan if possible
						status = navQuery.FinalizedSlicedPathPartial(path, npath, reqPath, ref reqPathCount, MAX_RES).ToStatus();
					}
					else
					{
						//try to move towards the target when the goal changes
						status = navQuery.FinalizeSlicedFindPath(reqPath, ref reqPathCount, MAX_RES).ToStatus();
					}

					if (status != Status.Failure && reqPathCount > 0)
					{
						//in progress or succeed
						if (reqPath[reqPathCount - 1] != agents[i].TargetRef)
						{
							//partial path, constrain target position in last polygon
							bool tempBool;
							status = navQuery.ClosestPointOnPoly(reqPath[reqPathCount - 1], agents[i].TargetPosition, out reqPos, out tempBool).ToStatus();
							if (status == Status.Failure)
								reqPathCount = 0;
						}
						else
						{
							reqPos = agents[i].TargetPosition;
						}
					}
					else
					{
						reqPathCount = 0;
					}

					if (reqPathCount == 0)
					{
						//could not find path, start the request from the current location
						reqPos = agents[i].Position;
						reqPath[0] = path[0];
						reqPathCount = 1;
					}

					agents[i].Corridor.SetCorridor(reqPos, reqPath, reqPathCount);
					agents[i].Boundary.Reset();
					agents[i].IsPartial = false;

					if (reqPath[reqPathCount - 1] == agents[i].TargetRef)
					{
						agents[i].TargetState = TargetState.Valid;
						agents[i].TargetReplanTime = 0.0f;
					}
					else
					{
						//the path is longer or potentially unreachable, full plan
						agents[i].TargetState = TargetState.WaitingForQueue;
					}
				}

				if (agents[i].TargetState == TargetState.WaitingForQueue)
				{
					numQueue = AddToPathQueue(agents[i], queue, numQueue, PATH_MAX_AGENTS);
				}
			}

			for (int i = 0; i < numQueue; i++)
			{
				queue[i].TargetPathqRef = pathq.Request(queue[i].Corridor.GetLastPoly(), queue[i].TargetRef, queue[i].Corridor.Target, queue[i].TargetPosition);
				if (queue[i].TargetPathqRef != PathQueue.Invalid)
					queue[i].TargetState = TargetState.WaitingForPath;
			}

			//update requests
			pathq.Update(MaxItersPerUpdate);

			//process path results
			for (int i = 0; i < maxAgents; i++)
			{
				if (!agents[i].IsActive)
					continue;
				if (agents[i].TargetState == TargetState.None || agents[i].TargetState == TargetState.Velocity)
					continue;

				if (agents[i].TargetState == TargetState.WaitingForPath)
				{
					//poll path queue
					status = pathq.GetRequestStatus(agents[i].TargetPathqRef);
					if (status == Status.Failure)
					{
						//path find failed, retry if the target location is still valid
						agents[i].TargetPathqRef = PathQueue.Invalid;
						if (agents[i].TargetRef != 0)
							agents[i].TargetState = TargetState.Requesting;
						else
							agents[i].TargetState = TargetState.Failed;
						agents[i].TargetReplanTime = 0.0f;
					}
					else if (status == Status.Success)
					{
						int[] path = agents[i].Corridor.Path;
						int npath = agents[i].Corridor.PathCount;

						//apply results
						Vector3 targetPos = new Vector3();
						targetPos = agents[i].TargetPosition;

						int[] res = new int[this.maxPathResult];
						for (int j = 0; j < this.maxPathResult; j++)
							res[i] = pathResult[j];
						bool valid = true;
						int nres = 0;
						status = pathq.GetPathResult(agents[i].TargetPathqRef, res, ref nres, maxPathResult).ToStatus();
						if (status == Status.Failure || nres == 0)
							valid = false;

						//Merge result and existing path
						if (valid && path[npath - 1] != res[0])
							valid = false;

						if (valid)
						{
							//put the old path infront of the old path
							if (npath > 1)
							{
								//make space for the old path
								if ((npath - 1) + nres > maxPathResult)
									nres = maxPathResult - (npath - 1);

								for (int j = 0; j < nres; j++)
									res[npath - 1 + j] = res[j];

								//copy old path in the beginning
								for (int j = 0; j < npath - 1; j++)
									res[j] = path[j];
								nres += npath - 1;

								//remove trackbacks
								for (int j = 0; j < nres; j++)
								{
									if (j - 1 >= 0 && j + 1 < nres)
									{
										if (res[j - 1] == res[j + 1])
										{
											for (int k = 0; k < nres - (j + 1); k++)
												res[j - 1 + k] = res[j + 1 + k];
											nres -= 2;
											j -= 2;
										}
									}
								}
							}

							//check for partial path
							if (res[nres - 1] != agents[i].TargetRef)
							{
								//partial path, constrain target position inside the last polygon
								Vector3 nearest;
								bool tempBool = false;
								status = navQuery.ClosestPointOnPoly(res[nres - 1], targetPos, out nearest, out tempBool).ToStatus();
								if (status == Status.Success)
									targetPos = nearest;
								else
									valid = false;
							}
						}

						if (valid)
						{
							//set current corridor
							agents[i].Corridor.SetCorridor(targetPos, res, nres);
							
							//forced to update boundary
							agents[i].Boundary.Reset();
							agents[i].TargetState = TargetState.Valid;
						}
						else
						{
							//something went wrong
							agents[i].TargetState = TargetState.Failed;
						}

						agents[i].TargetReplanTime = 0.0f;
					}
				}
			}
		}

		/// <summary>
		/// Reoptimize the path corridor for all agents
		/// </summary>
		/// <param name="agents">The agents array</param>
		/// <param name="numAgents">The number of agents</param>
		/// <param name="dt">Time until next update</param>
		public void UpdateTopologyOptimization(Agent[] agents, int numAgents, float dt)
		{
			if (numAgents == 0)
				return;

			const float OPT_TIME_THR = 0.5f; //seconds
			const int OPT_MAX_AGENTS = 1;
			Agent[] queue = new Agent[OPT_MAX_AGENTS];
			int nqueue = 0;

			for (int i = 0; i < numAgents; i++)
			{
				if (agents[i].State != AgentState.Walking)
					continue;
				if (agents[i].TargetState == TargetState.None ||
					agents[i].TargetState == TargetState.Velocity)
					continue;
				if ((agents[i].Parameters.UpdateFlags & UpdateFlags.OptimizeTopo) == 0)
					continue;
				agents[i].topologyOptTime += dt;
				if (agents[i].topologyOptTime >= OPT_TIME_THR)
					nqueue = AddToOptQueue(agents[i], queue, nqueue, OPT_MAX_AGENTS);
			}

			for (int i = 0; i < nqueue; i++)
			{
				queue[i].Corridor.OptimizePathTopology(navQuery);
				queue[i].topologyOptTime = 0.0f;
			}
		}

		/// <summary>
		/// Make sure that each agent is taking a valid path
		/// </summary>
		/// <param name="agents">The agent array</param>
		/// <param name="agentCount">The number of agents</param>
		/// <param name="dt">Time until next update</param>
		public void CheckPathValidity(Agent[] agents, int agentCount, float dt)
		{
			const int CHECK_LOOKAHEAD = 10;
			const float TARGET_REPLAN_DELAY = 1.0f; //seconds

			//Iterate through all the agents
			for (int i = 0; i < agentCount; i++)
			{
				Agent ag = agents[i];

				if (ag.State != AgentState.Walking)
					continue;

				if (ag.TargetState == TargetState.None || ag.TargetState == TargetState.Velocity)
					continue;

				ag.TargetReplanTime += dt;

				bool replan = false;

				//first check that the current location is valid
				int agentRef = ag.Corridor.GetFirstPoly();
				Vector3 agentPos = ag.Position;
				if (!navQuery.IsValidPolyRef(agentRef))
				{
					//current location is not valid, try to reposition
					//Vector3 nearest = agentPos;
					Vector3 pos = ag.Position;
					agentRef = 0;
					NavPoint nearestPt;
					navQuery.FindNearestPoly(ref pos, ref ext, out nearestPt);
					//nearest = nearestPt.Position;
					agentRef = nearestPt.Polygon;
					agentPos = nearestPt.Position;

					if (agentRef == 0)
					{
						//could not find location in navmesh, set state to invalid
						ag.Corridor.Reset(0, agentPos);
						ag.IsPartial = false;
						ag.Boundary.Reset();
						ag.State = AgentState.Invalid;
						continue;
					}

					//make sure the first polygon is valid
					ag.Corridor.FixPathStart(agentRef, agentPos);
					ag.Boundary.Reset();
					ag.Position = agentPos;

					replan = true;
				}

				//try to recover move request position
				if (ag.TargetState != TargetState.None &&
					ag.TargetState != TargetState.Failed)
				{
					if (!navQuery.IsValidPolyRef(ag.TargetRef))
					{
						//current target is not valid, try to reposition
						Vector3 nearest = ag.TargetPosition;
						Vector3 tpos = ag.TargetPosition;
						ag.TargetRef = 0;
						NavPoint nearestPt;
						navQuery.FindNearestPoly(ref tpos, ref ext, out nearestPt);
						ag.TargetRef = nearestPt.Polygon;
						nearest = nearestPt.Position;
						ag.TargetPosition = nearest;
						replan = true;
					}

					if (ag.TargetRef == 0)
					{
						//failed to reposition target
						ag.Corridor.Reset(agentRef, agentPos);
						ag.IsPartial = false;
						ag.TargetState = TargetState.None;
					}
				}

				//if nearby corridor is not valid, replan
				if (!ag.Corridor.IsValid(CHECK_LOOKAHEAD, navQuery))
				{
					replan = true;
				}

				//if the end of the path is near and it is not the request location, replan
				if (ag.TargetState == TargetState.Valid)
				{
					if (ag.TargetReplanTime > TARGET_REPLAN_DELAY &&
						ag.Corridor.PathCount < CHECK_LOOKAHEAD &&
						ag.Corridor.GetLastPoly() != ag.TargetRef)
						replan = true;
				}

				//try to replan path to goal
				if (replan)
				{
					if (ag.TargetState != TargetState.None)
					{
						ag.RequestMoveTargetReplan(ag.TargetRef, ag.TargetPosition);
					}
				}
			}
		}

		public bool OverOffmeshConnection(Agent ag, float radius)
		{
			if (ag.CornerCount == 0)
				return false;

			bool offmeshConnection = ((ag.CornerFlags[ag.CornerCount - 1] & PathfindingCommon.STRAIGHTPATH_OFFMESH_CONNECTION) != 0)
				? true : false;
			if (offmeshConnection)
			{
				float dist = Vector3Extensions.Distance2D(ag.Position, ag.CornerVerts[ag.CornerCount - 1]);
				if (dist * dist < radius * radius)
					return true;
			}

			return false;
		}

		/// <summary>
		/// Calculate a vector based off of the map
		/// </summary>
		/// <param name="ag">The agent</param>
		/// <param name="dir">The resulting steer direction</param>
		public void CalcSmoothSteerDirection(Agent ag, ref Vector3 dir)
		{
			if (ag.CornerCount == 0)
			{
				dir = new Vector3(0, 0, 0);
				return;
			}

			int ip0 = 0;
			int ip1 = Math.Min(1, ag.CornerCount - 1);
			Vector3 p0 = ag.CornerVerts[ip0];
			Vector3 p1 = ag.CornerVerts[ip1];

			Vector3 dir0 = p0 - ag.Position;
			Vector3 dir1 = p1 - ag.Position;
			dir0.Y = 0;
			dir1.Y = 0;

			float len0 = dir0.Length();
			float len1 = dir1.Length();
			if (len1 > 0.001f)
				dir1 = dir1 * 1.0f / len1;

			dir.X = dir0.X - dir1.X * len0 * 0.5f;
			dir.Y = 0;
			dir.Z = dir0.Z - dir1.Z * len0 * 0.5f;

			dir.Normalize();
		}

		/// <summary>
		/// Calculate a straight vector to the destination
		/// </summary>
		/// <param name="ag">The agent</param>
		/// <param name="dir">The resulting steer direction</param>
		public void CalcStraightSteerDirection(Agent ag, ref Vector3 dir)
		{
			if (ag.CornerCount == 0)
			{
				dir = new Vector3(0, 0, 0);
				return;
			}

			dir = ag.CornerVerts[0] - ag.Position;
			dir.Y = 0;
			dir.Normalize();
		}

		/// <summary>
		/// Find the crowd agent's distance to its goal
		/// </summary>
		/// <param name="ag">Thw crowd agent</param>
		/// <param name="range">The maximum range</param>
		/// <returns>Distance to goal</returns>
		public float GetDistanceToGoal(Agent ag, float range)
		{
			if (ag.CornerCount == 0)
				return range;

			bool endOfPath = ((ag.CornerFlags[ag.CornerCount - 1] & PathfindingCommon.STRAIGHTPATH_END) != 0) ? true : false;
			if (endOfPath)
				return Math.Min(Vector3Extensions.Distance2D(ag.Position, ag.CornerVerts[ag.CornerCount - 1]), range);

			return range;
		}

		/// <summary>
		/// Get the crowd agent's neighbors.
		/// </summary>
		/// <param name="pos">Current position</param>
		/// <param name="height">The height</param>
		/// <param name="range">The range to search within</param>
		/// <param name="skip">The current crowd agent</param>
		/// <param name="result">The neihbors array</param>
		/// <param name="maxResult">The maximum number of neighbors that can be stored</param>
		/// <param name="agents">Array of all crowd agents</param>
		/// <param name="grid">The ProximityGrid</param>
		/// <returns>The number of neighbors</returns>
		public int GetNeighbours(Vector3 pos, float height, float range, Agent skip, CrowdNeighbor[] result, int maxResult, Agent[] agents, ProximityGrid<Agent> grid)
		{
			int n = 0;

			const int MAX_NEIS = 32;
			Agent[] ids = new Agent[MAX_NEIS];
			int nids = grid.QueryItems(pos.X - range, pos.Z - range, pos.X + range, pos.Z + range, ids, MAX_NEIS);

			for (int i = 0; i < nids; i++)
			{
				Agent ag = ids[i];

				if (ag == skip)
					continue;

				//check for overlap
				Vector3 diff = pos - ag.Position;
				if (Math.Abs(diff.Y) >= (height + ag.Parameters.Height) / 2.0f)
					continue;
				diff.Y = 0;
				float distSqr = diff.LengthSquared();
				if (distSqr > range * range)
					continue;

				n = AddNeighbour(ids[i], distSqr, result, n, maxResult);
			}

			return n;
		}

		/// <summary>
		/// Add a CrowdNeighbor to the array
		/// </summary>
		/// <param name="Agent">The neighbor</param>
		/// <param name="dist">Distance from current agent</param>
		/// <param name="neis">The neighbors array</param>
		/// <param name="nneis">The number of neighbors</param>
		/// <param name="maxNeis">The maximum number of neighbors allowed</param>
		/// <returns>An updated neighbor count</returns>
		public int AddNeighbour(Agent agent, float dist, CrowdNeighbor[] neis, int nneis, int maxNeis)
		{
			//insert neighbour based on distance
			int neiPos = 0;
			if (nneis == 0)
			{
				neiPos = nneis;
			}
			else if (dist >= neis[nneis - 1].Distance)
			{
				if (nneis >= maxNeis)
					return nneis;
				neiPos = nneis;
			}
			else
			{
				int i;
				for (i = 0; i < nneis; i++)
					if (dist <= neis[i].Distance)
						break;

				int tgt = i + 1;
				int n = Math.Min(nneis - i, maxNeis - tgt);

				if (n > 0)
				{
					for (int j = 0; j < n; j++)
						neis[tgt + j] = neis[i + j];
				}

				neiPos = i;
			}

			//TODO rework Crowd so that Agents are passed around instead of indices
			int index;
			for (index = 0; index < agents.Length; index++)
			{
				if (agent.Equals(agents[index]))
					break;
			}

			if (index == agents.Length)
				throw new IndexOutOfRangeException("Agent not in crowd.");

			var neighbor = new CrowdNeighbor();
			neighbor.Index = index;
			neighbor.Distance = dist;
			neis[neiPos] = neighbor;

			return Math.Min(nneis + 1, maxNeis);
		}

		/// <summary>
		/// Add the CrowdAgent to the path queue
		/// </summary>
		/// <param name="newag">The new CrowdAgent</param>
		/// <param name="agents">The current CrowdAgent array</param>
		/// <param name="numAgents">The number of CrowdAgents</param>
		/// <param name="maxAgents">The maximum number of agents allowed</param>
		/// <returns>An updated agent count</returns>
		public int AddToPathQueue(Agent newag, Agent[] agents, int numAgents, int maxAgents)
		{
			//insert neighbour based on greatest time
			int slot = 0;
			if (numAgents == 0)
			{
				slot = numAgents;
			}
			else if (newag.TargetReplanTime <= agents[numAgents - 1].TargetReplanTime)
			{
				if (numAgents >= maxAgents)
					return numAgents;
				slot = numAgents;
			}
			else
			{
				int i;
				for (i = 0; i < numAgents; i++)
					if (newag.TargetReplanTime >= agents[i].TargetReplanTime)
						break;

				int tgt = i + 1;
				int n = Math.Min(numAgents - i, maxAgents - tgt);

				if (n > 0)
				{
					for (int j = 0; j < n; j++)
						agents[tgt + j] = agents[i + j];
				}

				slot = i;
			}

			agents[slot] = newag;

			return Math.Min(numAgents + 1, maxAgents);
		}

		/// <summary>
		/// Add the CrowdAgent to the optimization queue
		/// </summary>
		/// <param name="newag">The new CrowdAgent</param>
		/// <param name="agents">The current CrowdAgent array</param>
		/// <param name="numAgents">The number of CrowdAgents</param>
		/// <param name="maxAgents">The maximum number of agents allowed</param>
		/// <returns>An updated agent count</returns>
		public int AddToOptQueue(Agent newag, Agent[] agents, int numAgents, int maxAgents)
		{
			//insert neighbor based on greatest time
			int slot = 0;
			if (numAgents == 0)
			{
				slot = numAgents;
			}
			else if (newag.topologyOptTime <= agents[numAgents - 1].topologyOptTime)
			{
				if (numAgents >= maxAgents)
					return numAgents;
				slot = numAgents;
			}
			else
			{
				int i;
				for (i = 0; i < numAgents; i++)
					if (newag.topologyOptTime >= agents[i].topologyOptTime)
						break;

				int tgt = i + 1;
				int n = Math.Min(numAgents - i, maxAgents - tgt);

				if (n > 0)
				{
					for (int j = 0; j < n; j++)
						agents[tgt + j] = agents[i + j];
				}

				slot = i;
			}

			agents[slot] = newag;

			return Math.Min(numAgents + 1, maxAgents);
		}
	}

	/// <summary>
	/// A neighboring crowd agent
	/// </summary>
	public struct CrowdNeighbor
	{
		public int Index;
		public float Distance;
	}

	/// <summary>
	/// Settings for a particular crowd agent
	/// </summary>
	public struct AgentParams
	{
		public float Radius;
		public float Height;
		public float MaxAcceleration;
		public float MaxSpeed;

		public float CollisionQueryRange;

		public float PathOptimizationRange;

		public float SeparationWeight;

		public UpdateFlags UpdateFlags;
			
		public byte ObstacleAvoidanceType;

		public byte QueryFilterType;
	}

	public struct AgentAnimation
	{
		public bool Active { get; set; }
		public Vector3 InitPos, StartPos, EndPos;
		public int PolyRef;
		public float T, TMax;
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\CrowdAgentState.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav.Crowds
{
	/// <summary>
	/// Describes the current state of a crowd agent
	/// </summary>
	[Flags]
	public enum AgentState
	{
		/// <summary>
		/// Not in any state
		/// </summary>
		Invalid,

		/// <summary>
		/// Walking on the navigation mesh
		/// </summary>
		Walking,

		/// <summary>
		/// Handling an offmesh connection
		/// </summary>
		Offmesh
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\LocalBoundary.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using SharpNav.Geometry;
using SharpNav.Pathfinding;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Crowds
{
	/// <summary>
	/// The LocalBoundary class stores segments and polygon indices for temporary use.
	/// </summary>
	public class LocalBoundary
	{
		#region Fields

		private const int MaxLocalSegs = 8;
		private const int MaxLocalPolys = 16;

		private Vector3 center;
		private Segment[] segs;
		private int segCount;

		private int[] polys;
		private int numPolys;

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <see cref="LocalBoundary" /> class.
		/// </summary>
		public LocalBoundary()
		{
			Reset();
			segs = new Segment[MaxLocalSegs];
			polys = new int[MaxLocalPolys];
		}

		#endregion

		#region Properties

		/// <summary>
		/// Gets the center
		/// </summary>
		public Vector3 Center
		{
			get
			{
				return center;
			}
		}

		/// <summary>
		/// Gets the segments
		/// </summary>
		public Segment[] Segs
		{
			get
			{
				return segs;
			}
		}

		/// <summary>
		/// Gets the number of segments
		/// </summary>
		public int SegCount
		{
			get
			{
				return segCount;
			}
		}

		#endregion

		#region Methods

		/// <summary>
		/// Reset all the internal data
		/// </summary>
		public void Reset()
		{
			center = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
			segCount = 0;
			numPolys = 0;
		}

		/// <summary>
		/// Add a line segment
		/// </summary>
		/// <param name="dist">The distance</param>
		/// <param name="s">The line segment</param>
		public void AddSegment(float dist, Segment s)
		{
			//insert neighbour based on distance
			int segPos = 0;
			if (segCount == 0)
			{
				segPos = 0;
			}
			else if (dist >= segs[segCount - 1].Dist)
			{
				//further than the last segment, skip
				if (segCount >= MaxLocalSegs)
					return;

				//last, trivial accept
				segPos = segCount;
			}
			else
			{
				//insert inbetween
				int i;
				for (i = 0; i < segCount; i++)
					if (dist <= segs[i].Dist)
						break;
				int tgt = i + 1;
				int n = Math.Min(segCount - i, MaxLocalSegs - tgt);
				if (n > 0)
				{
					for (int j = 0; j < n; j++)
						segs[tgt + j] = segs[i + j];
				}

				segPos = i;
			}

			segs[segPos].Dist = dist;
			segs[segPos].Start = s.Start;
			segs[segPos].End = s.End;

			if (segCount < MaxLocalSegs)
				segCount++;
		}

		/// <summary>
		/// Examine polygons in the NavMeshQuery and add polygon edges
		/// </summary>
		/// <param name="reference">The starting polygon reference</param>
		/// <param name="pos">Current position</param>
		/// <param name="collisionQueryRange">Range to query</param>
		/// <param name="navquery">The NavMeshQuery</param>
		public void Update(int reference, Vector3 pos, float collisionQueryRange, NavMeshQuery navquery)
		{
			const int MAX_SEGS_PER_POLY = PathfindingCommon.VERTS_PER_POLYGON;

			if (reference == 0)
			{
				this.center = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
				this.segCount = 0;
				this.numPolys = 0;
				return;
			}

			this.center = pos;

			//first query non-overlapping polygons
			int[] tempArray = new int[polys.Length];
			navquery.FindLocalNeighbourhood(new NavPoint(reference, pos), collisionQueryRange, polys, tempArray, ref numPolys, MaxLocalPolys);

			//secondly, store all polygon edges
			this.segCount = 0;
			Segment[] segs = new Segment[MAX_SEGS_PER_POLY];
			int numSegs = 0;
			for (int j = 0; j < numPolys; j++)
			{
				tempArray = new int[segs.Length];
				navquery.GetPolyWallSegments(polys[j], segs, tempArray, ref numSegs, MAX_SEGS_PER_POLY);
				for (int k = 0; k < numSegs; k++)
				{
					//skip too distant segments
					float tseg;
					float distSqr = Distance.PointToSegment2DSquared(ref pos, ref segs[k].Start, ref segs[k].End, out tseg);
					if (distSqr > collisionQueryRange * collisionQueryRange)
						continue;
					AddSegment(distSqr, segs[k]);
				}
			}
		}

		/// <summary>
		/// Determines whether the polygon reference is a part of the NavMeshQuery.
		/// </summary>
		/// <param name="navquery">The NavMeshQuery</param>
		/// <returns>True if valid, false if not</returns>
		public bool IsValid(NavMeshQuery navquery)
		{
			if (numPolys == 0)
				return false;

			for (int i = 0; i < numPolys; i++)
			{
				if (!navquery.IsValidPolyRef(polys[i]))
					return false;
			}

			return true;
		}

		#endregion

		/// <summary>
		/// A line segment contains two points
		/// </summary>
		public struct Segment
		{
			/// <summary>
			/// Start and end points
			/// </summary>
			public Vector3 Start, End;
			
			/// <summary>
			/// Distance for pruning
			/// </summary>
			public float Dist; 
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\ObstacleAvoidanceQuery.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Crowds
{
	public class ObstacleAvoidanceQuery
	{
		#region Fields

		private const int MaxPatternDivs = 32;
		private const int MaxPatternRings = 4;

		private ObstacleAvoidanceParams parameters;
		private float invHorizTime;
		//private float vmax;
		private float invVmax;

		private int maxCircles;
		private ObstacleCircle[] circles;
		private int numCircles;

		private int maxSegments;
		private ObstacleSegment[] segments;
		private int numSegments;

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <see cref="ObstacleAvoidanceQuery" /> class.
		/// </summary>
		/// <param name="maxCircles">The maximum number of circles</param>
		/// <param name="maxSegments">The maximum number of segments</param>
		public ObstacleAvoidanceQuery(int maxCircles, int maxSegments)
		{
			this.maxCircles = maxCircles;
			this.numCircles = 0;
			this.circles = new ObstacleCircle[this.maxCircles];

			this.maxSegments = maxSegments;
			this.numSegments = 0;
			this.segments = new ObstacleSegment[this.maxSegments];
		}

		#endregion

		#region Methods

		/// <summary>
		/// Resets the ObstacleAvoidanceQuery's internal data
		/// </summary>
		public void Reset()
		{
			numCircles = 0;
			numSegments = 0;
		}

		/// <summary>
		/// Add a new circle to the array
		/// </summary>
		/// <param name="pos">The position</param>
		/// <param name="rad">The radius</param>
		/// <param name="vel">The velocity</param>
		/// <param name="dvel">The desired velocity</param>
		public void AddCircle(Vector3 pos, float rad, Vector3 vel, Vector3 dvel)
		{
			if (numCircles >= maxCircles)
				return;

			circles[numCircles].Position = pos;
			circles[numCircles].Radius = rad;
			circles[numCircles].Vel = vel;
			circles[numCircles].DesiredVel = dvel;
			numCircles++;
		}

		/// <summary>
		/// Add a segment to the array
		/// </summary>
		/// <param name="p">One endpoint</param>
		/// <param name="q">The other endpoint</param>
		public void AddSegment(Vector3 p, Vector3 q)
		{
			if (numSegments > maxSegments)
				return;

			segments[numSegments].P = p;
			segments[numSegments].Q = q;
			numSegments++;
		}

		/// <summary>
		/// Prepare the obstacles for further calculations
		/// </summary>
		/// <param name="position">Current position</param>
		/// <param name="desiredVel">Desired velocity</param>
		public void Prepare(Vector3 position, Vector3 desiredVel)
		{
			//prepare obstacles
			for (int i = 0; i < numCircles; i++)
			{
				//side
				Vector3 pa = position;
				Vector3 pb = circles[i].Position;

				Vector3 orig = new Vector3(0, 0, 0);
				circles[i].Dp = pb - pa;
				circles[i].Dp.Normalize();
				Vector3 dv = circles[i].DesiredVel - desiredVel;

				float a = Triangle3.Area2D(orig, circles[i].Dp, dv);
				if (a < 0.01f)
				{
					circles[i].Np.X = -circles[i].Dp.Z;
					circles[i].Np.Z = circles[i].Dp.X;
				}
				else
				{
					circles[i].Np.X = circles[i].Dp.Z;
					circles[i].Np.Z = -circles[i].Dp.X;
				}
			}

			for (int i = 0; i < numSegments; i++)
			{
				//precalculate if the agent is close to the segment
				float r = 0.01f;
				float t;
				segments[i].Touch = Distance.PointToSegment2DSquared(ref position, ref segments[i].P, ref segments[i].Q, out t) < (r * r);
			}
		}

		public float ProcessSample(Vector3 vcand, float cs, Vector3 position, float radius, Vector3 vel, Vector3 desiredVel)
		{
			//find min time of impact and exit amongst all obstacles
			float tmin = parameters.HorizTime;
			float side = 0;
			int numSide = 0;

			for (int i = 0; i < numCircles; i++)
			{
				ObstacleCircle cir = circles[i];

				//RVO
				Vector3 vab = vcand * 2;
				vab = vab - vel;
				vab = vab - cir.Vel;

				//side
				side += MathHelper.Clamp(Math.Min(Vector3Extensions.Dot2D(ref cir.Dp, ref vab) * 0.5f + 0.5f, Vector3Extensions.Dot2D(ref cir.Np, ref vab) * 2.0f), 0.0f, 1.0f);
				numSide++;

				float htmin = 0, htmax = 0;
				if (!SweepCircleCircle(position, radius, vab, cir.Position, cir.Radius, ref htmin, ref htmax))
					continue;

				//handle overlapping obstacles
				if (htmin < 0.0f && htmax > 0.0f)
				{
					//avoid more when overlapped
					htmin = -htmin * 0.5f;
				}

				if (htmin >= 0.0f)
				{
					//the closest obstacle is sometime ahead of us, keep track of nearest obstacle
					if (htmin < tmin)
						tmin = htmin;
				}
			}

			for (int i = 0; i < numSegments; i++)
			{
				ObstacleSegment seg = segments[i];
				float htmin = 0;

				if (seg.Touch)
				{
					//special case when the agent is very close to the segment
					Vector3 sdir = seg.Q - seg.P;
					Vector3 snorm = new Vector3(0, 0, 0);
					snorm.X = -sdir.Z;
					snorm.Z = sdir.X;

					//if the velocity is pointing towards the segment, no collision
					if (Vector3Extensions.Dot2D(ref snorm, ref vcand) < 0.0f)
						continue;

					//else immediate collision
					htmin = 0.0f;
				}
				else
				{
					if (!IntersectRaySegment(position, vcand, seg.P, seg.Q, ref htmin))
						continue;
				}

				//avoid less when facing walls
				htmin *= 2.0f;

				//the closest obstacle is somewhere ahead of us, keep track of the nearest obstacle
				if (htmin < tmin)
					tmin = htmin;
			}

			//normalize side bias
			if (numSide != 0)
				side /= numSide;

			float vpen = parameters.WeightDesVel * (Vector3Extensions.Distance2D(vcand, desiredVel) * invVmax);
			float vcpen = parameters.WeightCurVel * (Vector3Extensions.Distance2D(vcand, vel) * invVmax);
			float spen = parameters.WeightSide * side;
			float tpen = parameters.WeightToi * (1.0f / (0.1f + tmin * invHorizTime));

			float penalty = vpen + vcpen + spen + tpen;

			return penalty;
		}

		public bool SweepCircleCircle(Vector3 center0, float radius0, Vector3 v, Vector3 center1, float radius1, ref float tmin, ref float tmax)
		{
			const float EPS = 0.0001f;
			Vector3 s = center1 - center0;
			float r = radius0 + radius1;
			float c = Vector3Extensions.Dot2D(ref s, ref s) - r * r;
			float a = Vector3Extensions.Dot2D(ref v, ref v);
			if (a < EPS)
				return false; //not moving

			//overlap, calculate time to exit
			float b = Vector3Extensions.Dot2D(ref v, ref s);
			float d = b * b - a * c;
			if (d < 0.0f)
				return false; //no intersection
			a = 1.0f / a;
			float rd = (float)Math.Sqrt(d);
			tmin = (b - rd) * a;
			tmax = (b + rd) * a;
			return true;
		}

		/// <summary>
		/// Determine whether the ray intersects the segment
		/// </summary>
		/// <param name="ap">A point</param>
		/// <param name="u">A vector</param>
		/// <param name="bp">Segment B endpoint</param>
		/// <param name="bq">Another one of segment B's endpoints</param>
		/// <param name="t">The parameter t</param>
		/// <returns>True if intersect, false if not</returns>
		public bool IntersectRaySegment(Vector3 ap, Vector3 u, Vector3 bp, Vector3 bq, ref float t)
		{
			Vector3 v = bq - bp;
			Vector3 w = ap - bp;
			float d;
			Vector3Extensions.PerpDotXZ(ref u, ref v, out d);
			d *= -1;
			if (Math.Abs(d) < 1e-6f)
				return false;

			d = 1.0f / d;
			Vector3Extensions.PerpDotXZ(ref v, ref w, out t);
			t *= -d;
			if (t < 0 || t > 1)
				return false;

			float s;
			Vector3Extensions.PerpDotXZ(ref u, ref w, out s);
			s *= -d;
			if (s < 0 || s > 1)
				return false;

			return true;
		}

		public int SampleVelocityGrid(Vector3 pos, float rad, float vmax, Vector3 vel, Vector3 desiredVel, ref Vector3 nvel, ObstacleAvoidanceParams parameters)
		{
			Prepare(pos, desiredVel);
			this.parameters = parameters;
			this.invHorizTime = 1.0f / this.parameters.HorizTime;
			//this.vmax = vmax;
			this.invVmax = 1.0f / vmax;

			nvel = new Vector3(0, 0, 0);

			float cvx = desiredVel.X * this.parameters.VelBias;
			float cvz = desiredVel.Z * this.parameters.VelBias;
			float cs = vmax * 2 * (1 - this.parameters.VelBias) / (float)(this.parameters.GridSize - 1);
			float half = (this.parameters.GridSize - 1) * cs * 0.5f;

			float minPenalty = float.MaxValue;
			int numSamples = 0;

			for (int y = 0; y < this.parameters.GridSize; y++)
			{
				for (int x = 0; x < this.parameters.GridSize; x++)
				{
					Vector3 vcand = new Vector3(0, 0, 0);
					vcand.X = cvx + x * cs - half;
					vcand.Y = 0;
					vcand.Z = cvz + y * cs - half;

					if (vcand.X * vcand.X + vcand.Z * vcand.Z > (vmax + cs / 2) * (vmax + cs / 2))
						continue;

					float penalty = ProcessSample(vcand, cs, pos, rad, vel, desiredVel);
					numSamples++;
					if (penalty < minPenalty)
					{
						minPenalty = penalty;
						nvel = vcand;
					}
				}
			}

			return numSamples;
		}

		public int SampleVelocityAdaptive(Vector3 position, float radius, float vmax, Vector3 vel, Vector3 desiredVel, ref Vector3 nvel, ObstacleAvoidanceParams parameters)
		{
			Prepare(position, desiredVel);

			this.parameters = parameters;
			this.invHorizTime = 1.0f / parameters.HorizTime;
			//this.vmax = vmax;
			this.invVmax = 1.0f / vmax;

			nvel = new Vector3(0, 0, 0);

			//build sampling pattern aligned to desired velocity
			float[] pattern = new float[(MaxPatternDivs * MaxPatternRings + 1) * 2];
			int numPatterns = 0;

			int numDivs = parameters.AdaptiveDivs;
			int numRings = parameters.AdaptiveRings;
			int depth = parameters.AdaptiveDepth;

			int newNumDivs = MathHelper.Clamp(numDivs, 1, MaxPatternDivs);
			int newNumRings = MathHelper.Clamp(numRings, 1, MaxPatternRings);
			float da = (1.0f / newNumDivs) * (float)Math.PI * 2;
			float dang = (float)Math.Atan2(desiredVel.Z, desiredVel.X);

			//always add sample at zero
			pattern[numPatterns * 2 + 0] = 0;
			pattern[numPatterns * 2 + 1] = 0;
			numPatterns++;

			for (int j = 0; j < newNumRings; j++)
			{
				float r = (float)(newNumRings - j) / (float)newNumRings;
				float a = dang + (j & 1) * 0.5f * da;
				for (int i = 0; i < newNumDivs; i++)
				{
					pattern[numPatterns * 2 + 0] = (float)Math.Cos(a) * r;
					pattern[numPatterns * 2 + 1] = (float)Math.Sin(a) * r;
					numPatterns++;
					a += da;
				}
			}

			//start sampling
			float cr = vmax * (1.0f - parameters.VelBias);
			Vector3 res = new Vector3(desiredVel.X * parameters.VelBias, 0, desiredVel.Z * parameters.VelBias);
			int ns = 0;

			for (int k = 0; k < depth; k++)
			{
				float minPenalty = float.MaxValue;
				Vector3 bvel = new Vector3(0, 0, 0);

				for (int i = 0; i < numPatterns; i++)
				{
					Vector3 vcand = new Vector3();
					vcand.X = res.X + pattern[i * 2 + 0] * cr;
					vcand.Y = 0;
					vcand.Z = res.Z + pattern[i * 2 + 1] * cr;

					if (vcand.X * vcand.X + vcand.Z * vcand.Z > (vmax + 0.001f) * (vmax + 0.001f))
						continue;

					float penalty = ProcessSample(vcand, cr / 10, position, radius, vel, desiredVel);
					ns++;
					if (penalty < minPenalty)
					{
						minPenalty = penalty;
						bvel = vcand;
					}
				}

				res = bvel;

				cr *= 0.5f;
			}

			nvel = res;

			return ns;
		}

		#endregion

		private struct ObstacleCircle
		{
			/// <summary>
			/// The position of the obstacle
			/// </summary>
			public Vector3 Position;

			/// <summary>
			/// The velocity of the obstacle
			/// </summary>
			public Vector3 Vel;

			/// <summary>
			/// The desired velocity of the obstacle
			/// </summary>
			public Vector3 DesiredVel;

			/// <summary>
			/// The radius of the obstacle
			/// </summary>
			public float Radius;

			/// <summary>
			/// Used for side selection during sampling
			/// </summary>
			public Vector3 Dp, Np;
		}

		private struct ObstacleSegment
		{
			/// <summary>
			/// Endpoints of the obstacle segment
			/// </summary>
			public Vector3 P, Q;

			public bool Touch;
		}

		public struct ObstacleAvoidanceParams
		{
			public float VelBias;
			public float WeightDesVel;
			public float WeightCurVel;
			public float WeightSide;
			public float WeightToi;
			public float HorizTime;
			public int GridSize;
			public int AdaptiveDivs;
			public int AdaptiveRings;
			public int AdaptiveDepth;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\PathCorridor.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;
using SharpNav.Geometry;

using SharpNav.Pathfinding;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Crowds
{
	public class PathCorridor
	{
		#region Fields

		private Vector3 pos;
		private Vector3 target;

		private int[] path;
		private int pathCount;
		private int maxPath;

		#endregion

		#region Constructors

		public PathCorridor(int maxPath)
		{
			this.path = new int[maxPath];
			this.pathCount = 0;
			this.maxPath = maxPath;
		}

		#endregion

		#region Properties

		public Vector3 Pos
		{
			get
			{
				return pos;
			}
		}

		public Vector3 Target
		{
			get
			{
				return target;
			}
		}

		public int[] Path
		{
			get
			{
				return path;
			}
		}

		public int PathCount
		{
			get
			{
				return pathCount;
			}
		}

		#endregion

		#region Methods

		/// <summary>
		/// Resets the path to the first polygon.
		/// </summary>
		/// <param name="reference">The starting polygon reference</param>
		/// <param name="pos">Starting position</param>
		public void Reset(int reference, Vector3 pos)
		{
			this.pos = pos;
			this.target = pos;
			this.path[0] = reference;
			this.pathCount = 1;
		}

		/// <summary>
		/// The current corridor position is expected to be within the first polygon in the path. The target
		/// is expected to be in the last polygon.
		/// </summary>
		/// <param name="target">The target</param>
		/// <param name="path">The polygon path</param>
		/// <param name="npath">The path length</param>
		public void SetCorridor(Vector3 target, int[] path, int npath)
		{
			this.target = target;
			path.CopyTo(this.path, 0);
			this.pathCount = npath;
		}

		/// <summary>
		/// Move along the NavMeshQuery and update the position
		/// </summary>
		/// <param name="npos">Current position</param>
		/// <param name="navquery">The NavMeshQuery</param>
		/// <returns>True if position changed, false if not</returns>
		public bool MovePosition(Vector3 npos, NavMeshQuery navquery)
		{
			//move along navmesh and update new position
			Vector3 result = new Vector3();
			const int MaxVisited = 16;
			int[] visited = new int[MaxVisited];
			List<int> listVisited = new List<int>(MaxVisited);
			bool status = navquery.MoveAlongSurface(new NavPoint(path[0], pos), npos, ref result, listVisited);
			visited = listVisited.ToArray();

			if (status == true)
			{
				pathCount = MergeCorridorStartMoved(path, pathCount, maxPath, visited, listVisited.Count);

				//adjust the position to stay on top of the navmesh
				float h = pos.Y;
				navquery.GetPolyHeight(path[0], result, ref h);
				result.Y = h;
				pos = result;
				return true;
			}

			return false;
		}

		public int FindCorners(Vector3[] cornerVerts, int[] cornerFlags, int[] cornerPolys, int maxCorners, NavMeshQuery navquery)
		{
			const float MinTargetDist = 0.01f;

			int numCorners = 0;
			navquery.FindStraightPath(pos, target, path, pathCount, cornerVerts, cornerFlags, cornerPolys, ref numCorners, maxCorners, 0);

			//prune points in the beginning of the path which are too close
			while (numCorners > 0)
			{
				if (((cornerFlags[0] & PathfindingCommon.STRAIGHTPATH_OFFMESH_CONNECTION) != 0) ||
					Vector3Extensions.Distance2D(cornerVerts[0], pos) > MinTargetDist)
					break;
				numCorners--;
				if (numCorners > 0)
				{
					for (int i = 0; i < numCorners; i++)
					{
						cornerFlags[i] = cornerFlags[i + 1];
						cornerPolys[i] = cornerPolys[i + 1];
						cornerVerts[i] = cornerVerts[i + 1];
					}
				}
			}

			//prune points after an off-mesh connection
			for (int i = 0; i < numCorners; i++)
			{
				if ((cornerFlags[i] & PathfindingCommon.STRAIGHTPATH_OFFMESH_CONNECTION) != 0)
				{
					numCorners = i + 1;
					break;
				}
			}

			return numCorners;
		}

		/// <summary>
		/// Use a local area path search to try to reoptimize this corridor
		/// </summary>
		/// <param name="navquery">The NavMeshQuery</param>
		/// <returns>True if optimized, false if not</returns>
		public bool OptimizePathTopology(NavMeshQuery navquery)
		{
			if (pathCount < 3)
				return false;

			const int MaxIter = 32;
			const int MaxRes = 32;

			int[] res = new int[MaxRes];
			int numRes = 0;
			int tempInt = 0;
			navquery.InitSlicedFindPath(new NavPoint(path[0], pos), new NavPoint(path[pathCount - 1], target));
			navquery.UpdateSlicedFindPath(MaxIter, ref tempInt);
			bool status = navquery.FinalizedSlicedPathPartial(path, pathCount, res, ref numRes, MaxRes);

			if (status == true && numRes > 0)
			{
				pathCount = MergeCorridorStartShortcut(path, pathCount, maxPath, res, numRes); 
				return true;
			}

			return false;
		}

		/// <summary>
		/// Use an efficient local visibility search to try to optimize the corridor between the current position and the next.
		/// </summary>
		/// <param name="next">The next postion</param>
		/// <param name="pathOptimizationRange">The range</param>
		/// <param name="navquery">The NavMeshQuery</param>
		public void OptimizePathVisibility(Vector3 next, float pathOptimizationRange, NavMeshQuery navquery)
		{
			//clamp the ray to max distance
			Vector3 goal = next;
			float dist = Vector3Extensions.Distance2D(pos, goal);

			//if too close to the goal, do not try to optimize
			if (dist < 0.01f)
				return;

			dist = Math.Min(dist + 0.01f, pathOptimizationRange);

			//adjust ray length
			Vector3 delta = goal - pos;
			goal = pos + delta * (pathOptimizationRange / dist);

			const int MaxRes = 32;
			int[] res = new int[MaxRes];
			float t = 0;
			Vector3 norm = new Vector3();
			int nres = 0;
			navquery.Raycast(new NavPoint(path[0], pos), goal, ref t, ref norm, res, ref nres, MaxRes);
			if (nres > 1 && t > 0.99f)
			{
				pathCount = MergeCorridorStartShortcut(path, pathCount, maxPath, res, nres);
			}
		}

		/// <summary>
		/// Merge two paths after the start is changed
		/// </summary>
		/// <param name="path">The current path</param>
		/// <param name="npath">Current path length</param>
		/// <param name="maxPath">Maximum path length allowed</param>
		/// <param name="visited">The visited polygons</param>
		/// <param name="nvisited">Visited path length</param>
		/// <returns>New path length</returns>
		public int MergeCorridorStartMoved(int[] path, int npath, int maxPath, int[] visited, int nvisited)
		{
			int furthestPath = -1;
			int furthestVisited = -1;

			//find furthest common polygon
			for (int i = npath - 1; i >= 0; i--)
			{
				bool found = false;
				for (int j = nvisited - 1; j >= 0; j--)
				{
					if (path[i] == visited[j])
					{
						furthestPath = i;
						furthestVisited = j;
						found = true;
					}
				}

				if (found)
					break;
			}

			//if no intersection found just return current path
			if (furthestPath == -1 || furthestVisited == -1)
				return npath;

			//concatenate paths

			//adjust beginning of buffer to include the visited
			int req = nvisited - furthestVisited;
			int orig = Math.Min(furthestPath + 1, npath);
			int size = Math.Max(0, npath - orig);
			if (req + size > maxPath)
				size = maxPath - req;
			if (size > 0)
			{
				for (int i = 0; i < size; i++)
					path[req + i] = path[orig + i];
			}

			//store visited
			for (int i = 0; i < req; i++)
				path[i] = visited[(nvisited - 1) - i];

			return req + size;
		}

		/// <summary>
		/// Merge two paths when a shorter path is found
		/// </summary>
		/// <param name="path">The current path</param>
		/// <param name="npath">Current path length</param>
		/// <param name="maxPath">Maximum path length allowed</param>
		/// <param name="visited">The visited polygons</param>
		/// <param name="nvisited">Visited path length</param>
		/// <returns>New path length</returns>
		public int MergeCorridorStartShortcut(int[] path, int npath, int maxPath, int[] visited, int nvisited)
		{
			int furthestPath = -1;
			int furthestVisited = -1;

			//find furthest common polygon
			for (int i = npath - 1; i >= 0; i--)
			{
				bool found = false;
				for (int j = nvisited - 1; j >= 0; j--)
				{
					if (path[i] == visited[j])
					{
						furthestPath = i;
						furthestVisited = j;
						found = true;
					}
				}

				if (found)
					break;
			}

			//if no intersection found, return current path
			if (furthestPath == -1 || furthestVisited == -1)
				return npath;

			//concatenate paths
			//adjust beginning of the buffer to include the visited
			int req = furthestVisited;
			if (req <= 0)
				return npath;

			int orig = furthestPath;
			int size = Math.Max(0, npath - orig);
			if (req + size > maxPath)
				size = maxPath - req;
			for (int i = 0; i < size; i++)
				path[req + i] = path[orig + i];

			//store visited
			for (int i = 0; i < req; i++)
				path[i] = visited[i];

			return req + size;
		}

		public bool MoveOverOffmeshConnection(int offMeshConRef, int[] refs, ref Vector3 startPos, ref Vector3 endPos, NavMeshQuery navquery)
		{
			//advance the path up to and over the off-mesh connection
			int prevRef = 0, polyRef = path[0];
			int npos = 0;
			while (npos < pathCount && polyRef != offMeshConRef)
			{
				prevRef = polyRef;
				polyRef = path[npos];
				npos++;
			}

			if (npos == pathCount)
			{
				//could not find offMeshConRef
				return false;
			}

			//prune path
			for (int i = npos; i < pathCount; i++)
				path[i - npos] = path[i];
			pathCount -= npos;

			refs[0] = prevRef;
			refs[1] = polyRef;

			TiledNavMesh nav = navquery.NavMesh;

			if (nav.GetOffMeshConnectionPolyEndPoints(refs[0], refs[1], ref startPos, ref endPos) == true)
			{
				pos = endPos;
				return true;
			}

			return false;
		}

		/// <summary>
		/// Adjust the beginning of the path
		/// </summary>
		/// <param name="safeRef">The starting polygon reference</param>
		/// <param name="safePos">The starting position</param>
		/// <returns>True if path start changed, false if not</returns>
		public bool FixPathStart(int safeRef, Vector3 safePos)
		{
			pos = safePos;
			if (pathCount < 3 && pathCount > 0)
			{
				path[2] = path[pathCount - 1];
				path[0] = safeRef;
				path[1] = 0;
				pathCount = 3;
			}
			else
			{
				path[0] = safeRef;
				path[1] = 0;
			}

			return true;
		}

		/// <summary>
		/// Determines whether all the polygons in the path are valid
		/// </summary>
		/// <param name="maxLookAhead">The amount of polygons to examine</param>
		/// <param name="navquery">The NavMeshQuery</param>
		/// <returns>True if all valid, false if otherwise</returns>
		public bool IsValid(int maxLookAhead, NavMeshQuery navquery)
		{
			int n = Math.Min(pathCount, maxLookAhead);
			for (int i = 0; i < n; i++)
			{
				if (!navquery.IsValidPolyRef(path[i]))
					return false;
			}

			return true;
		}

		public int GetFirstPoly()
		{
			return (pathCount != 0) ? path[0] : 0;
		}

		public int GetLastPoly()
		{
			return (pathCount != 0) ? path[pathCount - 1] : 0;
		}

		#endregion
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\PathQueue.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using SharpNav.Geometry;
using SharpNav.Pathfinding;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Crowds
{
	public class PathQueue
	{
		#region Fields

		public const byte Invalid = 0;
		private const int MaxQueue = 8;

		private PathQuery[] queue; //size = MAX_QUEUE
		private int nextHandle = 1;
		private int maxPathSize;
		private int queueHead;
		private NavMeshQuery navquery;

		#endregion

		#region Constructors

		public PathQueue(int maxPathSize, int maxSearchNodeCount, ref TiledNavMesh nav)
		{
			this.navquery = new NavMeshQuery(nav, maxSearchNodeCount);

			this.maxPathSize = maxPathSize;
			this.queue = new PathQuery[MaxQueue];
			for (int i = 0; i < MaxQueue; i++)
			{
				queue[i].Reference = Invalid;
				queue[i].Path = new int[maxPathSize];
			}

			this.queueHead = 0;
		}

		#endregion

		#region Methods

		public void Update(int maxIters)
		{
			const int MAX_KEEP_ALIVE = 2; //in update ticks

			//update path request until there is nothing left to update
			//or up to maxIters pathfinder iterations have been consumed
			int iterCount = maxIters;

			for (int i = 0; i < MaxQueue; i++)
			{
				PathQuery q = queue[queueHead % MaxQueue];

				//skip inactive requests
				if (q.Reference == Invalid)
				{
					queueHead++;
					continue;
				}

				//handle completed request
				if (q.status == Status.Success || q.status == Status.Failure)
				{
					q.KeepAlive++;
					if (q.KeepAlive > MAX_KEEP_ALIVE)
					{
						q.Reference = Invalid;
						q.status = 0;
					}

					queueHead++;
					continue;
				}

				//handle query start
				if (q.status == 0)
				{
					q.status = navquery.InitSlicedFindPath(new NavPoint(q.StartRef, q.StartPos), new NavPoint(q.EndRef, q.EndPos)).ToStatus();
				}

				//handle query in progress
				if (q.status == Status.InProgress)
				{
					int iters = 0;
					q.status = navquery.UpdateSlicedFindPath(iterCount, ref iters).ToStatus();

					iterCount -= iters;
				}

				if (q.status == Status.Success)
				{
					q.status = navquery.FinalizeSlicedFindPath(q.Path, ref q.PathCount, maxPathSize).ToStatus();
				}

				if (iterCount <= 0)
					break;

				queueHead++;
			}
		}

		/// <summary>
		/// Request an empty slot in the path queue
		/// </summary>
		/// <param name="startRef">Start polygon reference</param>
		/// <param name="endRef">End polygon reference</param>
		/// <param name="startPos">Start position</param>
		/// <param name="endPos">End position</param>
		/// <returns>Index of empty slot</returns>
		public int Request(int startRef, int endRef, Vector3 startPos, Vector3 endPos)
		{
			//find empty slot
			int slot = -1;
			for (int i = 0; i < MaxQueue; i++)
			{
				if (queue[i].Reference == Invalid)
				{
					slot = i;
					break;
				}
			}

			//could not find slot
			if (slot == -1)
				return Invalid;

			int reference = nextHandle++;
			if (nextHandle == Invalid) nextHandle++;

			PathQuery q = queue[slot];
			q.Reference = reference;
			q.StartPos = startPos;
			q.StartRef = startRef;
			q.EndPos = endPos;
			q.EndRef = endRef;

			q.status = 0;
			q.PathCount = 0;
			q.KeepAlive = 0;

			queue[slot] = q;

			return reference;
		}

		/// <summary>
		/// Get the status of the polygon in the path queue
		/// </summary>
		/// <param name="reference">The polygon reference</param>
		/// <returns>The status in the queue</returns>
		public Status GetRequestStatus(int reference)
		{
			for (int i = 0; i < MaxQueue; i++)
			{
				if (queue[i].Reference == reference)
					return queue[i].status;
			}

			return Status.Failure;
		}

		public bool GetPathResult(int reference, int[] path, ref int pathSize, int maxPath)
		{
			for (int i = 0; i < MaxQueue; i++)
			{
				if (queue[i].Reference == reference)
				{
					PathQuery q = queue[i];
					
					//free request for reuse
					q.Reference = Invalid;
					q.status = 0;
					
					//copy path
					int n = Math.Min(q.PathCount, maxPath);
					q.Path.CopyTo(path, 0);
					pathSize = n;

					queue[i] = q;

					return true;
				}
			}

			return false;
		}

		#endregion

		private struct PathQuery
		{
			public int Reference;
			
			//path find start and end location
			public Vector3 StartPos, EndPos;
			public int StartRef, EndRef;

			//result
			public int[] Path;
			public int PathCount;

			//state
			public Status status;
			public int KeepAlive;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\Status.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

namespace SharpNav.Crowds
{
	/// <summary>
	/// Similar to a boolean, except there is an intermediate variable between true and false.
	/// </summary>
	public enum Status
	{
		/// <summary>
		/// Operation failed to complete
		/// </summary>
		Failure,

		/// <summary>
		/// Operation finished
		/// </summary>
		Success,
		
		/// <summary>
		/// Operation in progress
		/// </summary>
		InProgress
	}

	/// <summary>
	/// A static class containing extension methods related to the <see cref="Status"/> enum.
	/// </summary>
	public static class StatusExtensions
	{
		/// <summary>
		/// Converts a boolean value to a <see cref="Status"/>.
		/// </summary>
		/// <param name="variable">The boolean value.</param>
		/// <returns>The equivalent status.</returns>
		public static Status ToStatus(this bool variable)
		{
			return variable ? Status.Success : Status.Failure;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\TargetState.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

namespace SharpNav.Crowds
{
	/// <summary>
	/// This state changes depending on what the crowd agent has to do next
	/// </summary>
	public enum TargetState
	{
		/// <summary>
		/// Not in any state
		/// </summary>
		None,

		/// <summary>
		/// Failed to find a new path
		/// </summary>
		Failed,
		
		/// <summary>
		/// Target destination reached.
		/// </summary>
		Valid,
		
		/// <summary>
		/// Requesting a new path
		/// </summary>
		Requesting,
		
		/// <summary>
		/// Add this agent to the crowd manager's path queue
		/// </summary>
		WaitingForQueue,
		
		/// <summary>
		/// The agent is in the path queue
		/// </summary>
		WaitingForPath,
		
		/// <summary>
		/// Changing its velocity
		/// </summary>
		Velocity
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Crowds\UpdateFlags.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav.Crowds
{
	/// <summary>
	/// The UpdateFlag affects the way the agent moves acorss its path.
	/// </summary>
	[Flags]
	public enum UpdateFlags
	{
		/// <summary>
		/// The agent will be making turns in its path
		/// </summary>
		AnticipateTurns = 1,

		/// <summary>
		/// Avoid obstacles on the path
		/// </summary>
		ObstacleAvoidance = 2,

		/// <summary>
		/// Separate this agent from other agents
		/// </summary>
		Separation = 4,

		/// <summary>
		/// Optimize if the agent can see the next corner
		/// </summary>
		OptimizeVis = 8,

		/// <summary>
		/// Optimize the agent's path corridor
		/// </summary>
		OptimizeTopo = 16
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\BBox2i.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav.Geometry
{
	/// <summary>
	/// A 2d bounding box represeted by integers.
	/// </summary>
	[Serializable]
	public struct BBox2i : IEquatable<BBox2i>
	{
		/// <summary>
		/// The minimum of the bounding box.
		/// </summary>
		public Vector2i Min;

		/// <summary>
		/// The maximum of the bounding box.
		/// </summary>
		public Vector2i Max;

		/// <summary>
		/// Initializes a new instance of the <see cref="BBox2i"/> struct.
		/// </summary>
		/// <param name="min">A minimum bound.</param>
		/// <param name="max">A maximum bound.</param>
		public BBox2i(Vector2i min, Vector2i max)
		{
			Min = min;
			Max = max;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="BBox2i"/> struct.
		/// </summary>
		/// <param name="minX">The minimum X bound.</param>
		/// <param name="minY">The minimum Y bound.</param>
		/// <param name="maxX">The maximum X bound.</param>
		/// <param name="maxY">The maximum Y bound.</param>
		public BBox2i(int minX, int minY, int maxX, int maxY)
		{
			Min.X = minX;
			Min.Y = minY;
			Max.X = maxX;
			Max.Y = maxY;
		}

		/// <summary>
		/// Compares two instances of <see cref="BBox2i"/> for equality.
		/// </summary>
		/// <param name="left">An instance of <see cref="BBox2i"/>.</param>
		/// <param name="right">Another instance of <see cref="BBox2i"/>.</param>
		/// <returns>A value indicating whether the two instances are equal.</returns>
		public static bool operator ==(BBox2i left, BBox2i right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two instances of <see cref="BBox2i"/> for inequality.
		/// </summary>
		/// <param name="left">An instance of <see cref="BBox2i"/>.</param>
		/// <param name="right">Another instance of <see cref="BBox2i"/>.</param>
		/// <returns>A value indicating whether the two instances are unequal.</returns>
		public static bool operator !=(BBox2i left, BBox2i right)
		{
			return !(left == right);
		}

		/// <summary>
		/// Turns the instance into a human-readable string.
		/// </summary>
		/// <returns>A string representing the instance.</returns>
		public override string ToString()
		{
			return "{ Min: " + Min.ToString() + ", Max: " + Max.ToString() + " }";
		}

		/// <summary>
		/// Gets a unique hash code for this instance.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			//TODO write a good hash code.
			return Min.GetHashCode() ^ Max.GetHashCode();
		}

		/// <summary>
		/// Checks for equality between this instance and a specified object.
		/// </summary>
		/// <param name="obj">An object.</param>
		/// <returns>A value indicating whether this instance and the object are equal.</returns>
		public override bool Equals(object obj)
		{
			BBox2i? objV = obj as BBox2i?;
			if (objV != null)
				return this.Equals(objV);

			return false;
		}

		/// <summary>
		/// Checks for equality between this instance and a specified instance of <see cref="BBox2i"/>.
		/// </summary>
		/// <param name="other">An instance of <see cref="BBox2i"/>.</param>
		/// <returns>A value indicating whether this instance and the other instance are equal.</returns>
		public bool Equals(BBox2i other)
		{
			return Min == other.Min && Max == other.Max;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\BBox3.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Geometry
{
	/// <summary>
	/// A 3d axis-aligned bounding box.
	/// </summary>
	[Serializable]
	public struct BBox3 : IEquatable<BBox3>
	{
		/// <summary>
		/// The minimum bounds.
		/// </summary>
		public Vector3 Min;

		/// <summary>
		/// The maximum bounds.
		/// </summary>
		public Vector3 Max;

		/// <summary>
		/// Initializes a new instance of the <see cref="BBox3"/> struct.
		/// </summary>
		/// <param name="min">The minimum bounds.</param>
		/// <param name="max">The maximum bounds.</param>
		public BBox3(Vector3 min, Vector3 max)
		{
			Min = min;
			Max = max;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="BBox3"/> struct.
		/// </summary>
		/// <param name="minX">The minimum on the X axis.</param>
		/// <param name="minY">The minimum on the Y axis.</param>
		/// <param name="minZ">The minimum on the Z axis.</param>
		/// <param name="maxX">The maximum on the X axis.</param>
		/// <param name="maxY">The maximum on the Y axis.</param>
		/// <param name="maxZ">The maximum on the Z axis.</param>
		public BBox3(float minX, float minY, float minZ, float maxX, float maxY, float maxZ)
		{
			Min.X = minX;
			Min.Y = minY;
			Min.Z = minZ;

			Max.X = maxX;
			Max.Y = maxY;
			Max.Z = maxZ;
		}

		/// <summary>
		/// Gets the center of the box.
		/// </summary>
		public Vector3 Center
		{
			get
			{
				return (Min + Max) / 2;
			}
		}

		/// <summary>
		/// Gets the size of the box.
		/// </summary>
		public Vector3 Size
		{
			get
			{
				return Max - Min;
			}
		}

		/// <summary>
		/// Checks whether two boudning boxes are intersecting.
		/// </summary>
		/// <param name="a">The first bounding box.</param>
		/// <param name="b">The second bounding box.</param>
		/// <returns>A value indicating whether the two bounding boxes are overlapping.</returns>
		public static bool Overlapping(ref BBox3 a, ref BBox3 b)
		{
			return !(a.Min.X > b.Max.X || a.Max.X < b.Min.X
				|| a.Min.Y > b.Max.Y || a.Max.Y < b.Min.Y
				|| a.Min.Z > b.Max.Z || a.Max.Z < b.Min.Z);
		}

		/// <summary>
		/// Determines whether a bounding box is valid. Validity consists of having no NaN values and the Min vector
		/// to be less than the Max vector on all axes.
		/// </summary>
		/// <param name="b">The bounding box to validate.</param>
		/// <returns>A value indicating whether the bounding box is valid.</returns>
		public static bool IsValid(ref BBox3 b)
		{
			//None of the values can be NaN.
			if (float.IsNaN(b.Min.X) ||
				float.IsNaN(b.Min.Y) ||
				float.IsNaN(b.Min.Z) ||
				float.IsNaN(b.Max.X) ||
				float.IsNaN(b.Max.Y) ||
				float.IsNaN(b.Max.Z))
				return false;

			//The min must be less than the max on all axes.
			if (b.Min.X > b.Max.X ||
				b.Min.Y > b.Max.Y ||
				b.Min.Z > b.Max.Z)
				return false;

			return true;
		}

		/// <summary>
		/// Compares two bounding boxes for equality.
		/// </summary>
		/// <param name="left">The first bounding box.</param>
		/// <param name="right">The second bounding box.</param>
		/// <returns>A value indicating the equality of the two boxes.</returns>
		public static bool operator ==(BBox3 left, BBox3 right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two bounding boxes for inequality.
		/// </summary>
		/// <param name="left">The first bounding box.</param>
		/// <param name="right">The second bounding box.</param>
		/// <returns>A value indicating the inequality of the two boxes.</returns>
		public static bool operator !=(BBox3 left, BBox3 right)
		{
			return !(left == right);
		}

		/// <summary>
		/// Compares this instance with another bounding box for equality.
		/// </summary>
		/// <param name="other">Another bounding box.</param>
		/// <returns>A value indicating the equality of the two boxes.</returns>
		public bool Equals(BBox3 other)
		{
			return Min == other.Min && Max == other.Max;
		}

		/// <summary>
		/// Compares this instance with another object for equality.
		/// </summary>
		/// <param name="obj">An object.</param>
		/// <returns>A value indicating equality between the two objects.</returns>
		public override bool Equals(object obj)
		{
			if (obj is BBox3)
				return this.Equals((BBox3)obj);
			else
				return false;
		}

		/// <summary>
		/// Generates a unique hashcode for this bouding box instance.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			//TODO write a better hash code
			return Min.GetHashCode() ^ Max.GetHashCode();
		}

		/// <summary>
		/// Returns a string containing the important information for this instance of <see cref="BBox3"/>.
		/// </summary>
		/// <returns>A human-readable string representation of this instance.</returns>
		public override string ToString()
		{
			return "{ Min: " + Min.ToString() + ", Max: " + Max.ToString() + " }";
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\Containment.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Geometry
{
	/// <summary>
	/// Contains helper methods to check for containment of points or shapes.
	/// </summary>
	internal static class Containment
	{
		/// <summary>
		/// Determines whether a point is inside a polygon.
		/// </summary>
		/// <param name="pt">A point.</param>
		/// <param name="verts">A set of vertices that define a polygon.</param>
		/// <param name="nverts">The number of vertices to use from <c>verts</c>.</param>
		/// <returns>A value indicating whether the point is contained within the polygon.</returns>
		internal static bool PointInPoly(Vector3 pt, Vector3[] verts, int nverts)
		{
			bool c = false;

			for (int i = 0, j = nverts - 1; i < nverts; j = i++)
			{
				Vector3 vi = verts[i];
				Vector3 vj = verts[j];
				if (((vi.Z > pt.Z) != (vj.Z > pt.Z)) &&
					(pt.X < (vj.X - vi.X) * (pt.Z - vi.Z) / (vj.Z - vi.Z) + vi.X))
				{
					c = !c;
				}
			}

			return c;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\Distance.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Geometry
{
	/// <summary>
	/// Contains helper methods to calculate the distance between two objects.
	/// </summary>
	internal static class Distance
	{
		/// <summary>
		/// Find the 3D distance between a point (x, y, z) and a segment PQ
		/// </summary>
		/// <param name="pt">The coordinate of the point.</param>
		/// <param name="p">The coordinate of point P in the segment PQ.</param>
		/// <param name="q">The coordinate of point Q in the segment PQ.</param>
		/// <returns>The distance between the point and the segment.</returns>
		internal static float PointToSegmentSquared(ref Vector3 pt, ref Vector3 p, ref Vector3 q)
		{
			//distance from P to Q
			Vector3 pq = q - p;

			//disance from P to the lone point
			float dx = pt.X - p.X;
			float dy = pt.Y - p.Y;
			float dz = pt.Z - p.Z;

			float segmentMagnitudeSquared = pq.LengthSquared();
			float t = pq.X * dx + pq.Y * dy + pq.Z * dz;

			if (segmentMagnitudeSquared > 0)
				t /= segmentMagnitudeSquared;

			//keep t between 0 and 1
			if (t < 0)
				t = 0;
			else if (t > 1)
				t = 1;

			dx = p.X + t * pq.X - pt.X;
			dy = p.Y + t * pq.Y - pt.Y;
			dz = p.Z + t * pq.Z - pt.Z;

			return dx * dx + dy * dy + dz * dz;
		}

		/// <summary>
		/// Find the 2d distance between a point (x, z) and a segment PQ, where P is (px, pz) and Q is (qx, qz).
		/// </summary>
		/// <param name="x">The X coordinate of the point.</param>
		/// <param name="z">The Z coordinate of the point.</param>
		/// <param name="px">The X coordinate of point P in the segment PQ.</param>
		/// <param name="pz">The Z coordinate of point P in the segment PQ.</param>
		/// <param name="qx">The X coordinate of point Q in the segment PQ.</param>
		/// <param name="qz">The Z coordinate of point Q in the segment PQ.</param>
		/// <returns>The distance between the point and the segment.</returns>
		internal static float PointToSegment2DSquared(int x, int z, int px, int pz, int qx, int qz)
		{
			float segmentDeltaX = qx - px;
			float segmentDeltaZ = qz - pz;
			float dx = x - px;
			float dz = z - pz;
			float segmentMagnitudeSquared = segmentDeltaX * segmentDeltaX + segmentDeltaZ * segmentDeltaZ;
			float t = segmentDeltaX * dx + segmentDeltaZ * dz;

			//normalize?
			if (segmentMagnitudeSquared > 0)
				t /= segmentMagnitudeSquared;

			//0 < t < 1
			if (t < 0)
				t = 0;
			else if (t > 1)
				t = 1;

			dx = px + t * segmentDeltaX - x;
			dz = pz + t * segmentDeltaZ - z;

			return dx * dx + dz * dz;
		}

		/// <summary>
		/// Find the 2d distance between a point and a segment PQ
		/// </summary>
		/// <param name="pt">The coordinate of the point.</param>
		/// <param name="p">The coordinate of point P in the segment PQ.</param>
		/// <param name="q">The coordinate of point Q in the segment PQ.</param>
		/// <returns>The distance between the point and the segment.</returns>
		internal static float PointToSegment2DSquared(ref Vector3 pt, ref Vector3 p, ref Vector3 q)
		{
			float t = 0;
			return PointToSegment2DSquared(ref pt, ref p, ref q, out t);
		}

		/// <summary>
		/// Find the 2d distance between a point and a segment PQ
		/// </summary>
		/// <param name="pt">The coordinate of the point.</param>
		/// <param name="p">The coordinate of point P in the segment PQ.</param>
		/// <param name="q">The coordinate of point Q in the segment PQ.</param>
		/// <param name="t">Parameterization ratio t</param>
		/// <returns>The distance between the point and the segment.</returns>
		internal static float PointToSegment2DSquared(ref Vector3 pt, ref Vector3 p, ref Vector3 q, out float t)
		{
			//distance from P to Q in the xz plane
			float segmentDeltaX = q.X - p.X;
			float segmentDeltaZ = q.Z - p.Z;

			//distance from P to lone point in xz plane
			float dx = pt.X - p.X;
			float dz = pt.Z - p.Z;

			float segmentMagnitudeSquared = segmentDeltaX * segmentDeltaX + segmentDeltaZ * segmentDeltaZ;
			t = segmentDeltaX * dx + segmentDeltaZ * dz;

			if (segmentMagnitudeSquared > 0)
				t /= segmentMagnitudeSquared;

			//keep t between 0 and 1
			if (t < 0)
				t = 0;
			else if (t > 1)
				t = 1;

			dx = p.X + t * segmentDeltaX - pt.X;
			dz = p.Z + t * segmentDeltaZ - pt.Z;

			return dx * dx + dz * dz;
		}

		internal static float PointToPolygonSquared(Vector3 point, Vector3[] verts, int vertCount)
		{
			float dmin = float.MaxValue;
			bool c = false;

			for (int i = 0, j = vertCount - 1; i < vertCount; j = i++)
			{
				Vector3 vi = verts[i];
				Vector3 vj = verts[j];

				if (((vi.Z > point.Z) != (vj.Z > point.Z)) && (point.X < (vj.X - vi.X) * (point.Z - vi.Z) / (vj.Z - vi.Z) + vi.X))
					c = !c;

				dmin = Math.Min(dmin, Distance.PointToSegment2DSquared(ref point, ref vj, ref vi));
			}

			return c ? -dmin : dmin;
		}

		//TOOD where did these come from?

		/// <summary>
		/// Finds the squared distance between a point and the nearest edge of a polygon.
		/// </summary>
		/// <param name="pt">A point.</param>
		/// <param name="verts">A set of vertices that define a polygon.</param>
		/// <param name="nverts">The number of vertices to use from <c>verts</c>.</param>
		/// <returns>The squared distance between a point and the nearest edge of a polygon.</returns>
		internal static float PointToPolygonEdgeSquared(Vector3 pt, Vector3[] verts, int nverts)
		{
			float dmin = float.MaxValue;
			for (int i = 0, j = nverts - 1; i < nverts; j = i++)
				dmin = Math.Min(dmin, Distance.PointToSegment2DSquared(ref pt, ref verts[j], ref verts[i]));

			return Containment.PointInPoly(pt, verts, nverts) ? -dmin : dmin;
		}

		/// <summary>
		/// Finds the distance between a point and the nearest edge of a polygon.
		/// </summary>
		/// <param name="pt">A point.</param>
		/// <param name="verts">A set of vertices that define a polygon.</param>
		/// <param name="nverts">The number of vertices to use from <c>verts</c>.</param>
		/// <param name="edgeDist">A buffer for edge distances to be stored in.</param>
		/// <param name="edgeT">A buffer for parametrization ratios to be stored in.</param>
		/// <returns>A value indicating whether the point is contained in the polygon.</returns>
		internal static bool PointToPolygonEdgeSquared(Vector3 pt, Vector3[] verts, int nverts, float[] edgeDist, float[] edgeT)
		{
			for (int i = 0, j = nverts - 1; i < nverts; j = i++)
				edgeDist[j] = PointToSegment2DSquared(ref pt, ref verts[j], ref verts[i], out edgeT[j]);

			return Containment.PointInPoly(pt, verts, nverts);
		}

		/// <summary>
		/// Finds the distance between a point and triangle ABC.
		/// </summary>
		/// <param name="p">A point.</param>
		/// <param name="a">The first vertex of the triangle.</param>
		/// <param name="b">The second vertex of the triangle.</param>
		/// <param name="c">The third vertex of the triangle.</param>
		/// <returns>The distnace between the point and the triangle.</returns>
		internal static float PointToTriangle(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
		{
			//If the point lies inside the triangle, return the interpolated y-coordinate
			float h;
			if (PointToTriangle(p, a, b, c, out h))
			{
				return Math.Abs(h - p.Y);
			}

			return float.MaxValue;
		}

		/// <summary>
		/// Finds the distance between a point and triangle ABC.
		/// </summary>
		/// <param name="p">A point.</param>
		/// <param name="a">The first vertex of the triangle.</param>
		/// <param name="b">The second vertex of the triangle.</param>
		/// <param name="c">The third vertex of the triangle.</param>
		/// <param name="height">The height between the point and the triangle.</param>
		/// <returns>A value indicating whether the point is contained within the triangle.</returns>
		internal static bool PointToTriangle(Vector3 p, Vector3 a, Vector3 b, Vector3 c, out float height)
		{
			Vector3 v0 = c - a;
			Vector3 v1 = b - a;
			Vector3 v2 = p - a;

			float dot00, dot01, dot02, dot11, dot12;

			Vector3Extensions.Dot2D(ref v0, ref v0, out dot00);
			Vector3Extensions.Dot2D(ref v0, ref v1, out dot01);
			Vector3Extensions.Dot2D(ref v0, ref v2, out dot02);
			Vector3Extensions.Dot2D(ref v1, ref v1, out dot11);
			Vector3Extensions.Dot2D(ref v1, ref v2, out dot12);

			//compute barycentric coordinates
			float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
			float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			float v = (dot00 * dot12 - dot01 * dot02) * invDenom;

			const float EPS = 1E-4f;

			//if point lies inside triangle, return interpolated y-coordinate
			if (u >= -EPS && v >= -EPS && (u + v) <= 1 + EPS)
			{
				height = a.Y + v0.Y * u + v1.Y * v;
				return true;
			}

			height = float.MaxValue;
			return false;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\Intersection.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Geometry
{
	/// <summary>
	/// Contains helper methods to check for intersection between two objects.
	/// </summary>
	internal static class Intersection
	{
		/// <summary>
		/// Determines whether two 2D segments AB and CD are intersecting.
		/// </summary>
		/// <param name="a">The endpoint A of segment AB.</param>
		/// <param name="b">The endpoint B of segment AB.</param>
		/// <param name="c">The endpoint C of segment CD.</param>
		/// <param name="d">The endpoint D of segment CD.</param>
		/// <returns>A value indicating whether the two segments are intersecting.</returns>
		internal static bool SegmentSegment2D(ref Vector3 a, ref Vector3 b, ref Vector3 c, ref Vector3 d)
		{
			float a1, a2, a3;

			Vector3Extensions.Cross2D(ref a, ref b, ref d, out a1);
			Vector3Extensions.Cross2D(ref a, ref b, ref c, out a2);

			if (a1 * a2 < 0.0f)
			{
				Vector3Extensions.Cross2D(ref c, ref d, ref a, out a3);
				float a4 = a3 + a2 - a1;

				if (a3 * a4 < 0.0f)
					return true;
			}

			return false;
		}

		/// <summary>
		/// Determines whether two 2D segments AB and CD are intersecting.
		/// </summary>
		/// <param name="a">The endpoint A of segment AB.</param>
		/// <param name="b">The endpoint B of segment AB.</param>
		/// <param name="c">The endpoint C of segment CD.</param>
		/// <param name="d">The endpoint D of segment CD.</param>
		/// <param name="s">The normalized dot product between CD and AC on the XZ plane.</param>
		/// <param name="t">The normalized dot product between AB and AC on the XZ plane.</param>
		/// <returns>A value indicating whether the two segments are intersecting.</returns>
		internal static bool SegmentSegment2D(ref Vector3 a, ref Vector3 b, ref Vector3 c, ref Vector3 d, out float s, out float t)
		{
			Vector3 u = b - a;
			Vector3 v = d - c;
			Vector3 w = a - c;

			float magnitude;
			Vector3Extensions.PerpDotXZ(ref u, ref v, out magnitude);

			if (Math.Abs(magnitude) < 1e-6f)
			{
				//TODO is NaN the best value to set here?
				s = float.NaN;
				t = float.NaN;
				return false;
			}

			Vector3Extensions.PerpDotXZ(ref v, ref w, out s);
			Vector3Extensions.PerpDotXZ(ref u, ref w, out t);
			s /= magnitude;
			t /= magnitude;

			return true;
		}

		/// <summary>
		/// Determines whether two polygons A and B are intersecting
		/// </summary>
		/// <param name="polya">Polygon A's vertices</param>
		/// <param name="npolya">Number of vertices for polygon A</param>
		/// <param name="polyb">Polygon B's vertices</param>
		/// <param name="npolyb">Number of vertices for polygon B</param>
		/// <returns>True if intersecting, false if not</returns>
		internal static bool PolyPoly2D(Vector3[] polya, int npolya, Vector3[] polyb, int npolyb)
		{
			const float EPS = 1E-4f;

			for (int i = 0, j = npolya - 1; i < npolya; j = i++)
			{
				Vector3 va = polya[j];
				Vector3 vb = polya[i];
				Vector3 n = new Vector3(va.X - vb.X, 0.0f, va.Z - vb.Z);
				float amin, amax, bmin, bmax;
				ProjectPoly(n, polya, npolya, out amin, out amax);
				ProjectPoly(n, polyb, npolyb, out bmin, out bmax);
				if (!OverlapRange(amin, amax, bmin, bmax, EPS))
				{
					//found separating axis
					return false;
				}
			}

			for (int i = 0, j = npolyb - 1; i < npolyb; j = i++)
			{
				Vector3 va = polyb[j];
				Vector3 vb = polyb[i];
				Vector3 n = new Vector3(va.X - vb.X, 0.0f, va.Z - vb.Z);
				float amin, amax, bmin, bmax;
				ProjectPoly(n, polya, npolya, out amin, out amax);
				ProjectPoly(n, polyb, npolyb, out bmin, out bmax);
				if (!OverlapRange(amin, amax, bmin, bmax, EPS))
				{
					//found separating axis
					return false;
				}
			}

			return true;
		}

		/// <summary>
		/// Determines whether the segment interesects with the polygon.
		/// </summary>
		/// <param name="p0">Segment's first endpoint</param>
		/// <param name="p1">Segment's second endpoint</param>
		/// <param name="verts">Polygon's vertices</param>
		/// <param name="nverts">The number of vertices in the polygon</param>
		/// <param name="tmin">Parameter t minimum</param>
		/// <param name="tmax">Parameter t maximum</param>
		/// <param name="segMin">Minimum vertex index</param>
		/// <param name="segMax">Maximum vertex index</param>
		/// <returns>True if intersect, false if not</returns>
		internal static bool SegmentPoly2D(Vector3 p0, Vector3 p1, Vector3[] verts, int nverts, out float tmin, out float tmax, out int segMin, out int segMax)
		{
			const float Epsilon = 0.00000001f;

			tmin = 0;
			tmax = 1;
			segMin = -1;
			segMax = -1;

			Vector3 dir = p1 - p0;

			for (int i = 0, j = nverts - 1; i < nverts; j = i++)
			{
				Vector3 edge = verts[i] - verts[j];
				Vector3 diff = p0 - verts[j];
				float n = edge.Z * diff.X - edge.X * diff.Z;
				float d = dir.Z * edge.X - dir.X * edge.Z;
				if (Math.Abs(d) < Epsilon)
				{
					//S is nearly parallel to this edge
					if (n < 0)
						return false;
					else
						continue;
				}

				float t = n / d;
				if (d < 0)
				{
					//segment S is entering across this edge
					if (t > tmin)
					{
						tmin = t;
						segMin = j;

						//S enters after leaving the polygon
						if (tmin > tmax)
							return false;
					}
				}
				else
				{
					//segment S is leaving across this edge
					if (t < tmax)
					{
						tmax = t;
						segMax = j;

						//S leaves before entering the polygon
						if (tmax < tmin)
							return false;
					}
				}
			}

			return true;
		}

		internal static void ProjectPoly(Vector3 axis, Vector3[] poly, int npoly, out float rmin, out float rmax)
		{
			Vector3Extensions.Dot2D(ref axis, ref poly[0], out rmin);
			Vector3Extensions.Dot2D(ref axis, ref poly[0], out rmax);
			for (int i = 1; i < npoly; i++)
			{
				float d;
				Vector3Extensions.Dot2D(ref axis, ref poly[i], out d);
				rmin = Math.Min(rmin, d);
				rmax = Math.Max(rmax, d);
			}
		}

		internal static bool OverlapRange(float amin, float amax, float bmin, float bmax, float eps)
		{
			return ((amin + eps) > bmax || (amax - eps) < bmin) ? false : true;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\Triangle3.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Runtime.InteropServices;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Geometry
{
	/// <summary>
	/// A 3d triangle.
	/// </summary>
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct Triangle3 : IEquatable<Triangle3>
	{
		#region Fields

		/// <summary>
		/// The first point.
		/// </summary>
		public Vector3 A;

		/// <summary>
		/// The second point.
		/// </summary>
		public Vector3 B;

		/// <summary>
		/// The third point.
		/// </summary>
		public Vector3 C;

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <see cref="Triangle3"/> struct.
		/// </summary>
		/// <param name="a">The second point.</param>
		/// <param name="b">The first point.</param>
		/// <param name="c">The third point.</param>
		public Triangle3(Vector3 a, Vector3 b, Vector3 c)
		{
			A = a;
			B = b;
			C = c;
		}

		#endregion

		#region Properties

		/// <summary>
		/// Gets the directed line segment from <see cref="A"/> to <see cref="B"/>.
		/// </summary>
		public Vector3 AB
		{
			get
			{
				Vector3 result;
				Vector3.Subtract(ref B, ref A, out result);
				return result;
			}
		}

		/// <summary>
		/// Gets the directed line segment from <see cref="A"/> to <see cref="C"/>.
		/// </summary>
		public Vector3 AC
		{
			get
			{
				Vector3 result;
				Vector3.Subtract(ref C, ref A, out result);
				return result;
			}
		}

		/// <summary>
		/// Gets the directed line segment from <see cref="B"/> to <see cref="A"/>.
		/// </summary>
		public Vector3 BA
		{
			get
			{
				Vector3 result;
				Vector3.Subtract(ref A, ref B, out result);
				return result;
			}
		}

		/// <summary>
		/// Gets the directed line segment from <see cref="B"/> to <see cref="C"/>.
		/// </summary>
		public Vector3 BC
		{
			get
			{
				Vector3 result;
				Vector3.Subtract(ref C, ref B, out result);
				return result;
			}
		}

		/// <summary>
		/// Gets the directed line segment from <see cref="C"/> to <see cref="A"/>.
		/// </summary>
		public Vector3 CA
		{
			get
			{
				Vector3 result;
				Vector3.Subtract(ref A, ref C, out result);
				return result;
			}
		}

		/// <summary>
		/// Gets the directed line segment from <see cref="C"/> to <see cref="B"/>.
		/// </summary>
		public Vector3 CB
		{
			get
			{
				Vector3 result;
				Vector3.Subtract(ref B, ref C, out result);
				return result;
			}
		}

		/// <summary>
		/// Gets the area of the triangle.
		/// </summary>
		public float Area
		{
			get
			{
				return Vector3.Cross(AB, AC).Length() * 0.5f;
			}
		}

		/// <summary>
		/// Gets the perimeter of the triangle.
		/// </summary>
		public float Perimeter
		{
			get
			{
				return AB.Length() + AC.Length() + BC.Length();
			}
		}

		/// <summary>
		/// Gets the centroid of the triangle.
		/// </summary>
		public Vector3 Centroid
		{
			get
			{
				const float OneThird = 1f / 3f;
				return A * OneThird + B * OneThird + C * OneThird;
			}
		}

		/// <summary>
		/// Gets the <see cref="Triangle3"/>'s surface normal. Assumes clockwise ordering of A, B, and C.
		/// </summary>
		public Vector3 Normal
		{
			get
			{
				return Vector3.Normalize(Vector3.Cross(AB, AC));
			}
		}

		#endregion

		#region Operators

		/// <summary>
		/// Compares two <see cref="Triangle3"/>'s for equality.
		/// </summary>
		/// <param name="left">The first triangle.</param>
		/// <param name="right">The second triangle.</param>
		/// <returns>A value indicating whether the two triangles are equal.</returns>
		public static bool operator ==(Triangle3 left, Triangle3 right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two <see cref="Triangle3"/>'s for inequality.
		/// </summary>
		/// <param name="left">The first triangle.</param>
		/// <param name="right">The second triangle.</param>
		/// <returns>A value indicating whether the two triangles are not equal.</returns>
		public static bool operator !=(Triangle3 left, Triangle3 right)
		{
			return !left.Equals(right);
		}

		#endregion

		#region Methods

		/// <summary>
		/// Calculates the bounding box of a triangle.
		/// </summary>
		/// <param name="tri">A triangle.</param>
		/// <returns>The triangle's bounding box.</returns>
		public static BBox3 GetBoundingBox(Triangle3 tri)
		{
			BBox3 b;
			GetBoundingBox(ref tri, out b);
			return b;
		}

		/// <summary>
		/// Calculates the bounding box of a triangle.
		/// </summary>
		/// <param name="tri">A triangle.</param>
		/// <param name="bbox">The triangle's bounding box.</param>
		public static void GetBoundingBox(ref Triangle3 tri, out BBox3 bbox)
		{
			GetBoundingBox(ref tri.A, ref tri.B, ref tri.C, out bbox);
		}

		/// <summary>
		/// Calculates the bounding box of a triangle from its vertices.
		/// </summary>
		/// <param name="a">The first vertex.</param>
		/// <param name="b">The second vertex.</param>
		/// <param name="c">The third vertex.</param>
		/// <param name="bbox">The bounding box between the points.</param>
		public static void GetBoundingBox(ref Vector3 a, ref Vector3 b, ref Vector3 c, out BBox3 bbox)
		{
			Vector3 min = a, max = a;

			if (b.X < min.X) min.X = b.X;
			if (b.Y < min.Y) min.Y = b.Y;
			if (b.Z < min.Z) min.Z = b.Z;
			if (c.X < min.X) min.X = c.X;
			if (c.Y < min.Y) min.Y = c.Y;
			if (c.Z < min.Z) min.Z = c.Z;

			if (b.X > max.X) max.X = b.X;
			if (b.Y > max.Y) max.Y = b.Y;
			if (b.Z > max.Z) max.Z = b.Z;
			if (c.X > max.X) max.X = c.X;
			if (c.Y > max.Y) max.Y = c.Y;
			if (c.Z > max.Z) max.Z = c.Z;

			bbox.Min = min;
			bbox.Max = max;
		}

		/// <summary>
		/// Gets the area of the triangle projected onto the XZ-plane.
		/// </summary>
		/// <param name="a">The first point.</param>
		/// <param name="b">The second point.</param>
		/// <param name="c">The third point.</param>
		/// <param name="area">The calculated area.</param>
		public static void Area2D(ref Vector3 a, ref Vector3 b, ref Vector3 c, out float area)
		{
			float abx = b.X - a.X;
			float abz = b.Z - a.Z;
			float acx = c.X - a.X;
			float acz = c.Z - a.Z;
			area = acx * abz - abx * acz;
		}

		/// <summary>
		/// Gets the area of the triangle projected onto the XZ-plane.
		/// </summary>
		/// <param name="a">The first point.</param>
		/// <param name="b">The second point.</param>
		/// <param name="c">The third point.</param>
		/// <returns>The calculated area.</returns>
		public static float Area2D(Vector3 a, Vector3 b, Vector3 c)
		{
			float result;
			Area2D(ref a, ref b, ref c, out result);
			return result;
		}

		/// <summary>
		/// Checks for equality with another <see cref="Triangle3"/>.
		/// </summary>
		/// <param name="other">The other triangle.</param>
		/// <returns>A value indicating whether other is equivalent to the triangle.</returns>
		public bool Equals(Triangle3 other)
		{
			return
				A.Equals(other.A) &&
				B.Equals(other.B) &&
				C.Equals(other.C);
		}

		/// <summary>
		/// Checks for equality with another object.
		/// </summary>
		/// <param name="obj">The other object.</param>
		/// <returns>A value indicating whether other is equivalent to the triangle.</returns>
		public override bool Equals(object obj)
		{
			Triangle3? other = obj as Triangle3?;

			if (other.HasValue)
				return this.Equals(other.Value);
			else
				return false;
		}

		/// <summary>
		/// Gets a unique hash code for the triangle.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			//see http://stackoverflow.com/a/263416/1122135
			int hash = 17;
			hash = hash * 23 + A.GetHashCode();
			hash = hash * 23 + B.GetHashCode();
			hash = hash * 23 + C.GetHashCode();
			return hash;
		}

		/// <summary>
		/// Converts the triangle's data into a human-readable format.
		/// </summary>
		/// <returns>A string containing the triangle's data.</returns>
		public override string ToString()
		{
			return "(" + A.ToString() + ", " + B.ToString() + ", " + C.ToString() + ")";
		}

		#endregion
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\TriangleEnumerable.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System.Collections.Generic;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Geometry
{
	//TODO array bounds checking to catch out of bounds exceptions early.
	//TODO index arrays of other integral types (byte, sbyte, short, ushort, uint) - possibly make generic?

	/// <summary>
	/// A static class that generates an <see cref="IEnumerable{T}"/> of <see cref="Triangle3"/> using iterator blocks.
	/// </summary>
	public static class TriangleEnumerable
	{
		/// <summary>
		/// Iterates over an array of <see cref="Triangle3"/> with a specified offset and length.
		/// </summary>
		/// <param name="triangles">An array of triangles.</param>
		/// <param name="triOffset">The index of the first triangle to be enumerated.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <returns>An enumerable collection of triangles.</returns>
		public static IEnumerable<Triangle3> FromTriangle(Triangle3[] triangles, int triOffset, int triCount)
		{
			for (int i = 0; i < triCount; i++)
				yield return triangles[triOffset + i];
		}

		/// <summary>
		/// Iterates over an array of <see cref="Vector3"/> with a specified offset, stride, and length.
		/// </summary>
		/// <param name="vertices">An array of vertices.</param>
		/// <param name="vertOffset">The index of the first vertex to be enumerated.</param>
		/// <param name="vertStride">The distance between the start of two triangles. A value of 0 means the data is tightly packed.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <returns>An enumerable collection of triangles.</returns>
		public static IEnumerable<Triangle3> FromVector3(Vector3[] vertices, int vertOffset, int vertStride, int triCount)
		{
			Triangle3 tri;

			if (vertStride == 0)
				vertStride = 3;

			for (int i = 0; i < triCount; i++)
			{
				tri.A = vertices[i * vertStride + vertOffset];
				tri.B = vertices[i * vertStride + vertOffset + 1];
				tri.C = vertices[i * vertStride + vertOffset + 2];

				yield return tri;
			}
		}

		/// <summary>
		/// Iterates over an array of <see cref="float"/> with a specified offset, stride, and length.
		/// </summary>
		/// <param name="vertices">An array of vertices.</param>
		/// <param name="floatOffset">The index of the first float to be enumerated.</param>
		/// <param name="floatStride">The distance between the start of two vertices. A value of 0 means the data is tightly packed.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <returns>An enumerable collection of triangles.</returns>
		public static IEnumerable<Triangle3> FromFloat(float[] vertices, int floatOffset, int floatStride, int triCount)
		{
			Triangle3 tri;

			if (floatStride == 0)
				floatStride = 3;

			for (int i = 0; i < triCount; i++)
			{
				int indA = i * (floatStride * 3) + floatOffset;
				int indB = indA + floatStride;
				int indC = indB + floatStride;

				tri.A.X = vertices[indA];
				tri.A.Y = vertices[indA + 1];
				tri.A.Z = vertices[indA + 2];

				tri.B.X = vertices[indB];
				tri.B.Y = vertices[indB + 1];
				tri.B.Z = vertices[indB + 2];

				tri.C.X = vertices[indC];
				tri.C.Y = vertices[indC + 1];
				tri.C.Z = vertices[indC + 2];

				yield return tri;
			}
		}

		/// <summary>
		/// Iterates over an array of <see cref="Vector3"/> indexed by an array of <see cref="int"/> with a specified offset, stride, and length.
		/// </summary>
		/// <param name="vertices">An array of vertices.</param>
		/// <param name="indices">An array of indices.</param>
		/// <param name="vertOffset">The index of the first vertex to be enumerated.</param>
		/// <param name="vertStride">The distance between the start of two triangles. A value of 0 means the data is tightly packed.</param>
		/// <param name="indexOffset">The index of the first index to be enumerated.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <returns>An enumerable collection of triangles.</returns>
		public static IEnumerable<Triangle3> FromIndexedVector3(Vector3[] vertices, int[] indices, int vertOffset, int vertStride, int indexOffset, int triCount)
		{
			Triangle3 tri;

			for (int i = 0; i < triCount; i++)
			{
				int indA = vertOffset + indices[i * 3 + indexOffset] * vertStride;
				int indB = vertOffset + indices[i * 3 + indexOffset + 1] * vertStride;
				int indC = vertOffset + indices[i * 3 + indexOffset + 2] * vertStride;

				tri.A = vertices[indA];
				tri.B = vertices[indB];
				tri.C = vertices[indC];

				yield return tri;
			}
		}

		/// <summary>
		/// Iterates over an array of <see cref="float"/> indexed by an array of <see cref="int"/> with a specified offset, stride, and length.
		/// </summary>
		/// <param name="vertices">An array of vertices.</param>
		/// <param name="indices">An array of indices.</param>
		/// <param name="floatOffset">The index of the first float to be enumerated.</param>
		/// <param name="floatStride">The distance between the start of two vertices. A value of 0 means the data is tightly packed.</param>
		/// <param name="indexOffset">The index of the first index to be enumerated.</param>
		/// <param name="triCount">The number of triangles to enumerate.</param>
		/// <returns>An enumerable collection of triangles.</returns>
		public static IEnumerable<Triangle3> FromIndexedFloat(float[] vertices, int[] indices, int floatOffset, int floatStride, int indexOffset, int triCount)
		{
			Triangle3 tri;

			for (int i = 0; i < triCount; i++)
			{
				int indA = floatOffset + indices[i * 3 + indexOffset] * floatStride;
				int indB = floatOffset + indices[i * 3 + indexOffset + 1] * floatStride;
				int indC = floatOffset + indices[i * 3 + indexOffset + 2] * floatStride;

				tri.A.X = vertices[indA];
				tri.A.Y = vertices[indA + 1];
				tri.A.Z = vertices[indA + 2];

				tri.B.X = vertices[indB];
				tri.B.Y = vertices[indB + 1];
				tri.B.Z = vertices[indB + 2];

				tri.C.X = vertices[indC];
				tri.C.Y = vertices[indC + 1];
				tri.C.Z = vertices[indC + 2];

				yield return tri;
			}
		}

		/// <summary>
		/// Generates a bounding box for a collection of triangles.
		/// </summary>
		/// <param name="tris">The triangles to create a bounding box from.</param>
		/// <returns>A bounding box containing every triangle.</returns>
		public static BBox3 GetBoundingBox(this IEnumerable<Triangle3> tris)
		{
			return GetBoundingBox(tris, float.Epsilon * 2f);
		}

		/// <summary>
		/// Generates a bounding box for a collection of triangles.
		/// </summary>
		/// <param name="tris">The triangles to create a bounding box from.</param>
		/// <param name="padding">Padding to the bounding box</param>
		/// <returns>A bounding box containing every triangle.</returns>
		public static BBox3 GetBoundingBox(this IEnumerable<Triangle3> tris, float padding)
		{
			BBox3 bounds = new BBox3();
			Vector3 va, vb, vc;
			foreach (Triangle3 tri in tris)
			{
				va = tri.A;
				vb = tri.B;
				vc = tri.C;
				ApplyVertexToBounds(ref va, ref bounds);
				ApplyVertexToBounds(ref vb, ref bounds);
				ApplyVertexToBounds(ref vc, ref bounds);
			}

			//pad the bounding box a bit to make sure outer triangles are fully contained.
			ApplyPaddingToBounds(padding, ref bounds);

			return bounds;
		}

		/// <summary>
		/// Generates a bounding box for a collection of vectors.
		/// </summary>
		/// <param name="vecs">The vectors to create a bounding box from.</param>
		/// <returns>A bounding box containing every vector.</returns>
		public static BBox3 GetBoundingBox(this IEnumerable<Vector3> vecs)
		{
			BBox3 bounds = new BBox3();
			Vector3 v;
			foreach (Vector3 vec in vecs)
			{
				v = vec;
				ApplyVertexToBounds(ref v, ref bounds);
			}

			ApplyPaddingToBounds(1.0f, ref bounds);

			return bounds;
		}

		/// <summary>
		/// Adjusts a bounding box to include a vertex.
		/// </summary>
		/// <param name="v">The vertex to include.</param>
		/// <param name="b">The bounding box to adjust.</param>
		private static void ApplyVertexToBounds(ref Vector3 v, ref BBox3 b)
		{
			if (v.X < b.Min.X)
				b.Min.X = v.X;
			if (v.Y < b.Min.Y)
				b.Min.Y = v.Y;
			if (v.Z < b.Min.Z)
				b.Min.Z = v.Z;
			if (v.X > b.Max.X)
				b.Max.X = v.X;
			if (v.Y > b.Max.Y)
				b.Max.Y = v.Y;
			if (v.Z > b.Max.Z)
				b.Max.Z = v.Z;
		}

		/// <summary>
		/// Applies a padding to the bounding box.
		/// </summary>
		/// <param name="pad">The amount to pad the bounding box on all sides.</param>
		/// <param name="b">The bounding box to pad.</param>
		private static void ApplyPaddingToBounds(float pad, ref BBox3 b)
		{
			b.Min.X -= pad;
			b.Min.Y -= pad;
			b.Min.Z -= pad;
			b.Max.X += pad;
			b.Max.Y += pad;
			b.Max.Z += pad;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\Vector2.cs:
 #region --- License ---
/*
Copyright (c) 2006 - 2008 The Open Toolkit library.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */
#endregion

#if !MONOGAME && !OPENTK && !SHARPDX && !XNA && !UNITY3D

using System;
//using System.Runtime.InteropServices;

namespace SharpNav.Geometry
{
	/// <summary>Represents a 2D vector using two single-precision floating-point numbers.</summary>
	/// <remarks>
	/// The Vector2 structure is suitable for interoperation with unmanaged code requiring two consecutive floats.
	/// </remarks>
	[Serializable]
	//[StructLayout(LayoutKind.Sequential)]
	public struct Vector2 : IEquatable<Vector2>
	{
		#region Fields

		private static string listSeparator = System.Globalization.CultureInfo.CurrentCulture.TextInfo.ListSeparator;

		/// <summary>
		/// The X component of the Vector2.
		/// </summary>
		public float X;

		/// <summary>
		/// The Y component of the Vector2.
		/// </summary>
		public float Y;

		#endregion

		#region Constructors

		/// <summary>
		/// Constructs a new instance.
		/// </summary>
		/// <param name="value">The value that will initialize this instance.</param>
		public Vector2(float value)
		{
			X = value;
			Y = value;
		}

		/// <summary>
		/// Constructs a new Vector2.
		/// </summary>
		/// <param name="x">The x coordinate of the net Vector2.</param>
		/// <param name="y">The y coordinate of the net Vector2.</param>
		public Vector2(float x, float y)
		{
			X = x;
			Y = y;
		}

		/// <summary>
		/// Constructs a new Vector2 from the given Vector2.
		/// </summary>
		/// <param name="v">The Vector2 to copy components from.</param>
		[Obsolete]
		public Vector2(Vector2 v)
		{
			X = v.X;
			Y = v.Y;
		}

		/// <summary>
		/// Constructs a new Vector2 from the given Vector3.
		/// </summary>
		/// <param name="v">The Vector3 to copy components from. Z is discarded.</param>
		[Obsolete]
		public Vector2(Vector3 v)
		{
			X = v.X;
			Y = v.Y;
		}

		#endregion

		#region Public Members

		#region Instance

		#region public float Length

		/// <summary>
		/// Gets the length (magnitude) of the vector.
		/// </summary>
		/// <see cref="LengthSquared"/>
		public float Length
		{
			get
			{
				return (float)System.Math.Sqrt(X * X + Y * Y);
			}
		}

		#endregion

		#region public float LengthSquared

		/// <summary>
		/// Gets the square of the vector length (magnitude).
		/// </summary>
		/// <remarks>
		/// This property avoids the costly square root operation required by the Length property. This makes it more suitable
		/// for comparisons.
		/// </remarks>
		/// <see cref="Length"/>
		public float LengthSquared
		{
			get
			{
				return X * X + Y * Y;
			}
		}

		#endregion

		#region public Vector2 PerpendicularRight

		/// <summary>
		/// Gets the perpendicular vector on the right side of this vector.
		/// </summary>
		public Vector2 PerpendicularRight
		{
			get
			{
				return new Vector2(Y, -X);
			}
		}

		#endregion

		#region public Vector2 PerpendicularLeft

		/// <summary>
		/// Gets the perpendicular vector on the left side of this vector.
		/// </summary>
		public Vector2 PerpendicularLeft
		{
			get
			{
				return new Vector2(-Y, X);
			}
		}

		#endregion

		/// <summary>
		/// Gets or sets the value at the index of the Vector.
		/// </summary>
		public float this[int index]
		{
			get
			{
				if (index == 0) return X;
				else if (index == 1) return Y;
				throw new IndexOutOfRangeException("You tried to access this vector at index: " + index);
			}
			set
			{
				if (index == 0) X = value;
				else if (index == 1) Y = value;
				else throw new IndexOutOfRangeException("You tried to set this vector at index: " + index);
			}
		}

		/// <summary>
		/// Returns a copy of the Vector2 scaled to unit length.
		/// </summary>
		/// <returns></returns>
		public Vector2 Normalized()
		{
			Vector2 v = this;
			v.Normalize();
			return v;
		}
		#region public void Normalize()

		/// <summary>
		/// Scales the Vector2 to unit length.
		/// </summary>
		public void Normalize()
		{
			float scale = 1.0f / this.Length;
			X *= scale;
			Y *= scale;
		}

		#endregion

		#endregion

		#region Static

		#region Fields

		/// <summary>
		/// Defines a unit-length Vector2 that points towards the X-axis.
		/// </summary>
		public static readonly Vector2 UnitX = new Vector2(1, 0);

		/// <summary>
		/// Defines a unit-length Vector2 that points towards the Y-axis.
		/// </summary>
		public static readonly Vector2 UnitY = new Vector2(0, 1);

		/// <summary>
		/// Defines a zero-length Vector2.
		/// </summary>
		public static readonly Vector2 Zero = new Vector2(0, 0);

		/// <summary>
		/// Defines an instance with all components set to 1.
		/// </summary>
		public static readonly Vector2 One = new Vector2(1, 1);

		/// <summary>
		/// Defines the size of the Vector2 struct in bytes.
		/// </summary>
		//public static readonly int SizeInBytes = Marshal.SizeOf(new Vector2());

		#endregion

		#region Add

		/// <summary>
		/// Adds two vectors.
		/// </summary>
		/// <param name="a">Left operand.</param>
		/// <param name="b">Right operand.</param>
		/// <returns>Result of operation.</returns>
		public static Vector2 Add(Vector2 a, Vector2 b)
		{
			Add(ref a, ref b, out a);
			return a;
		}

		/// <summary>
		/// Adds two vectors.
		/// </summary>
		/// <param name="a">Left operand.</param>
		/// <param name="b">Right operand.</param>
		/// <param name="result">Result of operation.</param>
		public static void Add(ref Vector2 a, ref Vector2 b, out Vector2 result)
		{
			result = new Vector2(a.X + b.X, a.Y + b.Y);
		}

		#endregion

		#region Subtract

		/// <summary>
		/// Subtract one Vector from another
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <returns>Result of subtraction</returns>
		public static Vector2 Subtract(Vector2 a, Vector2 b)
		{
			Subtract(ref a, ref b, out a);
			return a;
		}

		/// <summary>
		/// Subtract one Vector from another
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <param name="result">Result of subtraction</param>
		public static void Subtract(ref Vector2 a, ref Vector2 b, out Vector2 result)
		{
			result = new Vector2(a.X - b.X, a.Y - b.Y);
		}

		#endregion

		#region Multiply

		/// <summary>
		/// Multiplies a vector by a scalar.
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of the operation.</returns>
		public static Vector2 Multiply(Vector2 vector, float scale)
		{
			Multiply(ref vector, scale, out vector);
			return vector;
		}

		/// <summary>
		/// Multiplies a vector by a scalar.
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <param name="result">Result of the operation.</param>
		public static void Multiply(ref Vector2 vector, float scale, out Vector2 result)
		{
			result = new Vector2(vector.X * scale, vector.Y * scale);
		}

		/// <summary>
		/// Multiplies a vector by the components a vector (scale).
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of the operation.</returns>
		public static Vector2 Multiply(Vector2 vector, Vector2 scale)
		{
			Multiply(ref vector, ref scale, out vector);
			return vector;
		}

		/// <summary>
		/// Multiplies a vector by the components of a vector (scale).
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <param name="result">Result of the operation.</param>
		public static void Multiply(ref Vector2 vector, ref Vector2 scale, out Vector2 result)
		{
			result = new Vector2(vector.X * scale.X, vector.Y * scale.Y);
		}

		#endregion

		#region Divide

		/// <summary>
		/// Divides a vector by a scalar.
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of the operation.</returns>
		public static Vector2 Divide(Vector2 vector, float scale)
		{
			Divide(ref vector, scale, out vector);
			return vector;
		}

		/// <summary>
		/// Divides a vector by a scalar.
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <param name="result">Result of the operation.</param>
		public static void Divide(ref Vector2 vector, float scale, out Vector2 result)
		{
			Multiply(ref vector, 1 / scale, out result);
		}

		/// <summary>
		/// Divides a vector by the components of a vector (scale).
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of the operation.</returns>
		public static Vector2 Divide(Vector2 vector, Vector2 scale)
		{
			Divide(ref vector, ref scale, out vector);
			return vector;
		}

		/// <summary>
		/// Divide a vector by the components of a vector (scale).
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <param name="result">Result of the operation.</param>
		public static void Divide(ref Vector2 vector, ref Vector2 scale, out Vector2 result)
		{
			result = new Vector2(vector.X / scale.X, vector.Y / scale.Y);
		}

		#endregion

		#region ComponentMin

		/// <summary>
		/// Calculate the component-wise minimum of two vectors
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <returns>The component-wise minimum</returns>
		public static Vector2 ComponentMin(Vector2 a, Vector2 b)
		{
			a.X = a.X < b.X ? a.X : b.X;
			a.Y = a.Y < b.Y ? a.Y : b.Y;
			return a;
		}

		/// <summary>
		/// Calculate the component-wise minimum of two vectors
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <param name="result">The component-wise minimum</param>
		public static void ComponentMin(ref Vector2 a, ref Vector2 b, out Vector2 result)
		{
			result.X = a.X < b.X ? a.X : b.X;
			result.Y = a.Y < b.Y ? a.Y : b.Y;
		}

		#endregion

		#region ComponentMax

		/// <summary>
		/// Calculate the component-wise maximum of two vectors
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <returns>The component-wise maximum</returns>
		public static Vector2 ComponentMax(Vector2 a, Vector2 b)
		{
			a.X = a.X > b.X ? a.X : b.X;
			a.Y = a.Y > b.Y ? a.Y : b.Y;
			return a;
		}

		/// <summary>
		/// Calculate the component-wise maximum of two vectors
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <param name="result">The component-wise maximum</param>
		public static void ComponentMax(ref Vector2 a, ref Vector2 b, out Vector2 result)
		{
			result.X = a.X > b.X ? a.X : b.X;
			result.Y = a.Y > b.Y ? a.Y : b.Y;
		}

		#endregion

		#region Min

		/// <summary>
		/// Returns the Vector3 with the minimum magnitude
		/// </summary>
		/// <param name="left">Left operand</param>
		/// <param name="right">Right operand</param>
		/// <returns>The minimum Vector3</returns>
		public static Vector2 Min(Vector2 left, Vector2 right)
		{
			return left.LengthSquared < right.LengthSquared ? left : right;
		}

		#endregion

		#region Max

		/// <summary>
		/// Returns the Vector3 with the minimum magnitude
		/// </summary>
		/// <param name="left">Left operand</param>
		/// <param name="right">Right operand</param>
		/// <returns>The minimum Vector3</returns>
		public static Vector2 Max(Vector2 left, Vector2 right)
		{
			return left.LengthSquared >= right.LengthSquared ? left : right;
		}

		#endregion

		#region Clamp

		/// <summary>
		/// Clamp a vector to the given minimum and maximum vectors
		/// </summary>
		/// <param name="vec">Input vector</param>
		/// <param name="min">Minimum vector</param>
		/// <param name="max">Maximum vector</param>
		/// <returns>The clamped vector</returns>
		public static Vector2 Clamp(Vector2 vec, Vector2 min, Vector2 max)
		{
			vec.X = vec.X < min.X ? min.X : vec.X > max.X ? max.X : vec.X;
			vec.Y = vec.Y < min.Y ? min.Y : vec.Y > max.Y ? max.Y : vec.Y;
			return vec;
		}

		/// <summary>
		/// Clamp a vector to the given minimum and maximum vectors
		/// </summary>
		/// <param name="vec">Input vector</param>
		/// <param name="min">Minimum vector</param>
		/// <param name="max">Maximum vector</param>
		/// <param name="result">The clamped vector</param>
		public static void Clamp(ref Vector2 vec, ref Vector2 min, ref Vector2 max, out Vector2 result)
		{
			result.X = vec.X < min.X ? min.X : vec.X > max.X ? max.X : vec.X;
			result.Y = vec.Y < min.Y ? min.Y : vec.Y > max.Y ? max.Y : vec.Y;
		}

		#endregion

		#region Normalize

		/// <summary>
		/// Scale a vector to unit length
		/// </summary>
		/// <param name="vec">The input vector</param>
		/// <returns>The normalized vector</returns>
		public static Vector2 Normalize(Vector2 vec)
		{
			float scale = 1.0f / vec.Length;
			vec.X *= scale;
			vec.Y *= scale;
			return vec;
		}

		/// <summary>
		/// Scale a vector to unit length
		/// </summary>
		/// <param name="vec">The input vector</param>
		/// <param name="result">The normalized vector</param>
		public static void Normalize(ref Vector2 vec, out Vector2 result)
		{
			float scale = 1.0f / vec.Length;
			result.X = vec.X * scale;
			result.Y = vec.Y * scale;
		}

		#endregion

		#region Dot

		/// <summary>
		/// Calculate the dot (scalar) product of two vectors
		/// </summary>
		/// <param name="left">First operand</param>
		/// <param name="right">Second operand</param>
		/// <returns>The dot product of the two inputs</returns>
		public static float Dot(Vector2 left, Vector2 right)
		{
			return left.X * right.X + left.Y * right.Y;
		}

		/// <summary>
		/// Calculate the dot (scalar) product of two vectors
		/// </summary>
		/// <param name="left">First operand</param>
		/// <param name="right">Second operand</param>
		/// <param name="result">The dot product of the two inputs</param>
		public static void Dot(ref Vector2 left, ref Vector2 right, out float result)
		{
			result = left.X * right.X + left.Y * right.Y;
		}

		#endregion

		#region PerpDot

		/// <summary>
		/// Calculate the perpendicular dot (scalar) product of two vectors
		/// </summary>
		/// <param name="left">First operand</param>
		/// <param name="right">Second operand</param>
		/// <returns>The perpendicular dot product of the two inputs</returns>
		public static float PerpDot(Vector2 left, Vector2 right)
		{
			return left.X * right.Y - left.Y * right.X;
		}

		/// <summary>
		/// Calculate the perpendicular dot (scalar) product of two vectors
		/// </summary>
		/// <param name="left">First operand</param>
		/// <param name="right">Second operand</param>
		/// <param name="result">The perpendicular dot product of the two inputs</param>
		public static void PerpDot(ref Vector2 left, ref Vector2 right, out float result)
		{
			result = left.X * right.Y - left.Y * right.X;
		}

		#endregion

		#region Lerp

		/// <summary>
		/// Returns a new Vector that is the linear blend of the 2 given Vectors
		/// </summary>
		/// <param name="a">First input vector</param>
		/// <param name="b">Second input vector</param>
		/// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
		/// <returns>a when blend=0, b when blend=1, and a linear combination otherwise</returns>
		public static Vector2 Lerp(Vector2 a, Vector2 b, float blend)
		{
			a.X = blend * (b.X - a.X) + a.X;
			a.Y = blend * (b.Y - a.Y) + a.Y;
			return a;
		}

		/// <summary>
		/// Returns a new Vector that is the linear blend of the 2 given Vectors
		/// </summary>
		/// <param name="a">First input vector</param>
		/// <param name="b">Second input vector</param>
		/// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
		/// <param name="result">a when blend=0, b when blend=1, and a linear combination otherwise</param>
		public static void Lerp(ref Vector2 a, ref Vector2 b, float blend, out Vector2 result)
		{
			result.X = blend * (b.X - a.X) + a.X;
			result.Y = blend * (b.Y - a.Y) + a.Y;
		}

		#endregion

		#region Barycentric

		/// <summary>
		/// Interpolate 3 Vectors using Barycentric coordinates
		/// </summary>
		/// <param name="a">First input Vector</param>
		/// <param name="b">Second input Vector</param>
		/// <param name="c">Third input Vector</param>
		/// <param name="u">First Barycentric Coordinate</param>
		/// <param name="v">Second Barycentric Coordinate</param>
		/// <returns>a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</returns>
		public static Vector2 BaryCentric(Vector2 a, Vector2 b, Vector2 c, float u, float v)
		{
			return a + u * (b - a) + v * (c - a);
		}

		/// <summary>Interpolate 3 Vectors using Barycentric coordinates</summary>
		/// <param name="a">First input Vector.</param>
		/// <param name="b">Second input Vector.</param>
		/// <param name="c">Third input Vector.</param>
		/// <param name="u">First Barycentric Coordinate.</param>
		/// <param name="v">Second Barycentric Coordinate.</param>
		/// <param name="result">Output Vector. a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</param>
		public static void BaryCentric(ref Vector2 a, ref Vector2 b, ref Vector2 c, float u, float v, out Vector2 result)
		{
			result = a; // copy

			Vector2 temp = b; // copy
			Subtract(ref temp, ref a, out temp);
			Multiply(ref temp, u, out temp);
			Add(ref result, ref temp, out result);

			temp = c; // copy
			Subtract(ref temp, ref a, out temp);
			Multiply(ref temp, v, out temp);
			Add(ref result, ref temp, out result);
		}

		#endregion

		#endregion

		#region Swizzle

		/// <summary>
		/// Gets or sets an OpenTK.Vector2 with the Y and X components of this instance.
		/// </summary>
		public Vector2 Yx
		{
			get
			{
				return new Vector2(Y, X);
			}
			set
			{
				Y = value.X;
				X = value.Y;
			}
		}

		#endregion

		#region Operators

		/// <summary>
		/// Adds the specified instances.
		/// </summary>
		/// <param name="left">Left operand.</param>
		/// <param name="right">Right operand.</param>
		/// <returns>Result of addition.</returns>
		public static Vector2 operator +(Vector2 left, Vector2 right)
		{
			left.X += right.X;
			left.Y += right.Y;
			return left;
		}

		/// <summary>
		/// Subtracts the specified instances.
		/// </summary>
		/// <param name="left">Left operand.</param>
		/// <param name="right">Right operand.</param>
		/// <returns>Result of subtraction.</returns>
		public static Vector2 operator -(Vector2 left, Vector2 right)
		{
			left.X -= right.X;
			left.Y -= right.Y;
			return left;
		}

		/// <summary>
		/// Negates the specified instance.
		/// </summary>
		/// <param name="vec">Operand.</param>
		/// <returns>Result of negation.</returns>
		public static Vector2 operator -(Vector2 vec)
		{
			vec.X = -vec.X;
			vec.Y = -vec.Y;
			return vec;
		}

		/// <summary>
		/// Multiplies the specified instance by a scalar.
		/// </summary>
		/// <param name="vec">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of multiplication.</returns>
		public static Vector2 operator *(Vector2 vec, float scale)
		{
			vec.X *= scale;
			vec.Y *= scale;
			return vec;
		}

		/// <summary>
		/// Multiplies the specified instance by a scalar.
		/// </summary>
		/// <param name="scale">Left operand.</param>
		/// <param name="vec">Right operand.</param>
		/// <returns>Result of multiplication.</returns>
		public static Vector2 operator *(float scale, Vector2 vec)
		{
			vec.X *= scale;
			vec.Y *= scale;
			return vec;
		}

		/// <summary>
		/// Component-wise multiplication between the specified instance by a scale vector.
		/// </summary>
		/// <param name="scale">Left operand.</param>
		/// <param name="vec">Right operand.</param>
		/// <returns>Result of multiplication.</returns>
		public static Vector2 operator *(Vector2 vec, Vector2 scale)
		{
			vec.X *= scale.X;
			vec.Y *= scale.Y;
			return vec;
		}
		
		/// <summary>
		/// Divides the specified instance by a scalar.
		/// </summary>
		/// <param name="vec">Left operand</param>
		/// <param name="scale">Right operand</param>
		/// <returns>Result of the division.</returns>
		public static Vector2 operator /(Vector2 vec, float scale)
		{
			float mult = 1.0f / scale;
			vec.X *= mult;
			vec.Y *= mult;
			return vec;
		}

		/// <summary>
		/// Compares the specified instances for equality.
		/// </summary>
		/// <param name="left">Left operand.</param>
		/// <param name="right">Right operand.</param>
		/// <returns>True if both instances are equal; false otherwise.</returns>
		public static bool operator ==(Vector2 left, Vector2 right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares the specified instances for inequality.
		/// </summary>
		/// <param name="left">Left operand.</param>
		/// <param name="right">Right operand.</param>
		/// <returns>True if both instances are not equal; false otherwise.</returns>
		public static bool operator !=(Vector2 left, Vector2 right)
		{
			return !left.Equals(right);
		}

		#endregion

		#region Overrides

		#region public override string ToString()

		/// <summary>
		/// Returns a System.String that represents the current Vector2.
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return string.Format("({0}{2} {1})", X, Y, listSeparator);
		}

		#endregion

		#region public override int GetHashCode()

		/// <summary>
		/// Returns the hashcode for this instance.
		/// </summary>
		/// <returns>A System.Int32 containing the unique hashcode for this instance.</returns>
		public override int GetHashCode()
		{
			return X.GetHashCode() ^ Y.GetHashCode();
		}

		#endregion

		#region public override bool Equals(object obj)

		/// <summary>
		/// Indicates whether this instance and a specified object are equal.
		/// </summary>
		/// <param name="obj">The object to compare to.</param>
		/// <returns>True if the instances are equal; false otherwise.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Vector2))
				return false;

			return this.Equals((Vector2)obj);
		}

		#endregion

		#endregion

		#endregion

		#region IEquatable<Vector2> Members

		/// <summary>Indicates whether the current vector is equal to another vector.</summary>
		/// <param name="other">A vector to compare with this vector.</param>
		/// <returns>true if the current vector is equal to the vector parameter; otherwise, false.</returns>
		public bool Equals(Vector2 other)
		{
			return
				X == other.X &&
				Y == other.Y;
		}

		#endregion
	}
}

#endif
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\Vector2i.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav.Geometry
{
	/// <summary>
	/// A 2d vector represented by integers.
	/// </summary>
	[Serializable]
	public struct Vector2i : IEquatable<Vector2i>
	{
		/// <summary>
		/// A vector where both X and Y are <see cref="int.MinValue"/>.
		/// </summary>
		public static readonly Vector2i Min = new Vector2i(int.MinValue, int.MinValue);

		/// <summary>
		/// A vector where both X and Y are <see cref="int.MaxValue"/>.
		/// </summary>
		public static readonly Vector2i Max = new Vector2i(int.MaxValue, int.MaxValue);

		/// <summary>
		/// A vector where both X and Y are 0.
		/// </summary>
		public static readonly Vector2i Zero = new Vector2i(0, 0);

		/// <summary>
		/// The X coordinate.
		/// </summary>
		public int X;

		/// <summary>
		/// The Y coordinate.
		/// </summary>
		public int Y;

		/// <summary>
		/// Initializes a new instance of the <see cref="Vector2i"/> struct with a specified coordinate.
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		public Vector2i(int x, int y)
		{
			X = x;
			Y = y;
		}

		/// <summary>
		/// Compares two instances of <see cref="Vector2i"/> for equality.
		/// </summary>
		/// <param name="left">An instance of <see cref="Vector2i"/>.</param>
		/// <param name="right">Another instance of <see cref="Vector2i"/>.</param>
		/// <returns>A value indicating whether the two instances are equal.</returns>
		public static bool operator ==(Vector2i left, Vector2i right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two instances of <see cref="Vector2i"/> for inequality.
		/// </summary>
		/// <param name="left">An instance of <see cref="Vector2i"/>.</param>
		/// <param name="right">Another instance of <see cref="Vector2i"/>.</param>
		/// <returns>A value indicating whether the two instances are unequal.</returns>
		public static bool operator !=(Vector2i left, Vector2i right)
		{
			return !(left == right);
		}

		/// <summary>
		/// Gets a unique hash code for this instance.
		/// </summary>
		/// <returns>A hash code.</returns>
		public override int GetHashCode()
		{
			//TODO generate a good hashcode.
			return base.GetHashCode();
		}

		/// <summary>
		/// Turns the instance into a human-readable string.
		/// </summary>
		/// <returns>A string representing the instance.</returns>
		public override string ToString()
		{
			return "{ X: " + X.ToString() + ", Y: " + Y.ToString() + " }";
		}

		/// <summary>
		/// Checks for equality between this instance and a specified object.
		/// </summary>
		/// <param name="obj">An object.</param>
		/// <returns>A value indicating whether this instance and the object are equal.</returns>
		public override bool Equals(object obj)
		{
			Vector2i? objV = obj as Vector2i?;
			if (objV != null)
				return this.Equals(objV);

			return false;
		}

		/// <summary>
		/// Checks for equality between this instance and a specified instance of <see cref="Vector2i"/>.
		/// </summary>
		/// <param name="other">An instance of <see cref="Vector2i"/>.</param>
		/// <returns>A value indicating whether this instance and the other instance are equal.</returns>
		public bool Equals(Vector2i other)
		{
			return X == other.X && Y == other.Y;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\Vector3.cs:
 #region --- License ---
/*
Copyright (c) 2006 - 2008 The Open Toolkit library.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */
#endregion

#if !MONOGAME && !OPENTK && !SHARPDX && !XNA && !UNITY3D

using System;

//using System.Runtime.InteropServices;

namespace SharpNav.Geometry
{
	/// <summary>
	/// Represents a 3D vector using three single-precision floating-point numbers.
	/// </summary>
	/// <remarks>
	/// The Vector3 structure is suitable for interoperation with unmanaged code requiring three consecutive floats.
	/// </remarks>
	[Serializable]
	//[StructLayout(LayoutKind.Sequential)]
	public struct Vector3 : IEquatable<Vector3>
	{
		#region Fields

		/// <summary>
		/// The X component of the Vector3.
		/// </summary>
		public float X;

		/// <summary>
		/// The Y component of the Vector3.
		/// </summary>
		public float Y;

		/// <summary>
		/// The Z component of the Vector3.
		/// </summary>
		public float Z;

		#endregion

		#region Constructors

		/// <summary>
		/// Constructs a new instance.
		/// </summary>
		/// <param name="value">The value that will initialize this instance.</param>
		public Vector3(float value)
		{
			X = value;
			Y = value;
			Z = value;
		}

		/// <summary>
		/// Constructs a new Vector3.
		/// </summary>
		/// <param name="x">The x component of the Vector3.</param>
		/// <param name="y">The y component of the Vector3.</param>
		/// <param name="z">The z component of the Vector3.</param>
		public Vector3(float x, float y, float z)
		{
			X = x;
			Y = y;
			Z = z;
		}

		/// <summary>
		/// Constructs a new Vector3 from the given Vector3.
		/// </summary>
		/// <param name="v">The Vector3 to copy components from.</param>
		public Vector3(Vector3 v)
		{
			X = v.X;
			Y = v.Y;
			Z = v.Z;
		}

		#endregion

		#region Public Members
		
		/// <summary>
		/// Sets the Vector3 values.
		/// </summary>
		/// <param name="x">The x component of the Vector3.</param>
		/// <param name="y">The y component of the Vector3.</param>
		/// <param name="z">The z component of the Vector3.</param>
		public void Set(float x, float y, float z)
		{
			this.X = x;
			this.Y = y;
			this.Z = z;
		}

		/// <summary>
		/// Gets or sets the value at the index of the Vector.
		/// </summary>
		public float this[int index]
		{
			get
			{
				switch (index)
				{
					case 0:
						return X;
					case 1:
						return Y;
					case 2:
						return Z;
					default:
						throw new ArgumentOutOfRangeException("You tried to access this vector at index: " + index);
				}
			}

			set
			{
				switch (index)
				{
					case 0:
						X = value;
						break;
					case 1:
						Y = value;
						break;
					case 2:
						Z = value;
						break;
					default:
						throw new ArgumentOutOfRangeException("You tried to set this vector at index: " + index);
				}
			}
		}

		#region Instance

		#region public void Add()

		/// <summary>Add the Vector passed as parameter to this instance.</summary>
		/// <param name="right">Right operand. This parameter is only read from.</param>
		[Obsolete("Use static Add() method instead.")]
		public void Add(Vector3 right)
		{
			this.X += right.X;
			this.Y += right.Y;
			this.Z += right.Z;
		}

		/// <summary>Add the Vector passed as parameter to this instance.</summary>
		/// <param name="right">Right operand. This parameter is only read from.</param>
		[Obsolete("Use static Add() method instead.")]
		public void Add(ref Vector3 right)
		{
			this.X += right.X;
			this.Y += right.Y;
			this.Z += right.Z;
		}

		#endregion public void Add()

		#region public void Sub()

		/// <summary>Subtract the Vector passed as parameter from this instance.</summary>
		/// <param name="right">Right operand. This parameter is only read from.</param>
		[Obsolete("Use static Subtract() method instead.")]
		public void Sub(Vector3 right)
		{
			this.X -= right.X;
			this.Y -= right.Y;
			this.Z -= right.Z;
		}

		/// <summary>Subtract the Vector passed as parameter from this instance.</summary>
		/// <param name="right">Right operand. This parameter is only read from.</param>
		[Obsolete("Use static Subtract() method instead.")]
		public void Sub(ref Vector3 right)
		{
			this.X -= right.X;
			this.Y -= right.Y;
			this.Z -= right.Z;
		}

		#endregion public void Sub()

		#region public void Mult()

		/// <summary>Multiply this instance by a scalar.</summary>
		/// <param name="f">Scalar operand.</param>
		[Obsolete("Use static Multiply() method instead.")]
		public void Mult(float f)
		{
			this.X *= f;
			this.Y *= f;
			this.Z *= f;
		}

		#endregion public void Mult()

		#region public void Div()

		/// <summary>Divide this instance by a scalar.</summary>
		/// <param name="f">Scalar operand.</param>
		[Obsolete("Use static Divide() method instead.")]
		public void Div(float f)
		{
			float mult = 1.0f / f;
			this.X *= mult;
			this.Y *= mult;
			this.Z *= mult;
		}

		#endregion public void Div()

		#region public float Length

		/// <summary>
		/// Gets the length (magnitude) of the vector.
		/// </summary>
		/// <see cref="LengthSquared"/>
		public float Length()
		{
			return (float)System.Math.Sqrt(X * X + Y * Y + Z * Z);
		}

		#endregion

		#region public float LengthSquared

		/// <summary>
		/// Gets the square of the vector length (magnitude).
		/// </summary>
		/// <remarks>
		/// This property avoids the costly square root operation required by the Length property. This makes it more suitable
		/// for comparisons.
		/// </remarks>
		/// <see cref="Length"/>
		public float LengthSquared()
		{
			return X * X + Y * Y + Z * Z;
		}

		#endregion

		/// <summary>
		/// Returns a copy of the Vector3 scaled to unit length.
		/// </summary>
		public Vector3 Normalized()
		{
			Vector3 v = this;
			v.Normalize();
			return v;
		}

		#region public void Normalize()

		/// <summary>
		/// Scales the Vector3 to unit length.
		/// </summary>
		public void Normalize()
		{
			float scale = 1.0f / this.Length();
			X *= scale;
			Y *= scale;
			Z *= scale;
		}

		#endregion

		#region public void Scale()

		/// <summary>
		/// Scales the current Vector3 by the given amounts.
		/// </summary>
		/// <param name="sx">The scale of the X component.</param>
		/// <param name="sy">The scale of the Y component.</param>
		/// <param name="sz">The scale of the Z component.</param>
		[Obsolete("Use static Multiply() method instead.")]
		public void Scale(float sx, float sy, float sz)
		{
			this.X = X * sx;
			this.Y = Y * sy;
			this.Z = Z * sz;
		}

		/// <summary>Scales this instance by the given parameter.</summary>
		/// <param name="scale">The scaling of the individual components.</param>
		[Obsolete("Use static Multiply() method instead.")]
		public void Scale(Vector3 scale)
		{
			this.X *= scale.X;
			this.Y *= scale.Y;
			this.Z *= scale.Z;
		}

		/// <summary>Scales this instance by the given parameter.</summary>
		/// <param name="scale">The scaling of the individual components.</param>
		[Obsolete("Use static Multiply() method instead.")]
		public void Scale(ref Vector3 scale)
		{
			this.X *= scale.X;
			this.Y *= scale.Y;
			this.Z *= scale.Z;
		}

		#endregion public void Scale()

		#endregion

		#region Static

		#region Fields

		/// <summary>
		/// Defines a unit-length Vector3 that points towards the X-axis.
		/// </summary>
		public static readonly Vector3 UnitX = new Vector3(1, 0, 0);

		/// <summary>
		/// Defines a unit-length Vector3 that points towards the Y-axis.
		/// </summary>
		public static readonly Vector3 UnitY = new Vector3(0, 1, 0);

		/// <summary>
		/// /// Defines a unit-length Vector3 that points towards the Z-axis.
		/// </summary>
		public static readonly Vector3 UnitZ = new Vector3(0, 0, 1);

		/// <summary>
		/// Defines a zero-length Vector3.
		/// </summary>
		public static readonly Vector3 Zero = new Vector3(0, 0, 0);

		/// <summary>
		/// Defines an instance with all components set to 1.
		/// </summary>
		public static readonly Vector3 One = new Vector3(1, 1, 1);

		/// <summary>
		/// Defines the size of the Vector3 struct in bytes.
		/// </summary>
		//public static readonly int SizeInBytes = Marshal.SizeOf(new Vector3());

		#endregion

		#region Obsolete

		#region Sub

		/// <summary>
		/// Subtract one Vector from another
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <returns>Result of subtraction</returns>
		[Obsolete("Use static Subtract() method instead.")]
		public static Vector3 Sub(Vector3 a, Vector3 b)
		{
			a.X -= b.X;
			a.Y -= b.Y;
			a.Z -= b.Z;
			return a;
		}

		/// <summary>
		/// Subtract one Vector from another
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <param name="result">Result of subtraction</param>
		[Obsolete("Use static Subtract() method instead.")]
		public static void Sub(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.X = a.X - b.X;
			result.Y = a.Y - b.Y;
			result.Z = a.Z - b.Z;
		}

		#endregion

		#region Mult

		/// <summary>
		/// Multiply a vector and a scalar
		/// </summary>
		/// <param name="a">Vector operand</param>
		/// <param name="f">Scalar operand</param>
		/// <returns>Result of the multiplication</returns>
		[Obsolete("Use static Multiply() method instead.")]
		public static Vector3 Mult(Vector3 a, float f)
		{
			a.X *= f;
			a.Y *= f;
			a.Z *= f;
			return a;
		}

		/// <summary>
		/// Multiply a vector and a scalar
		/// </summary>
		/// <param name="a">Vector operand</param>
		/// <param name="f">Scalar operand</param>
		/// <param name="result">Result of the multiplication</param>
		[Obsolete("Use static Multiply() method instead.")]
		public static void Mult(ref Vector3 a, float f, out Vector3 result)
		{
			result.X = a.X * f;
			result.Y = a.Y * f;
			result.Z = a.Z * f;
		}

		#endregion

		#region Div

		/// <summary>
		/// Divide a vector by a scalar
		/// </summary>
		/// <param name="a">Vector operand</param>
		/// <param name="f">Scalar operand</param>
		/// <returns>Result of the division</returns>
		[Obsolete("Use static Divide() method instead.")]
		public static Vector3 Div(Vector3 a, float f)
		{
			float mult = 1.0f / f;
			a.X *= mult;
			a.Y *= mult;
			a.Z *= mult;
			return a;
		}

		/// <summary>
		/// Divide a vector by a scalar
		/// </summary>
		/// <param name="a">Vector operand</param>
		/// <param name="f">Scalar operand</param>
		/// <param name="result">Result of the division</param>
		[Obsolete("Use static Divide() method instead.")]
		public static void Div(ref Vector3 a, float f, out Vector3 result)
		{
			float mult = 1.0f / f;
			result.X = a.X * mult;
			result.Y = a.Y * mult;
			result.Z = a.Z * mult;
		}

		#endregion

		#endregion

		#region Add

		/// <summary>
		/// Adds two vectors.
		/// </summary>
		/// <param name="a">Left operand.</param>
		/// <param name="b">Right operand.</param>
		/// <returns>Result of operation.</returns>
		public static Vector3 Add(Vector3 a, Vector3 b)
		{
			Add(ref a, ref b, out a);
			return a;
		}

		/// <summary>
		/// Adds two vectors.
		/// </summary>
		/// <param name="a">Left operand.</param>
		/// <param name="b">Right operand.</param>
		/// <param name="result">Result of operation.</param>
		public static void Add(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result = new Vector3(a.X + b.X, a.Y + b.Y, a.Z + b.Z);
		}

		#endregion

		#region Subtract

		/// <summary>
		/// Subtract one Vector from another
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <returns>Result of subtraction</returns>
		public static Vector3 Subtract(Vector3 a, Vector3 b)
		{
			Subtract(ref a, ref b, out a);
			return a;
		}

		/// <summary>
		/// Subtract one Vector from another
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <param name="result">Result of subtraction</param>
		public static void Subtract(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result = new Vector3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);
		}

		#endregion

		#region Multiply

		/// <summary>
		/// Multiplies a vector by a scalar.
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of the operation.</returns>
		public static Vector3 Multiply(Vector3 vector, float scale)
		{
			Multiply(ref vector, scale, out vector);
			return vector;
		}

		/// <summary>
		/// Multiplies a vector by a scalar.
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <param name="result">Result of the operation.</param>
		public static void Multiply(ref Vector3 vector, float scale, out Vector3 result)
		{
			result = new Vector3(vector.X * scale, vector.Y * scale, vector.Z * scale);
		}

		/// <summary>
		/// Multiplies a vector by the components a vector (scale).
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of the operation.</returns>
		public static Vector3 Multiply(Vector3 vector, Vector3 scale)
		{
			Multiply(ref vector, ref scale, out vector);
			return vector;
		}

		/// <summary>
		/// Multiplies a vector by the components of a vector (scale).
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <param name="result">Result of the operation.</param>
		public static void Multiply(ref Vector3 vector, ref Vector3 scale, out Vector3 result)
		{
			result = new Vector3(vector.X * scale.X, vector.Y * scale.Y, vector.Z * scale.Z);
		}

		#endregion

		#region Divide

		/// <summary>
		/// Divides a vector by a scalar.
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of the operation.</returns>
		public static Vector3 Divide(Vector3 vector, float scale)
		{
			Divide(ref vector, scale, out vector);
			return vector;
		}

		/// <summary>
		/// Divides a vector by a scalar.
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <param name="result">Result of the operation.</param>
		public static void Divide(ref Vector3 vector, float scale, out Vector3 result)
		{
			Multiply(ref vector, 1 / scale, out result);
		}

		/// <summary>
		/// Divides a vector by the components of a vector (scale).
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <returns>Result of the operation.</returns>
		public static Vector3 Divide(Vector3 vector, Vector3 scale)
		{
			Divide(ref vector, ref scale, out vector);
			return vector;
		}

		/// <summary>
		/// Divide a vector by the components of a vector (scale).
		/// </summary>
		/// <param name="vector">Left operand.</param>
		/// <param name="scale">Right operand.</param>
		/// <param name="result">Result of the operation.</param>
		public static void Divide(ref Vector3 vector, ref Vector3 scale, out Vector3 result)
		{
			result = new Vector3(vector.X / scale.X, vector.Y / scale.Y, vector.Z / scale.Z);
		}

		#endregion

		#region ComponentMin

		/// <summary>
		/// Calculate the component-wise minimum of two vectors
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <returns>The component-wise minimum</returns>
		public static Vector3 ComponentMin(Vector3 a, Vector3 b)
		{
			a.X = a.X < b.X ? a.X : b.X;
			a.Y = a.Y < b.Y ? a.Y : b.Y;
			a.Z = a.Z < b.Z ? a.Z : b.Z;
			return a;
		}

		/// <summary>
		/// Calculate the component-wise minimum of two vectors
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <param name="result">The component-wise minimum</param>
		public static void ComponentMin(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.X = a.X < b.X ? a.X : b.X;
			result.Y = a.Y < b.Y ? a.Y : b.Y;
			result.Z = a.Z < b.Z ? a.Z : b.Z;
		}

		#endregion

		#region ComponentMax

		/// <summary>
		/// Calculate the component-wise maximum of two vectors
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <returns>The component-wise maximum</returns>
		public static Vector3 ComponentMax(Vector3 a, Vector3 b)
		{
			a.X = a.X > b.X ? a.X : b.X;
			a.Y = a.Y > b.Y ? a.Y : b.Y;
			a.Z = a.Z > b.Z ? a.Z : b.Z;
			return a;
		}

		/// <summary>
		/// Calculate the component-wise maximum of two vectors
		/// </summary>
		/// <param name="a">First operand</param>
		/// <param name="b">Second operand</param>
		/// <param name="result">The component-wise maximum</param>
		public static void ComponentMax(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.X = a.X > b.X ? a.X : b.X;
			result.Y = a.Y > b.Y ? a.Y : b.Y;
			result.Z = a.Z > b.Z ? a.Z : b.Z;
		}

		#endregion

		#region Min

		/// <summary>
		/// Returns the Vector3 with the minimum magnitude
		/// </summary>
		/// <param name="left">Left operand</param>
		/// <param name="right">Right operand</param>
		/// <returns>The minimum Vector3</returns>
		public static Vector3 Min(Vector3 left, Vector3 right)
		{
			return left.LengthSquared() < right.LengthSquared() ? left : right;
		}

		#endregion

		#region Max

		/// <summary>
		/// Returns the Vector3 with the minimum magnitude
		/// </summary>
		/// <param name="left">Left operand</param>
		/// <param name="right">Right operand</param>
		/// <returns>The minimum Vector3</returns>
		public static Vector3 Max(Vector3 left, Vector3 right)
		{
			return left.LengthSquared() >= right.LengthSquared() ? left : right;
		}

		#endregion

		#region Clamp

		/// <summary>
		/// Clamp a vector to the given minimum and maximum vectors
		/// </summary>
		/// <param name="vec">Input vector</param>
		/// <param name="min">Minimum vector</param>
		/// <param name="max">Maximum vector</param>
		/// <returns>The clamped vector</returns>
		public static Vector3 Clamp(Vector3 vec, Vector3 min, Vector3 max)
		{
			vec.X = vec.X < min.X ? min.X : vec.X > max.X ? max.X : vec.X;
			vec.Y = vec.Y < min.Y ? min.Y : vec.Y > max.Y ? max.Y : vec.Y;
			vec.Z = vec.Z < min.Z ? min.Z : vec.Z > max.Z ? max.Z : vec.Z;
			return vec;
		}

		/// <summary>
		/// Clamp a vector to the given minimum and maximum vectors
		/// </summary>
		/// <param name="vec">Input vector</param>
		/// <param name="min">Minimum vector</param>
		/// <param name="max">Maximum vector</param>
		/// <param name="result">The clamped vector</param>
		public static void Clamp(ref Vector3 vec, ref Vector3 min, ref Vector3 max, out Vector3 result)
		{
			result.X = vec.X < min.X ? min.X : vec.X > max.X ? max.X : vec.X;
			result.Y = vec.Y < min.Y ? min.Y : vec.Y > max.Y ? max.Y : vec.Y;
			result.Z = vec.Z < min.Z ? min.Z : vec.Z > max.Z ? max.Z : vec.Z;
		}

		#endregion

		#region Normalize

		/// <summary>
		/// Scale a vector to unit length
		/// </summary>
		/// <param name="vec">The input vector</param>
		/// <returns>The normalized vector</returns>
		public static Vector3 Normalize(Vector3 vec)
		{
			float scale = 1.0f / vec.Length();
			vec.X *= scale;
			vec.Y *= scale;
			vec.Z *= scale;
			return vec;
		}

		/// <summary>
		/// Scale a vector to unit length
		/// </summary>
		/// <param name="vec">The input vector</param>
		/// <param name="result">The normalized vector</param>
		public static void Normalize(ref Vector3 vec, out Vector3 result)
		{
			float scale = 1.0f / vec.Length();
			result.X = vec.X * scale;
			result.Y = vec.Y * scale;
			result.Z = vec.Z * scale;
		}

		#endregion

		#region Dot

		/// <summary>
		/// Calculate the dot (scalar) product of two vectors
		/// </summary>
		/// <param name="left">First operand</param>
		/// <param name="right">Second operand</param>
		/// <returns>The dot product of the two inputs</returns>
		public static float Dot(Vector3 left, Vector3 right)
		{
			return left.X * right.X + left.Y * right.Y + left.Z * right.Z;
		}

		/// <summary>
		/// Calculate the dot (scalar) product of two vectors
		/// </summary>
		/// <param name="left">First operand</param>
		/// <param name="right">Second operand</param>
		/// <param name="result">The dot product of the two inputs</param>
		public static void Dot(ref Vector3 left, ref Vector3 right, out float result)
		{
			result = left.X * right.X + left.Y * right.Y + left.Z * right.Z;
		}

		#endregion

		#region Cross

		/// <summary>
		/// Caclulate the cross (vector) product of two vectors
		/// </summary>
		/// <param name="left">First operand</param>
		/// <param name="right">Second operand</param>
		/// <returns>The cross product of the two inputs</returns>
		public static Vector3 Cross(Vector3 left, Vector3 right)
		{
			Vector3 result;
			Cross(ref left, ref right, out result);
			return result;
		}

		/// <summary>
		/// Caclulate the cross (vector) product of two vectors
		/// </summary>
		/// <param name="left">First operand</param>
		/// <param name="right">Second operand</param>
		/// <returns>The cross product of the two inputs</returns>
		/// <param name="result">The cross product of the two inputs</param>
		public static void Cross(ref Vector3 left, ref Vector3 right, out Vector3 result)
		{
			result = new Vector3(left.Y * right.Z - left.Z * right.Y,
				left.Z * right.X - left.X * right.Z,
				left.X * right.Y - left.Y * right.X);
		}

		#endregion

		#region Lerp

		/// <summary>
		/// Returns a new Vector that is the linear blend of the 2 given Vectors
		/// </summary>
		/// <param name="a">First input vector</param>
		/// <param name="b">Second input vector</param>
		/// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
		/// <returns>a when blend=0, b when blend=1, and a linear combination otherwise</returns>
		public static Vector3 Lerp(Vector3 a, Vector3 b, float blend)
		{
			a.X = blend * (b.X - a.X) + a.X;
			a.Y = blend * (b.Y - a.Y) + a.Y;
			a.Z = blend * (b.Z - a.Z) + a.Z;
			return a;
		}

		/// <summary>
		/// Returns a new Vector that is the linear blend of the 2 given Vectors
		/// </summary>
		/// <param name="a">First input vector</param>
		/// <param name="b">Second input vector</param>
		/// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
		/// <param name="result">a when blend=0, b when blend=1, and a linear combination otherwise</param>
		public static void Lerp(ref Vector3 a, ref Vector3 b, float blend, out Vector3 result)
		{
			result.X = blend * (b.X - a.X) + a.X;
			result.Y = blend * (b.Y - a.Y) + a.Y;
			result.Z = blend * (b.Z - a.Z) + a.Z;
		}

		#endregion

		#region Barycentric

		/// <summary>
		/// Interpolate 3 Vectors using Barycentric coordinates
		/// </summary>
		/// <param name="a">First input Vector</param>
		/// <param name="b">Second input Vector</param>
		/// <param name="c">Third input Vector</param>
		/// <param name="u">First Barycentric Coordinate</param>
		/// <param name="v">Second Barycentric Coordinate</param>
		/// <returns>a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</returns>
		public static Vector3 BaryCentric(Vector3 a, Vector3 b, Vector3 c, float u, float v)
		{
			return a + u * (b - a) + v * (c - a);
		}

		/// <summary>Interpolate 3 Vectors using Barycentric coordinates</summary>
		/// <param name="a">First input Vector.</param>
		/// <param name="b">Second input Vector.</param>
		/// <param name="c">Third input Vector.</param>
		/// <param name="u">First Barycentric Coordinate.</param>
		/// <param name="v">Second Barycentric Coordinate.</param>
		/// <param name="result">Output Vector. a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</param>
		public static void BaryCentric(ref Vector3 a, ref Vector3 b, ref Vector3 c, float u, float v, out Vector3 result)
		{
			result = a; // copy

			Vector3 temp = b; // copy
			Subtract(ref temp, ref a, out temp);
			Multiply(ref temp, u, out temp);
			Add(ref result, ref temp, out result);

			temp = c; // copy
			Subtract(ref temp, ref a, out temp);
			Multiply(ref temp, v, out temp);
			Add(ref result, ref temp, out result);
		}

		#endregion

		#region CalculateAngle

		/// <summary>
		/// Calculates the angle (in radians) between two vectors.
		/// </summary>
		/// <param name="first">The first vector.</param>
		/// <param name="second">The second vector.</param>
		/// <returns>Angle (in radians) between the vectors.</returns>
		/// <remarks>Note that the returned angle is never bigger than the constant Pi.</remarks>
		public static float CalculateAngle(Vector3 first, Vector3 second)
		{
			return (float)System.Math.Acos((Vector3.Dot(first, second)) / (first.Length() * second.Length()));
		}

		/// <summary>Calculates the angle (in radians) between two vectors.</summary>
		/// <param name="first">The first vector.</param>
		/// <param name="second">The second vector.</param>
		/// <param name="result">Angle (in radians) between the vectors.</param>
		/// <remarks>Note that the returned angle is never bigger than the constant Pi.</remarks>
		public static void CalculateAngle(ref Vector3 first, ref Vector3 second, out float result)
		{
			float temp;
			Vector3.Dot(ref first, ref second, out temp);
			result = (float)System.Math.Acos(temp / (first.Length() * second.Length()));
		}

		#endregion

		#endregion

		#region Swizzle

		#region 3-component

		/// <summary>
		/// Gets or sets an OpenTK.Vector3 with the X, Z, and Y components of this instance.
		/// </summary>
		public Vector3 Xzy { get { return new Vector3(X, Z, Y); } set { X = value.X; Z = value.Y; Y = value.Z; } }

		/// <summary>
		/// Gets or sets an OpenTK.Vector3 with the Y, X, and Z components of this instance.
		/// </summary>
		public Vector3 Yxz { get { return new Vector3(Y, X, Z); } set { Y = value.X; X = value.Y; Z = value.Z; } }

		/// <summary>
		/// Gets or sets an OpenTK.Vector3 with the Y, Z, and X components of this instance.
		/// </summary>
		public Vector3 Yzx { get { return new Vector3(Y, Z, X); } set { Y = value.X; Z = value.Y; X = value.Z; } }

		/// <summary>
		/// Gets or sets an OpenTK.Vector3 with the Z, X, and Y components of this instance.
		/// </summary>
		public Vector3 Zxy { get { return new Vector3(Z, X, Y); } set { Z = value.X; X = value.Y; Y = value.Z; } }

		/// <summary>
		/// Gets or sets an OpenTK.Vector3 with the Z, Y, and X components of this instance.
		/// </summary>
		public Vector3 Zyx { get { return new Vector3(Z, Y, X); } set { Z = value.X; Y = value.Y; X = value.Z; } }

		#endregion

		#endregion

		#region Operators

		/// <summary>
		/// Adds two instances.
		/// </summary>
		/// <param name="left">The first instance.</param>
		/// <param name="right">The second instance.</param>
		/// <returns>The result of the calculation.</returns>
		public static Vector3 operator +(Vector3 left, Vector3 right)
		{
			left.X += right.X;
			left.Y += right.Y;
			left.Z += right.Z;
			return left;
		}

		/// <summary>
		/// Subtracts two instances.
		/// </summary>
		/// <param name="left">The first instance.</param>
		/// <param name="right">The second instance.</param>
		/// <returns>The result of the calculation.</returns>
		public static Vector3 operator -(Vector3 left, Vector3 right)
		{
			left.X -= right.X;
			left.Y -= right.Y;
			left.Z -= right.Z;
			return left;
		}

		/// <summary>
		/// Negates an instance.
		/// </summary>
		/// <param name="vec">The instance.</param>
		/// <returns>The result of the calculation.</returns>
		public static Vector3 operator -(Vector3 vec)
		{
			vec.X = -vec.X;
			vec.Y = -vec.Y;
			vec.Z = -vec.Z;
			return vec;
		}

		/// <summary>
		/// Multiplies an instance by a scalar.
		/// </summary>
		/// <param name="vec">The instance.</param>
		/// <param name="scale">The scalar.</param>
		/// <returns>The result of the calculation.</returns>
		public static Vector3 operator *(Vector3 vec, float scale)
		{
			vec.X *= scale;
			vec.Y *= scale;
			vec.Z *= scale;
			return vec;
		}

		/// <summary>
		/// Multiplies an instance by a scalar.
		/// </summary>
		/// <param name="scale">The scalar.</param>
		/// <param name="vec">The instance.</param>
		/// <returns>The result of the calculation.</returns>
		public static Vector3 operator *(float scale, Vector3 vec)
		{
			vec.X *= scale;
			vec.Y *= scale;
			vec.Z *= scale;
			return vec;
		}

		/// <summary>
		/// Component-wise multiplication between the specified instance by a scale vector.
		/// </summary>
		/// <param name="scale">Left operand.</param>
		/// <param name="vec">Right operand.</param>
		/// <returns>Result of multiplication.</returns>
		public static Vector3 operator *(Vector3 vec, Vector3 scale)
		{
			vec.X *= scale.X;
			vec.Y *= scale.Y;
			vec.Z *= scale.Z;
			return vec;
		}

		/// <summary>
		/// Divides an instance by a scalar.
		/// </summary>
		/// <param name="vec">The instance.</param>
		/// <param name="scale">The scalar.</param>
		/// <returns>The result of the calculation.</returns>
		public static Vector3 operator /(Vector3 vec, float scale)
		{
			float mult = 1.0f / scale;
			vec.X *= mult;
			vec.Y *= mult;
			vec.Z *= mult;
			return vec;
		}

		/// <summary>
		/// Compares two instances for equality.
		/// </summary>
		/// <param name="left">The first instance.</param>
		/// <param name="right">The second instance.</param>
		/// <returns>True, if left equals right; false otherwise.</returns>
		public static bool operator ==(Vector3 left, Vector3 right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Compares two instances for inequality.
		/// </summary>
		/// <param name="left">The first instance.</param>
		/// <param name="right">The second instance.</param>
		/// <returns>True, if left does not equa lright; false otherwise.</returns>
		public static bool operator !=(Vector3 left, Vector3 right)
		{
			return !left.Equals(right);
		}

		#endregion

		#region Overrides

		#region public override string ToString()

		private static string listSeparator = System.Globalization.CultureInfo.CurrentCulture.TextInfo.ListSeparator;
		/// <summary>
		/// Returns a System.String that represents the current Vector3.
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return String.Format("({0}{3} {1}{3} {2})", X, Y, Z, listSeparator);
		}

		#endregion

		#region public override int GetHashCode()

		/// <summary>
		/// Returns the hashcode for this instance.
		/// </summary>
		/// <returns>A System.Int32 containing the unique hashcode for this instance.</returns>
		public override int GetHashCode()
		{
			return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode();
		}

		#endregion

		#region public override bool Equals(object obj)

		/// <summary>
		/// Indicates whether this instance and a specified object are equal.
		/// </summary>
		/// <param name="obj">The object to compare to.</param>
		/// <returns>True if the instances are equal; false otherwise.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Vector3))
				return false;

			return this.Equals((Vector3)obj);
		}

		#endregion

		#endregion

		#endregion

		#region IEquatable<Vector3> Members

		/// <summary>Indicates whether the current vector is equal to another vector.</summary>
		/// <param name="other">A vector to compare with this vector.</param>
		/// <returns>true if the current vector is equal to the vector parameter; otherwise, false.</returns>
		public bool Equals(Vector3 other)
		{
			return
				X == other.X &&
				Y == other.Y &&
				Z == other.Z;
		}

		#endregion
	}
}

#endif
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Geometry\Vector3Extensions.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Geometry
{
	/// <summary>
	/// A class that provides extension methods to fix discrepancies between Vector3 implementations.
	/// </summary>
	internal static class Vector3Extensions
	{
#if OPENTK

		/// <summary>
		/// Gets the length of a <see cref="Vector3"/>.
		/// </summary>
		/// <param name="v">A vector.</param>
		/// <returns>The length of the vector.</returns>
		internal static float Length(this Vector3 v)
		{
			return v.Length;
		}

		/// <summary>
		/// Gets the squared length of a <see cref="Vector3"/>. This avoids the square root operation
		/// and is suitable for comparisons.
		/// </summary>
		/// <param name="v">A vector.</param>
		/// <returns>The length of the vector.</returns>
		internal static float LengthSquared(this Vector3 v)
		{
			return v.LengthSquared;
		}

#endif

#if UNITY3D
		internal static float Length(this Vector3 v)
		{
			return v.magnitude;
		}

		internal static float LengthSquared(this Vector3 v)
		{
			return v.sqrMagnitude;
		}
#endif

		/// <summary>
		/// Calculates the component-wise minimum of two vectors.
		/// </summary>
		/// <param name="left">A vector.</param>
		/// <param name="right">Another vector.</param>
		/// <param name="result">The component-wise minimum of the two vectors.</param>
		internal static void ComponentMin(ref Vector3 left, ref Vector3 right, out Vector3 result)
		{
#if OPENTK || STANDALONE
			Vector3.ComponentMin(ref left, ref right, out result);
#elif UNITY3D
			result = Vector3.Min(left, right);
#else
			result = Vector3.Min(left, right);
			//result = Vector3.Min(ref left, ref right);
#endif
		}

		/// <summary>
		/// Calculates the component-wise maximum of two vectors.
		/// </summary>
		/// <param name="left">A vector.</param>
		/// <param name="right">Another vector.</param>
		/// <param name="result">The component-wise maximum of the two vectors.</param>
		internal static void ComponentMax(ref Vector3 left, ref Vector3 right, out Vector3 result)
		{
#if OPENTK || STANDALONE
			Vector3.ComponentMax(ref left, ref right, out result);
#elif UNITY3D
			result = Vector3.Min(left, right);
#else
			result = Vector3.Min(left, right);
			//Vector3.Max(ref left, ref right, out result);
#endif
		}

		/// <summary>
		/// Calculates the distance between two points on the XZ plane.
		/// </summary>
		/// <param name="a">A point.</param>
		/// <param name="b">Another point.</param>
		/// <returns>The distance between the two points.</returns>
		internal static float Distance2D(Vector3 a, Vector3 b)
		{
			float result;
			Distance2D(ref a, ref b, out result);
			return result;
		}

		/// <summary>
		/// Calculates the distance between two points on the XZ plane.
		/// </summary>
		/// <param name="a">A point.</param>
		/// <param name="b">Another point.</param>
		/// <param name="dist">The distance between the two points.</param>
		internal static void Distance2D(ref Vector3 a, ref Vector3 b, out float dist)
		{
			float dx = b.X - a.X;
			float dz = b.Z - a.Z;
			dist = (float)Math.Sqrt(dx * dx + dz * dz);
		}

		/// <summary>
		/// Calculates the dot product of two vectors projected onto the XZ plane.
		/// </summary>
		/// <param name="left">A vector.</param>
		/// <param name="right">Another vector</param>
		/// <param name="result">The dot product of the two vectors.</param>
		internal static void Dot2D(ref Vector3 left, ref Vector3 right, out float result)
		{
			result = left.X * right.X + left.Z * right.Z;
		}

		/// <summary>
		/// Calculates the dot product of two vectors projected onto the XZ plane.
		/// </summary>
		/// <param name="left">A vector.</param>
		/// <param name="right">Another vector</param>
		/// <returns>The dot product</returns>
		internal static float Dot2D(ref Vector3 left, ref Vector3 right)
		{
			return left.X * right.X + left.Z * right.Z;
		}

		/// <summary>
		/// Calculates the cross product of two vectors (formed from three points)
		/// </summary>
		/// <param name="p1">The first point</param>
		/// <param name="p2">The second point</param>
		/// <param name="p3">The third point</param>
		/// <returns>The 2d cross product</returns>
		internal static float Cross2D(Vector3 p1, Vector3 p2, Vector3 p3)
		{
			float result;
			Cross2D(ref p1, ref p2, ref p3, out result);
			return result;
		}

		/// <summary>
		/// Calculates the cross product of two vectors (formed from three points)
		/// </summary>
		/// <param name="p1">The first point</param>
		/// <param name="p2">The second point</param>
		/// <param name="p3">The third point</param>
		/// <param name="result">The 2d cross product</param>
		internal static void Cross2D(ref Vector3 p1, ref Vector3 p2, ref Vector3 p3, out float result)
		{
			float u1 = p2.X - p1.X;
			float v1 = p2.Z - p1.Z;
			float u2 = p3.X - p1.X;
			float v2 = p3.Z - p1.Z;

			result = u1 * v2 - v1 * u2;
		}

		/// <summary>
		/// Calculates the perpendicular dot product of two vectors projected onto the XZ plane.
		/// </summary>
		/// <param name="a">A vector.</param>
		/// <param name="b">Another vector.</param>
		/// <param name="result">The perpendicular dot product on the XZ plane.</param>
		internal static void PerpDotXZ(ref Vector3 a, ref Vector3 b, out float result)
		{
			result = a.X * b.Z - a.Z * b.X;
		}

		internal static void CalculateSlopeAngle(ref Vector3 vec, out float angle)
		{
			Vector3 up = Vector3.UnitY;
			float dot;
			Vector3.Dot(ref vec, ref up, out dot);
			angle = (float)Math.Acos(dot);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\BoundarySide.cs:
 // Copyright (c) 2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// An enumeration of the different places a point can be relative to a rectangular boundary on the XZ plane.
	/// </summary>
	public enum BoundarySide : byte
	{
		/// <summary>
		/// Not outside of the defined boundary.
		/// </summary>
		Internal = 0xff,

		/// <summary>
		/// Only outside of the defined bondary on the X axis, in the positive direction.
		/// </summary>
		PlusX = 0,

		/// <summary>
		/// Outside of the defined boundary on both the X and Z axes, both in the positive direction.
		/// </summary>
		PlusXPlusZ = 1,

		/// <summary>
		/// Only outside of the defined bondary on the Z axis, in the positive direction.
		/// </summary>
		PlusZ = 2,

		/// <summary>
		/// Outside of the defined boundary on both the X and Z axes, in the negative and positive directions respectively.
		/// </summary>
		MinusXPlusZ = 3,

		/// <summary>
		/// Only outside of the defined bondary on the X axis, in the negative direction.
		/// </summary>
		MinusX = 4,

		/// <summary>
		/// Outside of the defined boundary on both the X and Z axes, both in the negative direction.
		/// </summary>
		MinusXMinusZ = 5,

		/// <summary>
		/// Only outside of the defined bondary on the Z axis, in the negative direction.
		/// </summary>
		MinusZ = 6,

		/// <summary>
		/// Outside of the defined boundary on both the X and Z axes, in the positive and negative directions respectively.
		/// </summary>
		PlusXMinusZ = 7
	}

	/// <summary>
	/// Extension methods for the <see cref="BoundarySide"/> enumeration.
	/// </summary>
	public static class BoundarySideExtensions
	{
		/// <summary>
		/// Gets the side in the exact opposite direction as a specified side.
		/// </summary>
		/// <remarks>
		/// The value <see cref="BoundarySide.Internal"/> will always return <see cref="BoundarySide.Internal"/>.
		/// </remarks>
		/// <param name="side">A side.</param>
		/// <returns>The opposite side.</returns>
		public static BoundarySide GetOpposite(this BoundarySide side)
		{
			if (side == BoundarySide.Internal)
				return BoundarySide.Internal;

			return (BoundarySide)((int)(side + 4) % 8);
		}

		/// <summary>
		/// Gets the boundary side of a point relative to a bounding box.
		/// </summary>
		/// <param name="pt">A point.</param>
		/// <param name="bounds">A bounding box.</param>
		/// <returns>The point's position relative to the bounding box.</returns>
		public static BoundarySide FromPoint(Vector3 pt, BBox3 bounds)
		{
			const int PlusX = 0x1;
			const int PlusZ = 0x2;
			const int MinusX = 0x4;
			const int MinusZ = 0x8;

			int outcode = 0;
			outcode |= (pt.X >= bounds.Max.X) ? PlusX : 0;
			outcode |= (pt.Z >= bounds.Max.Z) ? PlusZ : 0;
			outcode |= (pt.X < bounds.Min.X) ? MinusX : 0;
			outcode |= (pt.Z < bounds.Min.Z) ? MinusZ : 0;

			switch (outcode)
			{
				case PlusX:
					return BoundarySide.PlusX;

				case PlusX | PlusZ:
					return BoundarySide.PlusXPlusZ;

				case PlusZ:
					return BoundarySide.PlusZ;

				case MinusX | PlusZ:
					return BoundarySide.MinusXPlusZ;

				case MinusX:
					return BoundarySide.MinusX;

				case MinusX | MinusZ:
					return BoundarySide.MinusXMinusZ;

				case MinusZ:
					return BoundarySide.MinusZ;

				case PlusX | MinusZ:
					return BoundarySide.PlusXMinusZ;

				default:
					return BoundarySide.Internal;
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\Link.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// A link is formed between two polygons in a TiledNavMesh
	/// </summary>
	public class Link
	{
		/// <summary>
		/// Entity links to external entity.
		/// </summary>
		public const int External = unchecked((int)0x80000000);

		/// <summary>
		/// Doesn't link to anything.
		/// </summary>
		public const int Null = unchecked((int)0xffffffff);

		/// <summary>
		/// Gets or sets the neighbor reference (the one it's linked to)
		/// </summary>
		public int Reference { get; set; }

		/// <summary>
		/// Gets or sets the index of next link
		/// </summary>
		public int Next { get; set; }

		/// <summary>
		/// Gets or sets the index of polygon edge
		/// </summary>
		public int Edge { get; set; }

		/// <summary>
		/// Gets or sets the polygon side
		/// </summary>
		public BoundarySide Side { get; set; }

		/// <summary>
		/// Gets or sets the minimum Vector3 of the bounding box
		/// </summary>
		public int BMin { get; set; }

		/// <summary>
		/// Gets or sets the maximum Vector3 of the bounding box
		/// </summary>
		public int BMax { get; set; }
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\MeshTile.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using SharpNav.Collections;
using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// The MeshTile contains the map data for pathfinding
	/// </summary>
	public class MeshTile
	{
		/// <summary>
		/// Gets or sets the counter describing modifications to the tile
		/// </summary>
		public int Salt { get; set; }

		/// <summary>
		/// Gets or sets the index to the next free link
		/// </summary>
		public int LinksFreeList { get; set; }

		/// <summary>
		/// Gets or sets the header
		/// </summary>
		public PathfindingCommon.NavMeshInfo Header { get; set; }

		/// <summary>
		/// Gets or sets the PolyMesh polygons
		/// </summary>
		public Poly[] Polys { get; set; }

		/// <summary>
		/// Gets or sets the PolyMesh vertices
		/// </summary>
		public Vector3[] Verts { get; set; }

		/// <summary>
		/// Gets or sets the links between polygons
		/// </summary>
		public Link[] Links { get; set; }

		/// <summary>
		/// Gets or sets the PolyMeshDetail data
		/// </summary>
		public PolyMeshDetail.MeshData[] DetailMeshes { get; set; }

		/// <summary>
		/// Gets or sets the PolyMeshDetail vertices
		/// </summary>
		public Vector3[] DetailVerts { get; set; }

		/// <summary>
		/// Gets or sets the PolyMeshDetail triangles
		/// </summary>
		public PolyMeshDetail.TriangleData[] DetailTris { get; set; }

		/// <summary>
		/// Gets or sets the OffmeshConnections
		/// </summary>
		public OffMeshConnection[] OffMeshConnections { get; set; }

		/// <summary>
		/// Gets or sets the bounding volume tree
		/// </summary>
		public BVTree BVTree { get; set; }

		/// <summary>
		/// Gets or sets the NavMeshBuilder data
		/// </summary>
		public NavMeshBuilder Data { get; set; }

		/// <summary>
		/// Gets or sets the next MeshTile
		/// </summary>
		public MeshTile Next { get; set; }

		/// <summary>
		/// Given a point, find the closest point on that poly.
		/// </summary>
		/// <param name="poly">The current polygon.</param>
		/// <param name="pos">The current position</param>
		/// <param name="closest">Reference to the closest point</param>
		public void ClosestPointOnPoly(Poly poly, Vector3 pos, ref Vector3 closest)
		{
			int indexPoly = 0;
			for (int i = 0; i < Polys.Length; i++)
			{
				if (Polys[i] == poly)
				{
					indexPoly = i;
					break;
				}
			}

			ClosestPointOnPoly(indexPoly, pos, ref closest);
		}

		/// <summary>
		/// Given a point, find the closest point on that poly.
		/// </summary>
		/// <param name="indexPoly">The current poly's index</param>
		/// <param name="pos">The current position</param>
		/// <param name="closest">Reference to the closest point</param>
		public void ClosestPointOnPoly(int indexPoly, Vector3 pos, ref Vector3 closest)
		{
			Poly poly = Polys[indexPoly];

			//Off-mesh connections don't have detail polygons
			if (Polys[indexPoly].PolyType == PolygonType.OffMeshConnection)
			{
				ClosestPointOnPolyOffMeshConnection(poly, pos, out closest);
				return;
			}

			ClosestPointOnPolyBoundary(poly, pos, out closest);

			float h;
			if (ClosestHeight(indexPoly, pos, out h))
				closest.Y = h;
		}

		/// <summary>
		/// Given a point, find the closest point on that poly.
		/// </summary>
		/// <param name="poly">The current polygon.</param>
		/// <param name="pos">The current position</param>
		/// <param name="closest">Reference to the closest point</param>
		public void ClosestPointOnPolyBoundary(Poly poly, Vector3 pos, out Vector3 closest)
		{
			//Clamp point to be inside the polygon
			Vector3[] verts = new Vector3[PathfindingCommon.VERTS_PER_POLYGON];
			float[] edgeDistance = new float[PathfindingCommon.VERTS_PER_POLYGON];
			float[] edgeT = new float[PathfindingCommon.VERTS_PER_POLYGON];
			int numPolyVerts = poly.VertCount;
			for (int i = 0; i < numPolyVerts; i++)
				verts[i] = Verts[poly.Verts[i]];

			bool inside = Distance.PointToPolygonEdgeSquared(pos, verts, numPolyVerts, edgeDistance, edgeT);
			if (inside)
			{
				//Point is inside the polygon
				closest = pos;
			}
			else
			{
				//Point is outside the polygon
				//Clamp to nearest edge
				float minDistance = float.MaxValue;
				int minIndex = -1;
				for (int i = 0; i < numPolyVerts; i++)
				{
					if (edgeDistance[i] < minDistance)
					{
						minDistance = edgeDistance[i];
						minIndex = i;
					}
				}

				Vector3 va = verts[minIndex];
				Vector3 vb = verts[(minIndex + 1) % numPolyVerts];
				closest = Vector3.Lerp(va, vb, edgeT[minIndex]);
			}
		}

		/// <summary>
		/// Find the distance from a point to a triangle.
		/// </summary>
		/// <param name="indexPoly">Current polygon's index</param>
		/// <param name="pos">Current position</param>
		/// <param name="h">Resulting height</param>
		/// <returns>True, if a height is found. False, if otherwise.</returns>
		public bool ClosestHeight(int indexPoly, Vector3 pos, out float h)
		{
			Poly poly = Polys[indexPoly];
			PolyMeshDetail.MeshData pd = DetailMeshes[indexPoly];

			//find height at the location
			for (int j = 0; j < DetailMeshes[indexPoly].TriangleCount; j++)
			{
				PolyMeshDetail.TriangleData t = DetailTris[pd.TriangleIndex + j];
				Vector3[] v = new Vector3[3];

				for (int k = 0; k < 3; k++)
				{
					if (t[k] < poly.VertCount)
						v[k] = Verts[poly.Verts[t[k]]];
					else
						v[k] = DetailVerts[pd.VertexIndex + (t[k] - poly.VertCount)];
				}

				if (Distance.PointToTriangle(pos, v[0], v[1], v[2], out h))
					return true;
			}

			h = float.MaxValue;
			return false;
		}

		/// <summary>
		/// Find the closest point on an offmesh connection, which is in between the two points.
		/// </summary>
		/// <param name="poly">Current polygon</param>
		/// <param name="pos">Current position</param>
		/// <param name="closest">Resulting point that is closest.</param>
		public void ClosestPointOnPolyOffMeshConnection(Poly poly, Vector3 pos, out Vector3 closest)
		{
			Vector3 v0 = Verts[poly.Verts[0]];
			Vector3 v1 = Verts[poly.Verts[1]];
			float d0 = (pos - v0).Length();
			float d1 = (pos - v1).Length();
			float u = d0 / (d0 + d1);
			closest = Vector3.Lerp(v0, v1, u);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\NavPoint.cs:
 // Copyright (c) 2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Runtime.InteropServices;

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// A point in a navigation mesh.
	/// </summary>
	[Serializable]
	[StructLayout(LayoutKind.Sequential)]
	public struct NavPoint
	{
		/// <summary>
		/// A null point that isn't associated with any polygon.
		/// </summary>
		public static readonly NavPoint Null = new NavPoint(0, Vector3.Zero);

		/// <summary>
		/// A reference to the polygon this point is on.
		/// </summary>
		public int Polygon;

		/// <summary>
		/// The 3d position of the point.
		/// </summary>
		public Vector3 Position;

		/// <summary>
		/// Initializes a new instance of the <see cref="NavPoint"/> struct.
		/// </summary>
		/// <param name="poly">The polygon that the point is on.</param>
		/// <param name="pos">The 3d position of the point.</param>
		public NavPoint(int poly, Vector3 pos)
		{
			this.Polygon = poly;
			this.Position = pos;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\OffMeshConnection.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// A set of flags that define properties about an off-mesh connection.
	/// </summary>
	[Flags]
	public enum OffMeshConnectionFlags : byte
	{
		/// <summary>
		/// No flags.
		/// </summary>
		None = 0x0,

		/// <summary>
		/// The connection is bi-directional.
		/// </summary>
		Bidirectional = 0x1
	}

	/// <summary>
	/// An offmesh connection links two polygons, which are not directly adjacent, but are accessibly through
	/// other means (jumping, climbing, etc...).
	/// </summary>
	public class OffMeshConnection
	{
		/// <summary>
		/// Gets or sets the first endpoint of the connection
		/// </summary>
		public Vector3 Pos0 { get; set; } 

		/// <summary>
		/// Gets or sets the second endpoint of the connection
		/// </summary>
		public Vector3 Pos1 { get; set; }

		/// <summary>
		/// Gets or sets the radius
		/// </summary>
		public float Radius { get; set; }

		/// <summary>
		/// Gets or sets the polygon's index
		/// </summary>
		public int Poly { get; set; }

		/// <summary>
		/// Gets or sets the polygon flag
		/// </summary>
		public OffMeshConnectionFlags Flags { get; set; }

		/// <summary>
		/// Gets or sets the endpoint's side
		/// </summary>
		public BoundarySide Side { get; set; } 

		/// <summary>
		/// Gets or sets user data for this connection.
		/// </summary>
		public object Tag { get; set; }
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\PathBuildFlags.cs:
 // Copyright (c) 2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// Flags for choosing how the path is built.
	/// </summary>
	[Flags]
	public enum PathBuildFlags
	{
		/// <summary>
		/// Build normally.
		/// </summary>
		None = 0x00,

		/// <summary>
		/// Adds a vertex to the path at each polygon edge crossing, but only when the areas of the two polygons are
		/// different
		/// </summary>
		AreaCrossingVertices = 0x01,

		/// <summary>
		/// Adds a vertex to the path at each polygon edge crossing.
		/// </summary>
		AllCrossingVertices = 0x02
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\PathfindingCommon.cs:
 // Copyright (c) 2013-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// Store constants, structs, methods in this single class so that other classes can access this information.
	/// </summary>
	public class PathfindingCommon
	{
		public const int VERTS_PER_POLYGON = 6; //max number of vertices

		public const int STRAIGHTPATH_START = 0x01; //vertex is in start position of path
		public const int STRAIGHTPATH_END = 0x02; //vertex is in end position of path
		public const int STRAIGHTPATH_OFFMESH_CONNECTION = 0x04; //vertex is at start of an off-mesh connection

		/// <summary>
		/// Generate an accurate sample of random points in the convex polygon and pick a point.
		/// </summary>
		/// <param name="pts">The polygon's points data</param>
		/// <param name="npts">The number of points</param>
		/// <param name="areas">The triangle areas</param>
		/// <param name="s">A random float</param>
		/// <param name="t">Another random float</param>
		/// <param name="pt">The resulting point</param>
		public static void RandomPointInConvexPoly(Vector3[] pts, int npts, float[] areas, float s, float t, out Vector3 pt)
		{
			//Calculate triangle areas
			float areaSum = 0.0f;
			float area;
			for (int i = 2; i < npts; i++)
			{
				Triangle3.Area2D(ref pts[0], ref pts[i - 1], ref pts[i], out area);
				areaSum += Math.Max(0.001f, area);
				areas[i] = area;
			}

			//Find sub triangle weighted by area
			float threshold = s * areaSum;
			float accumulatedArea = 0.0f;
			float u = 0.0f;
			int triangleVertex = 0;
			for (int i = 2; i < npts; i++)
			{
				float currentArea = areas[i];
				if (threshold >= accumulatedArea && threshold < (accumulatedArea + currentArea))
				{
					u = (threshold - accumulatedArea) / currentArea;
					triangleVertex = i;
					break;
				}

				accumulatedArea += currentArea;
			}

			float v = (float)Math.Sqrt(t);

			float a = 1 - v;
			float b = (1 - u) * v;
			float c = u * v;
			Vector3 pointA = pts[0];
			Vector3 pointB = pts[triangleVertex - 1];
			Vector3 pointC = pts[triangleVertex];

			pt = a * pointA + b * pointB + c * pointC;
		}

		/// <summary>
		/// Contains information about a navigation mesh
		/// </summary>
		public class NavMeshInfo
		{
			public int X;
			public int Y;
			public int Layer;
			public int PolyCount;
			public int VertCount;
			public int MaxLinkCount;

			public int DetailMeshCount;
			public int DetailVertCount;
			public int DetailTriCount;

			public int BvNodeCount;

			public int OffMeshConCount;
			public int OffMeshBase; //index of first polygon which is off-mesh connection

			public float WalkableHeight;
			public float WalkableRadius;
			public float WalkableClimb;
			public BBox3 Bounds;
			public float BvQuantFactor;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\Poly.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// Uses the PolyMesh polygon data for pathfinding
	/// </summary>
	public class Poly
	{
		/// <summary>
		/// Polygon type
		/// </summary>
		private PolygonType polyType;

		/// <summary>
		/// Gets or sets the index to first link in linked list
		/// </summary>
		public int FirstLink { get; set; }

		/// <summary>
		/// Gets or sets the indices of polygon's vertices
		/// </summary>
		public int[] Verts { get; set; }

		/// <summary>
		/// Gets or sets packed data representing neighbor polygons references and flags for each edge
		/// </summary>
		public int[] Neis { get; set; }

		//TODO turn flags into a Tag object, which is more standard for C#

		/// <summary>
		/// Gets or sets a user defined polygon flags
		/// </summary>
		public int Flags { get; set; }

		/// <summary>
		/// Gets or sets the number of vertices
		/// </summary>
		public int VertCount { get; set; }

		/// <summary>
		/// Gets or sets the AreaId
		/// </summary>
		public Area Area { get; set; }

		/// <summary>
		/// Gets or sets the polygon type (ground or offmesh)
		/// </summary>
		public PolygonType PolyType
		{
			get
			{
				return polyType;
			}

			set
			{
				polyType = value;
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Pathfinding\PolygonType.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;

namespace SharpNav.Pathfinding
{
	/// <summary>
	/// Flags representing the type of a navmesh polygon.
	/// </summary>
	[Flags]
	public enum PolygonType : byte
	{
		/// <summary>A polygon that is part of the navmesh.</summary>
		Ground = 0,

		/// <summary>An off-mesh connection consisting of two vertices.</summary>
		OffMeshConnection = 1
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\LaunchPadWindow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.UI.Impl.UnityEditor;

namespace DungeonArchitect.Editors.LaunchPad
{
    public class LaunchPadWindow : EditorWindow
    {
        [MenuItem("Dungeon Architect/Launch Pad", priority = 1000)]
        public static void OpenWindow_LaunchPad()
        {
            LaunchPadWindow.OpenWindow();
        }

        class BreadCrumbUserData
        {
            public BreadCrumbUserData(ScreenPage page)
            {
                this.page = page;
                this.scrollPos = Vector2.zero;
            }

            public ScreenPage page;
            public Vector2 scrollPos = Vector2.zero;
        }

        UISystem uiSystem;
        UIRenderer renderer;
        Color backgroundColor = new Color(0.1f, 0.1f, 0.1f);
        BreadCrumbWidget breadCrumb;
        PanelWidget pageHost;
        ScrollPanelWidget pageScroller;
        ListViewWidget<LaunchPadCategoryData> categoryListView;

        public static void OpenWindow()
        {
            LaunchPadWindow window = EditorWindow.GetWindow(typeof(LaunchPadWindow)) as LaunchPadWindow;
            window.Init();
            window.Show(); 
        }

        public void Init()
        {
            titleContent = new GUIContent("Dungeon Architect - Launch Pad");
            CreateUISystem();
        }

        void CreateUISystem()
        {
            uiSystem = new UnityEditorUISystem();
            renderer = new UnityEditorUIRenderer();
            BuildLayout();
        }

        [System.Serializable]
        class SidebarDataEntry
        {
            public string page = "";
            public string title = "";
        }

        [System.Serializable]
        class SidebarData
        {
            public SidebarDataEntry[] items = new SidebarDataEntry[0];
        }

        IWidget CreateReviewWidget()
        {
            var color = 0.5f;
            var link = new LinkWidget(
                new LabelWidget("Leave a review")
                    .SetColor(new Color(color, color, color))
                    .SetFontSize(14)
                    .SetTextAlign(TextAnchor.MiddleCenter))
                .SetDrawLinkOutline(false);

            link.LinkClicked += LeaveReviewLinkClicked;

            return link;
        }

        private void LeaveReviewLinkClicked(WidgetClickEvent clickEvent)
        {
            string assetStoreURL = "https://u3d.as/nAL";
            Application.OpenURL(assetStoreURL);
        }

        void OnInspectorUpdate()
        {
            if (categoryDataSource != null && categoryDataSource.Count == 0)
            {
                LoadCategories();
                if (categoryDataSource.Count > 0)
                {
                    categoryListView.Bind(categoryDataSource);
                    
                    var categories = categoryDataSource.GetItems();
                    if (categories != null && categories.Length > 0)
                    {
                        ShowRootPage(categories[0].path);
                        requestRepaint = true;
                    }
                }
            }
        }

        private LaunchPadCategoryDataSource categoryDataSource = new LaunchPadCategoryDataSource();
        
        void LoadCategories()
        {
            var categories = new List<LaunchPadCategoryData>();
            var datafilePath = "LaunchPad/sidebar";
            var sidebarDataAsset = Resources.Load<TextAsset>(datafilePath);
            if (sidebarDataAsset != null)
            {
                var sidebarData = JsonUtility.FromJson<SidebarData>(sidebarDataAsset.text);
                if (sidebarData != null)
                {
                    foreach (var item in sidebarData.items)
                    {
                        categories.Add(new LaunchPadCategoryData(item.page, item.title));
                    }
                }
            }
            categoryDataSource.SetItems(categories.ToArray());
        }
        
        IWidget BuildCategoriesListView()
        {
            LoadCategories();

            categoryListView = new ListViewWidget<LaunchPadCategoryData>();
            categoryListView.ItemHeight = 45;
            categoryListView.backgroundColor = new Color(0.1f, 0.1f, 0.1f);
            categoryListView.Bind(categoryDataSource);
            categoryListView.ItemClicked += OnCategoryItemClicked;
            categoryListView.SelectionChanged += OnCategoryItemClicked;


            var reviewWidget = CreateReviewWidget();

            IWidget content = categoryListView;

            // Add asset store award widget
            {
                // Add asset store award logo
                var awardImage = ScreenPageLoader.LoadImageAsset("misc/UnityAwards16_seal-AssetStore_small");
                var awardImageColor = new Color(1, 1, 1, 0.5f);
                var listViewSize = categoryListView.GetDesiredSize(Vector2.zero, uiSystem);
                var heightOffset = listViewSize.y;

                content = new OverlayPanelWidget()
                    .AddWidget(content)
                    .AddWidget(
                        new StackPanelWidget(StackPanelOrientation.Horizontal)
                        .AddWidget(new NullWidget())
                        .AddWidget(
                            new StackPanelWidget(StackPanelOrientation.Vertical)
                            .AddWidget(new NullWidget(), heightOffset)
                            .AddWidget(
                                new BorderWidget(
                                    new ImageWidget(awardImage)
                                    .SetTint(awardImageColor)
                                    .SetDrawMode(ImageWidgetDrawMode.Fixed))
                                .SetTransparent()
                                .SetPadding(0, 10, 0, 0)
                            , 0, true)
                            .AddWidget(new NullWidget())
                            .AddWidget(reviewWidget, 24)
                        , 0, true)
                        .AddWidget(new NullWidget()));
            }
            return content;
        }

        private void OnCategoryItemClicked(LaunchPadCategoryData item)
        {
            ShowRootPage(item.path);
        }

        IWidget BuildContentWidget()
        {
            breadCrumb = new BreadCrumbWidget();
            breadCrumb.LinkClicked += BreadCrumb_LinkClicked;
            breadCrumb.FontSize = 14;
            breadCrumb.TextColor = new Color(0.5f, 0.5f, 0.5f);

            pageHost = new PanelWidget(new NullWidget());
            pageScroller = new ScrollPanelWidget(pageHost);
            var body = new BorderWidget(pageScroller)
                .SetColor(new Color(0.2f, 0.2f, 0.2f))
                .SetBorderColor(new Color(0, 0, 0, 0))
                .SetPadding(0, 0, 0, 0);

            var content = new StackPanelWidget(StackPanelOrientation.Vertical)
                .AddWidget(
                    new BorderWidget(
                        new BorderWidget(breadCrumb)
                            .SetPadding(5, 5, 5, 5)
                            .SetBorderColor(new Color(0.1f, 0.1f, 0.1f))
                            .SetColor(new Color(0.15f, 0.15f, 0.15f)))
                        .SetPadding(10, 10, 10, 10)
                        .SetBorderColor(new Color(0, 0, 0, 0))
                        .SetColor(new Color(0.2f, 0.2f, 0.2f))
                    , 0, true)
                .AddWidget(body);

            return content;
        }

        void PushPage(string path)
        {
            var page = ScreenPageLoader.LoadPage(path);
            if (page != null)
            {
                var scrollPos = (pageScroller != null) ? pageScroller.ScrollPosition : Vector2.zero;
                var topItemData = breadCrumb.GetTopItemUserData() as BreadCrumbUserData;
                topItemData.scrollPos = scrollPos;

                breadCrumb.PushPage(page.Title, new BreadCrumbUserData(page));

                pageHost.SetContent(page.Widget);
            }
        }

        void ShowRootPage(string path)
        {
            var page = ScreenPageLoader.LoadPage(path);
            if (page != null)
            {
                page.LinkClicked += OnPageLinkClicked;
                pageHost.SetContent(page.Widget);
                breadCrumb.Clear();
                breadCrumb.PushPage(page.Title, new BreadCrumbUserData(page));
            }
            else
            {
                pageHost.SetContent(new NullWidget());
                breadCrumb.Clear();
            }
        }

        private void OnPageLinkClicked(string path)
        {
            PushPage(path);
        }

        private void BreadCrumb_LinkClicked(object userdata)
        {
            var navData = userdata as BreadCrumbUserData;
            if (navData != null && navData.page != null)
            {
                pageHost.SetContent(navData.page.Widget);
                if (pageScroller != null)
                {
                    pageScroller.ScrollPosition = navData.scrollPos;
                }
            }
        }

        IWidget CreateBrandingWidget()
        {
            string label = "DUNGEON ARCHITECT - LAUNCH PAD";
            var padding = 4;
            var branding = new BorderWidget(
                new LabelWidget(label)
                    .SetFontSize(14)
                    .SetTextAlign(TextAnchor.MiddleCenter)
                    .SetColor(new Color(0.75f, 0.75f, 0.75f)))
                .SetPadding(padding, padding, padding, 0)
                .SetColor(new Color(0.1f, 0.1f, 0.1f))
                .SetBorderColor(new Color(0, 0, 0, 0));

            return branding;
        }

        void BuildLayout()
        {
            var categories = BuildCategoriesListView();
            var content = BuildContentWidget();

            categoryListView.SetSelectedIndex(0);

            IWidget layout =
                new BorderWidget()
                .SetColor(backgroundColor)
                .SetBorderColor(new Color(0, 0, 0, 0))
                .SetPadding(5, 5, 6, 6)
                .SetContent(
                    new StackPanelWidget(StackPanelOrientation.Horizontal)
                        .AddWidget(categories, 200)
                        .AddWidget(content));

            layout = new StackPanelWidget(StackPanelOrientation.Vertical)
                .AddWidget(CreateBrandingWidget(), 0, true)
                .AddWidget(layout);

            uiSystem.SetLayout(layout);
        }
        
        private bool requestRepaint = false;

        void Update()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }
            
            
            if (requestRepaint)
            {
                Repaint();
                requestRepaint = false;
            }
            
        }
        
        private void OnGUI()
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (uiSystem.Layout == null)
            {
                BuildLayout();
            }

            var bounds = new Rect(Vector2.zero, position.size);
            uiSystem.Update(bounds);
            
            uiSystem.Draw(renderer);
            
            var e = Event.current;
            if (e.isScrollWheel)
            {
                requestRepaint = true;
            }

            switch (e.type)
            {
                case EventType.MouseMove:
                case EventType.MouseDrag:
                case EventType.MouseDown:
                case EventType.MouseUp:
                case EventType.KeyDown:
                case EventType.KeyUp:
                case EventType.MouseEnterWindow:
                case EventType.MouseLeaveWindow:
                    requestRepaint = true;
                    break;
            }
            
            HandleInput(e);
        }

        void HandleInput(Event e)
        {
            if (uiSystem == null || renderer == null)
            {
                CreateUISystem();
            }

            if (uiSystem != null && uiSystem.Layout != null)
            {
                var layout = uiSystem.Layout;
                if (e.type == EventType.MouseDown || e.type == EventType.ScrollWheel)
                {
                    WidgetUtils.ProcessInputFocus(e.mousePosition, uiSystem, layout);
                }

                if (uiSystem.IsDragDrop)
                {
                    WidgetUtils.ProcessDragOperation(e, layout, uiSystem);
                }

                UpdateDragDropState(e);

                WidgetUtils.HandleWidgetInput(uiSystem, e, e.mousePosition, layout);
            }

        }

        void UpdateDragDropState(Event e)
        {
            if (uiSystem != null)
            {
                if (e.type == EventType.DragUpdated)
                {
                    uiSystem.SetDragging(true);
                }
                else if (e.type == EventType.DragPerform || e.type == EventType.DragExited)
                {
                    uiSystem.SetDragging(false);
                }
            }
        }
    }

    public class LaunchPadWindowImportLauncher : AssetPostprocessor
    {
        static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
        {
            bool launchWindow = false;
            foreach (var asset in importedAssets)
            {
                if (asset.Contains("DungeonArchitect_LaunchPad"))
                {
                    if (asset.Contains("sidebar.json") || asset.Contains("builder_templates.json"))
                    {
                        launchWindow = true;
                        break;
                    }
                }
            }

            if (launchWindow)
            {
                LaunchPadWindow.OpenWindow();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Extra\DemoBuilder_GridFlow_CustomPlacement\CenterGridFlowPlacement.cs:
 using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Flow.Items;
using UnityEngine;

public class CenterGridFlowPlacement : ScriptableObject, ITilemapItemPlacementStrategy
{
    
    public bool PlaceItems(FlowItem item, FlowTilemapCell[] freeCells, TilemapItemPlacementSettings settings, TilemapItemPlacementStrategyContext context,
        ref int outFreeTileIndex, ref string errorMessage)
    {
        var chunkTiles = context.chunkTiles;
        if (freeCells.Length == 0 || chunkTiles.Length == 0)
        {
            outFreeTileIndex = -1;
            errorMessage = "No free tiles";
            return false;
        }

        var min = chunkTiles[0].TileCoord;
        var max =  chunkTiles[0].TileCoord;
        
        // find the bounds of the free cells
        foreach (var cell in chunkTiles)
        {
            min.x = Mathf.Min(cell.TileCoord.x, min.x);
            min.y = Mathf.Min(cell.TileCoord.y, min.y);
            max.x = Mathf.Max(cell.TileCoord.x, max.x);
            max.y = Mathf.Max(cell.TileCoord.y, max.y);
        }

        // Find the center of these bounds
        var center = new Vector2(
            (min.x + max.x) * 0.5f,
            (min.y + max.y) * 0.5f);

        // Find a free cell that is closest to the center
        float bestDistanceSq = float.MaxValue;
        int bestIndex = -1;
        for (int i = 0; i < freeCells.Length; i++)
        {
            var cell = freeCells[i];
            var coord = new Vector2(cell.TileCoord.x, cell.TileCoord.y);
            var distSq = (coord - center).sqrMagnitude;
            if (distSq < bestDistanceSq)
            {
                bestDistanceSq = distSq;
                bestIndex = i;
            }
        }

        outFreeTileIndex = bestIndex;
        return true;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\CustomPaths\CustomMainPathConstraints.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections;
using System.Collections.Generic;
using DungeonArchitect;
using UnityEngine;

namespace DungeonArchitect.Samples
{
    public class CustomMainPathConstraints : ScriptableObject, IGridFlowLayoutNodePositionConstraint
    {
        public bool CanCreateNodeAt(int currentPathPosition, int totalPathLength, Vector2Int nodeCoord, Vector2Int gridSize)
        {
            return nodeCoord.x == 0 ||
                   nodeCoord.y == 0 ||
                   nodeCoord.x == gridSize.x - 1 ||
                   nodeCoord.y == gridSize.y - 1;
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\CustomPaths\CustomPathConstraintsA.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections;
using System.Collections.Generic;
using DungeonArchitect;
using UnityEngine;

namespace DungeonArchitect.Samples
{
    public class CustomPathConstraintsA : ScriptableObject, IGridFlowLayoutNodePositionConstraint
    {
        public bool CanCreateNodeAt(int currentPathPosition, int totalPathLength, Vector2Int nodeCoord, Vector2Int gridSize)
        {
            return nodeCoord.x == 1 ||
                   nodeCoord.y == 1 ||
                   nodeCoord.x == gridSize.x - 2 ||
                   nodeCoord.y == gridSize.y - 2;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\DemoGame\GridFlowGameController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Builders.GridFlow;
using UnityEngine;


namespace DungeonArchitect.Samples.GridFlow
{
    public class GridFlowGameController : MonoBehaviour
    {
        public Dungeon dungeon;
        // Start is called before the first frame update
        void Start()
        {
            // Randomize and build the dungeon
            if (dungeon != null)
            {
                var dungeonConfig = dungeon.GetComponent<GridFlowDungeonConfig>();
                var random = new System.Random();
                dungeonConfig.Seed = (uint)random.Next();
                dungeon.Build();
            }
        }

        // Update is called once per frame
        void Update()
        {

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\DemoGame\GridFlowPlayerController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.GridFlow
{
    public class GridFlowPlayerController : MonoBehaviour
    {

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\ThemeRules\RandomTreeTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;


namespace DungeonArchitect.Samples.GridFlow
{
    public class RandomTreeTransformRule : TransformationRule
    {
        public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale)
        {
            base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);

            // Random rotation
            var angle = random.value() * 360;
            var rotation = Quaternion.Euler(0, angle, 0);
            outRotation = rotation;

            // Random position
            var maxJitterDistance = 0.25f;
            var jitterDistance = random.NextFloat() * maxJitterDistance;
            var jitterAngle = random.NextFloat() * Mathf.PI * 2;
            var jitter = new Vector3(Mathf.Cos(jitterAngle), 0, Mathf.Sin(jitterAngle)) * maxJitterDistance;
            outPosition += jitter;
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow2D\Scripts\Rules\RestoreRotationTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.GridFlow
{
    public class RestoreRotationTransformRule : TransformationRule
    {
        public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale)
        {
            base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);
            var rotation = socket.Transform.rotation;
            outRotation = Quaternion.Inverse(rotation);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_SnapGridFlow_Simple\ExtraExamples\HideOtherFloors\SGFHideOtherFloors.cs:
 using System.Collections;
using System.Collections.Generic;
using DungeonArchitect.Builders.SnapGridFlow;
using DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D;
using DungeonArchitect.Samples.ShooterGame;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Samples.SnapGridFlow
{
    public enum SGFHideFloorMode
    {
        HideAboveAndBelow,
        HideAbove,
        HideBelow,
        None,
    }
    
    public class SGFHideOtherFloors : DungeonEventListener
    {
        public SGFHideFloorMode hideMode = SGFHideFloorMode.HideAboveAndBelow;
        
        [Tooltip("offset to apply on the distance check from the player's Y position, when purging rooms above the player")]
        public float distanceThresholdBelow = 0;
        
        [Tooltip("offset to apply on the distance check from the player's Y position, when purging rooms above the player")]
        public float distanceThresholdAbove = 0;

        [Tooltip("How often should the test be run (in seconds)")]
        public float updateFrequency = 0.2f;

        
        [Tooltip("Set this to true if you want to automatically find the player object after the dungeon is built. Make sure you player prefab is tagged as 'Player'")]
        public bool autoFindPlayerObject = true;
        
        [Tooltip("The game object to track.  Leave this blank if you have set the above flag to true")]
        public Transform playerObject;
        
        void Start()
        {
            InvokeRepeating("HideFloors", 0, updateFrequency);
        }

        void HideFloors()
        {
            if (playerObject == null) return;
            float playerY = playerObject.position.y;

            var model = GetComponent<SnapGridFlowModel>();
            foreach (var moduleNode in model.snapModules)
            {
                // Grab the world bounds of the module
                var worldBounds = moduleNode.GetModuleBounds();
                
                // Test if we need to hide it
                float moduleLowest = worldBounds.center.y - worldBounds.extents.y;
                float moduleHighest = worldBounds.center.y + worldBounds.extents.y;

                bool belowPlayer = playerY > moduleHighest;
                bool abovePlayer = playerY < moduleLowest;

                bool shouldHide = false;
                if (hideMode == SGFHideFloorMode.HideAboveAndBelow)
                {
                    shouldHide = belowPlayer || abovePlayer;
                } 
                else if (hideMode == SGFHideFloorMode.HideAbove)
                {
                    shouldHide = abovePlayer;
                } 
                else if (hideMode == SGFHideFloorMode.HideAbove)
                {
                    shouldHide = belowPlayer;
                }
                else if (hideMode == SGFHideFloorMode.None)
                {
                    shouldHide = false;
                }

                moduleNode.SpawnedModule.gameObject.SetActive(!shouldHide);
            }
        }

        
        /// <summary>
        /// Find the player object, if we need automatic detection
        /// </summary>
        /// <param name="dungeon"></param>
        /// <param name="model"></param>
        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            if (autoFindPlayerObject)
            {
                playerObject = null;
                var player = GameObject.FindWithTag(GameTags.Player);
                if (player != null)
                {
                    playerObject = player.transform;
                }
                else
                {
                    Debug.LogError("Hide Floor Script: No Player object found. Make sure your player prefab is tagged as 'Player'");
                }
            }
        }

        /// <summary>
        /// Clear the player object if we have automatic detection
        /// </summary>
        /// <param name="dungeon"></param>
        public override void OnDungeonDestroyed(Dungeon dungeon)
        {
            if (autoFindPlayerObject)
            {
                playerObject = null;
            }
        }
    }
}

 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_Snap_Extras\Snap_Marker_Support\Scripts\SnapCustomMarker.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Samples.Snap
{
    public class SnapCustomMarker : MonoBehaviour
    {
        public string markerName = "MyMarker";
        private GUIStyle textStyle;
        public bool hideGizmoVisuals = false;

        private void OnDrawGizmos()
        {
            DrawGizmo(false);
        }

        private void OnDrawGizmosSelected()
        {
            DrawGizmo(true);
        }

        void DrawGizmo(bool selected)
        {
            if (hideGizmoVisuals) return;
            
            var t = transform;
            var position = t.position;

            Gizmos.color = selected ? Color.red : Color.blue;
            Gizmos.DrawSphere(position, 0.2f);

            if (textStyle == null)
            {
                textStyle = new GUIStyle(GUI.skin.label);
                textStyle.normal.textColor = Color.red;
            }
            
            //Handles.Label(position + new Vector3(0, 1.0f, 0), markerName, textStyle);
            //Handles.color = Color.red;
            //Handles.ArrowHandleCap(0, position, t.rotation, 1.1f, EventType.Repaint);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_Snap_Extras\Snap_Marker_Support\Scripts\SnapDungeonMarkerSpawner.cs:
 using System.Collections;
using System.Collections.Generic;
using DungeonArchitect;
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Graphs;
using UnityEngine;

public class SnapDungeonMarkerSpawner : DungeonEventListener
{
    public List<Graph> dungeonThemes;
    public GridDungeonBuilder gridDungeonTemplate;

    [SerializeField, HideInInspector]
    private Dungeon spawnedDungeon;

    public bool hideMarkerGizmos = true;
    
    public override void OnPostDungeonBuild(Dungeon snapDungeon, DungeonModel model)
    {
        if (gridDungeonTemplate == null)
        {
            Debug.LogError("Missing grid dungeon template");
            return;
        }
        DestroySpawnedDungeon();
        
        // Instantiate our second dungeon
        var gridDungeonObject = Instantiate(gridDungeonTemplate.gameObject);
        var gridConfig = gridDungeonObject.GetComponent<GridDungeonConfig>();
        gridConfig.NumCells = 0;    // This will disable dungeon generation and won't emit any procedural markers
        
        // Assign the themes and build the dungeon to spawn the markers
        var markerInserter = gridDungeonObject.AddComponent<SnapThemeEngineMarkerInserter>();
        markerInserter.hideMarkerGizmos = hideMarkerGizmos;
        
        spawnedDungeon = gridDungeonObject.GetComponent<Dungeon>();
        spawnedDungeon.dungeonThemes = dungeonThemes;
        
        // Assign the parent object from the snap dungeon to keep things clean
        {
            var snapSceneProvider = snapDungeon.GetComponent<DungeonSceneProvider>();
            var gridSceneProvider = spawnedDungeon.GetComponent<DungeonSceneProvider>();
            gridSceneProvider.itemParent = snapSceneProvider.itemParent;
            
            // Move the spawned dungeon to this folder
            spawnedDungeon.transform.SetParent(gridSceneProvider.itemParent.transform);
        }
        spawnedDungeon.Build();
    }

    public override void OnDungeonDestroyed(Dungeon dungeon)
    {
        DestroySpawnedDungeon();
    }

    void DestroySpawnedDungeon()
    {
        // Destroy our spawned dungeon
        if (spawnedDungeon != null)
        {
            spawnedDungeon.DestroyDungeon();

            if (Application.isPlaying)
            {
                Destroy(spawnedDungeon.gameObject);
            }
            else
            {
                DestroyImmediate(spawnedDungeon.gameObject);
            }

            spawnedDungeon = null;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Demo_Theme_OutdoorCliffs\Scripts\Rules\CliffTileRandomTransformer.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;

public class CliffTileRandomTransformer : TransformationRule {
    public float tileWidth = 3;
    public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale)
    {
        var halfWidth = tileWidth / 2.0f;
        outPosition = new Vector3(
            random.Range(-halfWidth, halfWidth), 0,
            random.Range(-halfWidth, halfWidth));

        outRotation = Quaternion.Euler(0, random.Range(0, 360), 0);
        outScale = Vector3.one;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Dungeons\GridFlowRules\GFSpriteNudge.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.JackRabbit
{
    public class GFSpriteNudge : TransformationRule
    {
        // Sta
        public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale)
        {
            base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);
            // Random position
            var maxJitterDistance = 0.15f;
            var jitterDistance = random.NextFloat() * maxJitterDistance;
            var jitterAngle = random.NextFloat() * Mathf.PI * 2;
            var jitter = new Vector3(Mathf.Cos(jitterAngle), 0, Mathf.Sin(jitterAngle)) * maxJitterDistance;
            outPosition += jitter;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game2D_JackRabbit\Dungeons\GridFlowRules\GFSpriteNudgeRot.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.JackRabbit
{
    public class GFSpriteNudgeRot : TransformationRule
    {
        // Sta
        public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale)
        {
            base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);

            // Random rotation
            var angle = random.value() * 360;
            var rotation = Quaternion.Euler(0, angle, 0);
            outRotation = rotation;

            // Random position
            var maxJitterDistance = 0.15f;
            var jitterDistance = random.NextFloat() * maxJitterDistance;
            var jitterAngle = random.NextFloat() * Mathf.PI * 2;
            var jitter = new Vector3(Mathf.Cos(jitterAngle), 0, Mathf.Sin(jitterAngle)) * maxJitterDistance;
            outPosition += jitter;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\AI\AIController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.AI;
using System.Collections.Generic;

namespace DungeonArchitect.Samples.ShooterGame
{
	public class AIStateBase : StateBase {
		protected AIController controller;
		
		public AIStateBase(AIController controller, float updateDelay) {
			this.controller = controller;

		}
		
		protected virtual void HandleFrameUpdate (float elapsedTime) {
		}

        public override void Update() {

            // if we are not already dead, then check for the player health
            var isInDeathState = (this is AIStateDead);
            if (!isInDeathState) {
                if (!controller.enabled) {
                    // Player is no longer alive. Move to the dead state
                    var deadState = new AIStateDead(controller);
                    stateMachine.MoveTo(deadState);
                }
            }

            if (controller.Agent.isActiveAndEnabled)
            {
                HandleFrameUpdate(Time.deltaTime);
            }
        }
		
		protected bool IsWithinPlayerProximity(ref Collider outCollider, float radius) {
			return false;
		}

		protected GameObject GetPlayer() {
			return GameObject.FindGameObjectWithTag(GameTags.Player);
		}

		protected bool IsPlayerVisible() {
			if (controller.mode2D) {
				return IsPlayerVisible2D();
			} else {
				return IsPlayerVisible3D();
			}
		}

		protected bool IsPlayerVisible2D() {
			var source = controller.gameObject.transform.position;
			var colliders = Physics2D.OverlapCircleAll(source, controller.maxViewSight);
			
			Collider2D player = null;
			foreach (var collider in colliders) {
				if (collider.isTrigger) continue;
				if (collider.gameObject.CompareTag(GameTags.Player)) {
					player = collider;
					break;
				}
			}
			
			if (player == null) {
				return false;
			}
			
			var target = player.gameObject.transform.position;
			
			// Check if the player is too close the npc
			var distanceSq = (source - target).sqrMagnitude;
			if (distanceSq <= controller.playerCloseByDistance * controller.playerCloseByDistance) {
				// Player is too close to the npc and will be detected, regardless of whether it sees it or not
				return true;
			}
			
			// Check if the player is within the NPC's field of vision
			{
				var forward3D = controller.Agent.velocity.normalized;
				var forward = new Vector2(forward3D.x, forward3D.z);
				var toPlayer = (target - controller.gameObject.transform.position).normalized;
				var angle = Vector3.Angle(forward, toPlayer);
				if (angle > controller.fieldOfView / 2.0f) {
					// Not within the field of vision
					return false;
				}
			}
			
			
			// The player is within the vision cone.  
			// Make a raycast and check if any objects are obstructing the vision (e.g. walls)
			var offset = Vector3.zero;
			var direction = (target - source).normalized;
			var hits = Physics2D.RaycastAll(source + offset, direction, controller.maxViewSight);
			
			// Sort the hits based on distance
			System.Array.Sort(hits, delegate(RaycastHit2D x, RaycastHit2D y) {
				if (x.distance == y.distance) return 0;
				return x.distance < y.distance ? -1 : 1;
			});
			
			var hitPlayer = false;
			foreach (var hit in hits) {
				if (hit.collider.isTrigger) continue;
				//if (hit.collider.gameObject.CompareTag(GameTags.Enemy)) continue;
				
				if (hit.collider == player) {
					hitPlayer = true;
				}
				break;
			}
			
			return hitPlayer;
		}

		protected bool IsPlayerVisible3D() {
			var source = controller.gameObject.transform.position;
			var colliders = Physics.OverlapSphere(source, controller.maxViewSight);

			Collider player = null;
			foreach (var collider in colliders) {
				if (collider.isTrigger) continue;
				if (collider.gameObject.CompareTag(GameTags.Player)) {
					player = collider;
					break;
				}
			}

			if (player == null) {
				return false;
			}

			var target = player.gameObject.transform.position;

			// Check if the player is too close the npc
			var distanceSq = (source - target).sqrMagnitude;
			if (distanceSq <= controller.playerCloseByDistance * controller.playerCloseByDistance) {
				// Player is too close to the npc and will be detected, regardless of whether it sees it or not
				return true;
			}

			// Check if the player is within the NPC's field of vision
			{
				var forward = controller.gameObject.transform.forward;
				var toPlayer = (target - controller.gameObject.transform.position).normalized;
				var angle = Vector3.Angle(forward, toPlayer);
				if (angle > controller.fieldOfView / 2.0f) {
					// Not within the field of vision
					return false;
				}
			}


			// The player is within the vision cone.  
			// Make a raycast and check if any objects are obstructing the vision (e.g. walls)
			var offset = Vector3.up;
			var direction = (target - source).normalized;
			var hits = Physics.RaycastAll(source + offset, direction, controller.maxViewSight);

			// Sort the hits based on distance
			System.Array.Sort(hits, delegate(RaycastHit x, RaycastHit y) {
				if (x.distance == y.distance) return 0;
				return x.distance < y.distance ? -1 : 1;
			});

			var hitPlayer = false;
			foreach (var hit in hits) {
				if (hit.collider.isTrigger) continue;
				//if (hit.collider.gameObject.CompareTag(GameTags.Enemy.ToLower())) continue;

				if (hit.collider == player) {
					hitPlayer = true;
				}
				break;
			}

			return hitPlayer;
		}
	}

	/** If the player is not visible, it moves to the last know position from the controller's last sighting */
	public class AIStateMoveToLastKnownPosition : AIStateBase {
		
		public AIStateMoveToLastKnownPosition(AIController controller) : base(controller, 0.1f) {}
		
		public override void OnEnter() {
			var hasSighting = controller.LastSighting.HasSighting();
			if (hasSighting) {
                // Start moving to the last know sighting of the player
                controller.Agent.isStopped = false;
				controller.Agent.destination = controller.LastSighting.Position;
			} 
			else {
				// Should not happen
				// Move to the patrol state if it does
				var patrol = new AIStatePatrol(controller);
				stateMachine.MoveTo(patrol);
	        }
		}
		
		public override void Update() {
			base.Update();
	    }
		
		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);

			// Check if we can see the player
			if (IsPlayerVisible()) {
				// The player is visible.  Start persuit of the player
				var persuit = new AIStatePersuit(controller);
				stateMachine.MoveTo(persuit);
	            return;
	        }

			// Check if we are near the last sighting position;
			if (controller.Agent.remainingDistance < controller.destinationArriveProximity) {
				// We have reached the last sighting position and still haven't found the player
				// Stand here and wait for a bit before returing to patrolling
				var waitAndSearch = new AIStateWaitAndSearch(controller);
				stateMachine.MoveTo(waitAndSearch);
			}
	    }
	}

	/** If the player is not visible, it moves to the last know position from the controller's last sighting */
	public class AIStateWaitAndSearch : AIStateBase {
		public AIStateWaitAndSearch(AIController controller) : base(controller, 0.1f) {}
		public float timeSinceStart = 0;
		public override void OnEnter() {
			base.OnEnter();
            controller.Agent.isStopped = true;
	    }
		
		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);
	        
			// Check if the player is visible
			if (IsPlayerVisible()) {
				// Start persuit of the player
				var persuit = new AIStatePersuit(controller);
				stateMachine.MoveTo (persuit);
			}

			timeSinceStart += elapsedTime;
			if (timeSinceStart >= controller.searchWaitTime) {
				// The player is not found and is lost. Clear the last sighting variable
				controller.LastSighting.ClearSighting();

				// Return back to the patrol state
				var patrol = new AIStatePatrol(controller);
				stateMachine.MoveTo(patrol);
			}
		}
	}

	public class AIStatePersuit : AIStateBase {
		Transform followTarget;

		public AIStatePersuit(AIController controller) : base(controller, 0.1f) {}

		public override void OnEnter() {
			// Find the player
			var playerObject = GetPlayer();
			if (playerObject != null) {
				followTarget = playerObject.transform;
			}

            controller.Agent.isStopped = false;
		}
		
		public override void OnExit() {
			controller.Agent.isStopped = true;
		}
		
		public override void Update() {
			base.Update();

		}

		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);
            
            Collider playerCollider = null;
			if (IsWithinPlayerProximity(ref playerCollider, controller.playerProximityRadius)) {
				// close to the player.  Move to the attack state
			} else {
				// Move to the player
				controller.Agent.destination = followTarget.position;
			}

			if (!IsPlayerVisible()) {
				// Move to the last know position
				if (controller.LastSighting.HasSighting()) {
					var moveToLastKnown = new AIStateMoveToLastKnownPosition(controller);
					stateMachine.MoveTo(moveToLastKnown);
				} else {
					// We don't have a last know position. Resume patroling 
					var patrol = new AIStatePatrol(controller);
					stateMachine.MoveTo(patrol);
				}
				return;
			} else {
				// Player is visible.  Update the last sighting
				controller.LastSighting.Position = followTarget.position;
			}
		}

	}


	public class AIStatePatrol : AIStateBase {
		int currentWaypointIndex = 0;

		// Apply some offset to the waypoints so they don't reach the exact waypoint position
		Vector3[] waypointOffsets;

		public AIStatePatrol(AIController controller) : base(controller, 0.1f) {}
		
		public override void OnEnter() {
            controller.Agent.isStopped = false;

			// Since we entered the patrol state, the player is not visible
			controller.LastSighting.ClearSighting();

			{
				var offsets = new List<Vector3>();
				var waypoints = controller.Patrol.PatrolPoints;
				for(int i = 0; i < waypoints.Length; i++) {
					var offset = Random.insideUnitSphere * controller.Patrol.randomOffset;
					offset.y = 0;
					offsets.Add (offset);
				}
				waypointOffsets = offsets.ToArray();
			}
		}

		void MoveToCurrentPoint() {
			var waypoints = controller.Patrol.PatrolPoints;
			if (waypoints.Length == 0) return;

			currentWaypointIndex = currentWaypointIndex % waypoints.Length;
			var point = waypoints[currentWaypointIndex];
			if (point == null) return;
			var offset = waypointOffsets[currentWaypointIndex % waypointOffsets.Length];

			controller.Agent.destination = point.gameObject.transform.position + offset;
		}

		public override void OnExit() {
		}
		
		public override void Update() {
			base.Update();
		}
		
		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);

			if (IsPlayerVisible()) {
				var persuit = new AIStatePersuit(controller);
				stateMachine.MoveTo(persuit);
				return;
			}

			// Since the player is not visible while we are patrolling, clear the last sighting 
			controller.LastSighting.ClearSighting();

			var agent = controller.Agent;

			if (agent.remainingDistance < controller.destinationArriveProximity) {
				currentWaypointIndex++;
			}
			MoveToCurrentPoint();
		}
	}

	enum AIAttackAnimState {
		Requested,
		Running,
		InterAttackWait
	}



	public class AIStateDead : AIStateBase {	
		public AIStateDead(AIController controller) : base(controller, 0.1f) {}

		public override void OnEnter() {
			base.OnEnter();
            controller.Agent.isStopped = true;
			controller.Agent.enabled = false;
			controller.Capsule.enabled = false;
		}
		
		public override void OnExit() {
			base.OnExit();
		}
	}


	public class AIStateIdle : AIStateBase {
		public AIStateIdle(AIController controller) : base(controller, 0.1f) {}

		public override void OnEnter() {
			base.OnEnter();

            controller.Agent.isStopped = true;

			controller.LastSighting.ClearSighting();
		}
		
		public override void OnExit() {
			base.OnExit();
		}
		
		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);
			
			// Check if the player is visible
			if (IsPlayerVisible()) {
				// Start persuit of the player
				var persuit = new AIStatePersuit(controller);
				stateMachine.MoveTo (persuit);
			}
		}
	}


	public class AIController : CharacterControlScript {
		NavMeshAgent agent;
		PatrolPath patrol;
		CapsuleCollider capsule;
		LastPlayerSighting lastSighting;

		public bool hasPatrolling = true;
		public float fieldOfView = 120;
		public float maxViewSight = 12;
		public float searchWaitTime = 3;
		public float playerCloseByDistance = 4;	// if the player is too close, the npc should detect it even if not facing the player
		public float destinationArriveProximity = 1;	// How close should the agent be to the destination to consider it arrived
		public float playerProximityRadius = 3.0f;
		public bool mode2D = false;

		public NavMeshAgent Agent {
			get {
				return agent;
			}
		}

		public CapsuleCollider Capsule {
			get {
				return capsule;
			}
		}

		public PatrolPath Patrol {
			get {
				return patrol;
			}
		}


		public LastPlayerSighting LastSighting {
			get {
				return lastSighting;
			}
		}

		protected override void Initialize() {
			capsule = GetComponent<CapsuleCollider>();
			patrol = GetComponent<PatrolPath>();
			agent = GetComponent<NavMeshAgent>();
			lastSighting = GetComponent<LastPlayerSighting>();

			State startState = null;
			if (hasPatrolling) {
				startState = new AIStatePatrol(this);
			} else {
				startState = new AIStateIdle(this);
			}

			stateMachine.MoveTo(startState);
		}

		public override bool GetInputJump() {
			return false;
		}
		public override bool GetInputAttackPrimary() {
			return false;
		}
		
		public override bool IsGrounded() {
			return true;
		}

		public override void ApplyMovement(Vector3 velocity) {

		}

	}
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\AI\AIController2D.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Navigation;

namespace DungeonArchitect.Samples.ShooterGame.TwoD
{
	public class AIStateBase : StateBase {
		protected AIController2D controller;
		
		public AIStateBase(AIController2D controller, float updateDelay) {
			this.controller = controller;

		}
		
		protected virtual void HandleFrameUpdate (float elapsedTime) {
		}

        public override void Update() {

			// if we are not already dead, then check for the player health
			var isInDeathState = (this is AIStateDead);
			if (!isInDeathState) {
				if (!controller.enabled) {
					// Player is no longer alive. Move to the dead state
					var deadState = new AIStateDead(controller);
					stateMachine.MoveTo(deadState);
				}
			}

			HandleFrameUpdate(Time.deltaTime);
        }
		
		protected bool IsWithinPlayerProximity(ref Collider outCollider, float radius) {
			return false;
		}

		protected GameObject GetPlayer() {
			return GameObject.FindGameObjectWithTag(GameTags.Player);
		}

		protected bool IsPlayerVisible() {
			if (controller.mode2D) {
				return IsPlayerVisible2D();
			} else {
				return IsPlayerVisible3D();
			}
		}

		protected bool IsPlayerVisible2D() {
			var source = controller.gameObject.transform.position;
			var colliders = Physics2D.OverlapCircleAll(source, controller.maxViewSight);
			
			Collider2D player = null;
			foreach (var collider in colliders) {
				if (collider.isTrigger) continue;
				if (collider.gameObject.CompareTag(GameTags.Player)) {
					player = collider;
					break;
				}
			}
			
			if (player == null) {
				return false;
			}
			
			var target = player.gameObject.transform.position;
			
			// Check if the player is too close the npc
			var distanceSq = (source - target).sqrMagnitude;
			if (distanceSq <= controller.playerCloseByDistance * controller.playerCloseByDistance) {
				// Player is too close to the npc and will be detected, regardless of whether it sees it or not
				return true;
			}
			
			// Check if the player is within the NPC's field of vision
			{
				var forward3D = controller.Agent.Velocity.normalized;
				var forward = new Vector2(forward3D.x, forward3D.z);
				var toPlayer = (target - controller.gameObject.transform.position).normalized;
				var angle = Vector3.Angle(forward, toPlayer);
				if (angle > controller.fieldOfView / 2.0f) {
					// Not within the field of vision
					return false;
				}
			}
			
			
			// The player is within the vision cone.  
			// Make a raycast and check if any objects are obstructing the vision (e.g. walls)
			var offset = Vector3.zero;
			var direction = (target - source).normalized;
			var hits = Physics2D.RaycastAll(source + offset, direction, controller.maxViewSight);
			
			// Sort the hits based on distance
			System.Array.Sort(hits, delegate(RaycastHit2D x, RaycastHit2D y) {
				if (x.distance == y.distance) return 0;
				return x.distance < y.distance ? -1 : 1;
			});
			
			var hitPlayer = false;
			foreach (var hit in hits) {
				if (hit.collider.isTrigger) continue;
				//if (hit.collider.gameObject.CompareTag(GameTags.Enemy)) continue;
				
				if (hit.collider == player) {
					hitPlayer = true;
				}
				break;
			}
			
			return hitPlayer;
		}

		protected bool IsPlayerVisible3D() {
			var source = controller.gameObject.transform.position;
			var colliders = Physics.OverlapSphere(source, controller.maxViewSight);

			Collider player = null;
			foreach (var collider in colliders) {
				if (collider.isTrigger) continue;
				if (collider.gameObject.CompareTag(GameTags.Player)) {
					player = collider;
					break;
				}
			}

			if (player == null) {
				return false;
			}

			var target = player.gameObject.transform.position;

			// Check if the player is too close the npc
			var distanceSq = (source - target).sqrMagnitude;
			if (distanceSq <= controller.playerCloseByDistance * controller.playerCloseByDistance) {
				// Player is too close to the npc and will be detected, regardless of whether it sees it or not
				return true;
			}

			// Check if the player is within the NPC's field of vision
			{
				var forward = controller.gameObject.transform.forward;
				var toPlayer = (target - controller.gameObject.transform.position).normalized;
				var angle = Vector3.Angle(forward, toPlayer);
				if (angle > controller.fieldOfView / 2.0f) {
					// Not within the field of vision
					return false;
				}
			}


			// The player is within the vision cone.  
			// Make a raycast and check if any objects are obstructing the vision (e.g. walls)
			var offset = Vector3.up;
			var direction = (target - source).normalized;
			var hits = Physics.RaycastAll(source + offset, direction, controller.maxViewSight);

			// Sort the hits based on distance
			System.Array.Sort(hits, delegate(RaycastHit x, RaycastHit y) {
				if (x.distance == y.distance) return 0;
				return x.distance < y.distance ? -1 : 1;
			});

			var hitPlayer = false;
			foreach (var hit in hits) {
				if (hit.collider.isTrigger) continue;
				//if (hit.collider.gameObject.CompareTag(GameTags.Enemy.ToLower())) continue;

				if (hit.collider == player) {
					hitPlayer = true;
				}
				break;
			}

			return hitPlayer;
		}
	}

	/** If the player is not visible, it moves to the last know position from the controller's last sighting */
	public class AIStateMoveToLastKnownPosition : AIStateBase {
		
		public AIStateMoveToLastKnownPosition(AIController2D controller) : base(controller, 0.1f) {}
		
		public override void OnEnter() {
			var hasSighting = controller.LastSighting.HasSighting();
			if (hasSighting) {
                // Start moving to the last know sighting of the player
                controller.Agent.Resume(); 
				controller.Agent.Destination = controller.LastSighting.Position;
			} 
			else {
				// Should not happen
				// Move to the patrol state if it does
				var patrol = new AIStatePatrol(controller);
				stateMachine.MoveTo(patrol);
	        }
		}
		
		public override void Update() {
			base.Update();
	    }
		
		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);

			// Check if we can see the player
			if (IsPlayerVisible()) {
				// The player is visible.  Start persuit of the player
				var persuit = new AIStatePersuit(controller);
				stateMachine.MoveTo(persuit);
	            return;
	        }

			// Check if we are near the last sighting position;
			if (controller.Agent.GetRemainingDistance() < controller.destinationArriveProximity) {
				// We have reached the last sighting position and still haven't found the player
				// Stand here and wait for a bit before returing to patrolling
				var waitAndSearch = new AIStateWaitAndSearch(controller);
				stateMachine.MoveTo(waitAndSearch);
			}
	    }
	}

	/** If the player is not visible, it moves to the last know position from the controller's last sighting */
	public class AIStateWaitAndSearch : AIStateBase {
		public AIStateWaitAndSearch(AIController2D controller) : base(controller, 0.1f) {}
		public float timeSinceStart = 0;
		public override void OnEnter() {
			base.OnEnter();
            controller.Agent.Stop();
	    }
		
		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);
	        
			// Check if the player is visible
			if (IsPlayerVisible()) {
				// Start persuit of the player
				var persuit = new AIStatePersuit(controller);
				stateMachine.MoveTo (persuit);
			}

			timeSinceStart += elapsedTime;
			if (timeSinceStart >= controller.searchWaitTime) {
				// The player is not found and is lost. Clear the last sighting variable
				controller.LastSighting.ClearSighting();

				// Return back to the patrol state
				var patrol = new AIStatePatrol(controller);
				stateMachine.MoveTo(patrol);
			}
		}
	}

	public class AIStatePersuit : AIStateBase {
		Transform followTarget;

		public AIStatePersuit(AIController2D controller) : base(controller, 0.1f) {}

		public override void OnEnter() {
			// Find the player
			var playerObject = GetPlayer();
			if (playerObject != null) {
				followTarget = playerObject.transform;
			}

            controller.Agent.Resume();
		}
		
		public override void OnExit() {
            controller.Agent.Stop();
		}
		
		public override void Update() {
			base.Update();

		}

		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);
            
            Collider playerCollider = null;
			if (IsWithinPlayerProximity(ref playerCollider, controller.playerProximityRadius)) {
				// close to the player.  Move to the attack state
			} else {
				// Move to the player
				controller.Agent.Destination = followTarget.position;
			}

			if (!IsPlayerVisible()) {
				// Move to the last know position
				if (controller.LastSighting.HasSighting()) {
					var moveToLastKnown = new AIStateMoveToLastKnownPosition(controller);
					stateMachine.MoveTo(moveToLastKnown);
				} else {
					// We don't have a last know position. Resume patroling 
					var patrol = new AIStatePatrol(controller);
					stateMachine.MoveTo(patrol);
				}
				return;
			} else {
				// Player is visible.  Update the last sighting
				controller.LastSighting.Position = followTarget.position;
			}
		}

	}


	public class AIStatePatrol : AIStateBase {
		int currentWaypointIndex = 0;

		// Apply some offset to the waypoints so they don't reach the exact waypoint position
		Vector3[] waypointOffsets;

		public AIStatePatrol(AIController2D controller) : base(controller, 0.1f) {}
		
		public override void OnEnter() {
            controller.Agent.Resume();

			// Since we entered the patrol state, the player is not visible
			controller.LastSighting.ClearSighting();

			{
				var offsets = new List<Vector3>();
				var waypoints = controller.Patrol.PatrolPoints;
				for(int i = 0; i < waypoints.Length; i++) {
					var offset = Random.insideUnitSphere * controller.Patrol.randomOffset;
					offset.y = 0;
					offsets.Add (offset);
				}
				waypointOffsets = offsets.ToArray();
			}
		}

		void MoveToCurrentPoint() {
			var waypoints = controller.Patrol.PatrolPoints;
			if (waypoints.Length == 0) return;

			currentWaypointIndex = currentWaypointIndex % waypoints.Length;
			var point = waypoints[currentWaypointIndex];
			if (point == null) return;
			var offset = waypointOffsets[currentWaypointIndex % waypointOffsets.Length];

			controller.Agent.Destination = point.gameObject.transform.position + offset;
		}

		public override void OnExit() {
		}
		
		public override void Update() {
			base.Update();
		}
		
		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);

			if (IsPlayerVisible()) {
				var persuit = new AIStatePersuit(controller);
				stateMachine.MoveTo(persuit);
				return;
			}

			// Since the player is not visible while we are patrolling, clear the last sighting 
			controller.LastSighting.ClearSighting();

			var agent = controller.Agent;

			if (agent.GetRemainingDistance() < controller.destinationArriveProximity) {
				currentWaypointIndex++;
			}
			MoveToCurrentPoint();
		}
	}

	enum AIAttackAnimState {
		Requested,
		Running,
		InterAttackWait
	}



	public class AIStateDead : AIStateBase {	
		public AIStateDead(AIController2D controller) : base(controller, 0.1f) {}

		public override void OnEnter() {
			base.OnEnter();
            controller.Agent.Stop();
			controller.Agent.enabled = false;
			controller.Capsule.enabled = false;
		}
		
		public override void OnExit() {
			base.OnExit();
		}
	}


	public class AIStateIdle : AIStateBase {
		public AIStateIdle(AIController2D controller) : base(controller, 0.1f) {}

		public override void OnEnter() {
			base.OnEnter();

            controller.Agent.Stop();

			controller.LastSighting.ClearSighting();
		}
		
		public override void OnExit() {
			base.OnExit();
		}
		
		protected override void HandleFrameUpdate (float elapsedTime)
		{
			base.HandleFrameUpdate(elapsedTime);
			
			// Check if the player is visible
			if (IsPlayerVisible()) {
				// Start persuit of the player
				var persuit = new AIStatePersuit(controller);
				stateMachine.MoveTo (persuit);
			}
		}
	}


	public class AIController2D : CharacterControlScript {
		DungeonNavAgent agent;
		PatrolPath patrol;
		CapsuleCollider capsule;
		LastPlayerSighting lastSighting;

		public bool hasPatrolling = true;
		public float fieldOfView = 120;
		public float maxViewSight = 12;
		public float searchWaitTime = 3;
		public float playerCloseByDistance = 4;	// if the player is too close, the npc should detect it even if not facing the player
		public float destinationArriveProximity = 1;	// How close should the agent be to the destination to consider it arrived
		public float playerProximityRadius = 3.0f;
		public bool mode2D = false;

		public DungeonNavAgent Agent {
			get {
				return agent;
			}
		}

		public CapsuleCollider Capsule {
			get {
				return capsule;
			}
		}

		public PatrolPath Patrol {
			get {
				return patrol;
			}
		}


		public LastPlayerSighting LastSighting {
			get {
				return lastSighting;
			}
		}

		protected override void Initialize() {
			capsule = GetComponent<CapsuleCollider>();
			patrol = GetComponent<PatrolPath>();
			agent = GetComponent<DungeonNavAgent>();
			lastSighting = GetComponent<LastPlayerSighting>();

			State startState = null;
			if (hasPatrolling) {
				startState = new AIStatePatrol(this);
			} else {
				startState = new AIStateIdle(this);
			}

			stateMachine.MoveTo(startState);
		}

		public override bool GetInputJump() {
			return false;
		}
		public override bool GetInputAttackPrimary() {
			return false;
		}
		
		public override bool IsGrounded() {
			return true;
		}

		public override void ApplyMovement(Vector3 velocity) {

		}

	}
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\AI\CharacterControlScript.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;


namespace DungeonArchitect.Samples.ShooterGame
{
	public abstract class CharacterControlScript : MonoBehaviour {
		protected StateMachine stateMachine;


		// Use this for initialization
		void Start () {
			stateMachine = new StateMachine();

			Initialize ();
		}

		protected virtual void Initialize() {}
		
		// Update is called once per frame
		void FixedUpdate () {

		}

		void Update() {
			stateMachine.Update();
		}

		public abstract bool GetInputJump();
		public abstract bool GetInputAttackPrimary();
		public abstract bool IsGrounded();
		public abstract void ApplyMovement(Vector3 velocity);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\AI\LastPlayerSighting.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
	public class LastPlayerSighting : MonoBehaviour {
		static readonly Vector3 NO_SIGHTING = new Vector3(-10000, -10000, -10000);

		Vector3 position;
		public Vector3 Position {
			get {
				return position;
			}
			set {
				position = value;
			}
		}

		public void ClearSighting() {
			position = NO_SIGHTING;
		}

		public bool HasSighting() {
			return position != NO_SIGHTING;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\AI\LevelNpcSpawner.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Samples.ShooterGame
{
	public class LevelNpcSpawner : DungeonEventListener {
		public GameObject parentObject;
		public GameObject[] npcTemplates;
		public Vector3 npcOffset = Vector3.zero;
	    public float spawnProbability = 0.25f;

		public override void OnPostDungeonBuild (Dungeon dungeon, DungeonModel model)
		{
			RebuildNPCs();
		}

		public void RebuildNPCs() {
			DestroyOldNpcs();
			if (npcTemplates.Length == 0) return;

			var waypoints = GameObject.FindObjectsOfType<Waypoint>();

			// Spawn an npc in each waypoint
			foreach (var waypoint in waypoints) {
	            if (Random.value < spawnProbability)
	            {
	                var position = waypoint.transform.position + npcOffset;
	                position = GetValidPointOnNavMesh(position);
	                var npcIndex = Random.Range(0, npcTemplates.Length);
	                var template = npcTemplates[npcIndex];
	                var npc = Instantiate(template, position, Quaternion.identity) as GameObject;

	                if (parentObject != null)
	                {
	                    npc.transform.parent = parentObject.transform;
	                }
	            }
			}
		}

		Vector3 GetValidPointOnNavMesh(Vector3 position) {
			UnityEngine.AI.NavMeshHit hit;
			if (UnityEngine.AI.NavMesh.SamplePosition(position, out hit, 4.0f, UnityEngine.AI.NavMesh.AllAreas)) {
				return hit.position;
			}
			return position;
		}

		public override void OnDungeonDestroyed(Dungeon dungeon) {
			DestroyOldNpcs();
		}

		void DestroyOldNpcs() {
			if (parentObject == null) {
				return;
			}

			var npcs = new List<GameObject>();
			var parentTransform = parentObject.transform;
			for(int i = 0; i < parentTransform.childCount; i++) {
				var npc = parentObject.transform.GetChild(i).gameObject;
				npcs.Add(npc);
			}

			foreach (var npc in npcs) {
				if (Application.isPlaying) {
					Destroy(npc);
				} else {
					DestroyImmediate(npc);
				}
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\AI\PatrolPath.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Samples.ShooterGame
{
	public class PatrolPath : MonoBehaviour {
		public int minPathLength = 5;
		public int maxPathLength = 10;
		public float randomOffset = 2;

		/// <summary>
		/// The distance the agent has to come close to this waypoint to consider it as arrived
		/// </summary>
		public float proximityThreshold = 1.0f;

		Waypoint[] patrolPoints = new Waypoint[0];
		bool looped = false;

		public bool Looped {
			get {
				return looped;
			}
		}

		public Waypoint[] PatrolPoints {
			get {
				return patrolPoints;
			}
		}

		// Use this for initialization
		void Awake () {
			Build ();
		}

		public void Build() {
			Build (gameObject.transform.position);
		}

		public void Build(Vector3 nearestStartingPoint) {
			// Find all the waypoints in the map
			var waypoints = GameObject.FindObjectsOfType<Waypoint>();
			var nearestWaypoint = FindNearest(waypoints, gameObject.transform.position);
			if (nearestWaypoint == null) {
				// No waypoints found
				Debug.LogWarning("No waypoints found in map for generating patrol path");
				return;
			}

			// Build the waypoint lookup
			var waypointLookup = new Dictionary<int, Waypoint>();
			foreach (var waypoint in waypoints) {
				waypointLookup.Add (waypoint.id, waypoint);
			}
			var startingWaypoint = nearestWaypoint;

			patrolPoints = FindLoopedPath(startingWaypoint);
			if (patrolPoints != null) {
				looped = true;
			} else {
				patrolPoints = FindNonLoopedPath(startingWaypoint);
				looped = false;
			}

			if (patrolPoints == null) {
				Debug.LogWarning("PatrolPath: No suitable waypoint found");
				patrolPoints = new Waypoint[0];
			}
		}

		/// <summary>
		/// Uses DFS to trace the next non-looped path between the path length constraint
		/// </summary>
		/// <returns>The non looped path.</returns>
		/// <param name="startingWaypoint">Starting waypoint.</param>
		Waypoint[] FindNonLoopedPath(Waypoint startingWaypoint) {
			var stack = new Stack<List<Waypoint>>();
			var startPath = new List<Waypoint>();
			startPath.Add(startingWaypoint);
			stack.Push(startPath);

			while (stack.Count > 0) {
				var topPath = stack.Pop();
				var lastPoint = topPath[topPath.Count - 1];

				var children = lastPoint.AdjacentWaypoints;
				// Suffle the child nodes before iterating for randomness
				children = Shuffle (children);
				
				var nextPathLength = topPath.Count + 1;	// Add one to account for the next node that would be added
				foreach (var child in children) {
					var visited = topPath.Contains(child);
					if (visited) continue;

					var nextPath = new List<Waypoint>();
					nextPath.AddRange(topPath);
					nextPath.Add(child);

					// TODO: Add more randomness here to that the length varies between the min/max path length range
					if (nextPathLength >= minPathLength) {
						// Found our path with the desired length
						return nextPath.ToArray();
					}
					stack.Push(nextPath);
				}
			}
			return null;
		}

		/// <summary>
		/// Uses BFS to trace a path back to the starting node, with the length between min/max constraint
		/// </summary>
		/// <returns>The looped path.</returns>
		/// <param name="startingWaypoint">Starting waypoint.</param>
		Waypoint[] FindLoopedPath(Waypoint startingWaypoint) {
			if (startingWaypoint == null || startingWaypoint.AdjacentWaypoints.Length <= 0) {
				// A loop cannot be made when the starting node has only one outgoing path
				return null;
			}

			// Use BFS to find the nearest path;
			var queue = new Queue<List<Waypoint>>();
			var startPath = new List<Waypoint>();
			startPath.Add (startingWaypoint);
			queue.Enqueue(startPath);
			while (queue.Count > 0) {
				var topPath = queue.Dequeue();

			    var nextPathLength = topPath.Count + 1;	// Add one to account for the next node that would be added
			    if (nextPathLength > maxPathLength) {
					// Path will be too big if more nodes are added. bail out from this branch
					continue;
				}

				// Suffle the child nodes before iterating for randomness
				var validPathLength = (topPath.Count >= minPathLength && topPath.Count <= maxPathLength);

				var lastPoint = topPath[topPath.Count - 1];
				var children = lastPoint.AdjacentWaypoints;
				children = Shuffle(children);
				foreach (var child in children) {
					var visited = topPath.Contains(child);
					if (!visited) {
						var nextPath = new List<Waypoint>();
						nextPath.AddRange(topPath);
						nextPath.Add (child);
						queue.Enqueue(nextPath);
					}
					else if (validPathLength && child == startingWaypoint) {
						// The path length matches the constraint and the next child connects back to the starting point
						return topPath.ToArray();
					}
				}
			}
			// No loops found
			return null;
		}

		Waypoint[] Shuffle(Waypoint[] data) {
			// TODO: Implement
			return data;
		}

		Waypoint FindNearest(Waypoint[] waypoints, Vector3 startingPoint) {
			float nearestDistance = float.MaxValue;
			Waypoint bestMatch = null;

			foreach (var waypoint in waypoints) {
				var distanceSq = (waypoint.gameObject.transform.position - startingPoint).sqrMagnitude;
				if (nearestDistance > distanceSq) {
					bestMatch = waypoint;
					nearestDistance = distanceSq;
				}
			}

			return bestMatch;
		}
		
		void OnDrawGizmosSelected() {
			VisualizePath();
		}
		
		void VisualizePath() {
			Gizmos.color = new Color(1, 0.5f, 0);
			for (int i = 0; i < patrolPoints.Length; i++) {
				if (!looped && i == patrolPoints.Length - 1) {
					// Dont draw the last line if we dont loop
					break;
				}
				var startPoint = patrolPoints[i];
				var endPoint = patrolPoints[(i + 1) % patrolPoints.Length];
				var start = startPoint.gameObject.transform.position;
				var end = endPoint.gameObject.transform.position;
				DrawLine(start, end, false);
			}
		}
		void DrawLine(Vector3 a, Vector3 b, bool mode2D) {
			if (mode2D) {
				Gizmos.DrawLine(FlipYZ(a), FlipYZ(b));
			}
			else {
				Gizmos.DrawLine(a, b);
			}
		}
		
		void DrawPoint(Vector3 p, bool mode2D) {
			if (mode2D) {
				Gizmos.DrawWireSphere(FlipYZ(p), 0.1f);
			} else {
				Gizmos.DrawWireSphere(p, 0.1f);
			}
		}
		
		Vector3 FlipYZ(Vector3 v) {
			return new Vector3(v.x, v.z, v.y);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\AI\SpecialRoomFinder.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Builders.SimpleCity;

namespace DungeonArchitect.Samples.ShooterGame {
	public class SpecialRoomFinder : DungeonEventListener {
		public GameObject levelEndGoalTemplate;

		/// <summary>
		/// Called after the dungeon is completely built
		/// </summary>
		/// <param name="model">The dungeon model</param>
		public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model) {
            if (model is GridDungeonModel)
            {
                // Handle the grid builder
                var gridModel = model as GridDungeonModel;

                var furthestCells = GridDungeonModelUtils.FindFurthestRooms(gridModel);
                if (furthestCells.Length == 2 && furthestCells[0] != null && furthestCells[1] != null)
                {
                    var startCell = furthestCells[0];
                    var endCell = furthestCells[1];

                    SetStartingCell(gridModel, startCell);
                    SetEndingCell(gridModel, endCell);
                }
            }
            else if (model is SimpleCityDungeonModel)
            {
                var cityModel = model as SimpleCityDungeonModel;

                // Randomly pick two road tiles 
                var roadCells = new List<SimpleCityCell>();
                for (int x = 0; x < cityModel.Cells.GetLength(0); x++)
                {
                    for (int y = 0; y < cityModel.Cells.GetLength(1); y++)
                    {
                        var cell = cityModel.Cells[x, y];
                        if (cell.CellType == SimpleCityCellType.Road)
                        {
                            roadCells.Add(cell);
                        }
                    }
                }
                
                var startCell = roadCells[Random.Range(0, roadCells.Count)];
                roadCells.Remove(startCell);
                var endCell = roadCells[Random.Range(0, roadCells.Count)];

                SetStartingCell(cityModel, startCell);
                SetEndingCell(cityModel, endCell);
            }
        }
		
		public override void OnDungeonDestroyed(Dungeon dungeon) {
            DestroyAllLevelGoals();
        }

		void SetStartingCell(GridDungeonModel model, Cell cell) {
			var roomCenter = MathUtils.GridToWorld(model.Config.GridCellSize, cell.CenterF);
            TeleportPlayerTo(roomCenter);
		}

        void SetStartingCell(SimpleCityDungeonModel model, SimpleCityCell cell)
        {
            var cellSize = new Vector3(model.Config.CellSize.x, 0, model.Config.CellSize.y);
            var position = Vector3.Scale(
                new Vector3(cell.Position.x, cell.Position.y, cell.Position.z), 
                cellSize);

            TeleportPlayerTo(position);
        }
        
        void SetEndingCell(SimpleCityDungeonModel model, SimpleCityCell cell)
        {
            var cellSize = new Vector3(model.Config.CellSize.x, 0, model.Config.CellSize.y);
            var position = Vector3.Scale(
                new Vector3(cell.Position.x, cell.Position.y, cell.Position.z),
                cellSize);

            CreateLevelGoalAt(position);
        }


        void SetEndingCell(GridDungeonModel model, Cell cell) {
            var roomCenter = MathUtils.GridToWorld(model.Config.GridCellSize, cell.CenterF);
            CreateLevelGoalAt(roomCenter);
        }

        void TeleportPlayerTo(Vector3 position)
        {
            var player = GameObject.FindGameObjectWithTag(GameTags.Player);
            if (player != null)
            {
                player.transform.position = position;
                var movement = player.GetComponent<PlayerMovement>();
                if (movement != null)
                {
                    movement.OnTeleportered();
                }
            }
        }
        
        void CreateLevelGoalAt(Vector3 position) {
            // Destroy all old level goal objects
            DestroyAllLevelGoals();

			var goal = Instantiate(levelEndGoalTemplate) as GameObject;
            goal.transform.position = position;

            if (goal.GetComponent<DungeonArchitect.Samples.ShooterGame.LevelGoal>() == null)
            {
                Debug.LogWarning("No LevelGoal component attached to the Level goal prefab.  cleanup will not be proper");
            }
		}

        void DestroyAllLevelGoals()
        {
            var oldGoals = GameObject.FindObjectsOfType<DungeonArchitect.Samples.ShooterGame.LevelGoal>();
            foreach (var oldGoal in oldGoals)
            {
                var oldGoalObj = oldGoal.gameObject;
                if (oldGoalObj != null)
                {
                    if (Application.isPlaying)
                    {
                        Destroy(oldGoalObj);
                    }
                    else
                    {
                        DestroyImmediate(oldGoalObj);
                    }
                }
            }
        }

	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\AI\StateMachine.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections.Generic;

namespace DungeonArchitect.Samples.ShooterGame
{
	public enum GameMessages {
	}

	public interface State {
		void Update();
		void FixedUpdate();
		void OnEnter();
		void OnExit();
		void TransitionTo(string stateName);
		void OnMessage(GameMessages messageType, object userdata);
		StateMachine StateMachine { get; set; }
	}

	public abstract class StateBase : State {
		public virtual void Update() {}
		public virtual void FixedUpdate() {}
		public virtual void OnEnter() {}
		public virtual void OnExit() {}
		public virtual void TransitionTo(string stateName) {}
		public virtual void OnMessage(GameMessages messageType, object userdata) {}

		protected StateMachine stateMachine;
		public StateMachine StateMachine {
			get {
				return stateMachine;
			}
			set {
				stateMachine = value;
			}
		}

	}

	public class StateMachine {
		Stack<State> stateStack = new Stack<State>();

		public State ActiveState {
			get {
				if (stateStack.Count == 0) return null;
				return stateStack.Peek();
			}
		}

		public void MoveTo(State state) {
			if (stateStack.Count > 0) {
				var top = stateStack.Pop();
				top.OnExit();
				stateStack.Clear();
			}
			state.StateMachine = this;
			stateStack.Push(state);
			state.OnEnter();
		}

		public void PushTo(State state) {
			state.StateMachine = this;
			stateStack.Push(state);
			state.OnEnter();
		}

		public void Pop() {
			if (stateStack.Count <= 1) return;
			var state = stateStack.Pop();
			state.OnExit();
		}

		// Update is called once per frame
		public void Update () {
			if (stateStack.Count == 0) return;
			var state = stateStack.Peek();
			state.Update();
		}

		public void SendMessage(GameMessages message, object userdata) {
			var state = ActiveState;
			if (state != null) {
				state.OnMessage(message, userdata);
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Audio\MixLevels.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.Audio;

namespace DungeonArchitect.Samples.ShooterGame {
	public class MixLevels : MonoBehaviour {

		public AudioMixer masterMixer;

		public void SetSfxLvl(float sfxLvl)
		{
			masterMixer.SetFloat("sfxVol", sfxLvl);
		}

		public void SetMusicLvl (float musicLvl)
		{
			masterMixer.SetFloat ("musicVol", musicLvl);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Camera\CameraFollow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class CameraFollow : MonoBehaviour
    {
        public Transform target;            // The position that that camera will be following.
		public float positionSmoothing = 5f;        // The speed with which the camera will be following.
		public float lookAtSmoothing = 5f;        // The speed with which the camera will be following.
        public Vector3 offset;                     // The initial offset from the target.

		Vector3 currentLookAt;

        void Start ()
        {
            // Calculate the initial offset.
            //offset = transform.position - target.position;
			currentLookAt = target.position;
        }


        void FixedUpdate ()
        {
            // Create a postion the camera is aiming for based on the offset from the target.
            Vector3 targetCamPos = target.position + offset;

			// Smoothly interpolate between the camera's current position and it's target position.
			transform.position = Vector3.Lerp (transform.position, targetCamPos, positionSmoothing * Time.deltaTime);
			currentLookAt = Vector3.Lerp (currentLookAt, target.position, lookAtSmoothing * Time.deltaTime);
			transform.LookAt(currentLookAt);
		}
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Enemy\EnemyAttack.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class EnemyAttack : MonoBehaviour
    {
        public float timeBetweenAttacks = 0.5f;     // The time in seconds between each attack.
        public int attackDamage = 10;               // The amount of health taken away per attack.


        Animator anim;                              // Reference to the animator component.
        GameObject player;                          // Reference to the player GameObject.
        PlayerHealth playerHealth;                  // Reference to the player's health.
        EnemyHealth enemyHealth;                    // Reference to this enemy's health.
        bool playerInRange;                         // Whether player is within the trigger collider and can be attacked.
        float timer;                                // Timer for counting up to the next attack.


        void Awake ()
        {
            // Setting up the references.
            player = GameObject.FindGameObjectWithTag ("Player");
            playerHealth = player.GetComponent <PlayerHealth> ();
            enemyHealth = GetComponent<EnemyHealth>();
            anim = GetComponent <Animator> ();
        }


        void OnTriggerEnter (Collider other)
        {
            // If the entering collider is the player...
            if(other.gameObject == player)
            {
                // ... the player is in range.
                playerInRange = true;
            }
        }


        void OnTriggerExit (Collider other)
        {
            // If the exiting collider is the player...
            if(other.gameObject == player)
            {
                // ... the player is no longer in range.
                playerInRange = false;
            }
        }


        void Update ()
        {
            // Add the time since Update was last called to the timer.
            timer += Time.deltaTime;

            // If the timer exceeds the time between attacks, the player is in range and this enemy is alive...
            if(timer >= timeBetweenAttacks && playerInRange && enemyHealth.currentHealth > 0)
            {
                // ... attack.
                Attack ();
            }

            // If the player has zero or less health...
            if(playerHealth.currentHealth <= 0)
            {
                // ... tell the animator the player is dead.
                anim.SetTrigger ("PlayerDead");
            }
        }


        void Attack ()
        {
            // Reset the timer.
            timer = 0f;

            // If the player has health to lose...
            if(playerHealth.currentHealth > 0)
            {
                // ... damage the player.
                playerHealth.TakeDamage (attackDamage);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Enemy\EnemyHealth.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.AI;
using System.Collections;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class EnemyHealth : MonoBehaviour
    {
        public int startingHealth = 100;            // The amount of health the enemy starts the game with.
        public int currentHealth;                   // The current health the enemy has.
        public float sinkSpeed = 0.3f;              // The speed at which the enemy sinks through the floor when dead.
        public int scoreValue = 10;                 // The amount added to the player's score when the enemy dies.
        public AudioClip deathClip;                 // The sound to play when the enemy dies.


        Animator anim;                              // Reference to the animator.
        AudioSource enemyAudio;                     // Reference to the audio source.
        ParticleSystem hitParticles;                // Reference to the particle system that plays when the enemy is damaged.
        CharacterController character;            // Reference to the capsule collider.
        bool isDead;                                // Whether the enemy is dead.
        bool isSinking;                             // Whether the enemy has started sinking through the floor.


        void Awake ()
        {
            // Setting up the references.
            anim = GetComponent <Animator> ();
            enemyAudio = GetComponent <AudioSource> ();
            hitParticles = GetComponentInChildren <ParticleSystem> ();
			character = GetComponent <CharacterController> ();

            // Setting the current health when the enemy first spawns.
            currentHealth = startingHealth;
        }


        void Update ()
        {
            // If the enemy should be sinking...
            if(isSinking)
            {
                // ... move the enemy down by the sinkSpeed per second.
                transform.Translate (-Vector3.up * sinkSpeed * Time.deltaTime);
            }
        }


        public void TakeDamage (int amount, Vector3 hitPoint)
        {
            // If the enemy is dead...
            if(isDead)
                // ... no need to take damage so exit the function.
                return;

            // Play the hurt sound effect.
            enemyAudio.Play ();

            // Reduce the current health by the amount of damage sustained.
            currentHealth -= amount;
            
            // Set the position of the particle system to where the hit was sustained.
            hitParticles.transform.position = hitPoint;

            // And play the particles.
            hitParticles.Play();

            // If the current health is less than or equal to zero...
            if(currentHealth <= 0)
            {
                // ... the enemy is dead.
                Death ();
            }
        }


        void Death ()
        {
            // The enemy is dead.
            isDead = true;

            // Turn the collider into a trigger so shots can pass through it.
			character.enabled = false;

            // Tell the animator that the enemy is dead.
            anim.SetTrigger ("Dead");

            // Change the audio clip of the audio source to the death clip and play it (this will stop the hurt clip playing).
            enemyAudio.clip = deathClip;
            enemyAudio.Play ();
        }


        public void StartSinking ()
        {
			StartCoroutine(StartSinkingAnimation());
		}

		IEnumerator StartSinkingAnimation() {
            // Find and disable the Nav Mesh Agent.
            GetComponent <NavMeshAgent> ().enabled = false;

			// Increase the score by the enemy's score value.
			ScoreManager.score += scoreValue;

			// Wait before we start sinking
			yield return new WaitForSeconds(2.0f);

            // Start sinking
            isSinking = true;

			// Wait until we sink before we destroy
			yield return new WaitForSeconds(3.0f);
            Destroy (gameObject);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Enemy\EnemyMovement.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.AI;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class EnemyMovement : MonoBehaviour
    {
        Transform player;               // Reference to the player's position.
        PlayerHealth playerHealth;      // Reference to the player's health.
        EnemyHealth enemyHealth;        // Reference to this enemy's health.
        NavMeshAgent navAgent;

        void Awake ()
        {
            // Set up the references.
            player = GameObject.FindGameObjectWithTag ("Player").transform;
            playerHealth = player.GetComponent <PlayerHealth> ();
            enemyHealth = GetComponent <EnemyHealth> ();
			navAgent = GetComponent<NavMeshAgent>();
        }

        void Update ()
        {
            // If the enemy and the player have health left...
            if(enemyHealth.currentHealth > 0 && playerHealth.currentHealth > 0)
            {
                // ... set the destination of the nav mesh agent to the player.
				navAgent.destination = player.position;
            }
            // Otherwise...
            else
            {
                // ... disable the nav mesh agent.
				navAgent.enabled = false;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Game\GameController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

namespace DungeonArchitect.Samples.ShooterGame {
	public class GameController : MonoBehaviour {
		private static GameController instance;
		public Dungeon dungeon;
		public GameObject minimap;

		public GameObject levelLoadingScreen;
		public Text textBuildingLayout;
		public Text textBuildingNavMesh;

		LevelNpcSpawner npcSpawner;
		string labelBuildingLayout = "Building Layout... ";
		string labelBuildingNavmesh = "Building Navmesh... ";


		public static GameController Instance {
			get {
				return instance;
			}
		}

		void Awake() {
			instance = this;
			npcSpawner = GetComponent<LevelNpcSpawner>();

			CreateNewLevel();
		}


		public void CreateNewLevel() {
			// Assing a different seed to create a new layout
			int seed = Mathf.FloorToInt(Random.value * int.MaxValue);
			dungeon.Config.Seed = (uint)seed;
			
			// Rebuild a new dungeon
			StartCoroutine(RebuildLevel(dungeon));
		}

        IEnumerator RebuildLevel(Dungeon dungeon) {
            textBuildingNavMesh.gameObject.SetActive(false);
            levelLoadingScreen.SetActive(true);
            if (minimap != null)
            {
                minimap.SetActive(false);
            }

            textBuildingLayout.text = labelBuildingLayout;
			textBuildingLayout.gameObject.SetActive(true);
			yield return 0;
            
			dungeon.DestroyDungeon();
			yield return 0;

			dungeon.Build();
			
			textBuildingLayout.text = labelBuildingLayout + "DONE!";

			textBuildingNavMesh.text = labelBuildingNavmesh;
			textBuildingNavMesh.gameObject.SetActive(true);
			yield return 0;
            
			npcSpawner.OnPostDungeonBuild(dungeon, dungeon.ActiveModel);

			levelLoadingScreen.SetActive(false);
            if (minimap != null)
            {
                minimap.SetActive(true);
            }

			// reset player health
			var player = GameObject.FindGameObjectWithTag(GameTags.Player);
			if (player != null) {
				var health = player.GetComponent<PlayerHealth>();
				if (health != null) {
					health.currentHealth = health.startingHealth;
				}
			}

			// Destroy any npc too close to the player
			var enemyControllers = GameObject.FindObjectsOfType<AIController>();
			var playerPosition = player.transform.position;
            foreach (var enemyController in enemyControllers)
            {
                var enemy = enemyController.gameObject;
				var distance = (playerPosition - enemy.transform.position).magnitude;
				if (distance < 1) {
					Destroy (enemy);
				}
			}
	    }
	}
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Game\LevelGoal.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame {
    public class LevelGoal : MonoBehaviour {
		void OnTriggerEnter(Collider other) {
			// Create a new level
			if (other.gameObject.CompareTag(GameTags.Player)) {
				GameController.Instance.CreateNewLevel();
			}
		}

		void Update() {
			if (Input.GetKeyDown(KeyCode.Space)) {
				GameController.Instance.CreateNewLevel();
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Helpers\BeautyShot.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
#if	UNITY_EDITOR
using UnityEditor;
#endif

using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame {
	public class BeautyShot : MonoBehaviour
	{
		public string generateFilename()
		{
			//var frame = Backstage.Director.PlayheadInFrames;
			//var frame = Backstage.frameCount;
			var frame = Time.frameCount;
			return string.Format("/{0}.png", frame + frameOffset );
		}


		public LayerMask layerMask;

		public int frameRate = 60;
		public float duration = 10;
		public int	frameOffset = 0;
		private float numFrames;
		
		public bool captureUsingScreenshot = false;
		
		public enum Supersample
		{
			None = 1,
			Two = 2,
			Four = 4,
			Eight = 8,
			Sixteen = 16,
			Wtf = 32
		};
		
		public Supersample supersampleScreenshot = Supersample.None;

#if UNITY_EDITOR
        private string _folder = "";
        private Texture2D _result = null;
#endif // UNITY_EDITOR


        void Start()
		{
			if( !Application.isPlaying )
				return;

	#if	UNITY_EDITOR
			Application.runInBackground = true;
			Time.captureFramerate = frameRate;
			numFrames = duration * frameRate;

			var path = "BeautyShots/scene/{1}";

			//	"640 k ought to be enough for anybody."
			for( var count = 0; count < 640000; count++ )
			{
				_folder = string.Format( path, count );
				if( !System.IO.Directory.Exists( _folder ) )
					break;
			}

			System.IO.Directory.CreateDirectory( _folder );
			_result = new Texture2D( Screen.width, Screen.height, TextureFormat.RGB24, false );
	#endif
		}

	#if	UNITY_EDITOR
		private byte[] captureCam( Camera cam, int w, int h )
		{
			var oldcullmask = cam.cullingMask;
			cam.cullingMask = layerMask;
			RenderTexture rt = RenderTexture.GetTemporary( w, h );

			var tmp = cam.targetTexture;
			cam.targetTexture = rt;
			cam.Render();

			RenderTexture.active = rt;
			_result.ReadPixels( new Rect( 0, 0, w, h ), 0, 0, false );
			cam.targetTexture = tmp;
			cam.cullingMask = oldcullmask;
			return _result.EncodeToPNG();
		}
	#endif
		
	#if	UNITY_EDITOR
		void OnPostRender()
		{
			var filename = _folder + generateFilename();
            if (captureUsingScreenshot == false)
            {
#if !UNITY_WEBPLAYER
                var cam = Camera.current;
                if (cam != null)
                {
                    System.IO.File.WriteAllBytes(filename, captureCam(cam, Screen.width, Screen.height));
                    Debug.Log("File written");
                }
                else
                    Debug.LogError("Cam is null?");
#endif
            }
            else
            {
               // ScreenCapture.CaptureScreenshot(filename, (int)supersampleScreenshot);
            }

			if( Time.frameCount % frameRate == 0 )
				Debug.Log( string.Format( "{0} second rendered, {1} total frames.", Time.frameCount / Time.captureFramerate, Time.frameCount ) );
			
			if( Time.frameCount > numFrames )
			{
				Debug.Log( string.Format( "Capture done, {0} second rendered, {1} total frames.", Time.frameCount / Time.captureFramerate, Time.frameCount ) );
				Application.runInBackground = false;
				EditorApplication.isPlaying = false; 		}
		}
	#endif
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Helpers\RandomAnimationPoint.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame {
	public class RandomAnimationPoint : MonoBehaviour
	{
	    public bool randomize;
	    [Range(0f, 1f)] public float normalizedTime;


	    void OnValidate ()
	    {
	        GetComponent<Animator> ().Update (0f);
	        GetComponent <Animator> ().Play ("Walk", 0, randomize ? Random.value : normalizedTime);
	    }
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Helpers\RandomParticlePoint.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame {
	public class RandomParticlePoint : MonoBehaviour 
	{
	    [Range(0f, 1f)]
	    public float normalizedTime;


	    void OnValidate()
	    {
	        GetComponent<ParticleSystem>().Simulate (normalizedTime, true, true);
	    }
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Helpers\VolumeHandler.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.UI;


namespace DungeonArchitect.Samples.ShooterGame {
	public class VolumeHandler : MonoBehaviour {

		// Use this for initialization
		void Start () 
		{
			if(GameObject.Find("EffectsSlider"))
			GameObject.Find("EffectsSlider").GetComponent<Slider>().onValueChanged.AddListener(SetVolume);
		}

		void SetVolume(float volume)
		{
			GetComponent<AudioSource>().volume = volume;
		}

		void OnDestroy()
		{
			if(GameObject.Find("EffectsSlider"))
			GameObject.Find("EffectsSlider").GetComponent<Slider>().onValueChanged.RemoveListener(SetVolume);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Managers\EnemyManager.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class EnemyManager : MonoBehaviour
    {
        public PlayerHealth playerHealth;       // Reference to the player's heatlh.
        public GameObject enemy;                // The enemy prefab to be spawned.
        public float spawnTime = 3f;            // How long between each spawn.
        public Transform[] spawnPoints;         // An array of the spawn points this enemy can spawn from.


        void Start ()
        {
            // Call the Spawn function after a delay of the spawnTime and then continue to call after the same amount of time.
            InvokeRepeating ("Spawn", spawnTime, spawnTime);
        }


        void Spawn ()
        {
            // If the player has no health left...
            if(playerHealth.currentHealth <= 0f)
            {
                // ... exit the function.
                return;
            }

            // Find a random index between zero and one less than the number of spawn points.
            int spawnPointIndex = Random.Range (0, spawnPoints.Length);

            // Create an instance of the enemy prefab at the randomly selected spawn point's position and rotation.
            Instantiate (enemy, spawnPoints[spawnPointIndex].position, spawnPoints[spawnPointIndex].rotation);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Managers\GameOverManager.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class GameOverManager : MonoBehaviour
    {
        public PlayerHealth playerHealth;       // Reference to the player's health.


        Animator anim;                          // Reference to the animator component.


        void Awake ()
        {
            // Set up the reference.
            anim = GetComponent <Animator> ();
        }


        void Update ()
        {
            // If the player has run out of health...
            if(playerHealth.currentHealth <= 0)
            {
                // ... tell the animator the game is over.
                anim.SetTrigger ("GameOver");
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Managers\PauseManager.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.Audio;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace DungeonArchitect.Samples.ShooterGame {
	public class PauseManager : MonoBehaviour {
		
		public AudioMixerSnapshot paused;
		public AudioMixerSnapshot unpaused;
		
		Canvas canvas;
		
		void Start()
		{
			canvas = GetComponent<Canvas>();
		}
		
		void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				canvas.enabled = !canvas.enabled;
				Pause();
			}
		}
		
		public void Pause()
		{
			Time.timeScale = Time.timeScale == 0 ? 1 : 0;
			Lowpass ();
			
		}
		
		void Lowpass()
		{
			if (Time.timeScale == 0)
			{
				paused.TransitionTo(.01f);
			}
			
			else
				
			{
				unpaused.TransitionTo(.01f);
			}
		}
		
		public void Quit()
		{
			#if UNITY_EDITOR 
			EditorApplication.isPlaying = false;
			#else 
			Application.Quit();
			#endif
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Managers\ScoreManager.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.UI;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class ScoreManager : MonoBehaviour
    {
        public static int score;        // The player's score.


        Text text;                      // Reference to the Text component.


        void Awake ()
        {
            // Set up the reference.
            text = GetComponent <Text> ();

            // Reset the score.
            score = 0;
        }


        void Update ()
        {
            // Set the displayed text to be the word "Score" followed by the score value.
            text.text = "Score: " + score;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\MiniMap\MiniMapCameraTracker.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;


namespace DungeonArchitect.Samples.ShooterGame
{
    public class MiniMapCameraTracker : MonoBehaviour
    {
        public Transform trackingTransform;
        public Transform baseDungeonTransform;
        public Transform dotTransform;


        // Use this for initialization
        void Start()
        {

        }

        // Update is called once per frame
        void Update()
        {
            var delta = trackingTransform.position - baseDungeonTransform.position;
            gameObject.transform.localPosition = delta;
            dotTransform.rotation = trackingTransform.rotation;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\MiniMap\MiniMapEnemyDots.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Samples.ShooterGame {
	public class MiniMapEnemyDots : MonoBehaviour {
		public GameObject enemyDotTemplate;
		public Queue<GameObject> dots = new Queue<GameObject>();
		public Transform baseDungeon;
		public Transform miniMapDungeon;

		Vector3 offset;
		// Use this for initialization
		void Start () {
			offset = miniMapDungeon.position - baseDungeon.position;
		}
		
		// Update is called once per frame
		void Update () {
			var enemyControllers = GameObject.FindObjectsOfType<AIController>();
			var currentDots = new Queue<GameObject>();
			foreach (var enemyController in enemyControllers) {
                var enemyObject = enemyController.gameObject;
                EnemyHealth health = enemyObject.GetComponent<EnemyHealth>();
				if (health == null) continue;
				if (health.currentHealth > 0) {
                    var dot = BuildDot(enemyObject);
                    currentDots.Enqueue(dot);
				}
			}

			// Destroy all unused dots
			foreach (var dot in dots) {
				Destroy (dot);
			}
			dots = currentDots;
		}

		GameObject BuildDot(GameObject enemy) {
			GameObject dot = null;
			if (dots.Count == 0) {
				// Dot pool exhausted. Build a new one
				dot = Instantiate(enemyDotTemplate) as GameObject;
				dot.transform.parent = gameObject.transform;
			}
			else {
				// Reuse an existing one
				dot = dots.Dequeue();
			}

			dot.transform.position = offset + enemy.transform.position;
			dot.transform.rotation = enemy.transform.rotation;

			return dot;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\MiniMap\MiniMapGenerator.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Graphs;


namespace DungeonArchitect.Samples.ShooterGame
{
    public class MiniMapGenerator : MonoBehaviour
    {
        public List<Graph> miniMapThemes;
        GameObject miniMapDungeonObject;
        Dungeon minimapDungeon;

        // Use this for initialization
        public void BuildMiniMap(Dungeon baseDungeon)
        {
            if (miniMapDungeonObject == null)
            {
                miniMapDungeonObject = Instantiate(baseDungeon.gameObject);
            }

            // Move the mini-map dungeon down
            minimapDungeon = miniMapDungeonObject.GetComponent<Dungeon>();
            minimapDungeon.transform.position = gameObject.transform.position;

            // Disable unwanted components from the cloned minimap dungeon
            DisableComponent<WaypointGenerator>(miniMapDungeonObject);
            DisableComponent<LevelNpcSpawner>(miniMapDungeonObject);
            DisableComponent<SpecialRoomFinder>(miniMapDungeonObject);
            DisableComponent<MiniMapRebuilder>(miniMapDungeonObject);

            // Apply the mini-map themes and rebuild
            minimapDungeon.dungeonThemes = miniMapThemes;
            minimapDungeon.Config.Seed = baseDungeon.Config.Seed;
            minimapDungeon.Build();
        }

        public void DestroyDungeon()
        {
            if (minimapDungeon != null)
            {
                minimapDungeon.DestroyDungeon();
            }

        }

        void DisableComponent<T>(GameObject obj) where T : MonoBehaviour
        {
            var component = obj.GetComponent<T>();
            if (component != null)
            {
                component.enabled = false;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\MiniMap\MiniMapRebuilder.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
namespace DungeonArchitect.Samples.ShooterGame
{
    public class MiniMapRebuilder : DungeonEventListener
    {
        public MiniMapGenerator miniMap;

        /// <summary>
        /// Called after the dungeon is completely built
        /// </summary>
        /// <param name="model">The dungeon model</param>
        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            miniMap.BuildMiniMap(dungeon);
        }

        /// <summary>
        /// Called after the dungeon is destroyed
        /// </summary>
        /// <param name="model">The dungeon model</param>
        public override void OnDungeonDestroyed(Dungeon dungeon)
        {
            miniMap.DestroyDungeon();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\MiniMap\MiniMapRenderer.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class MiniMapRenderer : MonoBehaviour
    {
        public Texture miniMapRtt;
        public Material miniMapMat;
        public int width = 256;
        public int height = 256;


        // Use this for initialization
        void Start()
        {

        }

        // Update is called once per frame
        void Update()
        {
        }


        void OnGUI()
        {
            if (Event.current.type.Equals(EventType.Repaint))
            {
                var padding = 10;
                var x = Screen.width - width - padding;
                var y = Screen.height - height - padding;
                var rect = new Rect(x, y, width, height);
                Graphics.DrawTexture(rect, miniMapRtt, miniMapMat);
            }

        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Player\PlayerHealth.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.UI;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class PlayerHealth : MonoBehaviour
    {
        public int startingHealth = 100;                            // The amount of health the player starts the game with.
        public int currentHealth;                                   // The current health the player has.
        public Slider healthSlider;                                 // Reference to the UI's health bar.
        public Image damageImage;                                   // Reference to an image to flash on the screen on being hurt.
        public AudioClip deathClip;                                 // The audio clip to play when the player dies.
        public float flashSpeed = 5f;                               // The speed the damageImage will fade at.
        public Color flashColour = new Color(1f, 0f, 0f, 0.1f);     // The colour the damageImage is set to, to flash.


        Animator anim;                                              // Reference to the Animator component.
        AudioSource playerAudio;                                    // Reference to the AudioSource component.
        PlayerMovement playerMovement;                              // Reference to the player's movement.
        PlayerShooting playerShooting;                              // Reference to the PlayerShooting script.
        bool isDead;                                                // Whether the player is dead.
        bool damaged;                                               // True when the player gets damaged.


        void Awake ()
        {
            // Setting up the references.
            anim = GetComponent <Animator> ();
            playerAudio = GetComponent <AudioSource> ();
            playerMovement = GetComponent <PlayerMovement> ();
            playerShooting = GetComponentInChildren <PlayerShooting> ();

            // Set the initial health of the player.
            currentHealth = startingHealth;
        }


        void Update ()
        {
            if (damageImage != null)
            {
                // If the player has just been damaged...
                if (damaged)
                {
                    if (damageImage)
                    {
                        // ... set the colour of the damageImage to the flash colour.
                        damageImage.color = flashColour;
                    }
                }
                // Otherwise...
                else
                {
                    if (damageImage)
                    {
                        // ... transition the colour back to clear.
                        damageImage.color = Color.Lerp(damageImage.color, Color.clear, flashSpeed * Time.deltaTime);
                    }
                }
            }

            // Reset the damaged flag.
            damaged = false;
        }


        public void TakeDamage (int amount)
        {
            // Set the damaged flag so the screen will flash.
            damaged = true;

            // Reduce the current health by the damage amount.
            currentHealth -= amount;

            // Set the health bar's value to the current health.
            healthSlider.value = currentHealth;

            // Play the hurt sound effect.
            playerAudio.Play ();

            // If the player has lost all it's health and the death flag hasn't been set yet...
            if(currentHealth <= 0 && !isDead)
            {
                // ... it should die.
                Death ();
            }
        }


        void Death ()
        {
            // Set the death flag so this function won't be called again.
            isDead = true;

            // Turn off any remaining shooting effects.
            playerShooting.DisableEffects ();

            // Tell the animator that the player is dead.
            anim.SetTrigger ("Die");

            // Set the audiosource to play the death clip and play it (this will stop the hurt sound from playing).
            playerAudio.clip = deathClip;
            playerAudio.Play ();

            // Turn off the movement and shooting scripts.
            playerMovement.enabled = false;
            playerShooting.enabled = false;
        }


        public void RestartLevel ()
        {
            // Reload the level that is currently loaded.
            //Application.LoadLevel (Application.loadedLevel);
            var activeScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene();
            UnityEngine.SceneManagement.SceneManager.LoadScene(activeScene.buildIndex);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Player\PlayerMovement.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class PlayerMovement : MonoBehaviour
    {
        public float speed = 6f;            // The speed that the player will move at.
		public float gravity = -4;

		CharacterController character;
        Vector3 movement;                   // The vector to store the direction of the player's movement.
        Animator anim;                      // Reference to the animator component.
        //Rigidbody playerRigidbody;          // Reference to the player's rigidbody.
        //int floorMask;                      // A layer mask so that a ray can be cast just at gameobjects on the floor layer.
        float camRayLength = 100f;          // The length of the ray from the camera into the scene.

        void Awake ()
        {

            // Set up references.
            anim = GetComponent <Animator> ();
			character = GetComponent<CharacterController>();
            character.enabled = false;
            //playerRigidbody = GetComponent <Rigidbody> ();
        }

        public void OnTeleportered()
        {
            character.enabled = true;
        }

        void FixedUpdate ()
        {
            // Store the input axes.
			float h = Input.GetAxisRaw("Horizontal");
            float v = Input.GetAxisRaw("Vertical");

            // Move the player around the scene.
            Move (h, v);

            // Turn the player to face the mouse cursor.
            Turning ();

            // Animate the player.
            Animating (h, v);
        }


        void Move (float h, float v)
        {
            // Set the movement vector based on the axis input.
            movement.Set (h, 0f, v);
            
            // Normalise the movement vector and make it proportional to the speed per second.
            movement = movement.normalized * speed * Time.deltaTime;
			movement.y += gravity * Time.deltaTime;

            if (character.enabled)
            {
                character.Move(movement);
            }
        }


        void Turning ()
        {
            // Create a ray from the mouse cursor on screen in the direction of the camera.
            Ray camRay = Camera.main.ScreenPointToRay (Input.mousePosition);

            // Create a RaycastHit variable to store information about what was hit by the ray.
            RaycastHit floorHit;

            // Perform the raycast and if it hits something on the floor layer...
            if(Physics.Raycast (camRay, out floorHit, camRayLength))
            {
                // Create a vector from the player to the point on the floor the raycast from the mouse hit.
                Vector3 playerToMouse = floorHit.point - transform.position;

                // Ensure the vector is entirely along the floor plane.
                playerToMouse.y = 0f;

                // Create a quaternion (rotation) based on looking down the vector from the player to the mouse.
                Quaternion newRotatation = Quaternion.LookRotation (playerToMouse);

                // Set the player's rotation to this new rotation.
				transform.rotation = newRotatation;
                //playerRigidbody.MoveRotation (newRotatation);
            }
        }


        void Animating (float h, float v)
        {
            // Create a boolean that is true if either of the input axes is non-zero.
            bool walking = h != 0f || v != 0f;

            // Tell the animator whether or not the player is walking.
            anim.SetBool ("IsWalking", walking);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Player\PlayerShooting.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
    public class PlayerShooting : MonoBehaviour
    {
        public int damagePerShot = 20;                  // The damage inflicted by each bullet.
        public float timeBetweenBullets = 0.15f;        // The time between each shot.
        public float range = 100f;                      // The distance the gun can fire.


        float timer;                                    // A timer to determine when to fire.
        public Ray shootRay;                                   // A ray from the gun end forwards.
        RaycastHit shootHit;                            // A raycast hit to get information about what was hit.
        ParticleSystem gunParticles;                    // Reference to the particle system.
        LineRenderer gunLine;                           // Reference to the line renderer.
        AudioSource gunAudio;                           // Reference to the audio source.
        Light gunLight;                                 // Reference to the light component.
		public Light faceLight;								// Duh
        float effectsDisplayTime = 0.2f;                // The proportion of the timeBetweenBullets that the effects will display for.


        void Awake ()
        {
            // Set up the references.
            gunParticles = GetComponent<ParticleSystem> ();
            gunLine = GetComponent <LineRenderer> ();
            gunAudio = GetComponent<AudioSource> ();
            gunLight = GetComponent<Light> ();
			//faceLight = GetComponentInChildren<Light> ();
        }


        void Update ()
        {
            // Add the time since Update was last called to the timer.
            timer += Time.deltaTime;

            // If the Fire1 button is being press and it's time to fire...
			if(Input.GetButton ("Fire1") && timer >= timeBetweenBullets && Time.timeScale != 0)
            {
                // ... shoot the gun.
                Shoot ();
            }

			// If the timer has exceeded the proportion of timeBetweenBullets that the effects should be displayed for...
            if(timer >= timeBetweenBullets * effectsDisplayTime)
            {
                // ... disable the effects.
                DisableEffects ();
            }
        }


        public void DisableEffects ()
        {
            // Disable the line renderer and the light.
            gunLine.enabled = false;
			faceLight.enabled = false;
            gunLight.enabled = false;
        }


        void Shoot ()
        {
            // Reset the timer.
            timer = 0f;

            // Play the gun shot audioclip.
            gunAudio.Play ();

            // Enable the lights.
            gunLight.enabled = true;
			faceLight.enabled = true;

            // Stop the particles from playing if they were, then start the particles.
            gunParticles.Stop ();
            gunParticles.Play ();

            // Enable the line renderer and set it's first position to be the end of the gun.
            gunLine.enabled = true;
            gunLine.SetPosition (0, transform.position);

            // Set the shootRay so that it starts at the end of the gun and points forward from the barrel.
            shootRay.origin = transform.position;
            shootRay.direction = transform.forward;

            // Perform the raycast against gameobjects on the shootable layer and if it hits something...
            if(Physics.Raycast (shootRay, out shootHit, range))
            {
                // Try and find an EnemyHealth script on the gameobject hit.
                EnemyHealth enemyHealth = shootHit.collider.GetComponent <EnemyHealth> ();

                // If the EnemyHealth component exist...
                if(enemyHealth != null)
                {
                    // ... the enemy should take damage.
                    enemyHealth.TakeDamage (damagePerShot, shootHit.point);
                }

                // Set the second position of the line renderer to the point the raycast hit.
                gunLine.SetPosition (1, shootHit.point);
            }
            // If the raycast didn't hit anything on the shootable layer...
            else
            {
                // ... set the second position of the line renderer to the fullest extent of the gun's range.
                gunLine.SetPosition (1, shootRay.origin + shootRay.direction * range);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Utils\BillboardGizmo.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

public class BillboardGizmo : MonoBehaviour {
	public string iconName = "flag_icon.png";
	void OnDrawGizmos() {
		Gizmos.DrawIcon(gameObject.transform.position, iconName, true);
		transform.localScale = new Vector3(.2f, .2f, .2f);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Utils\GameTags.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;


namespace DungeonArchitect.Samples.ShooterGame
{
	public class GameTags : MonoBehaviour {
		public static readonly string Player = "Player";
	
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Waypoints\Waypoint.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.ShooterGame
{
	public class Waypoint : MonoBehaviour {
		public int id;

		[SerializeField]
		Waypoint[] adjacentWaypoints = new Waypoint[0];

		public Waypoint[] AdjacentWaypoints {
			get {
				return adjacentWaypoints;
			}
			set {
				adjacentWaypoints = value;
			}
		}

		public override string ToString ()
		{
			if (gameObject == null) {
				return base.ToString();
			}
			return gameObject.transform.position.ToString();
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Waypoints\WaypointGenerator.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Builders.SimpleCity;

namespace DungeonArchitect.Samples.ShooterGame
{
	public class WaypointGenerator : DungeonEventListener {
		public GameObject waypointTemplate;
		public GameObject waypointParent;
		public Vector3 waypointOffset = Vector3.up;
		bool mode2D = false;

        public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers) 
		{
            BuildWaypoints(model, markers);
        }

        public void BuildWaypoints(DungeonModel model, LevelMarkerList markers)
        {
            // Destroy all existing waypoints
            DestroyAllWaypoints();

            if (model is GridDungeonModel)
            {
                BuildGridWaypoints(model as GridDungeonModel, markers);
            }
            else if (model is SimpleCityDungeonModel)
            {
                BuildCityWaypoints(model as SimpleCityDungeonModel);
            }
            else
            {
                Debug.LogWarning("Waypoint generator does not support model of type: " + model.GetType());
                return;
            }
        }

        void BuildGridWaypoints(GridDungeonModel gridModel, LevelMarkerList markers)
        {
            mode2D = gridModel.Config.Mode2D;

			// Destroy all existing waypoints
			DestroyAllWaypoints();

			var cellToWaypoint = new Dictionary<int, Waypoint>();

			int idCounter = 1;

            var wall2DPositions = new HashSet<IntVector>();
            if (mode2D)
            {
                foreach (var marker in markers)
                {
                    if (marker.SocketType == GridDungeonMarkerNames.Wall2D)
                    {
                        wall2DPositions.Add(marker.gridPosition);
                    }
                }
            }

			// Create a waypoint on each cell
	        foreach (var cell in gridModel.Cells)
	        {
                if (mode2D)
                {
                    if (wall2DPositions.Contains(cell.Bounds.Location))
                    {
                        // Don't want to create a waypoint on a wall tile
                        continue;
                    }
                }
	            var worldPos = MathUtils.GridToWorld(gridModel.Config.GridCellSize, cell.CenterF);
				worldPos += waypointOffset;
				if (mode2D) {
					worldPos = FlipYZ(worldPos);
				}
				var waypointObject = Instantiate(waypointTemplate, worldPos, Quaternion.identity) as GameObject;
				waypointObject.transform.parent = waypointParent.transform;

				var waypoint = waypointObject.GetComponent<Waypoint>();
				waypoint.id = idCounter++;
				cellToWaypoint.Add (cell.Id, waypoint);
			}

			// Connect adjacent waypoints
			foreach (var cellId in cellToWaypoint.Keys) {
				var waypoint = cellToWaypoint[cellId];
	            var cell = gridModel.GetCell(cellId);
				var adjacentWaypoints = new List<Waypoint>();
                var visited = new HashSet<int>();
				foreach (var adjacentCellId in cell.AdjacentCells) {
                    if (visited.Contains(GetHash(cellId, adjacentCellId))) continue;

	                var adjacentCell = gridModel.GetCell(adjacentCellId);
					// add only if there is a direct path to it (through a door or stair or open space)
	                bool directPath = HasDirectPath(gridModel, cell, adjacentCell);
					if (directPath) {
						if (cellToWaypoint.ContainsKey(adjacentCellId)) {
							var adjacentWaypoint = cellToWaypoint[adjacentCellId];
                            adjacentWaypoints.Add(adjacentWaypoint);
                            visited.Add(GetHash(cellId, adjacentCellId));
                            visited.Add(GetHash(adjacentCellId, cellId));
						}
					}
				}
				waypoint.AdjacentWaypoints = adjacentWaypoints.ToArray();
			}
		}

        void BuildCityWaypoints(SimpleCityDungeonModel model)
        {
            var cells = model.Cells;
            var width = cells.GetLength(0);
            var height = cells.GetLength(1);
            var cellSize = new Vector3(model.Config.CellSize.x, 0, model.Config.CellSize.y);
            int idCounter = 1;
            var cellToWaypoint = new Dictionary<SimpleCityCell, Waypoint>();
            var adjacentWaypoints = new Dictionary<Waypoint, List<Waypoint>>();

            for (int x = 0; x < width; x++)
            {
                for (int z = 0; z < height; z++)
                {
                    var cell = cells[x, z];
                    if (cell.CellType == SimpleCityCellType.Road)
                    {
                        // Create a waypoint here
                        var worldPos = Vector3.Scale(cellSize, new Vector3(x, 0, z));
                        worldPos += waypointOffset;
                        var waypointObject = Instantiate(waypointTemplate, worldPos, Quaternion.identity) as GameObject;
                        waypointObject.transform.parent = waypointParent.transform;

                        var waypoint = waypointObject.GetComponent<Waypoint>();
                        adjacentWaypoints.Add(waypoint, new List<Waypoint>());
                        waypoint.id = idCounter++;
                        cellToWaypoint.Add(cell, waypoint);
                    }
                }
            }

            for (int x = 0; x < width; x++)
            {
                for (int z = 0; z < height; z++)
                {
                    var cell = cells[x, z];
                    // connect to adjacent road tiles
                    ConnectAdjacentRoadTiles(model, cell, 0, -1, cellToWaypoint, adjacentWaypoints);
                    ConnectAdjacentRoadTiles(model, cell, -1, 0, cellToWaypoint, adjacentWaypoints);
                }
            }

            foreach (var waypoint in cellToWaypoint.Values)
            {
                waypoint.AdjacentWaypoints = adjacentWaypoints[waypoint].ToArray();
            }
        }

        void ConnectAdjacentRoadTiles(SimpleCityDungeonModel model, SimpleCityCell cell, int dx, int dz,
            Dictionary<SimpleCityCell, Waypoint> cellToWaypoint, Dictionary<Waypoint, List<Waypoint>> adjacentWaypoints)
        {
            int adjacentX = cell.Position.x + dx;
            int adjacentZ = cell.Position.z + dz;
            if (adjacentX < 0 || adjacentZ < 0) return;
            var adjacentCell = model.Cells[adjacentX, adjacentZ];
            if (cell.CellType == SimpleCityCellType.Road && adjacentCell.CellType == SimpleCityCellType.Road)
            {
                // Connect the two cells
                var waypoint1 = cellToWaypoint[cell];
                var waypoint2 = cellToWaypoint[adjacentCell];

                adjacentWaypoints[waypoint1].Add(waypoint2);
                adjacentWaypoints[waypoint2].Add(waypoint1);
            }
        }

        int GetHash(int a, int b)
        {
            return a << 16 | b;
        }

	    bool HasDirectPath(GridDungeonModel gridModel, Cell cellA, Cell cellB)
	    {
			bool directPath = true;
			if (cellA.CellType == CellType.Room || cellB.CellType == CellType.Room) {
	            directPath = gridModel.DoorManager.ContainsDoorBetweenCells(cellA.Id, cellB.Id);
			}
			else {
				// Check if we have a fence separating them if they have different heights
				if (cellA.Bounds.Location.y != cellB.Bounds.Location.y) {
	                directPath = gridModel.ContainsStair(cellA.Id, cellB.Id);
				}
			}
			return directPath;
		}

		public override void OnDungeonDestroyed(Dungeon dungeon) {
			DestroyAllWaypoints();
		}

		void DestroyAllWaypoints() {
			var oldWaypoints = GameObject.FindObjectsOfType<Waypoint>();
			foreach (var waypoint in oldWaypoints) {
				if (Application.isPlaying) {
					Destroy(waypoint.gameObject);
				} else {
                    DestroyImmediate(waypoint.gameObject);
				}
			}
		}

		Vector3 FlipYZ(Vector3 v) {
			return new Vector3(v.x, v.z, v.y);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Scripts\Waypoints\WaypointPathVisualizer.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;


namespace DungeonArchitect.Samples.ShooterGame
{
	public class WaypointPathVisualizer : MonoBehaviour {
		public Color pathColor = Color.cyan;

		void OnDrawGizmosSelected() {
			DrawWaypointPaths();
		}

		void DrawWaypointPaths() {
			Gizmos.color = pathColor;
			// Draw the connection of waypoints
			var waypoints = GameObject.FindObjectsOfType<Waypoint>();
			foreach (var waypoint in waypoints) {
				if (waypoint == null) continue;
				var startPosition = waypoint.gameObject.transform.position;
				DrawPoint(startPosition);
				foreach (var adjacentWaypoint in waypoint.AdjacentWaypoints) {
					var endPosition = adjacentWaypoint.gameObject.transform.position;
					DrawLine(startPosition, endPosition);
				}
			}
		}

		void DrawLine(Vector3 a, Vector3 b) {
			/*
			if (mode2D) {
				Gizmos.DrawLine(FlipYZ(a), FlipYZ(b));
			}
			else {
				Gizmos.DrawLine(a, b);
			}
			*/
			Gizmos.DrawLine(a, b);
		}

		void DrawPoint(Vector3 p) {
			/*
			if (mode2D) {
				Gizmos.DrawWireSphere(FlipYZ(p), 0.1f);
			} else {
				Gizmos.DrawWireSphere(p, 0.1f);
			}
			*/
			Gizmos.DrawWireSphere(p, 0.1f);
		}

		Vector3 FlipYZ(Vector3 v) {
			return new Vector3(v.x, v.z, v.y);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Game3D_SurvivalShooter\Themes\Rules\MMRoomSelector.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect.Builders.Grid;

namespace DungeonArchitect.Samples.ShooterGame {
	public class MMRoomSelector : SelectorRule {
		
		public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
		{
			if (model is GridDungeonModel) {
				var gridModel = model as GridDungeonModel;
				var cell = gridModel.GetCell(socket.cellId);
				if (cell != null) {
					return cell.CellType == CellType.Room;
				}
			}
			return false;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Scripts\FindRoomDoorsDemo\SampleFindRoomDoorsController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect.Builders.Grid;

namespace DungeonArchitect.Samples
{
    public class SampleFindRoomDoorsController : MonoBehaviour
    {
        public Dungeon dungeon;
        public Transform player;

        GridDungeonConfig config;
        GridDungeonQuery dungeonQuery;
        
        private void Awake()
        {
            if (dungeon != null)
            {
                dungeonQuery = dungeon.GetComponent<GridDungeonQuery>();
                config = dungeon.GetComponent<GridDungeonConfig>();
            }
        }

        void Start()
        {
            if (dungeon != null)
            {
                dungeon.Build();
            }

            // Place the player on a valid dungeon platform
            {
                Cell cell = dungeonQuery.GetRandomCell();
                var cellBounds = cell.GetWorldBounds(config.GridCellSize);
                player.transform.position = cellBounds.center;
            }
        }

        ///////////////////// Find the doors for the room the player is on and handle them ///////////////////// 
        void Update()
        {
            // Find the cell the player is on
            if (dungeonQuery != null)
            {
                Cell cell;
                if (dungeonQuery.GetCellAtPosition(player.position, out cell))
                {
                    GameObject[] doorObjects = new GameObject[0];
                    if (cell.CellType == CellType.Room)
                    {
                        // The player is inside a room. 
                        // Grab the spawned door game objects
                        dungeonQuery.GetDoorsForCell(cell.Id, out doorObjects);
                    }

                    // Do something with the door objects
                    ProcessDoorObjects(doorObjects);
                }
            }
        }

        ///////////////////// Custom game code to handle the door logic ///////////////////// 
        // In this example, the active doors are colored red
        void ProcessDoorObjects(GameObject[] doorObjects)
        {
            // This code finds the new objects that were tracked and paints them red
            
            // First restore the previously tracked door colors
            foreach (var trackedDoor in trackedDoorObjects)
            {
                var renderer = trackedDoor.gameObject.GetComponent<Renderer>();
                if (renderer != null)
                {
                    renderer.material.color = Color.white;
                }
            }

            // Set the color of the newly tracked doors to red
            trackedDoorObjects = doorObjects;
            foreach (GameObject trackedDoor in trackedDoorObjects)
            {
                var renderer = trackedDoor.gameObject.GetComponent<Renderer>();
                if (renderer != null)
                {
                    renderer.material.color = Color.red;
                }
            }
            
        }

        GameObject[] trackedDoorObjects = new GameObject[0];
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Scripts\NavigationDemo\NavigationDemoController.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.AI;
using DungeonArchitect.Builders.Grid;

namespace DungeonArchitect.Samples.Navigation
{
    public class NavigationDemoController : MonoBehaviour
    {
        public Dungeon dungeon;
        public GameObject player;
        public GameObject[] npcs;
        public Vector3 spawnOffset;

        // Use this for initialization
        void Awake()
        {
            dungeon.Config.Seed = (uint)Random.Range(0, 100000);
            dungeon.Build();

            TeleportToValidPlatform(player);
            foreach (var npc in npcs)
            {
                TeleportToValidPlatform(npc);
            }
        }

        void TeleportToValidPlatform(GameObject obj)
        {
            if (obj == null) return;

            var gridModel = dungeon.ActiveModel as GridDungeonModel;
            var gridConfig = dungeon.Config as GridDungeonConfig;
            int numCells = gridModel.Cells.Count;
            if (numCells > 0)
            {
                int randomCellIndex = Random.Range(0, numCells);
                var cell = gridModel.Cells[randomCellIndex];
                var cellCenter = Vector3.Scale(cell.Bounds.CenterF(), gridConfig.GridCellSize);
                var tilePosition = cellCenter + spawnOffset;
                var hit = new NavMeshHit();
                if (NavMesh.SamplePosition(tilePosition, out hit, 1.0f, NavMesh.AllAreas))
                {
                    obj.transform.position = hit.position;
                }
                else
                {
                    Debug.LogError("Failed to place " + obj.name + " in nav mesh");
                }

            }
        }

        // Update is called once per frame
        void Update()
        {

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Scripts\NavigationDemo\NavigationDemoNPC.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.AI;

namespace DungeonArchitect.Samples.Navigation
{
    public class NavigationDemoNPC : MonoBehaviour
    {
        NavMeshAgent agent;
        CharacterController character;

        public Transform target;

        void Awake()
        {
            agent = GetComponent<NavMeshAgent>();
            character = GetComponent<CharacterController>();
        }

        void Update()
        {
            if (target != null)
            {
                agent.SetDestination(target.position);

                if (agent.remainingDistance > agent.stoppingDistance)
                {
                    character.SimpleMove(agent.desiredVelocity);
                }
                else
                {
                    character.SimpleMove(Vector3.zero);
                }
            }
            
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Misc_Examples\Scripts\NavigationDemo\NavigationDemoPlayer.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.Navigation
{
    public class NavigationDemoPlayer : MonoBehaviour
    {
        CharacterController character;
        void Awake()
        {
            character = GetComponent<CharacterController>();
        }

        public float speed = 3.0F;
        public float rotateSpeed = 3.0F;

        void FixedUpdate()
        {
            transform.Rotate(0, Input.GetAxis("Horizontal") * rotateSpeed, 0);
            Vector3 forward = transform.TransformDirection(Vector3.forward);
            float curSpeed = speed * Input.GetAxis("Vertical");
            character.SimpleMove(forward * curSpeed);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\DeveloperTools\Editor\SceneLightmapBaker.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.SceneManagement;

namespace DungeonArchitect.Editors.DevTools
{
    public class SceneLightmapBaker
    {
        static void SetupLightSettings()
        {
            Lightmapping.realtimeGI = false;
            Lightmapping.bakedGI = false;
            Lightmapping.giWorkflowMode = Lightmapping.GIWorkflowMode.OnDemand;
        }


        //[MenuItem("Dungeon Architect/Internal Dev Tools/Lightmap/Clear Current", priority = 2001)]
        public static void ClearCurrentScene()
        {
            Lightmapping.Clear();
            Lightmapping.ClearLightingDataAsset();
        }

        //[MenuItem("Dungeon Architect/Internal Dev Tools/Lightmap/Bake Current", priority = 2002)]
        public static void BakeCurrentScene()
        {
            SetupLightSettings();
            ClearCurrentScene();
            Lightmapping.Bake();
        }

        [MenuItem("Window/Rendering/Dungeon Architect/Internal Dev Tools/Clear Lighting on All Samples", priority = 2021)]
        public static void ClearAllScenes()
        {
            bool proceed = EditorUtility.DisplayDialog("Build Lighting", "Are you sure you want to clear lighting data on all the scenes?", "Yes", "No");
            if (proceed)
            {
                OpenAllScenes(() => ClearCurrentScene(), false);
            }
        }


        [MenuItem("Window/Rendering/Dungeon Architect/Internal Dev Tools/Bake Lighting on All Samples", priority = 2021)]
        public static void BakeAllScenes()
        {
            bool build = EditorUtility.DisplayDialog("Build Lighting", "Are you sure you want to build lighting on all the scenes?", "Yes", "No");
            if (build)
            {
                OpenAllScenes(() => BakeCurrentScene(), true);
            }
        }

        static void OpenAllScenes(System.Action action, bool saveAfterAction)
        {
            if (action == null)
            {
                return;
            }

            var assetPaths = AssetDatabase.GetAllAssetPaths();
            var scenePaths = new List<string>();
            foreach (var assetPath in assetPaths)
            {
                if (assetPath.EndsWith(".unity") && assetPath.StartsWith("Assets/CodeRespawn"))
                {
                    if (!assetPath.Contains("DungeonArchitect_LaunchPad"))
                    {
                        scenePaths.Add(assetPath);
                    }
                }
            }
            foreach (var scenePath in scenePaths)
            {
                EditorSceneManager.OpenScene(scenePath);
                action.Invoke();

                if (saveAfterAction)
                {
                    EditorSceneManager.MarkAllScenesDirty();
                    EditorSceneManager.SaveOpenScenes();
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Demo\DemoHUD.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

public class DemoHUD : MonoBehaviour {

    public GUIStyle guiStyle;

    void OnGUI()
    {
        var bounds = new Rect(10, 10, 200, 70);
        GUI.Label(bounds, "Right Click - Look Around \nWASD - Move \nSpace - Generate New layout", guiStyle);
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Demo\RegenerateDungeonLayout.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections;
using DungeonArchitect;


public class RegenerateDungeonLayout : MonoBehaviour {
    public Dungeon dungeon;

    /// <summary>
    /// If we have static geometry already in the level created during design time, then the pooled scene
    /// provider cannot re-use it because the editor would have performed optimizations on it and might not be able to move it
    /// This flag clears out any design time static geometry before rebuilding to avoid movement issues of static objects
    /// </summary>
    bool performCleanRebuild = true;

	// Use this for initialization
	void Start () {
        StartCoroutine(RebuildDungeon());
	}
	
	// Update is called once per frame
	void Update () {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            StartCoroutine(RebuildDungeon());
        }
	}

    IEnumerator RebuildDungeon()
    {
        if (dungeon != null)
        {
            if (performCleanRebuild)
            {
                // We want to remove design time data with a clean destroy since editor would allow modification of optimized static game objects
                // We want to do this only for the first time
                dungeon.DestroyDungeon();
                performCleanRebuild = false;

                // Wait for 1 frame to make sure our design time objects were destroyed
                yield return 0;
            }

            // Build the dungeon
            var config = dungeon.Config;
            if (config != null)
            {
                config.Seed = (uint)(Random.value * uint.MaxValue);
                dungeon.Build();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Emitters\CornerEmitter3D.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect;
using DungeonArchitect.Builders.Grid;

class CellSpatialConfig3D
{
    public string MarkerName;

    //// Neighbor config flags
    //  0: Don't care
    //  1: Land
    //  2: Empty Space
    /////////////////////////
    public int[] NeighborConfig;

    public float RotationOffsetZ = 0;

    public bool StopOnFound = true;
};

public class CornerEmitter3D : DungeonMarkerEmitter
{
    List<CellSpatialConfig3D> CornerConfigs = new List<CellSpatialConfig3D>();
    public bool mergeRoomCorridor = false;

    void RegisterConfig(string MarkerName, int[] NeighborConfig)
    {
        RegisterConfig(MarkerName, NeighborConfig, true);
    }
    void RegisterConfig(string MarkerName, int[] NeighborConfig, bool StopOnFound)
    {
        {
            var Config = new CellSpatialConfig3D();
            Config.MarkerName = MarkerName;
            Config.NeighborConfig = NeighborConfig;
            Config.RotationOffsetZ = 0;
            Config.StopOnFound = StopOnFound;
            CornerConfigs.Add(Config);
        }

        var RotatedMap = NeighborConfig;
        // rotate 3 times by 90 degrees to get all 4 config rotated around 360 degrees
        for (int i = 1; i < 4; i++)
        {
            RotatedMap = Rotate90(RotatedMap);
            var Config = new CellSpatialConfig3D();
            Config.MarkerName = MarkerName;
            Config.NeighborConfig = RotatedMap;
            Config.RotationOffsetZ = i * 90;
            Config.StopOnFound = StopOnFound;
            CornerConfigs.Add(Config);
        }
    }

    int[] Rotate90(int[] NeighborConfig)
    {
        var SrcIndex = new int[] {
           0, 1, 2,
           3, 4, 5,
           6, 7, 8
       };
        var DstIndex = new int[] {
           6, 3, 0,
           7, 4, 1,
           8, 5, 2
       };

        var Result = new int[9];
        for (int i = 0; i < 9; i++)
        {
            Result[DstIndex[i]] = NeighborConfig[SrcIndex[i]];
        }
        return Result;
    }

    public override void EmitMarkers(DungeonBuilder builder)
    {
        Initialize();
        if (!(builder is GridDungeonBuilder))
        {
            Debug.LogWarning("Unsupported builder type used with marker emitter MarkerEmitterFindLowestPoint. Expected GridDungeonBuilder. Received:" + (builder != null ? builder.GetType().ToString() : "null"));
            return;
        }

        var gridModel = builder.Model as GridDungeonModel;

        foreach (var cell in gridModel.Cells)
        {
            var bounds = cell.Bounds;
            for (var x = bounds.X; x < bounds.X + bounds.Width; x++)
            {
                for (var z = bounds.Z; z < bounds.Z + bounds.Length; z++)
                {
                    var point = new IntVector(x, bounds.Location.y, z);
                    EmitForPoint(builder, gridModel, point);
                }
            }
        }
    }

    void EmitForPoint(DungeonBuilder builder, GridDungeonModel model, IntVector point)
    {
        foreach (var config in CornerConfigs)
        {
            if (ConfigMatches(model, point, config))
            {
                EmitCornerMarker(builder, model, point, config.RotationOffsetZ, config.MarkerName);
                if (config.StopOnFound)
                {
                    break;
                }
            }
        }
    }

    bool ConfigMatches(GridDungeonModel Model, IntVector Point, CellSpatialConfig3D Config)
    {
        var centerCellInfo = Model.GetGridCellLookup(Point.x, Point.z);
        var neighbors = Config.NeighborConfig;
        for (int i = 0; i < neighbors.Length; i++)
        {
            int code = neighbors[i];
            if (code == 0)
            {
                // Don't care about this cell
                continue;
            }
            int dx = i % 3;
            int dz = i / 3;
            dx--; dz--;    // bring to -1..1 range (from previous 0..2)
            //dy *= -1;
            int x = Point.x + dx;
            int z = Point.z + dz;

            var cellInfo = Model.GetGridCellLookup(x, z);
            bool empty = cellInfo.CellType == CellType.Unknown;
            if (!centerCellInfo.ContainsDoor)
            {
                empty |= IsRoomCorridor(centerCellInfo.CellType, cellInfo.CellType);
            }
            if (!empty && centerCellInfo.CellType == CellType.Room && cellInfo.CellType == CellType.Room && centerCellInfo.CellId != cellInfo.CellId)
            {
                if (!mergeRoomCorridor)
                {
                    empty = true;
                }
            }
            if (!empty)
            {
                var cell0 = Model.GetCell(cellInfo.CellId);
                var cell1 = Model.GetCell(centerCellInfo.CellId);
                if (cell0.Bounds.Location.y != cell1.Bounds.Location.y)
                {
                    empty = true;
                }
            }

            if (code == 1 && empty)
            {
                // We were expecting a non-empty space here, but it is empty
                return false;
            }
            else if (code == 2 && !empty)
            {
                // We were expecting a empty space here, but it is not empty
                return false;
            }
        }

        // Matches, all tests have passed
        return true;
    }



    bool IsRoomCorridor(CellType type0, CellType type1)
    {
        if (mergeRoomCorridor)
        {
            return false;
        }
        int rooms = 0, corridors = 0;
        rooms += (type0 == CellType.Room) ? 1 : 0;
        rooms += (type1 == CellType.Room) ? 1 : 0;

        corridors += (type0 == CellType.Corridor || type0 == CellType.CorridorPadding) ? 1 : 0;
        corridors += (type1 == CellType.Corridor || type1 == CellType.CorridorPadding) ? 1 : 0;
        return (rooms == 1 && corridors == 1);
    }


    void EmitCornerMarker(DungeonBuilder builder, GridDungeonModel model, IntVector point, float angleY, string markerName)
    {
        var gridSize = model.Config.GridCellSize;
        var position = point * gridSize;
        position += Vector3.Scale(new Vector3(0.5f, 0, 0.5f), gridSize);
        var rotation = Quaternion.Euler(0, angleY, 0);
        var transform = Matrix4x4.TRS(position, rotation, Vector3.one);
        builder.EmitMarker(markerName, transform, point, -1);
    }

    void Initialize()
    {
        CornerConfigs.Clear();
        RegisterConfig("Corner_i", new int[] {
           0, 0, 0,
           2, 1, 0,
           0, 2, 0
       }, false);
        RegisterConfig("Corner_e", new int[] {
           0, 1, 2,
           0, 1, 1,
           0, 0, 0
       }, false);

        RegisterConfig("Floor_r_c", new int[] {
           0, 1, 1,
           2, 1, 1,
           0, 2, 0
       });
        RegisterConfig("Floor_r_s", new int[] {
           0, 1, 0,
           1, 1, 1,
           0, 2, 0
       });
        RegisterConfig("Floor_r_f", new int[] {
           0, 1, 0,
           1, 1, 1,
           0, 1, 0
       });
        RegisterConfig("Floor_c_s", new int[] {
           0, 1, 0,
           2, 1, 2,
           0, 1, 0
       });
        RegisterConfig("Floor_c_se", new int[] {
           0, 2, 0,
           2, 1, 2,
           0, 1, 0
       });
        RegisterConfig("Floor_c_t", new int[] {
           0, 2, 0,
               1, 1, 1,
               2, 1, 2
       });
        RegisterConfig("Floor_c_t", new int[] {
           0, 2, 0,
           1, 1, 1,
           2, 1, 2
       });
        RegisterConfig("Floor_c_c", new int[] {
           0, 1, 2,
           2, 1, 1,
           2, 2, 0
       });
        RegisterConfig("Floor_c_x", new int[] {
           2, 1, 2,
           1, 1, 1,
           2, 1, 2
       });

        RegisterConfig("Floor_fallback", new int[] {
           0, 0, 0,
           0, 1, 0,
           0, 0, 0
       });
    }

}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Emitters\GaiaLandscapeModifier.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Landscape;

public class GaiaLandscapeModifier : DungeonEventListener
{
    public Terrain terrain;
    public int corridorTextureIndex = 0;

    public int roadBlurDistance = 6;
    public float corridorBlurThreshold = 0.5f;

    public bool modifyTextures = true;
    public bool modifyDetails = true;      

	public override void OnPostDungeonLayoutBuild(Dungeon dungeon, DungeonModel model) {
        var gridModel = model as GridDungeonModel;
        if (modifyTextures) {
            UpdateTerrainTextures(gridModel);
        }
        if (modifyDetails)
        {
            UpdateTerrainDetails(gridModel);
        }
    }

    void UpdateTerrainDetails(GridDungeonModel model)
    {
        if (terrain == null || terrain.terrainData == null) return;

        var data = terrain.terrainData;
        for (int layer = 0; layer < data.alphamapLayers; layer++)
        {
            var map = data.GetDetailLayer(0, 0, data.detailWidth, data.detailHeight, layer);
            UpdateDetailTexture(model, map);
            data.SetDetailLayer(0, 0, layer, map);
        }
    }

    void UpdateTerrainTextures(GridDungeonModel model)
    {
        if (terrain == null || terrain.terrainData == null) return;

        var data = terrain.terrainData;
        var map = data.GetAlphamaps(0, 0, data.alphamapWidth, data.alphamapHeight);
        UpdateBaseTexture(model, map);
        data.SetAlphamaps(0, 0, map);
    }


    void UpdateDetailTexture(GridDungeonModel model, int[,] map)
    {
        var gridSize = model.Config.GridCellSize;
        
        foreach (var cell in model.Cells)
        {
            var bounds = cell.Bounds;
            var locationGrid = bounds.Location;
            var location = locationGrid * gridSize;
            var size = bounds.Size * gridSize;
            int gx1, gy1, gx2, gy2;
            LandscapeDataRasterizer.WorldToTerrainDetailCoord(terrain, location.x, location.z, out gx1, out gy1);
            LandscapeDataRasterizer.WorldToTerrainDetailCoord(terrain, location.x + size.x, location.z + size.z, out gx2, out gy2);
            for (var gx = gx1; gx <= gx2; gx++)
            {
                for (var gy = gy1; gy <= gy2; gy++)
                {
                    map[gy, gx] = 0;
                }
            }
        }
    }

    void UpdateBaseTexture(GridDungeonModel model, float[, ,] map)
    {
        var gridSize = model.Config.GridCellSize;
        var layoutMap = new float[map.GetLength(0), map.GetLength(1)];

        foreach (var cell in model.Cells)
        {
            var bounds = cell.Bounds;
            var locationGrid = bounds.Location;
            var location = locationGrid * gridSize;
            var size = bounds.Size * gridSize;
            int gx1, gy1, gx2, gy2;
            LandscapeDataRasterizer.WorldToTerrainTextureCoord(terrain, location.x, location.z, out gx1, out gy1);
            LandscapeDataRasterizer.WorldToTerrainTextureCoord(terrain, location.x + size.x, location.z + size.z, out gx2, out gy2);
            for (var gx = gx1; gx <= gx2; gx++)
            {
                for (var gy = gy1; gy <= gy2; gy++)
                {
                    layoutMap[gy, gx] = 1;
                }
            }
        }

        // Blur the layout data
        var filter = new BlurFilter(roadBlurDistance);
        layoutMap = filter.ApplyFilter(layoutMap);
        var data = terrain.terrainData;

        // Fill up the inner region with corridor index
        for (var y = 0; y < data.alphamapHeight; y++)
        {
            for (var x = 0; x < data.alphamapWidth; x++)
            {
                bool corridor = (layoutMap[y, x] > corridorBlurThreshold);
                if (corridor)
                {
                    for (int layer = 0; layer < data.alphamapLayers; layer++)
                    {
                        var weight = (layer == corridorTextureIndex) ? 1 : 0;
                        map[y, x, layer] = weight;
                    }
                }
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Emitters\IsaacMarkerEmitter_RoomCenter.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.Isaac;

public class IsaacMarkerEmitter_RoomCenter : DungeonMarkerEmitter
{
    public override void EmitMarkers(DungeonBuilder builder)
    {
        var model = builder.Model as IsaacDungeonModel;
        if (model == null) return;
        var config = model.config as IsaacDungeonConfig;
        if (config == null) return;

        var tileSize = new Vector3(config.tileSize.x, 0, config.tileSize.y);
        var roomSizeWorld = new IntVector(config.roomWidth, 0, config.roomHeight) * tileSize;
        var roomPadding = new Vector3(config.roomPadding.x, 0, config.roomPadding.y);

        string markerNameRoomCenter = "RoomCenter";
        string markerNameRoomCorner = "RoomCorner";
        bool alignCenterWithGrid = false;

        foreach (var room in model.rooms)
        {
            var roomBasePosition = room.position * (roomSizeWorld + roomPadding);
            var roomWidth = room.layout.Tiles.GetLength(0);
            var roomHeight = room.layout.Tiles.GetLength(1);

            // Insert the room center
            {
                var centerPosition = new Vector3(roomWidth - 1, 0, roomHeight - 1) * 0.5f;
                if (alignCenterWithGrid)
                {
                    centerPosition.x = Mathf.FloorToInt(centerPosition.x);
                    centerPosition.z = Mathf.FloorToInt(centerPosition.z);
                }

                var tileOffset = Vector3.Scale(centerPosition, tileSize);
                var markerPosition = roomBasePosition + tileOffset;
                var transform = Matrix4x4.TRS(markerPosition, Quaternion.identity, Vector3.one);
                builder.EmitMarker(markerNameRoomCenter, transform, new IntVector(centerPosition), room.roomId);
            }

            // Insert the room corners
            {
                var cornerCoords = new Vector3[]
                {
                    new Vector3(0, 0, 0),
                    new Vector3(roomWidth - 1, 0, 0),
                    new Vector3(roomWidth - 1, 0, roomHeight - 1),
                    new Vector3(0, 0, roomHeight - 1)
                };

                var cornerAngles = new float[] { 0, 270, 180, 90 };

                for (int i = 0; i < 4; i++)
                {
                    var gridCoord = cornerCoords[i];
                    var tileOffset = Vector3.Scale(gridCoord, tileSize);
                    var markerPosition = roomBasePosition + tileOffset;
                    var rotation = Quaternion.Euler(0, cornerAngles[i], 0);
                    var transform = Matrix4x4.TRS(markerPosition, rotation, Vector3.one);
                    builder.EmitMarker(markerNameRoomCorner, transform, new IntVector(gridCoord), room.roomId);
                }
            }

        }

    }


}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Emitters\MarkerTerrainClampListener.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Landscape;

public class MarkerTerrainClampListener : DungeonEventListener {
    
    public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers) 
    {
        var terrain = Terrain.activeTerrain;
        if (terrain == null) return;

        foreach (var marker in markers)
        {
            var clampedPosition = GetClampedPosition(ref marker.Transform, terrain);
            Matrix.SetTranslation(ref marker.Transform, clampedPosition);
        }
    }

    Vector3 GetClampedPosition(ref Matrix4x4 mat, Terrain terrain)
    {
        var position = Matrix.GetTranslation(ref mat);
        position.y = LandscapeDataRasterizer.GetHeight(terrain, position.x, position.z);
        return position;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Emitters\RoomMidEmitter.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.Grid;

public class RoomMidEmitter : DungeonMarkerEmitter {
	
	public override void EmitMarkers(DungeonBuilder builder)
	{
		var model = builder.Model as GridDungeonModel;
		if (model == null) return;
		var config = model.Config as GridDungeonConfig;
		if (config == null) return;

		var cellSize = config.GridCellSize;
		foreach (var cell in model.Cells) {
			var bounds = cell.Bounds;
			var cx = (bounds.Location.x + bounds.Size.x / 2.0f) * cellSize.x;
			var cy = bounds.Location.y * cellSize.y;
			var cz = (bounds.Location.z + bounds.Size.z / 2.0f) * cellSize.z;
			var position = new Vector3(cx, cy, cz);
			var transform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
			var markerName = (cell.CellType == CellType.Room) ? "RoomCenter" : "CorridorCenter";
			builder.EmitMarker(markerName, transform, cell.Bounds.Location, cell.Id);
		}

	}


}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\FPSController\DAFPSMouseLook.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Samples.Common
{
    public class DAFPSMouseLook : MonoBehaviour
    {
        public float lookSpeed = 1.25f;
        public Transform playerBody;

        float angleUpDown = 0;

        public void Start()
        {
            Cursor.lockState = CursorLockMode.Locked;
        }

        private void Update()
        {
            float mouseX = Input.GetAxis("Mouse X") * lookSpeed;
            float mouseY = Input.GetAxis("Mouse Y") * lookSpeed;

            angleUpDown -= mouseY;
            angleUpDown = Mathf.Clamp(angleUpDown, -90, 90);
            transform.localRotation = Quaternion.Euler(angleUpDown, 0, 0);

            if (playerBody != null)
            {
                playerBody.Rotate(0, mouseX, 0);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\FPSController\DAFPSMovement.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.Common
{
    public class DAFPSMovement : MonoBehaviour
    {
        public float speed = 12;
        public float gravity = -9.81f;
        public bool enableJumping = false;
        public float jumpHeight = 1;

        public CharacterController controller;
        float speedY = 0;

        void Update()
        {
            if (controller == null) return;

            var x = Input.GetAxis("Horizontal") * speed * Time.deltaTime;
            var z = Input.GetAxis("Vertical") * speed * Time.deltaTime;

            Vector3 move = transform.right * x + transform.forward * z;

            if (controller.isGrounded)
            {
                speedY = 0;
                if (enableJumping && Input.GetButton("Jump"))
                {
                    speedY += jumpHeight;
                }
            }
            speedY += gravity * Time.deltaTime;

            move.y = speedY * Time.deltaTime;
            controller.Move(move);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\AlternateSelectionRule.cs:
 using UnityEngine;
using DungeonArchitect;
using Random = System.Random;

public class AlternateSelectionRule : SelectorRule {
    public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random) {
        int rnd = random.Next(4, 6); // Generates a random integer between 2 (inclusive) and 4 (exclusive)
        return (socket.gridPosition.x + socket.gridPosition.z) % rnd == 0;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\BrokenTilesTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;

public class BrokenTilesTransformRule : TransformationRule {

	public float maxAngle = 5;

	public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale) {
		base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);
		
		var rx = random.Range(-maxAngle, maxAngle);
		var ry = random.Range(-maxAngle, maxAngle);
		var rz = random.Range(-maxAngle, maxAngle);
	
		outRotation = Quaternion.Euler(rx, ry, rz);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\ClampToGroundTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;

public class ClampToGroundTransformRule : TransformationRule {
	
	public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale) {
		base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);

		// Get the ground location at this position
        if (model is GridDungeonModel)
        {
			var gridModel = model as GridDungeonModel;
            var config = gridModel.Config as GridDungeonConfig;
            var positionWorld = Matrix.GetTranslation(ref propTransform);
			var gridCoord = MathUtils.WorldToGrid(positionWorld, config.GridCellSize);
			var cellInfo = gridModel.GetGridCellLookup(gridCoord.x, gridCoord.z);
			if (cellInfo.CellType != CellType.Unknown) {
				var cell = gridModel.GetCell(socket.cellId);
				var cellY = cell.Bounds.Location.y * config.GridCellSize.y;
				var markerY = Matrix.GetTranslation(ref propTransform).y;
				var deltaY = cellY - markerY;
				outPosition.y = deltaY;
			}
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\ClampToTerrainTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Landscape;

public class ClampToTerrainTransformRule : TransformationRule {
	
	public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale) {
		base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);

		var terrain = Terrain.activeTerrain;
		if (terrain == null) {
			return;
		}

		var position = Matrix.GetTranslation(ref propTransform);
		var currentY = position.y;
		var targetY = LandscapeDataRasterizer.GetHeight(terrain, position.x, position.z);

		outPosition.y = targetY - currentY;

        // HACK
        {
            /*
            var baseScale = Matrix.GetScale(ref propTransform);
            outPosition.x /= baseScale.x;
            outPosition.y /= baseScale.y;
            outPosition.z /= baseScale.z;
            */
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\NonDoorTileSelectionRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;

public class NonDoorTileSelectionRule : SelectorRule {
	public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random) {
		if (model is GridDungeonModel) {
			var gridModel = model as GridDungeonModel;
			var config = gridModel.Config as GridDungeonConfig;
			var cellSize = config.GridCellSize;

			var position = Matrix.GetTranslation(ref propTransform);
			var gridPositionF = MathUtils.Divide (position, cellSize);
			var gridPosition = MathUtils.ToIntVector(gridPositionF);
			var cellInfo = gridModel.GetGridCellLookup(gridPosition.x, gridPosition.z);
			return !cellInfo.ContainsDoor;
		} else {
			return false;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\NonStairRoomTileSelectorRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;

public class NonStairRoomTileSelectorRule : NonViewBlockingSelectionRule {
    public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random) {
        var selected = base.CanSelect(socket, propTransform, model, random);
        if (!selected) return false;

        // Further filter near the door positions
        if (model is GridDungeonModel)
        {
            var gridModel = model as GridDungeonModel;
            var position = Matrix.GetTranslation(ref propTransform);
            var gridSize = gridModel.Config.GridCellSize;
            var x = Mathf.FloorToInt(position.x / gridSize.x);
            var z = Mathf.FloorToInt(position.z / gridSize.z);
            var cellInfo = gridModel.GetGridCellLookup(x, z);
            bool isRoom = cellInfo.CellType == CellType.Room;
            bool containsStair = gridModel.ContainsStairAtLocation(x, z);
            return isRoom && !containsStair;
        }

        return false;
    }

}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\NonStairTileSelectorRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;
using DungeonArchitect.Builders.Grid;

public class NonStairTileSelectorRule : NonViewBlockingSelectionRule
{
    public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
    {
        var selected = base.CanSelect(socket, propTransform, model, random);
        if (!selected) return false;

        // Further filter near the door positions
        if (model is GridDungeonModel)
        {
            var gridModel = model as GridDungeonModel;
            var position = Matrix.GetTranslation(ref propTransform);
            var gridSize = gridModel.Config.GridCellSize;
            var x = Mathf.FloorToInt(position.x / gridSize.x);
            var z = Mathf.FloorToInt(position.z / gridSize.z);
            return !gridModel.ContainsStairAtLocation(x, z);
        }

        return false;
    }

}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\NonViewBlockingPillarSelectorRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.Grid;

public class NonViewBlockingPillarSelectorRule : NonViewBlockingSelectionRule {
	public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random) {
		var selected = base.CanSelect(socket, propTransform, model, random);
		if (!selected) return false;

		// Further filter near the door positions
		var cellId = socket.cellId;
		if (model is GridDungeonModel) {
			var gridModel = model as GridDungeonModel;
			foreach (var door in gridModel.Doors) {
				if (door.AdjacentCells.Length == 2) {
					if (door.AdjacentCells[0] == cellId || door.AdjacentCells[1] == cellId) {
						return false;
					}
				}
			}
			// Check if a door exists in this location
			//gridModel.DoorManager.ContainsDoorBetweenCells

			var cell = gridModel.GetCell(socket.cellId);
			if (cell == null) return false;
		}

		return true;
	}


}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\NonViewBlockingSelectionRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;

public class NonViewBlockingSelectionRule : SelectorRule {
	static Vector3[] validDirections = new Vector3[] {
		new Vector3(1, 0, 0),
		new Vector3(0, 0, 1),
	};

	public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random) {
		var rotation = Matrix.GetRotation(ref socket.Transform);
		var baseDirection = new Vector3(1, 0, 0);
		var direction = rotation * baseDirection;
		foreach (var testDirection in validDirections) {
			var dot = Vector3.Dot(direction, testDirection);
			if (dot > 0.707f) return true;
		}
		return false;
	}

}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\RandomCliffTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;

public class RandomCliffTransformRule : TransformationRule {
	
	public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale) {
		base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);
		
		var angle = random.NextFloat() * 360;
		var rotation = Quaternion.Euler(0, angle, 0);
		outRotation = rotation;

		var variation = new Vector3(0.25f, -1, 0.25f);
		outPosition = Vector3.Scale (random.OnUnitSphere(), variation);


	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\RandomRotY90TransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;

public class RandomRotY90TransformRule : TransformationRule {
	
	public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale) {
		base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);

        var angle = random.Range(0, 1) * 90;
		var rotation = Quaternion.Euler(0, angle, 0);
		outRotation = rotation;
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\RandomRotYTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;

public class RandomRotYTransformRule : TransformationRule {
	
	public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale) {
		base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);

		var angle = random.value() * 360;
		var rotation = Quaternion.Euler(0, angle, 0);
		outRotation = rotation;
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\RoomSelectionRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Builders.Grid;

public class RoomSelectionRule : SelectorRule {
	public override bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random) {
		if (model is GridDungeonModel) {
			var gridModel = model as GridDungeonModel;
			var cell = gridModel.GetCell(socket.cellId);
			if (cell == null) return false;
			return cell.CellType == CellType.Room;
		} else {
			return false;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\SmallYTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;

public class SmallYTransformRule : TransformationRule {
	public float angleVariation = 8;

	public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale) {
		base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);

		var randomVal = random.value() * 2 - 1;
		var angle = randomVal * angleVariation;
		var rotation = Quaternion.Euler(0, angle, 0);
		outRotation = rotation;
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Rules\ZFightingFixTransformRule.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using DungeonArchitect;

public class ZFightingFixTransformRule : TransformationRule {

	float movementDistance = 0.01f;

	public override void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale) {
		base.GetTransform(socket, model, propTransform, random, out outPosition, out outRotation, out outScale);

		// Apply a small random transform to avoid z-fighting
		outPosition = random.OnUnitSphere() * movementDistance;
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Utils\AADisableChecker.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DADemo_Sample_Utils
{
    public class AADisableChecker : MonoBehaviour
    {
        // Use this for initialization
        void Start()
        {
            bool active = false;
            if (QualitySettings.antiAliasing > 0)
            {
                active = true;
            }
            gameObject.SetActive(active);
        }

        // Update is called once per frame
        void Update()
        {

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Utils\CameraMovement.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

public class CameraMovement : MonoBehaviour {
	public float movementSpeed = 15;

	// Use this for initialization
	void Start () {
	
	}
	
	// Update is called once per frame
	void Update () {
		float forward = Input.GetAxis ("Vertical"); 
		float right = Input.GetAxis ("Horizontal"); ;
		var distance = movementSpeed * Time.deltaTime;

		// forward movement
		gameObject.transform.position += transform.forward * distance * forward;

		// strafe movement
		gameObject.transform.position += transform.right * distance * right;
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Utils\DestroyOnStart.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

public class DestroyOnStart : MonoBehaviour {

	// Use this for initialization
	void Start () {
		Destroy (gameObject);
	}
	
	// Update is called once per frame
	void Update () {
	
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\Support\Scripts\Utils\SimpleSmoothMouseLook.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

// Very simple smooth mouselook modifier for the MainCamera in Unity
// by Francis R. Griffiths-Keam - www.runningdimensions.com

[AddComponentMenu("Camera/Simple Smooth Mouse Look ")]
public class SimpleSmoothMouseLook : MonoBehaviour
{
	Vector2 _mouseAbsolute;
	Vector2 _smoothMouse;
	
	public Vector2 clampInDegrees = new Vector2(360, 180);
	public bool lockCursor;
	public Vector2 sensitivity = new Vector2(2, 2);
	public Vector2 smoothing = new Vector2(3, 3);
	public Vector2 targetDirection;
	public Vector2 targetCharacterDirection;


	// Assign this if there's a parent object controlling motion, such as a Character Controller.
	// Yaw rotation will affect this object instead of the camera if set.
	public GameObject characterBody;
	
	void Start()
	{
		// Set target direction to the camera's initial orientation.
		targetDirection = transform.localRotation.eulerAngles;
		
		// Set target direction for the character body to its inital state.
		if (characterBody) targetCharacterDirection = characterBody.transform.localRotation.eulerAngles;
	}
	
	void Update()
	{
		// Ensure the cursor is always locked when set
		Cursor.lockState = lockCursor ? CursorLockMode.Locked : CursorLockMode.None;
		//Screen.lockCursor = lockCursor;
		
		// Allow the script to clamp based on a desired target value.
		var targetOrientation = Quaternion.Euler(targetDirection);
		var targetCharacterOrientation = Quaternion.Euler(targetCharacterDirection);
		
		// Get raw mouse input for a cleaner reading on more sensitive mice.
		var mouseDelta = new Vector2(Input.GetAxisRaw("Mouse X"), Input.GetAxisRaw("Mouse Y"));
		if (!Input.GetMouseButton(1)) {
			//return;
			mouseDelta = new Vector2(0, 0);
		}
		
		// Scale input against the sensitivity setting and multiply that against the smoothing value.
		mouseDelta = Vector2.Scale(mouseDelta, new Vector2(sensitivity.x * smoothing.x, sensitivity.y * smoothing.y));
		
		// Interpolate mouse movement over time to apply smoothing delta.
		_smoothMouse.x = Mathf.Lerp(_smoothMouse.x, mouseDelta.x, 1f / smoothing.x);
		_smoothMouse.y = Mathf.Lerp(_smoothMouse.y, mouseDelta.y, 1f / smoothing.y);
		
		// Find the absolute mouse movement value from point zero.
		_mouseAbsolute += _smoothMouse;
		
		// Clamp and apply the local x value first, so as not to be affected by world transforms.
		if (clampInDegrees.x < 360)
			_mouseAbsolute.x = Mathf.Clamp(_mouseAbsolute.x, -clampInDegrees.x * 0.5f, clampInDegrees.x * 0.5f);
		
		var xRotation = Quaternion.AngleAxis(-_mouseAbsolute.y, targetOrientation * Vector3.right);
		transform.localRotation = xRotation;
		
		// Then clamp and apply the global y value.
		if (clampInDegrees.y < 360)
			_mouseAbsolute.y = Mathf.Clamp(_mouseAbsolute.y, -clampInDegrees.y * 0.5f, clampInDegrees.y * 0.5f);
		
		transform.localRotation *= targetOrientation;
		
		// If there's a character body that acts as a parent to the camera
		if (characterBody)
		{
			var yRotation = Quaternion.AngleAxis(_mouseAbsolute.x, characterBody.transform.up);
			characterBody.transform.localRotation = yRotation;
			characterBody.transform.localRotation *= targetCharacterOrientation;
		}
		else
		{
			var yRotation = Quaternion.AngleAxis(_mouseAbsolute.x, transform.InverseTransformDirection(Vector3.up));
			transform.localRotation *= yRotation;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\Dungeon\Markers\PlaceableMarkerEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors
{
    [CustomEditor(typeof(PlaceableMarker))]
    public class PlaceableMarkerEditor : Editor
    {
        private SerializedObject sobject;
        private SerializedProperty supportedMarkers;
        
        private SerializedProperty debugColor;
        private SerializedProperty debugText;

        private void OnEnable()
        {
            sobject = new SerializedObject(target);
            supportedMarkers = sobject.FindProperty("supportedMarkers");
            
            debugColor = sobject.FindProperty("debugColor");
            debugText = sobject.FindProperty("debugText");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            
            GUILayout.Label("Placeable Marker", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox(new GUIContent("Provide a list of possible markers that can be spawned here.  If the builder needs to spawn one of these, it will be spawned here"));
            EditorGUILayout.PropertyField(supportedMarkers, true);
            EditorGUILayout.Space();

            GUILayout.Label("Debug Visuals", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(debugColor);
            EditorGUILayout.PropertyField(debugText);
            EditorGUILayout.Space();
            
            sobject.ApplyModifiedProperties();
        }

        protected virtual void OnSceneGUI()
        {
            if (Event.current.type == EventType.Repaint)
            {
                var placeableMarker = target as PlaceableMarker;
                Transform transform = placeableMarker.transform;
                Handles.color = Handles.xAxisColor;

                {
                    Vector3 position = placeableMarker.transform.position + Vector3.up * 1.0f;
                    string posString = position.ToString();

                    GUIStyle style = new GUIStyle(GUI.skin.button);
                    style.alignment = TextAnchor.MiddleCenter;
                    Handles.Label(position, placeableMarker.debugText, style);
                }

                {
                    Handles.color = placeableMarker.debugColor;
                    Handles.ArrowHandleCap(
                        0,
                        transform.position,
                        transform.rotation,
                        1.0f,
                        EventType.Repaint
                    );
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\SpatialConstraints\NodeEditors\SCBaseDomainNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.Graphs.SpatialConstraints;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.SpatialConstraints
{
    /// <summary>
    /// Renders a marker node
    /// </summary>
    public class SCDomainNodeRenderer : GraphNodeRenderer
    {
        Color GetNodeColor(SCBaseDomainNode node)
        {
            var color = node.GetColor();

            if (!node.IsSnapped)
            {
                color = Color.red;
            }

            color.a = node.Selected ? 1.0f : 0.33f;
            return color;
        }

        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            var guiState = new GUIState(renderer);
            var domainNode = node as SCBaseDomainNode;
            var ringTexture = renderer.GetResource<Texture2D>(UIResourceLookup.TEXTURE_CURSOR_RING_SOLID) as Texture2D;
            var bounds = camera.WorldToScreen(node.Bounds);
            var color = GetNodeColor(domainNode);
            renderer.DrawTexture(bounds, ringTexture, ScaleMode.ScaleToFit, true, color);

            // Draw the domain, if we are snapped
            if (domainNode.IsSnapped && !domainNode.Dragging)
            {
                const float DomainSizeHi = 0.75f;
                const float DomainSizeLo = 0.15f;
                var domainRectSize = bounds.size;
                if (domainNode.RuleDomain == SCRuleNodeDomain.Corner)
                {
                    domainRectSize = Vector2.one * (SCBaseDomainNode.TileSize * DomainSizeLo);
                }
                else if (domainNode.RuleDomain == SCRuleNodeDomain.Tile)
                {
                    domainRectSize = Vector2.one * (SCBaseDomainNode.TileSize * DomainSizeHi);
                }
                else if (domainNode.RuleDomain == SCRuleNodeDomain.Edge)
                {
                    var coords = domainNode.GetHalfGridLogicalCoords();
                    var localSize = (coords.x == 1) ? new Vector2(DomainSizeHi, DomainSizeLo) : new Vector2(DomainSizeLo, DomainSizeHi);
                    domainRectSize = localSize * SCBaseDomainNode.TileSize;
                }
                domainRectSize /= camera.ZoomLevel;
                var domainBounds = new Rect(bounds.center - domainRectSize / 2.0f, domainRectSize);
                var domainColor = color;
                domainColor.a *= 0.5f;
                renderer.color = domainColor;
                renderer.DrawRect(domainBounds, domainColor);
            }
            guiState.Restore();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\SpatialConstraints\NodeEditors\SCReferenceNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using DungeonArchitect.Graphs.SpatialConstraints;

namespace DungeonArchitect.Editors.SpatialConstraints
{
    [CustomEditor(typeof(SCReferenceNode))]
    public class SCReferenceNodeEditor : SCRuleNodeEditor
    {

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\SpatialConstraints\NodeEditors\SCRuleNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.Graphs.SpatialConstraints;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Editors.SpatialConstraints
{

    [CustomEditor(typeof(SCRuleNode))]
    public class SCRuleNodeEditor : GraphNodeEditor
    {
        RuleNodeEditorUIState uiState;
        SerializedProperty constraintEvaluationMode;
        SerializedProperty exclusionRuleSearchRadius;
        SerializedProperty exclusionRuleMarkersToRemove;
        int activeTab = 0;

        public override void OnEnable()
        {
            base.OnEnable();

            uiState = new RuleNodeEditorUIState();
            constraintEvaluationMode = sobject.FindProperty("constraintEvaluationMode");
            exclusionRuleSearchRadius = sobject.FindProperty("exclusionRuleSearchRadius");
            exclusionRuleMarkersToRemove = sobject.FindProperty("exclusionRuleMarkersToRemove");
        }

        protected override void HandleInspectorGUI()
        {
            var ruleNode = target as SCRuleNode;
            var domainName = ruleNode.RuleDomain.ToString();
            GUILayout.Label(domainName + " Rule Node", EditorStyles.boldLabel);

            string[] tabs = new string[]
            {
                "Constraint Rules",
                "Removal Rules"
            };
            activeTab = GUILayout.Toolbar(activeTab, tabs);
            EditorGUILayout.Space();

            if (activeTab == 0)
            {
                ShowTabConstraintRules();
            }
            else if (activeTab == 1)
            {
                ShowTabRemovalRules();
            }
        }

        protected override void OnGuiChanged()
        {
            var editorWindow = DungeonEditorHelper.GetWindowIfOpen<SpatialConstraintsEditorWindow>();
            if (editorWindow != null)
            {
                var graphEditor = editorWindow.GraphEditor;
                graphEditor.HandleGraphStateChanged(editorWindow.uiSystem);
                graphEditor.HandleNodePropertyChanged(target as GraphNode);
            }
        }

        void ShowTabRemovalRules()
        {
            string helpMessage = "If the spatial constraint graph succeeds, you can optionally remove markers from the scene to accommodate your new setup.  Here is where you specify the markers to be removed, which will be searched for relative to this rule node";
            EditorGUILayout.HelpBox(helpMessage, MessageType.Info);
            
            EditorGUILayout.PropertyField(exclusionRuleMarkersToRemove, new GUIContent("Markers to Remove"), true);
            EditorGUILayout.PropertyField(exclusionRuleSearchRadius, new GUIContent("Search Radius"));
        }

        void ShowTabConstraintRules()
        {
            EmitAddConstraintWidget();

            var ruleNode = target as SCRuleNode;
            EmitEvaluationModeWidget(ruleNode);

            var constraints = ruleNode.constraints.Where(c => c != null);
            foreach (var constraint in constraints)
            {
                if (!uiState.constraintStates.ContainsKey(constraint))
                {
                    var state = new RuleNodeEditorUIState.ConstraintUIState();
                    state.foldout = true;
                    state.enabled = constraint.enabled;
                    uiState.constraintStates.Add(constraint, state);
                }

                var constraintUI = uiState.constraintStates[constraint];
                EmitConstraintScript(constraint, constraintUI);
            }

            if (constraints.Count() == 0)
            {
                EditorGUILayout.HelpBox("Constraint rules allow you to enforce various conditions on the rule node", MessageType.Info);
            }
        }

        // Returns the theme graph asset by moving up the chain from the constraint rule node
        Object GetAssetObject()
        {
            var node = target as SCRuleNode;
            var scGraph = node.Graph as SpatialConstraintGraph;
            if (scGraph == null) return null;
            var scAsset = scGraph.asset;
            if (scAsset.hostThemeNode == null) return null;
            return scAsset.hostThemeNode.Graph;
        }

        void EmitEvaluationModeWidget(SCRuleNode node)
        {
            if (node.constraints.Length <= 1)
            {
                // We have too few rules. No need to show this
                return;
            }

            EditorGUILayout.PropertyField(constraintEvaluationMode);
        }

        void AddConstraintRule(System.Type constraintType)
        {
            var constraint = CreateInstance(constraintType) as ConstraintRule;
            constraint.ruleName = ConstraintRule.GetScriptName(constraintType);

            var ruleNode = target as SCRuleNode;
            var constraintList = new List<ConstraintRule>(ruleNode.constraints);
            constraintList.Add(constraint);
            ruleNode.constraints = constraintList.ToArray();

            // Add this constraint to the theme graph's asset file so it is serialized and not garbage collected
            AssetDatabase.AddObjectToAsset(constraint, GetAssetObject());
        }

        Object GetOwningAsset()
        {
            var ruleNode = target as SCRuleNode;
            var graph = ruleNode.Graph as SpatialConstraintGraph;
            if (graph == null) return null;
            if (graph.asset == null) return null;
            if (graph.asset.hostThemeNode == null) return null;
            return graph.asset.hostThemeNode.Graph;
        }

        void DestroyConstraintRule(ConstraintRule rule)
        {
            var ruleNode = target as SCRuleNode;
            var constraints = new List<ConstraintRule>(ruleNode.constraints);

            Undo.RegisterCompleteObjectUndo(GetOwningAsset(), "Delete Node Spatial Constraint");
            Undo.RecordObject(ruleNode, "Delete Constraint");

            constraints.Remove(rule);
            Undo.DestroyObjectImmediate(rule);

            ruleNode.constraints = constraints.ToArray();
        }

        void EmitConstraintScript(ConstraintRule constraint, RuleNodeEditorUIState.ConstraintUIState constraintUI)
        {
            EditorGUILayout.BeginHorizontal();

            // Draw the enabled toggle box
            constraintUI.enabled = EditorGUILayout.Toggle(constraintUI.enabled, GUILayout.Width(26));

            // Draw the fold out rule text (in bold)
            var origFontStyle = EditorStyles.label.fontStyle;
            EditorStyles.foldout.fontStyle = FontStyle.Bold;
            constraintUI.foldout = EditorGUILayout.Foldout(constraintUI.foldout, constraint.ToString(), true);
            EditorStyles.label.fontStyle = origFontStyle;

            // Draw the close button
            if (GUILayout.Button("x", GUILayout.Width(20)))
            {
                DestroyConstraintRule(constraint);
                constraintUI.foldout = false;
            }
            EditorGUILayout.EndHorizontal();

            if (constraintUI.foldout)
            {
                EditorGUI.indentLevel++;

                // Emit the property fields
                {
                    var csobject = new SerializedObject(constraint);
                    csobject.Update();

                    foreach (var field in constraint.GetType().GetFields())
                    {
                        if (field.GetCustomAttributes(typeof(HideInInspector), true).Length > 0)
                        {
                            // Do not show this property
                            continue;
                        }

                        SerializedProperty property = csobject.FindProperty(field.Name);
                        EditorGUILayout.PropertyField(property);
                    }

                    csobject.ApplyModifiedProperties();
                }
                EditorGUI.indentLevel--;
                EditorGUILayout.Space();
            }
        }

        void HandleAddConstratinMenuClick(object constraintTypeObject)
        {
            var constraintType = constraintTypeObject as System.Type;
            if (constraintType == null)
            {
                Debug.LogError("Invalid constraint type object passed to HandleAddConstratinMenuClick");
                return;
            }

            AddConstraintRule(constraintType);
        }

        void EmitAddConstraintWidget()
        {
            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            int buttonWidth = 250;
            int buttonHeight = 40;
            if (GUILayout.Button(new GUIContent("Add Constraint Rule"), GUILayout.Width(buttonWidth), GUILayout.Height(buttonHeight)))
            {
                var menuPosition = Event.current.mousePosition;
                var rect = new Rect(menuPosition, Vector2.one);
                var menu = new GenericMenu();

                var constraintTypes = Assembly.GetAssembly(typeof(ConstraintRule)).GetTypes()
                    .Where(type => type.IsClass && !type.IsAbstract && type.IsSubclassOf(typeof(ConstraintRule))).ToArray();

                foreach (var type in constraintTypes)
                {
                    var path = ConstraintRule.GetFullMenuPath(type);
                    menu.AddItem(new GUIContent(path), false, HandleAddConstratinMenuClick, type);
                }

                menu.DropDown(rect);
            }

            GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();

            EditorGUILayout.Space();
            EditorGUILayout.Space();

        }

        class RuleNodeEditorUIState
        {
            public int ruleDropDownIndex = 0;
            public Dictionary<ConstraintRule, ConstraintUIState> constraintStates = new Dictionary<ConstraintRule, ConstraintUIState>();

            public class ConstraintUIState
            {
                public bool foldout;
                public bool enabled = true;
            }
        }


    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Core\SpatialConstraints\RuleEditors\ConstraintRuleEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Editors.SpatialConstraints
{
    [CustomEditor(typeof(ConstraintRule))]
    public class ConstraintRuleEditor : GraphNodeEditor
    {
        protected SerializedProperty exclusionRule;

        public override void OnEnable()
        {
            base.OnEnable();
            exclusionRule = sobject.FindProperty("exclusionRule");
        }

        protected override void HandleInspectorGUI()
        {
            GUILayout.Label("Constraint Rule", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(exclusionRule);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\DomainEditors\FlowDomainEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.DomainEditors
{
    public abstract class FlowDomainEditor : ScriptableObject
    {        
        public virtual void Init(IFlowDomain domain, FlowEditorConfig editorConfig, UISystem uiSystem)
        {
            FlowDomain = domain;
            EditorConfig = editorConfig;
        }

        public bool IsInitialized()
        {
            return Content != null;
        }
        
        public FlowEditorConfig EditorConfig { get; private set; }
        public IFlowDomain FlowDomain { get; private set; }
        public abstract IWidget Content { get; protected set; }
        public abstract bool StateValid { get; }
        public abstract void UpdateNodePreview(FlowExecTaskState taskState);
        public virtual void Update() {}
        public virtual void Destroy() {}
        public virtual void Invalidate() {}
        public virtual void SetReadOnly(bool readOnly) {}
        public virtual bool RequiresRepaint() { return false; }
        public virtual void HandleInput(UISystem uiSystem) {}
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Utils\FlowEditorUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors.Flow
{
    public class FlowEditorUtils
    {
        #region Asset Management
        public static void InitAsset(FlowAssetBase asset, UIPlatform platform)
        {
            if (asset == null) return;

            asset.execGraph = CreateAssetObject<FlowExecGraph>(asset);

            InitializeExecutionGraph(asset, platform);
        }

        private static T CreateAssetObject<T>(FlowAssetBase asset) where T : ScriptableObject
        {
            var obj = ScriptableObject.CreateInstance<T>();
            obj.hideFlags = HideFlags.HideInHierarchy;
            AssetDatabase.AddObjectToAsset(obj, asset);
            return obj;
        }

        private static void InitializeExecutionGraph(FlowAssetBase asset, UIPlatform platform)
        {
            // Create an entry node in the execution graph
            var resultNode = CreateGraphNode<FlowExecResultGraphNode>(Vector2.zero, asset.execGraph, asset, platform);
            resultNode.Position = Vector2.zero;
            asset.execGraph.resultNode = resultNode;
            resultNode.task = CreateAssetObject<FlowExecTaskResult>(asset);
        }

        static T CreateGraphNode<T>(Vector2 position, Graph graph, FlowAssetBase asset, UIPlatform platform) where T : GraphNode
        {
            var node = GraphOperations.CreateNode(graph, typeof(T), null);
            GraphEditorUtils.AddToAsset(platform, asset, node);
            return node as T;
        }
        #endregion
        
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Utils\FlowEdSceneUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Flow.Items;

namespace DungeonArchitect.Editors.Flow
{
    public abstract class KeyLockLinkVisualizerBase : Editor
    {
        protected void DrawLine(Component a, Component b)
        {
            if (a == null || b == null) return;
            var rendererA = a.gameObject.GetComponent<Renderer>();
            var rendererB = b.gameObject.GetComponent<Renderer>();
            var posA = rendererA != null ? rendererA.bounds.center : a.gameObject.transform.position;
            var posB = rendererB != null ? rendererB.bounds.center : b.gameObject.transform.position;

            Handles.color = Color.red;
            Handles.DrawLine(posA, posB);
        }
    }

    [CustomEditor(typeof(FlowDoorKeyComponent))]
    public class GridFlowDoorKeyComponentEditor : KeyLockLinkVisualizerBase
    {
        void OnSceneGUI()
        {
            var key = target as FlowDoorKeyComponent;
            if (key != null && key.lockRefs != null)
            {
                foreach (var lockComponent in key.lockRefs) {
                    DrawLine(key, lockComponent);
                }
            }
        }
    }

    [CustomEditor(typeof(FlowDoorLockComponent))]
    public class GridFlowDoorLockComponentEditor : KeyLockLinkVisualizerBase
    {
        void OnSceneGUI()
        {
            var lockComponent = target as FlowDoorLockComponent;
            if (lockComponent != null && lockComponent.validKeyRefs != null)
            {
                foreach (var key in lockComponent.validKeyRefs)
                {
                    DrawLine(key, lockComponent);
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Editors\MarkerGenEditor.cs:
 using DungeonArchitect.Editors.MarkerGenerator.UI.Viewport;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Rule;
using DungeonArchitect.UI;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.Editors
{
    public abstract class MarkerGenEditor
    {
        public abstract System.Type PatternType { get; }
        public abstract System.Type RuleType { get; }
        
        public PatternViewportWidget PatternViewport { get; set; }
        public bool RequestRepaint { get; set; }
        public MarkerGeneratorAsset Asset { get; set; }

        public abstract void Update(double frameTime);
        public abstract void LoadScene(MarkerGenPattern pattern, UIPlatform platform);
        public abstract void HandleInput(Event widgetEvent, UISystem uiSystem);

        public virtual void OnRuleGraphChanged(MarkerGenRule rule) { }
        public virtual void HandleRulePropertyChange(MarkerGenRule rule) { }

        public delegate void OnRuleSelected(MarkerGenRule rule);
        public event OnRuleSelected RuleSelected;

        protected void NotifyRuleSelected(MarkerGenRule rule)
        {
            RuleSelected?.Invoke(rule);
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Editors\MarkerGenEditorFactory.cs:
 using DungeonArchitect.Editors.MarkerGenerator.Editors.Grid;
using DungeonArchitect.MarkerGenerator;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.Editors
{
    public class MarkerGenEditorFactory
    {
        public static MarkerGenEditor Create(MarkerGeneratorAsset asset)
        {
            MarkerGenEditor editor = null;

            if (asset != null)
            {
                if (asset.layoutType == MarkerGeneratorLayoutType.Grid)
                {
                    editor = new GridMarkerGenEditor();
                }
                else
                {
                    Debug.Log("Unsupported pattern match editor implementation: " + asset.layoutType);
                }    
            }
            else
            {
                Debug.Log("Cannot create pattern matcher editor. Invalid asset reference");
            }

            if (editor != null)
            {
                editor.Asset = asset;
            }

            return editor;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Utils\MarkerGenEditorUtils.cs:
 using System;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Editors.MarkerGenerator.TextGen;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Nodes.Actions;
using DungeonArchitect.MarkerGenerator.Nodes.Actions.Info;
using DungeonArchitect.MarkerGenerator.Nodes.Condition;
using DungeonArchitect.MarkerGenerator.Rule;
using DungeonArchitect.MarkerGenerator.VM;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using UnityEditor;
using UnityEngine;
using Random = UnityEngine.Random;

namespace DungeonArchitect.Editors.MarkerGenerator
{
    public class MarkerGenEditorUtils
    {
        public static void InitAsset(MarkerGeneratorAsset asset, UIPlatform platform)
        {
            // TODO: initialize me
        }

        public static MarkerGenPattern AddNewPattern(System.Type patternType, MarkerGeneratorAsset asset, UIPlatform platform)
        {
            if (asset == null) return null;

            var pattern = CreateAssetObject(patternType, asset, platform) as MarkerGenPattern;
            if (pattern != null)
            {
                pattern.patternName = "Pattern";
                asset.patterns = asset.patterns.Concat(new[] { pattern }).ToArray();
            }

            return pattern;
        }
        
        public static T AddNewPattern<T>(MarkerGeneratorAsset asset, UIPlatform platform) where T : MarkerGenPattern
        {
            return AddNewPattern(typeof(T), asset, platform) as T;
        }
        
        public static void RemovePattern(MarkerGeneratorAsset asset, MarkerGenPattern pattern)
        {
            if (asset == null) return;

            asset.patterns = asset.patterns.Where(p => p != pattern).ToArray();

            // Destroy the pattern owned objects
            {
                foreach (var rule in pattern.rules)
                {
                    DestroyAssetObject(rule.ruleGraph);
                    DestroyAssetObject(rule.program);
                    DestroyAssetObject(rule.actions);
                    DestroyAssetObject(rule);
                }

                pattern.rules = Array.Empty<MarkerGenRule>();
            }

            DestroyAssetObject(pattern);
        }
        
        public static T AddNewRule<T>(MarkerGeneratorAsset asset, MarkerGenPattern pattern, UIPlatform platform) where T : MarkerGenRule
        {
            return AddNewRule(typeof(T), asset, pattern, platform) as T;
        }

        public static MarkerGenRule AddNewRule(System.Type ruleType, MarkerGeneratorAsset asset, MarkerGenPattern pattern, UIPlatform platform)
        {
            if (pattern == null) return null;

            var rule = CreateAssetObject(ruleType, asset, platform) as MarkerGenRule;
            if (rule != null)
            {
                rule.ruleGraph = CreateAssetObject<MarkerGenRuleGraph>(asset, platform);
                rule.program = CreateAssetObject<MarkerGenRuleProgram>(asset, platform);
                rule.actions = CreateAssetObject<MarkerGenRuleActionList>(asset, platform);
                InitRuleGraph(rule.ruleGraph, asset, platform);
                CompileRule(rule, asset, platform);
                pattern.rules = pattern.rules.Concat(new []{ rule }).ToArray();
            }
            
            return rule;
        }

        public static void CompileRule(MarkerGenRule rule, MarkerGeneratorAsset asset, UIPlatform platform)
        {
            if (rule == null || asset == null)
            {
                return;
            }
            
            if (rule.ruleGraph == null) { rule.ruleGraph = CreateAssetObject<MarkerGenRuleGraph>(asset, platform); }
            if (rule.program == null) { rule.program = CreateAssetObject<MarkerGenRuleProgram>(asset, platform); }
            if (rule.actions == null) { rule.actions = CreateAssetObject<MarkerGenRuleActionList>(asset, platform); }
            
            // Compile the condition graph
            ConditionGraphCompiler.Compile(rule.ruleGraph, rule.program);
            
            // Compile the action graph
            if (asset != null && platform != null)
            {
                ActionGraphCompiler.Compile(rule.ruleGraph, rule.actions);
                
                // Add the actions to the asset
                foreach (var action in rule.actions.actionList)
                {
                    action.hideFlags = HideFlags.HideInHierarchy;
                    platform.AddObjectToAsset(action, asset);
                }
            }
            
            MarkerGenRuleTextGenerator.GenerateRulePreviewText(rule);
        }

        
        private static void InitRuleGraph(MarkerGenRuleGraph ruleGraph, MarkerGeneratorAsset asset, UIPlatform platform)
        {
            // Add the result node
            var resultNode = GraphOperations.CreateNode(ruleGraph, typeof(MarkerGenRuleNodeResult), null);
            GraphEditorUtils.AddToAsset(platform, asset, resultNode);
            resultNode.Position = Vector2.zero;
            
            var execNode = GraphOperations.CreateNode(ruleGraph, typeof(MarkerGenRuleNodeOnPass), null);
            GraphEditorUtils.AddToAsset(platform, asset, execNode);
            execNode.Position = new Vector2(120, 0);

            ruleGraph.resultNode = resultNode as MarkerGenRuleNodeResult;
            ruleGraph.passNode = execNode as MarkerGenRuleNodeOnPass;
        }

        public static void RemoveRule(MarkerGeneratorAsset asset, MarkerGenPattern pattern, MarkerGenRule rule)
        {
            if (asset == null || pattern == null || rule == null)
            {
                Debug.LogError("RemoveRule: Invalid rule parameter");
                return;
            }
            DestroyAssetObject(rule.ruleGraph);
            rule.ruleGraph = null;

            pattern.rules = pattern.rules.Where(r => r != rule).ToArray();

            // Remove the owned objects
            DestroyAssetObject(rule);
        }
        
        
        private static T CreateAssetObject<T>(MarkerGeneratorAsset asset, UIPlatform platform) where T : ScriptableObject
        {
            return CreateAssetObject(typeof(T), asset, platform) as T;
        }

        private static ScriptableObject CreateAssetObject(System.Type type, MarkerGeneratorAsset asset, UIPlatform platform)
        {
            var obj = ScriptableObject.CreateInstance(type);
            obj.hideFlags = HideFlags.HideInHierarchy;
            platform.AddObjectToAsset(obj, asset);
            return obj;
        }
        
        private static void DestroyAssetObject<T>(T obj) where T : ScriptableObject
        {
            //AssetDatabase.RemoveObjectFromAsset(obj);
            if (obj != null)
            {
                Undo.DestroyObjectImmediate(obj);
            }
        }

        public static Color CreateRandomColor()
        {
            var hue = Random.value;
            var saturation = 0.5f;
            var value = 1.0f;
            return Color.HSVToRGB(hue, saturation, value);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Utils\MarkerGenRuleTextGenerator.cs:
 using System.Collections.Generic;
using DungeonArchitect.MarkerGenerator.Nodes.Actions.Info;
using DungeonArchitect.MarkerGenerator.Rule;
using DungeonArchitect.MarkerGenerator.VM;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.TextGen
{
    struct TextExecStackInfo
    {
        public string Text;
        public bool Parenthesis;

        public TextExecStackInfo(string text, bool parenthesis)
        {
            this.Text = text;
            this.Parenthesis = parenthesis;
        }
    }

    public static class MarkerGenRuleTextGenerator
    {
        public static void GenerateRulePreviewText(MarkerGenRule rule)
        {
            if (!rule.program.compiled)
            {
                return;
            }
            
            // Generate the condition graph
            {
                var scriptTypes = new Dictionary<string, System.Type>();
                var execStack = new Stack<int>();
                var textStack = new Stack<TextExecStackInfo>();
                foreach (var instruction in rule.program.instructions)
                {
                    if (instruction.opcode == OpCodes.MarkerExists)
                    {
                        var stringIdx = execStack.Pop();
                        textStack.Pop();    // One of the string table true/false key
                        var markerName = rule.program.stringTable[stringIdx];
                        markerName = SanitizeMarkerName(markerName);
                        textStack.Push(new TextExecStackInfo() { Text = markerName, Parenthesis = false });
                    }
                    if (instruction.opcode == OpCodes.ConditionScript)
                    {
                        var stringIdx = execStack.Pop();
                        textStack.Pop();    // One of the string table true/false key
                        var scriptName = rule.program.stringTable[stringIdx];
                        System.Type scriptType = System.Type.GetType(scriptName);
                        var text = scriptType == null ? "<NONE>" : scriptType.Name;
                        textStack.Push(new TextExecStackInfo() { Text = text, Parenthesis = false });
                    }
                    else if (instruction.opcode == OpCodes.Not)
                    {
                        var text = "NOT " + PopTopText(textStack);
                        textStack.Push(new TextExecStackInfo() { Text = text, Parenthesis = false });
                    }
                    else if (instruction.opcode == OpCodes.And)
                    {
                        var b = PopTopText(textStack);
                        var a = PopTopText(textStack);
                        var text = a + " AND " + b;
                        textStack.Push(new TextExecStackInfo() { Text = text, Parenthesis = true });
                    }
                    else if (instruction.opcode == OpCodes.Or)
                    {
                        var b = PopTopText(textStack);
                        var a = PopTopText(textStack);
                        var text = a + " OR " + b;
                        textStack.Push(new TextExecStackInfo() { Text = text, Parenthesis = true });
                    }
                    else if (instruction.opcode == OpCodes.Push)
                    {
                        execStack.Push(instruction.arg0);

                        var text = instruction.arg0 == 0 ? "False" : "True";
                        textStack.Push(new TextExecStackInfo() { Text = text, Parenthesis = false });
                    }
                    else if (instruction.opcode == OpCodes.Halt)
                    {
                        break;
                    }
                }

                if (textStack.Count == 1)
                {
                    var result = textStack.Pop();
                    rule.previewTextCondition = result.Text;
                }
            }

            
            // Generate the action list text
            {
                var result = new List<string>();
                foreach (var action in rule.actions.actionList)
                {
                    if (action is MarkerGenRuleActionInfoAddMarker addAction)
                    {
                        result.Add("ADD " + SanitizeMarkerName(addAction.markerName));
                    }
                    else if (action is MarkerGenRuleActionInfoRemoveMarker removeAction)
                    {
                        result.Add("DEL " + SanitizeMarkerName(removeAction.markerName));
                    } 
                }

                rule.previewTextActions = result.ToArray();
            }
        }

        private static string PopTopText(Stack<TextExecStackInfo> stack)
        {
            if (stack.Count > 0)
            {
                var top = stack.Pop();
                return top.Parenthesis ? ApplyParenthesis(top.Text) : top.Text;
            }
            else
            {
                return "";
            }
        }
        
        private static string ApplyParenthesis(string text)
        {
            return "(" + text + ")";
        }

        private static string SanitizeMarkerName(string name)
        {
            return name.Trim().Length == 0 ? "<NONE>" : name;
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\RoomDesigner\Tools\DungeonRoomDesignerTool_DoorBounds.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.RoomDesigner.Editors
{
    public class DungeonRoomDesignerTool_DoorBounds : DungeonRoomDesignerTools
    {
        public override void DrawSceneGUI(DungeonRoomDesigner room)
        {

        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\RoomDesigner\Tools\DungeonRoomDesignerTool_DoorMove.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;
using MU = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.RoomDesigner.Editors
{
    public class DungeonRoomDesignerTool_DoorMove : DungeonRoomDesignerTools
    {
        float SnapToGrid(float value, float gridValue)
        {
            return Mathf.RoundToInt(value / gridValue) * gridValue;
        }

        void ClampToWalls(DungeonRoomDesigner room, Vector3 p, out Quaternion rotation, out Vector3 freeMovePosition, out Vector3 snappedPosition)
        {
            var min = IntVector.Zero;
            var max = min + room.roomSize;
            
            p.x = Mathf.Clamp(p.x, min.x, max.x);
            p.y = Mathf.Clamp(p.y, min.y, max.y);
            p.z = Mathf.Clamp(p.z, min.z, max.z);
            
            // Clamp from the inside
            float minDistance = float.MaxValue;
            Vector3 bestResult = p;
            rotation = Quaternion.identity;
            var offsetFix = Vector3.zero;
            if (p.x - min.x < minDistance)
            {
                minDistance = p.x - min.x;
                bestResult = p;
                bestResult.x = min.x;
                rotation = Quaternion.Euler(0, 90, 0);
                offsetFix = new Vector3(0, 0, 0.5f);
            }
            if (max.x - p.x < minDistance)
            {
                minDistance = max.x - p.x;
                bestResult = p;
                bestResult.x = max.x;
                rotation = Quaternion.Euler(0, 270, 0);
                offsetFix = new Vector3(0, 0, 0.5f);
            }
            if (p.z - min.z < minDistance)
            {
                minDistance = p.z - min.z;
                bestResult = p;
                bestResult.z = min.z;
                rotation = Quaternion.Euler(0, 0, 0);
                offsetFix = new Vector3(0.5f, 0, 0);
            }
            if (max.z - p.z < minDistance)
            {
                minDistance = max.z - p.z;
                bestResult = p;
                bestResult.z = max.z;
                rotation = Quaternion.Euler(0, 180, 0);
                offsetFix = new Vector3(0.5f, 0, 0);
            }

            freeMovePosition = bestResult;
            snappedPosition = MU.V3FloorToInt(bestResult) + offsetFix;

            snappedPosition.y = Mathf.Min(snappedPosition.y, max.y - 2);

            if (snappedPosition.x > max.x) --snappedPosition.x;
            if (snappedPosition.z > max.z) --snappedPosition.z;
        }

        void DrawDoorEditor(DungeonRoomDesigner room, ref DungeonRoomDoorDesigner door)
        {
            var snap = Vector3.one;
            var baseOffset = room.roomPosition.ToVector3();

            var doorWorldPos = Vector3.Scale(baseOffset + door.logicalCursorPosition, room.gridSize);
            Handles.color = Color.green;
            float size = HandleUtility.GetHandleSize(doorWorldPos) * 0.25f;
            var fmh_79_65_638341410831406063 = Quaternion.identity; doorWorldPos = Handles.FreeMoveHandle(doorWorldPos, size, snap, Handles.SphereHandleCap);
            var logicalPos = MU.Divide(doorWorldPos, room.gridSize) - baseOffset;

            var oldLogicalPosition = door.logicalPosition;
            ClampToWalls(room, logicalPos, out door.rotation, out door.logicalCursorPosition, out door.logicalPosition);
            
            DrawDoorOutline(room, door);

            if (oldLogicalPosition != door.logicalPosition)
            {
                RequestRebuild(room);
            }
        }

        public void DrawDoorOutline(DungeonRoomDesigner room, DungeonRoomDoorDesigner door)
        {
            // Draw the door outline
            var offset = room.gridSize.x / 2.0f;
            var doorHeight = room.gridSize.y * 2;
            var points = new Vector3[]
            {
                new Vector3(-offset, 0, 0),
                new Vector3( offset, 0, 0),
                new Vector3( offset, doorHeight, 0),
                new Vector3(-offset, doorHeight, 0)
            };

            var doorWorldPos = Vector3.Scale(room.roomPosition.ToVector3() + door.logicalPosition, room.gridSize);
            for (int i = 0; i < points.Length; i++)
            {
                points[i] = doorWorldPos + door.rotation * points[i];
            }

            var indices = new int[] { 0, 1, 1, 2, 2, 3, 3, 0 };
            Handles.DrawDottedLines(points, indices, 4);
        }

        public override void DrawSceneGUI(DungeonRoomDesigner room)
        {
            for (int i = 0; i < room.doors.Length; i++)
            {
                DrawDoorEditor(room, ref room.doors[i]);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\RoomDesigner\Tools\DungeonRoomDesignerTool_RoomBounds.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using UnityEditor.IMGUI.Controls;

namespace DungeonArchitect.RoomDesigner.Editors
{
    public class DungeonRoomDesignerTool_RoomBounds : DungeonRoomDesignerTools
    {
        private BoxBoundsHandle boundsHandle = new BoxBoundsHandle();

        public override void DrawSceneGUI(DungeonRoomDesigner room)
        {
            DrawBoundsHandle(room, PrimitiveBoundsHandle.Axes.All);
        }

        void DrawBoundsHandle(DungeonRoomDesigner room, PrimitiveBoundsHandle.Axes drawAxes)
        {
            var worldSize = GetWorldCoord(room.roomSize, room.gridSize);
            var worldPos = GetWorldCoord(room.roomPosition, room.gridSize);
            var center = worldPos + worldSize / 2.0f;

            boundsHandle.center = center;
            boundsHandle.size = worldSize;
            boundsHandle.axes = drawAxes;
            boundsHandle.midpointHandleDrawFunction = Handles.CircleHandleCap;
            boundsHandle.midpointHandleSizeFunction = HandleSizeFunction;
            boundsHandle.wireframeColor = Color.white;
            boundsHandle.handleColor = Color.white;
            EditorGUI.BeginChangeCheck();
            boundsHandle.DrawHandle();
            if (EditorGUI.EndChangeCheck())
            {
                center = boundsHandle.center;
                var minF = center - boundsHandle.size / 2.0f;
                var maxF = center + boundsHandle.size / 2.0f;
                var g = room.gridSize;
                var min = new IntVector();
                var max = new IntVector();
                min.x = Mathf.RoundToInt(minF.x / g.x);
                max.x = Mathf.RoundToInt(maxF.x / g.x);
                min.y = Mathf.RoundToInt(minF.y / g.y);
                max.y = Mathf.RoundToInt(maxF.y / g.y);
                min.z = Mathf.RoundToInt(minF.z / g.z);
                max.z = Mathf.RoundToInt(maxF.z / g.z);

                var targetPosition = min;
                var targetSize = max - min;

                targetSize.x = Mathf.Max(1, targetSize.x);
                targetSize.y = Mathf.Max(1, targetSize.y);
                targetSize.z = Mathf.Max(1, targetSize.z);

                if (!room.roomPosition.Equals(targetPosition) || !room.roomSize.Equals(targetSize))
                {
                    room.roomPosition = targetPosition;
                    room.roomSize = targetSize;

                    RequestRebuild(room);
                }
            }
        }

        float HandleSizeFunction(Vector3 position)
        {
            return HandleUtility.GetHandleSize(position) / 6.0f;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\RoomDesigner\Tools\DungeonRoomDesignerTool_RoomMove.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.RoomDesigner.Editors
{
    public class DungeonRoomDesignerTool_RoomMove : DungeonRoomDesignerTools
    {
        public override void DrawSceneGUI(DungeonRoomDesigner room)
        {
            var worldSize = GetWorldCoord(room.roomSize, room.gridSize);
            var worldPos = GetWorldCoord(room.roomPosition, room.gridSize);
            var center = worldPos + worldSize / 2.0f;

            var snap = room.gridSize;
            float size = HandleUtility.GetHandleSize(center) * 0.25f;
            Handles.color = Color.green;
            var fmh_18_60_638341410831388355 = Quaternion.identity; var newCenter = Handles.FreeMoveHandle(center, size, snap, Handles.SphereHandleCap);
            var diffF = newCenter - center;
            var diff = new IntVector(
                Mathf.RoundToInt(diffF.x / room.gridSize.x),
                Mathf.RoundToInt(diffF.y / room.gridSize.y),
                Mathf.RoundToInt(diffF.z / room.gridSize.z));

            Event e = Event.current;
            bool moveXZ = true;
            if (e.shift)
            {
                // Only move along Y if shift key is pressed
                moveXZ = false;
            }

            if (moveXZ)
            {
                diff.y = 0;
            }
            else
            {
                diff.x = 0;
                diff.z = 0;
            }

            room.roomPosition += diff;
            if (!diff.Equals(IntVector.Zero))
            {
                RequestRebuild(room);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Validation\DungeonFlowValidatorActions.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Grammar;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.SnapFlow
{
    public interface ISnapEdValidatorAction
    {
        void Execute(SnapEditorWindow editor);
    }

    public abstract class SnapEdValidatorActionBase : ISnapEdValidatorAction
    {
        public abstract void Execute(SnapEditorWindow editor);
    }

    public class EmptyNodeListSnapEdValidatorAction : SnapEdValidatorActionBase
    {
        public override void Execute(SnapEditorWindow editor)
        {
            var layoutRoot = editor.GetRootLayout();
            DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, layoutRoot, DungeonFlowEditorHighlightID.NodePanel);
        }
    }
    public class EmptyRuleListSnapEdValidatorAction : SnapEdValidatorActionBase
    {
        public override void Execute(SnapEditorWindow editor)
        {
            var layoutRoot = editor.GetRootLayout();
            DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, layoutRoot, DungeonFlowEditorHighlightID.RulePanel);
        }
    }

    public class InvalidExecutionGraphSnapEdValidatorAction : SnapEdValidatorActionBase
    {
        public override void Execute(SnapEditorWindow editor)
        {
            var layoutRoot = editor.GetRootLayout();
            var flowAsset = editor.FlowAsset;
            var execGraph = (flowAsset != null) ? flowAsset.executionGraph : null;
            DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, layoutRoot, execGraph);
        }
    }


    public class InvalidProductionRuleAction : SnapEdValidatorActionBase
    {
        GrammarProductionRule productionRule;
        public InvalidProductionRuleAction(GrammarProductionRule productionRule)
        {
            this.productionRule = productionRule;
        }
        public override void Execute(SnapEditorWindow editor)
        {
            var rulePanel = editor.GetRuleListPanel();
            rulePanel.ListView.SetSelectedItem(editor.uiSystem, productionRule, true);
            DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, rulePanel, productionRule);
        }
    }

    public class MissingProductionRuleRHSAction : SnapEdValidatorActionBase
    {
        GrammarProductionRule productionRule;
        public MissingProductionRuleRHSAction(GrammarProductionRule productionRule)
        {
            this.productionRule = productionRule;
        }
        public override void Execute(SnapEditorWindow editor)
        {
            var rulePanel = editor.GetRuleListPanel();
            rulePanel.ListView.SetSelectedItem(editor.uiSystem, productionRule);
            editor.ForceUpdateWidgetFromCache(rulePanel);

            DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, editor.GetProductionRuleWidget(), DungeonFlowEditorHighlightID.ProductionAddRHSButton);
        }
    }

    public class InvalidNodeTypeAction : SnapEdValidatorActionBase
    {
        GrammarNodeType nodeType;
        public InvalidNodeTypeAction(GrammarNodeType nodeType)
        {
            this.nodeType = nodeType;
        }
        public override void Execute(SnapEditorWindow editor)
        {
            var nodesPanel = editor.GetNodeListPanel();
            nodesPanel.ListView.SetSelectedItem(editor.uiSystem, nodeType, true);
            DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, nodesPanel, nodeType);
        }
    }

    public class InvalidProductionGraphAction : SnapEdValidatorActionBase
    {
        GrammarGraph graph;
        GrammarProductionRule productionRule;

        public InvalidProductionGraphAction(GrammarProductionRule productionRule, GrammarGraph graph)
        {
            this.productionRule = productionRule;
            this.graph = graph;
        }

        public override void Execute(SnapEditorWindow editor)
        {
            var rulePanel = editor.GetRuleListPanel();
            rulePanel.ListView.SetSelectedItem(editor.uiSystem, productionRule);
            editor.ForceUpdateWidgetFromCache(rulePanel);

            var productionRuleEditor = editor.GetProductionRuleWidget();
            DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, productionRuleEditor, graph);
        }
    }

    public class InvalidProductionGraphNodeAction : SnapEdValidatorActionBase
    {
        GraphNode node;
        GrammarProductionRule productionRule;

        public InvalidProductionGraphNodeAction(GrammarProductionRule productionRule, GraphNode node)
        {
            this.productionRule = productionRule;
            this.node = node;
        }

        GraphEditor FindGraphEditor(SnapEditorWindow editor, Graph graph)
        {
            var graphEditors = editor.GetProductionRuleWidget().GetGraphEditors();
            foreach (var graphEditor in graphEditors)
            {
                if (graphEditor.Graph == graph)
                {
                    return graphEditor;
                }
            }
            return null;
        }

        public override void Execute(SnapEditorWindow editor)
        {
            var rulePanel = editor.GetRuleListPanel();
            rulePanel.ListView.SetSelectedItem(editor.uiSystem, productionRule);
            editor.ForceUpdateWidgetFromCache(rulePanel);

            var productionRuleEditor = editor.GetProductionRuleWidget();
            DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, productionRuleEditor, node.Graph);

            var graphEditor = FindGraphEditor(editor, node.Graph);
            if (graphEditor != null)
            {
                editor.AddDeferredCommand(new EditorCommand_FocusOnGraphNode(graphEditor, node));
            }
        }
    }

    public class InvalidExecutionGraphNodeAction : SnapEdValidatorActionBase
    {
        GraphNode node;

        public InvalidExecutionGraphNodeAction(GraphNode node)
        {
            this.node = node;
        }

        public override void Execute(SnapEditorWindow editor)
        {
            var execGraphPanel = editor.GetExecGraphPanel();
            if (execGraphPanel != null)
            {
                DungeonFlowEditorHighlighter.HighlightObjects(editor.uiSystem, execGraphPanel, node.Graph);

                var graphEditor = execGraphPanel.GraphEditor;
                if (graphEditor != null)
                {
                    editor.AddDeferredCommand(new EditorCommand_FocusOnGraphNode(graphEditor, node));
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Validation\SnapEdValidator.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Grammar;
using System.Collections.Generic;
using System.Linq;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class SnapEdValidator
    {
        public static void Validate(SnapFlowAsset asset, DungeonFlowErrorList errorList)
        {
            if (asset != null && errorList != null && errorList.Errors != null)
            {
                Validate_NodeTypes(asset.nodeTypes, errorList);
                Validate_Rules(asset.productionRules, errorList);
                Validate_ExecutionGraph(asset.executionGraph, errorList);
            }
        }

        private static void Validate_NodeTypes(GrammarNodeType[] nodeTypesArray, DungeonFlowErrorList errorList)
        {
            var nodeTypes = new List<GrammarNodeType>(nodeTypesArray);
            if (nodeTypes.Count == 0)
            {
                errorList.Errors.Add(new DungeonFlowErrorEntry("Empty Node List", DungeonFlowErrorType.Error, new EmptyNodeListSnapEdValidatorAction()));
            }
            else
            {
                nodeTypes = nodeTypes.OrderBy(x => x.nodeName).ToList();

                for (int i = 0; i < nodeTypes.Count; i++)
                {
                    var nodeType = nodeTypes[i];
                    if (nodeType == null) continue;

                    if (nodeType.nodeName == "")
                    {
                        errorList.Errors.Add(new DungeonFlowErrorEntry("Empty node name", DungeonFlowErrorType.Error, new InvalidNodeTypeAction(nodeType)));
                    }

                    if (i > 0)
                    {
                        var previousNodeType = nodeTypes[i - 1];
                        if (previousNodeType != null && previousNodeType.nodeName == nodeType.nodeName)
                        {
                            string message = string.Format("Duplicate node name: '{0}'", nodeType.nodeName);
                            errorList.Errors.Add(new DungeonFlowErrorEntry(message, DungeonFlowErrorType.Error, new InvalidNodeTypeAction(nodeType)));
                        }
                    }
                }
            }
        }

        private static void Validate_Rules(GrammarProductionRule[] rulesArray, DungeonFlowErrorList errorList)
        {
            var rules = new List<GrammarProductionRule>(rulesArray);
            if (rules.Count == 0)
            {
                errorList.Errors.Add(new DungeonFlowErrorEntry("Empty Rule List", DungeonFlowErrorType.Error, new EmptyRuleListSnapEdValidatorAction()));
            }
            else
            {
                rules = rules.OrderBy(x => x.ruleName).ToList();

                for (int i = 0; i < rules.Count; i++)
                {
                    var rule = rules[i];
                    if (rule == null) continue;

                    if (rule.ruleName == "")
                    {
                        errorList.Errors.Add(new DungeonFlowErrorEntry("Empty rule name", DungeonFlowErrorType.Error, new InvalidProductionRuleAction(rule)));
                    }

                    // Validate the graphs
                    Validate_RuleGraphs(rule, rule.LHSGraph, "LHS", errorList);
                    if (rule.RHSGraphs.Count == 0)
                    {
                        string message = string.Format("No RHS graphs defined for rule: '{0}'", rule.ruleName);
                        errorList.Errors.Add(new DungeonFlowErrorEntry(message, DungeonFlowErrorType.Error, new MissingProductionRuleRHSAction(rule)));
                    }
                    else
                    {
                        for (int rhsIdx = 0; rhsIdx < rule.RHSGraphs.Count; rhsIdx++)
                        {
                            var rhsGraph = rule.RHSGraphs[rhsIdx].graph;
                            string graphName = string.Format("RHS({0})", rhsIdx + 1);
                            Validate_RuleGraphs(rule, rhsGraph, graphName, errorList);
                        }
                    }

                    if (i > 0)
                    {
                        var previousRule = rules[i - 1];
                        if (previousRule != null && previousRule.ruleName == rule.ruleName)
                        {
                            string message = string.Format("Duplicate rule name: '{0}'", rule.ruleName);
                            errorList.Errors.Add(new DungeonFlowErrorEntry(message, DungeonFlowErrorType.Error, new InvalidProductionRuleAction(rule)));
                        }
                    }
                }
            }
        }

        private static void Validate_RuleGraphs(GrammarProductionRule rule, GrammarGraph graph, string graphName, DungeonFlowErrorList errorList)
        {
            if (graph.Nodes.Count == 0)
            {
                string message = string.Format("Empty {0} graph for rule: '{1}'", graphName, rule.ruleName);
                errorList.Errors.Add(new DungeonFlowErrorEntry(message, DungeonFlowErrorType.Warning, new InvalidProductionGraphAction(rule, graph)));
            }

            // Check for deleted graph nodes
            foreach (var node in graph.Nodes)
            {
                if (node is GrammarTaskNode)
                {
                    var taskNode = node as GrammarTaskNode;
                    if (taskNode.NodeType == null)
                    {
                        string message = string.Format("Deleted node found in rule: '{0}', graph: '{0}'", rule.ruleName, graphName);
                        errorList.Errors.Add(new DungeonFlowErrorEntry(message, DungeonFlowErrorType.Error, new InvalidProductionGraphNodeAction(rule, node)));
                    }
                }
            }
        }

        private static void Validate_ExecutionGraph(GrammarExecGraph executionGraph, DungeonFlowErrorList errorList)
        {
            // Check if the entry node is connected
            {
                bool entryNodeConnected = false;
                foreach (var link in executionGraph.Links)
                {
                    if (link != null && link.Output != null && link.Output.Node != null)
                    {
                        if (link.Output.Node is GrammarExecEntryNode)
                        {
                            entryNodeConnected = true;
                        }
                    }
                }

                if (!entryNodeConnected)
                {
                    string message = "Execution graph's Entry Node is not connected";
                    errorList.Errors.Add(new DungeonFlowErrorEntry(message, DungeonFlowErrorType.Error, new InvalidExecutionGraphSnapEdValidatorAction()));
                }
            }

            // Check for deleted graph nodes
            foreach (var node in executionGraph.Nodes)
            {
                if (node is GrammarExecRuleNode)
                {
                    var execNode = node as GrammarExecRuleNode;
                    if (execNode.rule == null)
                    {
                        string message = "Deleted node found in execution graph";
                        errorList.Errors.Add(new DungeonFlowErrorEntry(message, DungeonFlowErrorType.Error, new InvalidExecutionGraphNodeAction(node)));
                    }
                }
            }

        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\NodeEditors\MarkerEmitterNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editors for MarkerEmitterNode
    /// </summary>
    [CustomEditor(typeof(MarkerEmitterNode))]
    public class MarkerEmitterNodeEditor : PlaceableNodeEditor
    {

        public override void OnEnable()
        {
            base.OnEnable();
            drawOffset = true;
            drawAttachments = false;
        }

        protected override string GetNodeTitle()
        {
            var emitterNode = target as MarkerEmitterNode;
            var markerCaption = (emitterNode.Marker != null) ? emitterNode.Marker.Caption : "Unknown";
            return "Marker Emitter: " + markerCaption;
        }
    }

    /// <summary>
    /// Renders a MarkerEmitterNode
    /// </summary>
    public class MarkerEmitterNodeRenderer : GraphNodeRenderer
    {
        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            // Draw the background base texture
            DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_MARKER_NODE_BG);
            
            var emitterNode = node as MarkerEmitterNode;
            var title = (emitterNode.Marker != null) ? emitterNode.Marker.Caption : "{NONE}";

			DrawTextCentered(renderer, rendererContext, node, camera, title, new Vector2(0, -2));

            // Draw the foreground frame textures
            DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_MARKER_EMITTER_NODE_FRAME);

            if (node.Selected)
            {
                DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_MARKER_NODE_SELECTION);
            }

            // Draw the pins
            base.Draw(renderer, rendererContext, node, camera);
        }

        protected override Color getBackgroundColor(GraphNode node)
        {
            var color = new Color(0.2f, 0.25f, 0.4f);
            return node.Selected ? GraphEditorConstants.NODE_COLOR_SELECTED : color;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\NodeEditors\MarkerNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editors for MarkerNode
    /// </summary>
    [CustomEditor(typeof(MarkerNode))]
    public class MarkerNodeEditor : Editor
    {
        SerializedObject sobject;
        SerializedProperty caption;
        const int CATEGORY_SPACING = 10;
        
        public void OnEnable()
        {
            sobject = new SerializedObject(target);
            caption = sobject.FindProperty("caption");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            GUILayout.Label("Marker Node", InspectorStyles.TitleStyle);
            GUILayout.Space(CATEGORY_SPACING);
            
            EditorGUILayout.PropertyField(caption, new GUIContent("Marker Name"));
            sobject.ApplyModifiedProperties();
        }
    }


    /// <summary>
    /// Renders a marker node
    /// </summary>
    public class MarkerNodeRenderer : GraphNodeRenderer
    {
        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            // Draw the background base texture
            DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_MARKER_NODE_BG);

			var pinHeight = node.OutputPins[0].BoundsOffset.height;
			DrawTextCentered(renderer, rendererContext, node, camera, node.Caption, new Vector2(0, -3));

            // Draw the foreground frame textures
            DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_MARKER_NODE_FRAME);

            if (node.Selected)
            {
                DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_MARKER_NODE_SELECTION);
            }

            // Draw the pins
            base.Draw(renderer, rendererContext, node, camera);

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\NodeEditors\MeshArrayNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors
{
	/// <summary>
	/// Custom property editors for GameObjectNode
	/// </summary>
	[CanEditMultipleObjects]
	[CustomEditor(typeof(GameObjectArrayNode))]
	public class MeshArrayNodeEditor : VisualNodeEditor
	{
		SerializedProperty Templates;

		public override void OnEnable()
		{
			base.OnEnable();
			drawOffset = true;
			drawAttachments = true;
			Templates = sobject.FindProperty("Templates");
		}

		protected override void DrawPreInspectorGUI()
		{
			DrawHeader("Game Object Array");
			using (new EditorGUI.IndentLevelScope())
			{
				EditorGUILayout.PropertyField(Templates, true);
			}

			base.DrawPreInspectorGUI();
		}

		protected override string GetNodeTitle()
		{
			return "Game Object Array Node";
		}
	}

	/// <summary>
	/// Renders a mesh node
	/// </summary>
	public class MeshArrayNodeRenderer : VisualNodeRenderer
	{
		protected override Object GetThumbObject(GraphNode node)
		{
			var meshNode = node as GameObjectArrayNode;
			if (meshNode == null || meshNode.Templates == null || meshNode.Templates.Length == 0) return null;
			return meshNode.Templates[0];
		}

		protected override void DrawFrameTexture(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera) {
			DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_GO_NODE_FRAME);
			DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_MULTI_GO_NODE_FRAME);
		}
	}

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\NodeEditors\MeshNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editors for GameObjectNode
    /// </summary>
    [CanEditMultipleObjects]
    [CustomEditor(typeof(GameObjectNode))]
    public class MeshNodeEditor : VisualNodeEditor
    {
        SerializedProperty Template;

        public override void OnEnable()
        {
            base.OnEnable();
            drawOffset = true;
            drawAttachments = true;
            Template = sobject.FindProperty("Template");
        }

        protected override void DrawPreInspectorGUI()
        {
            DrawHeader("Game Object");
            using (new EditorGUI.IndentLevelScope())
            {
                EditorGUILayout.PropertyField(Template);
            }

            base.DrawPreInspectorGUI();
        }
        
        protected override string GetNodeTitle()
        {
            return "Game Object Node";
        }
    }

    /// <summary>
    /// Renders a mesh node
    /// </summary>
    public class MeshNodeRenderer : VisualNodeRenderer
    {
        protected override Object GetThumbObject(GraphNode node)
        {
            var meshNode = node as GameObjectNode;
            if (meshNode == null) return null;
            return meshNode.Template;
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\NodeEditors\PlaceableNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for placeable node
    /// </summary>
    public abstract class PlaceableNodeEditor : GraphNodeEditor
    {
        SerializedProperty ConsumeOnAttach;
        SerializedProperty AttachmentProbability;
        protected bool drawOffset = false;
        protected bool drawAttachments = false;

        public override void OnEnable()
        {
            base.OnEnable();

            ConsumeOnAttach = sobject.FindProperty("consumeOnAttach");
            AttachmentProbability = sobject.FindProperty("attachmentProbability");
        }

        protected abstract string GetNodeTitle();

        public static void DrawHeader(string title)
        {
            GUILayout.Space(CATEGORY_SPACING);
            GUILayout.Label(title, InspectorStyles.HeaderStyle);
        }
        
        protected override void HandleInspectorGUI() {

            GUILayout.Label(GetNodeTitle(), InspectorStyles.TitleStyle);
            
            if (drawOffset)
            {
                // Draw the transform offset editor
                DrawHeader("Offset");
                if (targets != null && targets.Length > 1)
                {
                    // Multiple object editing not supported
                    EditorGUILayout.HelpBox("Multiple Objects selected", MessageType.Info);
                }
                else
                {
                    var node = target as PlaceableNode;
                    GUILayout.BeginHorizontal();
                    GUILayout.Space(INDENT_SPACING);
                    GUILayout.BeginVertical();
                    InspectorUtils.DrawMatrixProperty("Offset", ref node.offset);
                    EditorGUILayout.HelpBox(new GUIContent("TIP: Visualize the correct alignment by turning it on from the theme editor's toolbar"));
                    GUILayout.EndVertical();
                    GUILayout.EndHorizontal();
                }
            }

            if (drawAttachments)
            {
                // Draw the attachment properties
                DrawHeader("Attachment");
                using (new EditorGUI.IndentLevelScope()) {
                    EditorGUILayout.PropertyField(AttachmentProbability, new GUIContent("Probability"));
                    EditorGUILayout.PropertyField(ConsumeOnAttach);
                }

                // Clamp the probability to [0..1]
                if (!AttachmentProbability.hasMultipleDifferentValues)
                {
                    AttachmentProbability.floatValue = Mathf.Clamp01(AttachmentProbability.floatValue);
                }
            }
            DrawPreInspectorGUI();
            DrawPostInspectorGUI();
            DrawMiscInspectorGUI();
        }

        protected override void OnGuiChanged()
        {
            var themeEditorWindow = DungeonEditorHelper.GetWindowIfOpen<DungeonThemeEditorWindow>();
            if (themeEditorWindow != null)
            {
                var graphEditor = themeEditorWindow.GraphEditor;
                graphEditor.HandleGraphStateChanged(themeEditorWindow.uiSystem);
                graphEditor.HandleNodePropertyChanged(target as GraphNode);
            }
        }

        protected virtual void DrawPreInspectorGUI() { }
        protected virtual void DrawPostInspectorGUI() { }
        
        protected virtual void DrawMiscInspectorGUI() { }

        protected const int CATEGORY_SPACING = 10;
        protected const int INDENT_SPACING = 12;

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\NodeEditors\SpriteNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for a sprite node
    /// </summary>
    [CanEditMultipleObjects]
    [CustomEditor(typeof(SpriteNode))]
    public class SpriteNodeEditor : VisualNodeEditor
    {
        SerializedProperty sprite;
        SerializedProperty color;
        SerializedProperty materialOverride;
        SerializedProperty sortingLayerName;
        SerializedProperty orderInLayer;

        SerializedProperty collisionType;
        SerializedProperty physicsMaterial;
        SerializedProperty physicsOffset;
        SerializedProperty physicsSize;
        SerializedProperty physicsRadius;

        public override void OnEnable()
        {
            base.OnEnable();
            drawOffset = true;
            drawAttachments = true;
            sprite = sobject.FindProperty("sprite");
            color = sobject.FindProperty("color");
            materialOverride = sobject.FindProperty("materialOverride");
            sortingLayerName = sobject.FindProperty("sortingLayerName");
            orderInLayer = sobject.FindProperty("orderInLayer");

            collisionType = sobject.FindProperty("collisionType");
            physicsMaterial = sobject.FindProperty("physicsMaterial");
            physicsOffset = sobject.FindProperty("physicsOffset");
            physicsSize = sobject.FindProperty("physicsSize");
            physicsRadius = sobject.FindProperty("physicsRadius");
        }

        protected override void DrawPreInspectorGUI()
        {
            DrawHeader("Sprite");
            using (new EditorGUI.IndentLevelScope())
            {
                EditorGUILayout.PropertyField(sprite);
                EditorGUILayout.PropertyField(color);
                EditorGUILayout.PropertyField(materialOverride);
                EditorGUILayout.PropertyField(sortingLayerName);
                EditorGUILayout.PropertyField(orderInLayer);
            }

            base.DrawPreInspectorGUI();
        }


        protected override void DrawPostInspectorGUI()
        {
            DrawHeader("Physics");

            using (new EditorGUI.IndentLevelScope())
            {
                EditorGUILayout.PropertyField(collisionType);

                var collsionIndex = collisionType.enumValueIndex;
                var collisionTypeValue = DungeonSpriteCollisionType.None;
                if (System.Enum.IsDefined(typeof(DungeonSpriteCollisionType), collsionIndex))
                {
                    collisionTypeValue = (DungeonSpriteCollisionType) collsionIndex;
                }

                if (collisionTypeValue != DungeonSpriteCollisionType.None)
                {
                    EditorGUILayout.PropertyField(physicsMaterial, new GUIContent("Material"));
                    EditorGUILayout.PropertyField(physicsOffset, new GUIContent("Offset"));
                    if (collisionTypeValue == DungeonSpriteCollisionType.Box)
                    {
                        EditorGUILayout.PropertyField(physicsSize, new GUIContent("Size"));
                    }
                    else if (collisionTypeValue == DungeonSpriteCollisionType.Circle)
                    {
                        EditorGUILayout.PropertyField(physicsRadius, new GUIContent("Radius"));
                    }
                }
            }
            
            base.DrawPostInspectorGUI();
        }
        
        protected override string GetNodeTitle()
        {
            return "Sprite Node";
        }
    }

    /// <summary>
    /// Renders a sprite node
    /// </summary>
    public class SpriteNodeRenderer : VisualNodeRenderer
    {
        protected override Object GetThumbObject(GraphNode node)
        {
            var spriteNode = node as SpriteNode;
            if (spriteNode == null) return null;
            return spriteNode.sprite;
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\NodeEditors\VisualNodeEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Utils;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.Editors.SpatialConstraints;

namespace DungeonArchitect.Editors
{
    /// <summary>
    /// Custom property editor for visual nodes
    /// </summary>
    [CanEditMultipleObjects]
    [CustomEditor(typeof(VisualNode))]
    public abstract class VisualNodeEditor : PlaceableNodeEditor
	{
        SerializedProperty IsStatic;
        SerializedProperty affectsNavigation;
        SerializedProperty useSpatialConstraint;
        InstanceCache instanceCache = new InstanceCache();
        bool foldoutSpatialAdvanced = false;

        public override void OnEnable()
        {
            base.OnEnable();
            drawOffset = true;
			drawAttachments = true;
            IsStatic = sobject.FindProperty("IsStatic");
            affectsNavigation = sobject.FindProperty("affectsNavigation");
            useSpatialConstraint = sobject.FindProperty("useSpatialConstraint");
        }

        protected override void DrawMiscInspectorGUI()
        {
	        base.DrawMiscInspectorGUI();

	        DrawHeader("Misc");
			using (new EditorGUI.IndentLevelScope())
			{
				EditorGUILayout.PropertyField(IsStatic, new GUIContent("Force Static (editor only)"));
				EditorGUILayout.PropertyField(affectsNavigation);
			}

        }
        
        protected override void DrawPostInspectorGUI()
        {
	        DrawHeader("Rules");

            GUILayout.BeginHorizontal();
            GUILayout.Space(INDENT_SPACING);
            GUILayout.BeginVertical();
            
            var meshNode = target as VisualNode;
            DrawRule<SelectorRule>(" Selection Rule", ref meshNode.selectionRuleEnabled, ref meshNode.selectionRuleClassName);
            DrawRule<TransformationRule>(" Transform Rule", ref meshNode.transformRuleEnabled, ref meshNode.transformRuleClassName);

            GUILayout.EndVertical();
            GUILayout.EndHorizontal();
            
            GUI.enabled = true;

            DrawSpatialConstraintCategory();
        }

        void DrawSpatialConstraintCategory()
        {
	        DrawHeader("SpatialConstraint");
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(useSpatialConstraint);

            var visualNode = target as VisualNode;
            if (visualNode.useSpatialConstraint && visualNode.spatialConstraint != null)
            {
                visualNode.spatialConstraint.rotateToFit = EditorGUILayout.Toggle("Rotate to Fit?", visualNode.spatialConstraint.rotateToFit);
                visualNode.spatialConstraint.applyFitRotation = EditorGUILayout.Toggle("Apply Fit Rotation?", visualNode.spatialConstraint.applyFitRotation);

                foldoutSpatialAdvanced = EditorGUILayout.Foldout(foldoutSpatialAdvanced, "Advanced");
                if (foldoutSpatialAdvanced)
                {
                    EditorGUI.indentLevel++;
                    visualNode.spatialConstraint.checkRelativeToMarkerRotation = EditorGUILayout.Toggle("Check relative to marker rotation?", visualNode.spatialConstraint.checkRelativeToMarkerRotation);
                    EditorGUI.indentLevel--;
                }

                EditorGUI.indentLevel++;
                if (GUILayout.Button("Open Spatial Constraints Window"))
                {
	                SpatialConstraintsEditorWindow.ShowWindow();
                }
                EditorGUI.indentLevel--;
            }

            EditorGUI.indentLevel--;
        }

        string GetTypeName(System.Type type)
        {
            var meta = System.Attribute.GetCustomAttribute(type, typeof(MetaAttribute)) as MetaAttribute;
            if (meta != null)
            {
                return meta.displayText;
            }
            return type.Name;
        }
        

        void DrawRule<T>(string caption, ref bool ruleEnabled, ref string ruleClassName) where T : ScriptableObject
        {
            GUI.enabled = true;
            EditorGUILayout.BeginHorizontal();
            ruleEnabled = EditorGUILayout.ToggleLeft(caption, ruleEnabled);
            GUI.enabled = ruleEnabled; 
            MonoScript script = null;
            if (ruleClassName != null)
            {
                var rule = instanceCache.GetInstance(ruleClassName) as ScriptableObject;
                if (rule != null)
                {
                    script = MonoScript.FromScriptableObject(rule);
                } 
            }
            var oldScript = script;
            script = EditorGUILayout.ObjectField(script, typeof(MonoScript), false) as MonoScript;
            if (oldScript != script && script != null)
            {
	            var ruleType = script.GetClass();
	            if (ruleType.IsSubclassOf(typeof(T)))
	            {
		            ruleClassName = script.GetClass().AssemblyQualifiedName;
	            }
	            else
	            {
		            ruleClassName = null;
	            }
            }
            else if (script == null)
            {
                ruleClassName = null;
            }

            EditorGUILayout.EndHorizontal();
            
            GUI.enabled = true;
        }
    }

    /// <summary>
    /// Renders a visual node
    /// </summary>
    public abstract class VisualNodeRenderer : GraphNodeRenderer
    {
		protected virtual void DrawFrameTexture(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera) {
			DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_GO_NODE_FRAME);
		}

		protected virtual void DrawBackgroundTexture(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera) {
			DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_GO_NODE_BG);
		}

		protected virtual void DrawThumbnail(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera) {
			var thumbObject = GetThumbObject(node);
			var visualNode = node as VisualNode;
			var thumbnailSize = 96 / camera.ZoomLevel;
			if (thumbObject != null)
			{
				Texture texture = AssetThumbnailCache.Instance.GetThumb(thumbObject);
				if (texture != null)
				{
					var positionWorld = new Vector2(12, 12) + visualNode.Position;
					var positionScreen = camera.WorldToScreen(positionWorld);
                    renderer.DrawTexture(new Rect(positionScreen.x, positionScreen.y, thumbnailSize, thumbnailSize), texture);
				}
			}
			else
			{
				DrawTextCentered(renderer, rendererContext, node, camera, "None");
			}
		}

        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            DrawBackgroundTexture(renderer, rendererContext, node, camera);

			DrawThumbnail(renderer, rendererContext, node, camera);

			DrawFrameTexture(renderer, rendererContext, node, camera);

            base.Draw(renderer, rendererContext, node, camera);

            if (node.Selected)
            {
                DrawNodeTexture(renderer, rendererContext, node, camera, UIResourceLookup.TEXTURE_GO_NODE_SELECTION);
            }
        }

        protected abstract Object GetThumbObject(GraphNode node);
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Tools\CommonThemeEditorTools.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using UnityEditor;
using System;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.Builders;
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Builders.Isaac;
using DungeonArchitect.Builders.SimpleCity;
using DungeonArchitect.Builders.CircularCity;
using DungeonArchitect.Builders.FloorPlan;
using DungeonArchitect.Builders.Mario;
using DungeonArchitect.Builders.Maze;
using DungeonArchitect.Builders.BSP;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;
using DungeonArchitect.Builders.Infinity.Caves;
using DungeonArchitect.UI.Impl.UnityEditor;

namespace DungeonArchitect.Editors.ThemeEditorTools
{
    public class CommonThemeEditorTools
    {
        [ThemeEditorTool("Refresh Thumbnails", 100)]
        public static void RefreshThumbnails(DungeonThemeEditorWindow editor)
        {
            if (editor.GraphEditor != null)
            {
                AssetThumbnailCache.Instance.Reset();
            }
        }

        [ThemeEditorTool("Center On Graph", 200)]
        public static void CenterOnGraph(DungeonThemeEditorWindow editor)
        {
            if (editor.GraphEditor != null)
            {
                editor.GraphEditor.FocusCameraOnBestFit(editor.position);
            }
        }

        [ThemeEditorTool("Advanced/Recreate Node Ids", 100100)]
        public static void RecreateNodeIds(DungeonThemeEditorWindow editor)
        {
            var confirm = EditorUtility.DisplayDialog("Recreate Node Ids?",
                    "Are you sure you want to recreate node Ids?  You should do this after cloning a theme file", "Yes", "Cancel");
            if (confirm)
            {
                DungeonEditorHelper._Advanced_RecreateGraphNodeIds();
            }
        }
    }


    public class BuilderThemeEditorTools
    {
        [ThemeEditorTool("Create Default Markers For/Grid Builder", 10100)]
        public static void CreateDefaultMarkersForGrid(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(GridDungeonBuilder), editor.uiSystem);
        }

        [ThemeEditorTool("Create Default Markers For/Grid Flow Builder", 10105)]
        public static void CreateDefaultMarkersForGridFlow(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(GridFlowDungeonBuilder), editor.uiSystem);
        }

        [ThemeEditorTool("Create Default Markers For/Simple City Builder", 10200)]
        public static void CreateDefaultMarkersForSimpleCity(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(SimpleCityDungeonBuilder), editor.uiSystem);
        }

        [ThemeEditorTool("Create Default Markers For/Circular City Builder", 10200)]
        public static void CreateDefaultMarkersForCircularCity(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(CircularCityDungeonBuilder), editor.uiSystem);
        }

        [ThemeEditorTool("Create Default Markers For/Floor Plan Builder", 10300)]
        public static void CreateDefaultMarkersForFloorPlan(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(FloorPlanBuilder), editor.uiSystem);
        }

		[ThemeEditorTool("Create Default Markers For/Isaac Builder", 10400)]
		public static void CreateDefaultMarkersForIsaac(DungeonThemeEditorWindow editor)
		{
			CreateDefaultMarkersFor(editor.GraphEditor, typeof(IsaacDungeonBuilder), editor.uiSystem);
		}

        [ThemeEditorTool("Create Default Markers For/Mario Builder", 10500)]
        public static void CreateDefaultMarkersForMario(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(MarioDungeonBuilder), editor.uiSystem);
        }

        [ThemeEditorTool("Create Default Markers For/Maze Builder", 10600)]
        public static void CreateDefaultMarkersForMaze(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(MazeDungeonBuilder), editor.uiSystem);
        }

        [ThemeEditorTool("Create Default Markers For/Spatial Builder", 10700)]
        public static void CreateDefaultMarkersForBSP(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(BSPDungeonBuilder), editor.uiSystem);
        }

        [ThemeEditorTool("Create Default Markers For/Infinity Cave Builder", 10800)]
        public static void CreateDefaultMarkersForInfinityCaves(DungeonThemeEditorWindow editor)
        {
            CreateDefaultMarkersFor(editor.GraphEditor, typeof(InfinityCaveChunkBuilder), editor.uiSystem);
        }

        static void CreateDefaultMarkersFor(GraphEditor graphEditor, Type builderType, UISystem uiSystem)
        {
            // Remove unused nodes
            // Grab the names of all the markers nodes in the graph
            var markerNames = new List<string>();
            foreach (var node in graphEditor.Graph.Nodes)
            {
                if (node is MarkerNode)
                {
                    var markerNode = node as MarkerNode;
                    markerNames.Add(markerNode.Caption);
                }
            }

            var unusedMarkers = new List<string>(markerNames.ToArray());


            // Remove markers from the unused list that have child nodes attached to it
            foreach (var node in graphEditor.Graph.Nodes)
            {
                if (node is VisualNode)
                {
                    var visualNode = node as VisualNode;
                    foreach (var parentNode in visualNode.GetParentNodes())
                    {
                        if (parentNode is MarkerNode)
                        {
                            var markerNode = parentNode as MarkerNode;
                            unusedMarkers.Remove(markerNode.Caption);
                        }
                    }
                }
            }
            
            // Remove markers from the unused list that are referenced by other marker emitters
            foreach (var node in graphEditor.Graph.Nodes)
            {
                if (node is MarkerEmitterNode)
                {
                    var emitterNode = node as MarkerEmitterNode;
                    string markerName = emitterNode.Caption;
                    // this marker is referenced by an emitter.  Remove it from the unused list
                    unusedMarkers.Remove(markerName);
                }
            }

            // Remove markers from the unused list that are required by the new builder type
            var builderMarkers = DungeonBuilderDefaultMarkers.GetDefaultMarkers(builderType);
            foreach (var builderMarker in builderMarkers)
            {
                unusedMarkers.Remove(builderMarker);
            }

            // Remove all the unused markers
            var markerNodesToDelete = new List<MarkerNode>();
            foreach (var node in graphEditor.Graph.Nodes)
            {
                if (node is MarkerNode)
                {
                    var markerNode = node as MarkerNode;
                    if (unusedMarkers.Contains(markerNode.Caption)) {
                        markerNodesToDelete.Add(markerNode);
                    }
                }
            }

            graphEditor.DeleteNodes(markerNodesToDelete.ToArray(), uiSystem);


            // Grab the names of all the markers nodes in the graph
            markerNames.Clear();
            foreach (var node in graphEditor.Graph.Nodes)
            {
                if (node is MarkerNode)
                {
                    var markerNode = node as MarkerNode;
                    markerNames.Add(markerNode.Caption);
                }
            }

            var markersToCreate = new List<string>();
            foreach (var builderMarker in builderMarkers)
            {
                if (!markerNames.Contains(builderMarker))
                {
                    markersToCreate.Add(builderMarker);
                }
            }

            var existingBounds = new List<Rect>();
            foreach (var node in graphEditor.Graph.Nodes)
            {
                existingBounds.Add(node.Bounds);
            }
            
            // Add the new nodes
            const int INTER_NODE_X = 200;
            const int INTER_NODE_Y = 300;
            int itemsPerRow = 5;
            int positionIndex = 0;
            int ix, iy, x, y;
            var markerNodeSize = new Vector2(120, 50);
            for (int i = 0; i < markersToCreate.Count; i++)
            {
                bool overlaps;
                int numOverlapTries = 0;
                int MAX_OVERLAP_TRIES = 100;
                do
                {
                    ix = positionIndex % itemsPerRow;
                    iy = positionIndex / itemsPerRow;
                    x = ix * INTER_NODE_X;
                    y = iy * INTER_NODE_Y;
                    positionIndex++;

                    overlaps = false;
                    var newNodeBounds = new Rect(x, y, markerNodeSize.x, markerNodeSize.y);
                    foreach (var existingBound in existingBounds)
                    {
                        if (newNodeBounds.Overlaps(existingBound))
                        {
                            overlaps = true;
                            break;
                        }
                    }
                    numOverlapTries++;
                } while (overlaps && numOverlapTries < MAX_OVERLAP_TRIES);

                var newNode = GraphOperations.CreateNode<MarkerNode>(graphEditor.Graph, uiSystem.Undo);
                GraphEditorUtils.AddToAsset(new UnityEditorUIPlatform(), graphEditor.Graph, newNode);
                newNode.Position = new Vector2(x, y);
                newNode.Caption = markersToCreate[i];
                
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Tools\ThemeEditorToolAttribute.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;

namespace DungeonArchitect.Editors
{
    [AttributeUsage(AttributeTargets.Method)]
    public class ThemeEditorToolAttribute : Attribute
    {
        string path;
        public string Path
        {
            get { return path; }
        }

        int priority;
        public int Priority
        {
            get { return priority; }
        }

        public ThemeEditorToolAttribute(string path, int priority)
        {
            this.path = path;
            this.priority = priority;
        }
    }

    public delegate void ThemeEditorToolFunctionDelegate(DungeonThemeEditorWindow editor);

    public class ThemeEditorToolFunctionInfo
    {
        public ThemeEditorToolFunctionDelegate function;
        public ThemeEditorToolAttribute attribute;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Tools\ThemeEditorToolPrefabReplacement.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;


namespace DungeonArchitect.Editors.ThemeEditorTools
{

    public class ThemeEditorToolPrefabReplacement
    {
        [ThemeEditorTool("Advanced/Bulk Replace Prefab", 200)]
        public static void BuildReplacePrefab(DungeonThemeEditorWindow editor)
        {
            var window = (BulkPrefabReplacementWindow)EditorWindow.GetWindow(typeof(BulkPrefabReplacementWindow));
            if (window != null)
            {
                window.titleContent = new GUIContent("Bulk Prefab Replacer");
                window.GraphEditor = editor;
                window.Show();
            }
        }
    }

    public enum BulkPrefabReplacementRuleType
    {
        Directory
    }

    interface IBulkPrefabReplaceRuleProcessor
    {
        void DrawGUI();
        BulkReplacementEntry[] Process(DungeonThemeEditorWindow editor);
    }

    class BulkReplacementEntry
    {
        public GameObjectNode node;
        public FileInfo currentPrefabInfo;
        public FileInfo replacementPrefabInfo;
    }

    class DirectoryBulkPrefabReplaceRuleProcessor : IBulkPrefabReplaceRuleProcessor
    {
        string targetDirectory = "";
        public void DrawGUI()
        {
            targetDirectory = EditorGUILayout.TextField("Target Directory", targetDirectory);
        }

        
        /// <summary>
        /// Returns a map of the filename (not path just name) to file info mapping for all target directory prefabs
        /// </summary>
        /// <returns></returns>
        Dictionary<string, FileInfo> GetTargetFiles()
        {
            var result = new Dictionary<string, FileInfo>();
            var targetAssetGuids = AssetDatabase.FindAssets("", new string[] { targetDirectory });
            for (int i = 0; i < targetAssetGuids.Length; i++)
            {
                var path = AssetDatabase.GUIDToAssetPath(targetAssetGuids[i]);
                var fileInfo = new FileInfo(path);
                if (!result.ContainsKey(fileInfo.Name))
                {
                    result.Add(fileInfo.Name, fileInfo);
                }
            }
            return result;
        }
        

        public BulkReplacementEntry[] Process(DungeonThemeEditorWindow editor)
        {
            var graphEditor = editor.GraphEditor;
            var targetFiles = GetTargetFiles();
            var replacements = new List<BulkReplacementEntry>();
            foreach (var node in graphEditor.Graph.Nodes)
            {
                if (node is GameObjectNode)
                {
                    var goNode = node as GameObjectNode;
                    if (goNode.Template != null) {
                        string path = AssetDatabase.GetAssetPath(goNode.Template);
                        var pathInfo = new FileInfo(path);
                        if (pathInfo != null)
                        {
                            if (targetFiles.ContainsKey(pathInfo.Name))
                            {
                                // Found a target file. Replace
                                var replacementEntry = new BulkReplacementEntry();
                                replacementEntry.node = goNode;
                                replacementEntry.currentPrefabInfo = pathInfo;
                                replacementEntry.replacementPrefabInfo = targetFiles[pathInfo.Name];

                                // Make sure the current and target are not the same prefabs, to avoid unnecessary replacements
                                if (replacementEntry.currentPrefabInfo.FullName != replacementEntry.replacementPrefabInfo.FullName)
                                {
                                    replacements.Add(replacementEntry);
                                }
                            }
                        }
                    }
                }
            }

            return replacements.ToArray();
        }
    }

    class BulkPrefabReplaceRuleFactory
    {
        public static IBulkPrefabReplaceRuleProcessor CreateProcessor(BulkPrefabReplacementRuleType RuleType)
        {
            switch (RuleType)
            {
                case BulkPrefabReplacementRuleType.Directory:
                    return new DirectoryBulkPrefabReplaceRuleProcessor();

                default:
                    return null;
            }
        }
    }

    class BulkPrefabReplacementWindow : EditorWindow
    {
        BulkPrefabReplacementRuleType ruleType = BulkPrefabReplacementRuleType.Directory;
        IBulkPrefabReplaceRuleProcessor ruleProcessor = null;
        DungeonThemeEditorWindow graphEditor = null;
        public DungeonArchitect.Editors.DungeonThemeEditorWindow GraphEditor
        {
            get { return graphEditor; }
            set { graphEditor = value; }
        }

        void OnGUI()
        {
            GUILayout.Label("Bulk Prefab Replacer", EditorStyles.boldLabel);

            EditorGUILayout.HelpBox("Bulk Replace prefabs in your theme node based on a rule.  Backup your theme file before proceeding", MessageType.Info);

            GUI.changed = false;
            ruleType = (BulkPrefabReplacementRuleType)EditorGUILayout.EnumPopup("Replacement Rule:", ruleType);
            if (ruleProcessor == null || GUI.changed)
            {
                ruleProcessor = BulkPrefabReplaceRuleFactory.CreateProcessor(ruleType);
            }
            
            BeginIndent();

            EditorGUILayout.HelpBox(GetRuleDescription(ruleType), MessageType.None);

            if (ruleProcessor != null)
            {
                ruleProcessor.DrawGUI();
                if (GUILayout.Button("Bulk Replace"))
                {
                    var replacements = ruleProcessor.Process(graphEditor);
                    bool replaced = PerformReplacements(replacements);
                    if (replaced)
                    {
                        // Refresh the thumbnails
                        CommonThemeEditorTools.RefreshThumbnails(graphEditor);
                    }
                }
            }

            EndIndent();
        }

        bool PerformReplacements(BulkReplacementEntry[] replacements)
        {
            if (replacements.Length == 0)
            {
                EditorUtility.DisplayDialog("Bulk Replacement", "Nothing to replace", "Ok");
                return false;
            }

            // Show confirmation
            bool confirm = EditorUtility.DisplayDialog("Perform replacements?", GetReplacementReport(replacements), "Replace", "Cancel");
            if (!confirm)
            {
                return false;
            }

            foreach (var replacement in replacements) {
                var path = ChopPreAssetPath(replacement.replacementPrefabInfo.FullName);
                var template = AssetDatabase.LoadAssetAtPath(path, typeof(GameObject)) as GameObject;
                replacement.node.Template = template;
            }

            return true;
        }

        static string ChopPreAssetPath(string path)
        {
            int index = path.IndexOf("Assets");
            return (index != -1) ? path.Substring(index) : path;
        }

        string GetReplacementReport(BulkReplacementEntry[] replacements)
        {
            var report = new System.Text.StringBuilder();
            foreach (var replacement in replacements)
            {
                report.AppendFormat("{0} => {1},    ", 
                    ChopPreAssetPath(replacement.currentPrefabInfo.FullName),
                    ChopPreAssetPath(replacement.replacementPrefabInfo.FullName));
            }
            return report.ToString();
        }

        static string GetRuleDescription(BulkPrefabReplacementRuleType ruleType)
        {
            switch (ruleType)
            {
                case BulkPrefabReplacementRuleType.Directory:
                    return "Replaces with similar named prefabs found in the target directory for each visual graph node in the current theme graph.   Does nothing if not found. Directory path should start with Asset/...";

                default:
                    return "";
            }
        }

        static readonly int INDENT_SPACING = 10;

        void BeginIndent()
        {
            EditorGUILayout.BeginHorizontal();
            GUILayout.Space(INDENT_SPACING);
            EditorGUILayout.BeginVertical();
        }

        void EndIndent()
        {
            EditorGUILayout.EndVertical();
            EditorGUILayout.EndHorizontal();
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Utils\ThemeEditorUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Editors.Utils
{
    public static class ThemeEditorUtils
    {
        public static MarkerNode GetMarkerNodeInHierarchy(GraphNode node)
        {
            MarkerNode markerNode = null;

            if (node is MarkerNode)
            {
                markerNode = node as MarkerNode;
            }
            else if (node is VisualNode)
            {
                // Check if the node is linked to a marker node
                var incomingNodes = GraphUtils.GetIncomingNodes(node);
                if (incomingNodes.Length == 1)
                {
                    markerNode = incomingNodes[0] as MarkerNode;
                }
            }

            return markerNode;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\ThemeEditorSceneVisualizer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Themeing;
using DungeonArchitect.Utils;
using UnityEditor;
using UnityEngine;
using MathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Editors.Visualization
{
    [System.Serializable]
    class ThemeEditorSceneVisualizer
    {
        [SerializeField]
        private DungeonMarkerVisualizerComponent visualizerComponentRefInternal = null;
        
        public void Build(Dungeon dungeon, string markerName)
        {
            var state = CreateState(dungeon, markerName);
            if (state == null)
            {
                Clear();
                return;
            }
            
            var visualizerComp = GetVisualizerComponent();
            if (visualizerComp != null)
            {
                visualizerComp.Build(state);
            }
        }

        public void Clear()
        {
            var visualizerComp = GetVisualizerComponent();
            if (visualizerComp != null)
            {
                visualizerComp.Clear();
            }
        }

        private DungeonMarkerVisualizerComponent GetVisualizerComponent()
        {
            if (visualizerComponentRefInternal != null)
            {
                return visualizerComponentRefInternal;
            }
            
            // Find the component in the scene
            visualizerComponentRefInternal = Object.FindObjectOfType<DungeonMarkerVisualizerComponent>();
            if (visualizerComponentRefInternal == null)
            {
                visualizerComponentRefInternal = CreateVisualizerGameObject_Internal();
            }
            return visualizerComponentRefInternal;
        }
        
        private static DungeonMarkerVisualizerComponent CreateVisualizerGameObject_Internal()
        {
            var gameObject = EditorUtility.CreateGameObjectWithHideFlags("ThemeEditorVisualizer", HideFlags.HideAndDontSave);  // TODO: Change to HideAndDontSave  
            var component = gameObject.AddComponent<DungeonMarkerVisualizerComponent>();
            return component;
        }
        
        ThemeEditorVisualizationState CreateState(Dungeon dungeon, string markerName)
        {
            if (dungeon == null || string.IsNullOrEmpty(markerName))
            {
                return null;
            }
            
            var dungeonBuilder = dungeon.GetComponent<DungeonBuilder>();
            if (dungeonBuilder == null)
            {
                return null;
            }
            
            var markerVisualizationBuilder = ThemeMarkerVisualizationBuilderFactory.Create(dungeonBuilder.GetType()); 
            if (markerVisualizationBuilder == null)
            {
                return null;
            }

            var state = new ThemeEditorVisualizationState();
            if (!markerVisualizationBuilder.Build(dungeon, markerName, out state.LocalGeometry, out state.Material))
            {
                return null;
            }

            var dungeonConfig = dungeon.GetComponent<DungeonConfig>();
            var mode2D = dungeonConfig != null && dungeonConfig.IsMode2D();
            var rotation2D = Quaternion.Euler(90, 0, 0);
            if (mode2D)
            {
                // Flip the geometry for 2D mode
                if (state.LocalGeometry != null)
                {
                    for (var i = 0; i < state.LocalGeometry.Vertices.Length; i++)
                    {
                        //state.LocalGeometry.Vertices[i] = rotation2D * state.LocalGeometry.Vertices[i];
                    }
                }
            }
            
            // Fill up the marker transform list
            var markerTransforms = new List<Matrix4x4>();
            foreach (var marker in dungeonBuilder.Markers)
            {
                if (marker.SocketType == markerName)
                {
                    var markerTransform = marker.Transform;
                    if (mode2D)
                    {
                        var position = Matrix.GetTranslation(ref markerTransform);
                        position = MathUtils.FlipYZ(position);
                        position.z = -30;
                        var scale = Matrix.GetScale(ref markerTransform);
                        markerTransform = Matrix4x4.TRS(position, rotation2D, scale);
                    }
                    
                    markerTransforms.Add(markerTransform);
                }
            }

            state.MarkerTransforms = markerTransforms.ToArray();

            return state;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\BaseFlowExecNodeHandler_ResultInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_ResultInspector : FlowExecNodeHandlerInspectorBase
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\GridFlowExecInspectorsUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Impl.GridFlow;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    class GridFlowExecNodePlacementSettingInspector
    {
        DAInspectorMonoScriptProperty<ITilemapItemPlacementStrategy> scriptProperty;
        string settingsVariableName;
        string title;
        TilemapItemPlacementSettings settings;
        public GridFlowExecNodePlacementSettingInspector(FlowExecNodeHandlerInspectorBase inspector, string settingsVariableName, string title, TilemapItemPlacementSettings settings)
        {
            this.settingsVariableName = settingsVariableName;
            this.settings = settings;
            this.title = title;
            scriptProperty = inspector.CreateScriptProperty<ITilemapItemPlacementStrategy>(settings.placementScriptClass);
        }

        public void Draw(FlowExecNodeHandlerInspectorBase inspector)
        {
            EditorGUILayout.Space();
            GUILayout.Label(title, InspectorStyles.HeaderStyle);
            {
                EditorGUI.indentLevel++;

                inspector.DrawProperties(settingsVariableName + ".placementMethod");
                if (settings.placementMethod == TilemapItemPlacementMethod.Script)
                {
                    scriptProperty.Draw(className => settings.placementScriptClass = className);
                }

                if (settings.placementMethod != TilemapItemPlacementMethod.Script)
                {
                    inspector.DrawProperties(settingsVariableName + ".avoidPlacingNextToDoors");
                }

                if (settings.placementMethod != TilemapItemPlacementMethod.RandomTile)
                {
                    inspector.DrawProperties(settingsVariableName + ".fallbackToRandomPlacement");
                }
                
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\GridFlowExecNodeHandler_ResultInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Exec;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(FlowExecTaskResult), false)]
    public class GridFlowExecNodeHandler_ResultInspector : BaseFlowExecNodeHandler_ResultInspector
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\SnapGridFlow\SGFModuleDatabaseInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Text;
using DungeonArchitect.Editors.Flow.Impl;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.SnapGridFlow
{
    [CustomEditor(typeof(SnapGridFlowModuleDatabase))]
    public class SnapGridFlowModuleDatabaseEditor : Editor
    {
        private SerializedObject sobject;
        private SerializedProperty moduleBoundsAsset;
        private SerializedProperty modules;
        
        protected virtual void OnEnable()
        {
            sobject = new SerializedObject(target);
            moduleBoundsAsset = sobject.FindProperty("ModuleBoundsAsset");
            modules = sobject.FindProperty("Modules");
        }

        void BeginSection(string title)
        {
            GUILayout.Label(title, EditorStyles.boldLabel);
            GUILayout.BeginHorizontal();
            GUILayout.Space(20);
            GUILayout.BeginVertical();
        }

        void EndSection()
        {
            GUILayout.EndVertical();
            GUILayout.EndHorizontal();
            GUILayout.Space(10);
        }

        void CompileDatabase()
        {
            var moduleDB = target as SnapGridFlowModuleDatabase;
            SnapGridFlowModuleDBCompiler.CompileResultEntry[] errors;
            SnapGridFlowModuleDBCompiler.Build(moduleDB, out errors);
            
            // Display the error messages
            if (errors.Length > 0)
            {
                var message = new StringBuilder();
                foreach (var error in errors)
                {
                    if (error.moduleIndex == -1)
                    {
                        message.AppendFormat("[{0}]: {1}", error.errorType.ToString(), error.message);
                    }
                    else
                    {
                        message.AppendFormat("[{0} on Module Index {1}]: {2}", error.errorType.ToString(), error.moduleIndex, error.message);
                    }

                    message.AppendLine();
                }
                EditorUtility.DisplayDialog("Compile Failed", message.ToString(), "OK");
            }
        }
        
        public override void OnInspectorGUI()
        {
            EditorGUILayout.HelpBox(new GUIContent("Hit compile whenever you modify your module prefabs or change the module entries below"));
            if (GUILayout.Button("Compile Module Database"))
            {
                CompileDatabase();
            }
            
            sobject.Update();

            GUILayout.Space(10);

            BeginSection("Module Bounds");
            EditorGUILayout.PropertyField(moduleBoundsAsset);
            EditorGUILayout.HelpBox(new GUIContent("Assign the bounds asset that is used in all the registered module prefabs"), false);
            EndSection();

            BeginSection("Module Prefabs");
            EditorGUILayout.PropertyField(modules, true);
            EndSection();
            
            sobject.ApplyModifiedProperties();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\CircularCity\Landscape\LandscapeTransformerCircularCity.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Landscape;

namespace DungeonArchitect.Builders.CircularCity
{

    /// <summary>
    /// The type of the texture defined in the landscape paint settings.  
    /// This determines how the specified texture would be painted in the modified terrain
    /// </summary>
    public enum CircularCityLandscapeTextureType
    {
        Fill,
        Road,
        Park,
        CityWallPadding
    }

    /// <summary>
    /// Data-structure to hold the texture settings.  This contains enough information to paint the texture 
    /// on to the terrain
    /// </summary>
    [System.Serializable]
    public class CircularCityLandscapeTexture
    {
        public CircularCityLandscapeTextureType textureType;
        public Texture2D diffuse;
        public Texture2D normal;
        public float metallic = 0;
        public Vector2 size = new Vector2(15, 15);
        public Vector2 offset = Vector2.zero;
        public AnimationCurve curve;
    }

    [System.Serializable]
    public class CircularCityFoliageEntry
    {
        public int grassIndex;
        public float density;
    }

    [System.Serializable]
    public class CircularCityFoliageTheme
    {
        public CircularCityLandscapeTextureType textureType = CircularCityLandscapeTextureType.Park;
        public CircularCityFoliageEntry[] foliageEntries;
        public AnimationCurve curve;
        public float density;
    }


    /// <summary>
    /// The terrain modifier that works with the grid based dungeon builder (DungeonBuilderGrid)
    /// It modifies the terrain by adjusting the height around the layout of the dungeon and painting 
    /// it based on the specified texture settings 
    /// </summary>
    public class LandscapeTransformerCity : LandscapeTransformerBase
    {
        public CircularCityLandscapeTexture[] textures;

        public CircularCityFoliageTheme[] foliage;
        //CircularCityFoliageTheme roadFoliage;
        //CircularCityFoliageTheme openSpaceFoliage;

        public int roadBlurDistance = 6;
        public float corridorBlurThreshold = 0.5f;
        public float roomBlurThreshold = 0.5f;


        protected override void BuildTerrain(DungeonModel model)
        {
            if (model is CircularCityDungeonModel && terrain != null)
            {
                //var cityModel = model as CircularCityDungeonModel;
                //SetupTextures();
                //UpdateTerrainTextures(cityModel);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\FloorPlanner\Tooling\FloorPlanCorridorTool.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.FloorPlan.Tooling
{
    public class FloorPlanCorridorTool : MonoBehaviour
    {
        public Dungeon dungeon;
        public bool dynamicUpdate = true;
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Landscape\LandscapeTransformerGrid.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Landscape;

namespace DungeonArchitect.Builders.Grid
{

	/// <summary>
	/// The type of the texture defined in the landscape paint settings.  
	/// This determines how the specified texture would be painted in the modified terrain
	/// </summary>
	public enum LandscapeTextureType
	{
		Room,
		Corridor,
		Cliff
	}

	/// <summary>
	/// Data-structure to hold the texture settings.  This contains enough information to paint the texture 
	/// on to the terrain
	/// </summary>
	[System.Serializable]
	public class LandscapeTexture
	{
		public LandscapeTextureType textureType;
		public TerrainLayer terrainLayer;
	}
	
    /// <summary>
    /// The terrain modifier that works with the grid based dungeon builder (DungeonBuilderGrid)
    /// It modifies the terrain by adjusting the height around the layout of the dungeon and painting 
    /// it based on the specified texture settings 
    /// </summary>
	public class LandscapeTransformerGrid : LandscapeTransformerBase
    {
		public LandscapeTexture[] textures;

		// The offset to apply on the terrain at the rooms and corridors. 
		// If 0, then it would touch the rooms / corridors so players can walk over it
		// Give a negative value if you want it to be below it (e.g. if you already have a ground mesh supported by pillars standing on this terrain)
		public float layoutLevelOffset = 0;

		public int smoothingDistance = 5;
		public AnimationCurve roomElevationCurve;
		public AnimationCurve corridorElevationCurve;

        public int roadBlurDistance = 6;
        public float corridorBlurThreshold = 0.5f;
        public float roomBlurThreshold = 0.5f;

        protected override void BuildTerrain(DungeonModel model) {

            if (model is GridDungeonModel && terrain != null)
            {
                var gridMode = model as GridDungeonModel;
                SetupTextures();
                UpdateHeights(gridMode);
                UpdateTerrainTextures(gridMode);
            }
		}

        Rectangle EncompassCellBounds(Rectangle cellBounds, Rectangle bounds)
        {
            int minX = Mathf.Min(bounds.Location.x, cellBounds.Location.x);
            int minZ = Mathf.Min(bounds.Location.z, cellBounds.Location.z);
            int maxX = Mathf.Max(bounds.Location.x + bounds.Size.x, cellBounds.Location.x + cellBounds.Size.x);
            int maxZ = Mathf.Max(bounds.Location.z + bounds.Size.z, cellBounds.Location.z + cellBounds.Size.z);

            return new Rectangle(minX, minZ, maxX - minX, maxZ - minZ);
        }

        protected override Rect GetDungeonBounds(DungeonModel model) {
            var gridConfig = GetComponent<GridDungeonConfig>();
            var gridModel = model as GridDungeonModel;
            var bounds = new Rectangle(0, 0, 0, 0);

            if (gridModel && gridConfig)
            {
                if (gridModel.Cells.Count > 0)
                {
                    bool first = true;
                    
                    foreach (var cell in gridModel.Cells)
                    {
                        if (first)
                        {
                            bounds = cell.Bounds;
                            first = false;
                            continue;
                        }

                        bounds = EncompassCellBounds(cell.Bounds, bounds);
                    }
                }
            }

            float expandX, expandY;
            {
                int expandByLogical = smoothingDistance * 2;
                LandscapeDataRasterizer.TerrainToWorldDistance(terrain, expandByLogical, expandByLogical, out expandX, out expandY);
            }

            var gridSize2D = new Vector2(gridConfig.GridCellSize.x, gridConfig.GridCellSize.z);
            var worldPos = new Vector2(bounds.X, bounds.Z) * gridSize2D;
            var worldSize = new Vector2(bounds.Width, bounds.Length) * gridSize2D;
            var result = new Rect(worldPos, worldSize);
            result.x -= expandX;
            result.y -= expandY;
            result.width += expandX * 2;
            result.height += expandY * 2;
            
            return result;
        }

        void SetupTextures() {
            if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;

            // Add the specified terrain layers on the terrain data, if they have not been added already
            {
                var targetLayers = new List<TerrainLayer>(data.terrainLayers);
                foreach (var texture in textures)
                {
                    if (!targetLayers.Contains(texture.terrainLayer))
                    {
                        targetLayers.Add(texture.terrainLayer);
                    }
                }

                data.terrainLayers = targetLayers.ToArray();
            }
        }

		void UpdateHeights(GridDungeonModel model) {
			if (terrain == null || terrain.terrainData == null) return;
			var rasterizer = new LandscapeDataRasterizer(terrain, GetDungeonBounds(model));
			rasterizer.LoadData();
			var gridSize = model.Config.GridCellSize;

			// Raise the terrain
			foreach (var cell in model.Cells) {
				var locationGrid = cell.Bounds.Location;
				var location = locationGrid * gridSize;
				var size = cell.Bounds.Size * gridSize;
				var cellY = location.y + layoutLevelOffset;
				rasterizer.DrawCell(location.x, location.z, size.x, size.z, cellY);
			}

            // Smooth the terrain
            ApplySmoothing(model, rasterizer);
            
			rasterizer.SaveData();
		}

        protected virtual void ApplySmoothing(GridDungeonModel model, LandscapeDataRasterizer rasterizer)
        {
            var gridSize = model.Config.GridCellSize;
            foreach (var cell in model.Cells)
            {
                var locationGrid = cell.Bounds.Location;
                var location = locationGrid * gridSize;
                var size = cell.Bounds.Size * gridSize;
                var cellY = location.y + layoutLevelOffset;
                var curve = (cell.CellType == CellType.Room) ? roomElevationCurve : corridorElevationCurve;
                rasterizer.SmoothCell(location.x, location.z, size.x, size.z, cellY, smoothingDistance, curve);
            }
        }

		void UpdateTerrainTextures(GridDungeonModel model) {
            if (terrain == null || terrain.terrainData == null) return;

			var data = terrain.terrainData;
			//var map = new float[data.alphamapWidth, data.alphamapHeight, numTextures];
            var map = data.GetAlphamaps(0, 0, data.alphamapWidth, data.alphamapHeight);
			UpdateBaseTexture(model, map);
			UpdateCliffTexture(map);
            RemoveFoliage(model);

			data.SetAlphamaps(0, 0, map);
		}

        void RemoveFoliage(GridDungeonModel model)
        {
            if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;
            var gridSize = model.Config.GridCellSize;

            foreach (var cell in model.Cells)
            {
                if (cell.CellType == CellType.Unknown) continue;

                var bounds = cell.Bounds;
                var locationGrid = bounds.Location;
                var location = locationGrid * gridSize;
                var size = bounds.Size * gridSize;
                int gx1, gy1, gx2, gy2;
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, location.x, location.z, out gx1, out gy1, RasterizerTextureSpace.DetailMap);
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, location.x + size.x, location.z + size.z, out gx2, out gy2, RasterizerTextureSpace.DetailMap);

                int sx = gx2 - gx1 + 1;
                int sy = gy2 - gy1 + 1;
                int[,] clearPatch = new int[sy, sx];
                for (int d = 0; d < data.detailPrototypes.Length; d++)
                {
                    data.SetDetailLayer(gx1, gy1, d, clearPatch);
                }
            }
        }

		void UpdateBaseTexture(GridDungeonModel model, float[,,] map) {
			if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;

            int corridorIndex = GetTextureIndex(LandscapeTextureType.Corridor);
            int roomIndex = GetTextureIndex(LandscapeTextureType.Room);

            // Apply the room/corridor texture
            {
				var gridSize = model.Config.GridCellSize;
                var roomMap = new float[map.GetLength(0), map.GetLength(1)];
                var corridorMap = new float[map.GetLength(0), map.GetLength(1)];
                foreach (var cell in model.Cells)
                {
					var bounds = cell.Bounds;
					var locationGrid = bounds.Location;
					var location = locationGrid * gridSize;
					var size = bounds.Size * gridSize;
					int gx1, gy1, gx2, gy2;
					LandscapeDataRasterizer.WorldToTerrainTextureCoord(terrain, location.x, location.z, out gx1, out gy1);
					LandscapeDataRasterizer.WorldToTerrainTextureCoord(terrain, location.x + size.x, location.z + size.z, out gx2, out gy2);
					for (var gx = gx1; gx <= gx2; gx++) {
						for (var gy = gy1; gy <= gy2; gy++) {
                            if (cell.CellType == CellType.Unknown) continue;
                            if (cell.CellType == CellType.Room)
                            {
                                roomMap[gy, gx] = 1;
                            }
                            else
                            {
                                corridorMap[gy, gx] = 1;
                            }
						}
					}
				}

                // Blur the layout data
                var filter = new BlurFilter(roadBlurDistance);
                roomMap = filter.ApplyFilter(roomMap);
                corridorMap = filter.ApplyFilter(corridorMap);

                // Fill up the inner region with corridor index
                int numMaps = map.GetLength(2);
				for (var y = 0; y < data.alphamapHeight; y++) {
					for (var x = 0; x < data.alphamapWidth; x++) {
                        bool wroteData = false;
                        bool isCorridor = (corridorMap[y, x] > corridorBlurThreshold);
						if (isCorridor) {
                            if (roomIndex >= 0)
                            {
                                map[y, x, roomIndex] = 0;
                            }
                            if (corridorIndex >= 0)
                            {
                                map[y, x, corridorIndex] = 1;
                                wroteData = true;
                            }
                        }
                    
                        bool isRoom = (roomMap[y, x] > roomBlurThreshold);
                        if (isRoom)
                        {
                            if (corridorIndex >= 0)
                            {
                                map[y, x, corridorIndex] = 0;
                            }
                            if (roomIndex >= 0)
                            {
                                map[y, x, roomIndex] = 1;
                                wroteData = true;
                            }
                        }

                        if (wroteData)
                        {
                            // Clear out other masks
                            for (int m = 0; m < numMaps; m++)
                            {
                                if (m == corridorIndex || m == roomIndex)
                                {
                                    continue;
                                }

                                map[y, x, m] = 0;
                            }
                        }
                    }
				}
			}
		}

		void UpdateCliffTexture(float[,,] map) {
			if (terrain == null) return;
			int cliffIndex = GetTextureIndex(LandscapeTextureType.Cliff);
			if (cliffIndex < 0) return;
			
			var data = terrain.terrainData;
			
			// For each point on the alphamap...
			for (var y = 0; y < data.alphamapHeight; y++) {
				for (var x = 0; x < data.alphamapWidth; x++) {
					// Get the normalized terrain coordinate that
					// corresponds to the the point.
					var normX = x * 1.0f / (data.alphamapWidth - 1);
					var normY = y * 1.0f / (data.alphamapHeight - 1);
					
					// Get the steepness value at the normalized coordinate.
					var angle = data.GetSteepness(normX, normY);
					
					// Steepness is given as an angle, 0..90 degrees. Divide
					// by 90 to get an alpha blending value in the range 0..1.
					var frac = angle / 90.0f;
					frac *= 2;
					frac = Mathf.Clamp01(frac);
					var cliffRatio = frac;
					var nonCliffRatio = 1 - frac;
					
					for (int t = 0; t < textures.Length; t++) {
						if (t == cliffIndex) {
							map[y, x, t] = cliffRatio;
						} else {
							map[y, x, t] *= nonCliffRatio;
						}
					}
				}
			}
		}
		
		/// <summary>
		/// Returns the index of the landscape texture.  -1 if not found
		/// </summary>
		/// <returns>The texture index. -1 if not found</returns>
		/// <param name="textureType">Texture type.</param>
		int GetTextureIndex(LandscapeTextureType textureType) {
            if (terrain == null || terrain.terrainData == null) return -1;
            var data = terrain.terrainData;
            for (int i = 0; i < textures.Length; i++) {
				if (textures[i].textureType == textureType) {
                    return System.Array.IndexOf(data.terrainLayers, textures[i].terrainLayer);
				}
			}
			return -1;	// Doesn't exist
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\LevelStreaming\GridDungeonItemGroup.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.LevelStreaming;

namespace DungeonArchitect.Builders.Grid
{
    public class GridDungeonItemGroup : DungeonItemGroup
    {
        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            base.OnPostDungeonBuild(dungeon,  model);
            
            GridDungeonModel gridModel = dungeon.ActiveModel as GridDungeonModel;
            
        var _groupInfoArray = GameObject.FindObjectsOfType<DungeonItemGroupInfo>();

        Dictionary<int, DungeonItemGroupInfo> groupObjectByCellId = new Dictionary<int, DungeonItemGroupInfo>();

        foreach (var groupInfo in _groupInfoArray)
        {
            if (groupInfo.dungeon == dungeon)
            {
                var cellId = groupInfo.groupId;
                var cell = gridModel.GetCell(cellId);
                if (cell == null || cell.CellType == CellType.Unknown)
                {
                    continue;
                }


                string objectNamePrefix = "";
                if (cell.CellType == CellType.Room)
                {
                    objectNamePrefix = "Room_";
                }
                else
                {
                    groupObjectByCellId[cell.Id] = groupInfo;

                    objectNamePrefix = (cell.CellType == CellType.Corridor) ? "CorridorBlock_" : "CorridorPad_";
                }

                if (objectNamePrefix.Length == 0)
                {
                    objectNamePrefix = "Cell_";
                }

                string groupName = objectNamePrefix + cell.Id;
                groupInfo.gameObject.name = groupName;
            }
        }


        var visited = new HashSet<int>();
        int clusterCounter = 1;
        var oldGroupsToDelete = new List<GameObject>();

        foreach (var groupInfo in groupObjectByCellId.Values)
        {
            var cellId = groupInfo.groupId;
            if (visited.Contains(cellId))
            {
                continue;
            }

            var clusters = GridBuilderUtils.GetCellCluster(gridModel, cellId);
            var itemsToGroup = new List<GameObject>();

            // Mark all cluster cells as visited
            foreach (var clusterItemId in clusters)
            {
                visited.Add(clusterItemId);
                if (groupObjectByCellId.ContainsKey(clusterItemId))
                {
                    var clusterItemGroupInfo = groupObjectByCellId[clusterItemId];
                    for (int i = 0; i < clusterItemGroupInfo.transform.childCount; i++)
                    {
                        var childObject = clusterItemGroupInfo.transform.GetChild(i);
                        itemsToGroup.Add(childObject.gameObject);
                    }
                    oldGroupsToDelete.Add(clusterItemGroupInfo.gameObject);
                }
            }

            int clusterId = clusterCounter++;
            GroupItems(itemsToGroup.ToArray(), "Corridor_" + clusterId, dungeon, clusterId);
        }

        groupObjectByCellId.Clear();

        // Destroy the inner group info objects
        foreach (var itemToDestory in oldGroupsToDelete)
        {
            EditorDestroyObject(itemToDestory);
        }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\MarkerEmitters\MarkerEmitterCornerBeautifier.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Grid
{
    /// <summary>
    /// Emits markers to beautify the level around corners based on the surrounding tiles
    /// </summary>
	public class MarkerEmitterCornerBeautifier : DungeonMarkerEmitter {
		public override void EmitMarkers(DungeonBuilder builder)
		{
			if (!(builder is GridDungeonBuilder))
			{
				Debug.LogWarning("Unsupported builder type used with marker emitter MarkerEmitterFindLowestPoint. Expected GridDungeonBuilder. Received:" + (builder != null ? builder.GetType().ToString() : "null"));
				return;
			}
			
			var gridModel = builder.Model as GridDungeonModel;

			foreach (var cell in gridModel.Cells) {
				var borderPoints = cell.Bounds.GetBorderPoints();
				foreach (var borderPoint in borderPoints) {
					EmitForPoint(builder, gridModel, borderPoint);
				}
			}
		}

		void EmitForPoint(DungeonBuilder builder, GridDungeonModel model, IntVector point) {
			foreach (var config in CornerConfigs) {
				if (ConfigMatches(model, point, config)) {
					EmitCornerMarker(builder, model, point, config.markerName);
					break;
				}
			}
		}

		bool ConfigMatches(GridDungeonModel model, IntVector point, CellSpatialConfig config) {
			var neighbors = config.neighborConfig;
			for (int i = 0; i < neighbors.Length; i++) {
				var code = neighbors[i];
				if (code == 0) {
					// Don't care about this cell
					continue;
				}
				var dx = i % 3;
				var dz = i / 3;
				dx--; dz--;	 // bring to -1..1 range (from previous 0..2)
				dz *= -1;
				var x = point.x + dx;
				var z = point.z + dz;

				var cellInfo = model.GetGridCellLookup(x, z);
				bool empty = cellInfo.CellType == CellType.Unknown;
				if (code == 1 && empty) {
					// We were expecting a non-empty space here, but it is empty
					return false;
				}
				else if (code == 2 && !empty) {
					// We were expecting a empty space here, but it is not empty
					return false;
				}
			}

			// Matches, all tests have passed
			return true;
		}

		void EmitCornerMarker(DungeonBuilder builder, GridDungeonModel model, IntVector point, string markerName) {
			// Add an empty marker here
			var gridSize = model.Config.GridCellSize;
			var position = point * gridSize;
			position += Vector3.Scale(new Vector3(0.5f, 0, 0.5f), gridSize);
			var transform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
			builder.EmitMarker(markerName, transform, point, -1);
		}

		
		class CellSpatialConfig {
			public CellSpatialConfig(string markerName, int[] neighborConfig) {
				this.markerName = markerName;
				this.neighborConfig = neighborConfig;
			}
			public string markerName;
			public int[] neighborConfig;
		}

		//// Neighbor config flags
		//  0: Dont care
		//  1: Land
		//  2: Empty Space
		/////////////////////////
		
		static CellSpatialConfig[] CornerConfigs = new CellSpatialConfig[] {
			new CellSpatialConfig("Corner_N", new int[] {
				0, 2, 0,
				1, 1, 1,
				0, 0, 0
			}),
			
			new CellSpatialConfig("Corner_S", new int[] {
				0, 0, 0,
				1, 1, 1,
				0, 2, 0
			}),
			
			new CellSpatialConfig("Corner_W", new int[] {
				0, 1, 0,
				2, 1, 0,
				0, 1, 0
			}),
			
			new CellSpatialConfig("Corner_E", new int[] {
				0, 1, 0,
				0, 1, 2,
				0, 1, 0
			}),
			
			/*
			*/
			new CellSpatialConfig("Corner_BSlash", new int[] {
				1, 1, 2,
				1, 1, 1,
				2, 1, 1
			}),
			new CellSpatialConfig("Corner_Slash", new int[] {
				2, 1, 1,
				1, 1, 1,
				1, 1, 2
			}),

			new CellSpatialConfig("Corner_ISlash", new int[] {
				1, 2, 2,
				2, 1, 2,
				2, 2, 1
			}),
			new CellSpatialConfig("Corner_IBSlash", new int[] {
				2, 2, 1,
				2, 1, 2,
				1, 2, 2
			}),

			new CellSpatialConfig("Corner_NW", new int[] {
				0, 2, 0,
				2, 1, 1,
				0, 1, 0
			}),
			
			new CellSpatialConfig("Corner_NE", new int[] {
				0, 2, 0,
				1, 1, 2,
				0, 1, 0
			}),
			
			new CellSpatialConfig("Corner_SW", new int[] {
				0, 1, 0,
				2, 1, 1,
				0, 2, 0
			}),
			
			new CellSpatialConfig("Corner_SE", new int[] {
				0, 1, 0,
				1, 1, 2,
				0, 2, 0
			}),
			
			// Inverted
			new CellSpatialConfig("Corner_INW", new int[] {
				2, 1, 0,
				1, 1, 0,
				0, 0, 0
			}),
			
			new CellSpatialConfig("Corner_INE", new int[] {
				0, 1, 2,
				0, 1, 1,
				0, 0, 0
			}),
			
			new CellSpatialConfig("Corner_ISW", new int[] {
				0, 0, 0,
				1, 1, 0,
				2, 1, 0
			}),
			
			new CellSpatialConfig("Corner_ISE", new int[] {
				0, 0, 0,
				0, 1, 1,
				0, 1, 2
			}),

		};

	}

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\MarkerEmitters\MarkerEmitterEmptySpace.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Builders.Grid
{
    /// <summary>
    /// Emits markers in the nearby empty space of the dungeon layout
    /// </summary>
    public class MarkerEmitterEmptySpace : DungeonMarkerEmitter
    {
        public int distanceToCover = 3;
        public string markerName = "EmptySpace";
        public string indexedMarkerNamePrefix = "EmptySpace_";

        public bool overrideY = false;
        public string overrideYBlackboardKey = "DungeonLowestY";

        public override void EmitMarkers(DungeonBuilder builder)
        {
            var visited = new HashSet<IntVector>();
            var model = builder.Model as GridDungeonModel;
            if (model == null) return;

            var config = model.Config as GridDungeonConfig;
            if (config == null) return;

            var gridSize = config.GridCellSize;
            float overrideYValue = 0;
            if (overrideY)
            {
                overrideYValue = builder.Blackboard.FloatEntries.GetValue(overrideYBlackboardKey);
            }

            for (int d = 1; d <= distanceToCover; d++)
            {
                var indexedMarkerName = indexedMarkerNamePrefix + d;
                foreach (var cell in model.Cells)
                {
                    if (cell.CellType == CellType.Unknown) continue;

                    var bounds = cell.Bounds;
                    bounds = Rectangle.ExpandBounds(bounds, d);
                    var points = bounds.GetBorderPoints();
                    foreach (var point in points)
                    {
                        var hash = new IntVector(point.x, 0, point.z);
                        if (!visited.Contains(hash))
                        {
                            // Check if this point does not lie in a cell
                            var cellInfo = model.GetGridCellLookup(point.x, point.z);
                            if (cellInfo.CellType == CellType.Unknown)
                            {
                                // Add an empty marker here
                                var position = point * gridSize;
                                position += Vector3.Scale(new Vector3(0.5f, 0, 0.5f), gridSize);
                                if (overrideY)
                                {
                                    position.y = overrideYValue;
                                }

                                var transform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
                                builder.EmitMarker(markerName, transform, point, -1);
                                builder.EmitMarker(indexedMarkerName, transform, point, -1);
                            }

                            visited.Add(hash);
                        }
                    }
                }
            }
        }

        
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\MarkerEmitters\MarkerEmitterFindLowestPoint.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Grid
{
    /// <summary>
    /// Finds the lowest dungeon point and emits a marker at that position.  Also sets the scale of the marker to match the width / height
    /// </summary>
    public class MarkerEmitterFindLowestPoint : DungeonMarkerEmitter
    {
        public string MarkerName = "LowestPoint";
        public string BlackboardKeyLowestY = "DungeonLowestY";

        public override void EmitMarkers(DungeonBuilder builder)
        {
            if (!(builder is GridDungeonBuilder))
            {
                Debug.LogWarning("Unsupported builder type used with marker emitter MarkerEmitterFindLowestPoint. Expected GridDungeonBuilder. Received:" + (builder != null ? builder.GetType().ToString() : "null"));
                return;
            }

            var gridModel = builder.Model as GridDungeonModel;
            var Min = new Vector3(int.MaxValue, int.MaxValue, int.MaxValue);
            var Max = new Vector3(-int.MaxValue, -int.MaxValue, -int.MaxValue);
            var gridSize = gridModel.Config.GridCellSize;

            if (gridModel.Cells.Count == 0)
            {
                Min = Vector3.zero;
                Max = Vector3.zero;
            }
            else
            {
                foreach (var cell in gridModel.Cells)
                {
                    var location = cell.Bounds.Location * gridSize;
                    var size = cell.Bounds.Size * gridSize;
                    Min.x = Mathf.Min(Min.x, location.x);
                    Min.y = Mathf.Min(Min.y, location.y);
                    Min.z = Mathf.Min(Min.z, location.z);

                    Max.x = Mathf.Max(Max.x, location.x + size.x);
                    Max.y = Mathf.Max(Max.y, location.y + size.y);
                    Max.z = Mathf.Max(Max.z, location.z + size.z);
                }
            }

            var rangeSize = Max - Min;

            var position = (Max + Min) / 2;
            position.y = Min.y;

            var scale = new Vector3(rangeSize.x, 1, rangeSize.z);
            var transform = Matrix4x4.TRS(position, Quaternion.identity, scale);

            builder.EmitMarker(MarkerName, transform, IntVector.Zero, -1);

            // Save this for other markers to use, if needed
            builder.Blackboard.FloatEntries.SetValue(BlackboardKeyLowestY, Min.y);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\MarkerEmitters\MarkerEmitterFreeSpaceDecorator.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Builders.Grid
{
    /// <summary>
    /// A more specialized version of the EmptySpace emitter. Emits decorative markers in empty space near the layout
    /// </summary>
	public class MarkerEmitterFreeSpaceDecorator : DungeonMarkerEmitter
	{
		public int distanceFromEdge = 2;
		public string markerName = "EmtpySpaceDecoration";

		public float pushDownAmount = 6;
		public Vector3[] pushDownTestAxis = new Vector3[0];

		public override void EmitMarkers(DungeonBuilder builder)
		{
			if (!(builder is GridDungeonBuilder))
			{
				Debug.LogWarning("Unsupported builder type used with marker emitter MarkerEmitterFreeSpaceDecorator. Expected GridDungeonBuilder. Received:" + (builder != null ? builder.GetType().ToString() : "null"));
				return;
			}
			
			var model = builder.Model as GridDungeonModel;
			var gridSize = model.Config.GridCellSize;

			
			var visited = new HashSet<IntVector>();
			var occupied = new HashSet<IntVector>();
			foreach (var cell in model.Cells)
			{
				if (cell.CellType == CellType.Unknown) continue;

				for (var distance = 2; distance <= 2; distance++) {
					var bounds = cell.Bounds;
					bounds = Rectangle.ExpandBounds(bounds, distance);
					var points = bounds.GetBorderPoints();
					foreach (var point in points)
					{
						
						var hash = new IntVector(point.x, 0, point.z);
						if (!visited.Contains(hash))
						{
							visited.Add(hash);
							if (occupied.Contains(hash)) continue;

							// Check if this point does not lie in a cell
							var cellInfo = model.GetGridCellLookup(point.x, point.z);
							if (cellInfo.CellType == CellType.Unknown)
							{
								// Make sure the surrounding area is free so we can place a decorative item
								bool valid = true;
								var s = distanceFromEdge - 1;
								for (var dx = -s; dx <= s; dx++) {
									for (var dz = -s; dz <= s; dz++) {
										var x = point.x + dx;
										var z = point.z + dz;
										var neighborHash = new IntVector(x, 0, z);
										if (occupied.Contains(neighborHash)) {
											valid = false;
											break;
										}
										var neighborCellInfo = model.GetGridCellLookup(x, z);
										if (neighborCellInfo.CellType != CellType.Unknown) {
											// Occupied by an existing cell
											occupied.Add(neighborHash);
											valid = false;
											break;
										}
									}
									if (!valid) {
										break;
									}
								}


								if (valid) {
									// Valid space.  Occupy the space here
									for (var dx = -s; dx <= s; dx++) {
										for (var dz = -s; dz <= s; dz++) {
											var x = point.x + dx;
											var z = point.z + dz;
											occupied.Add (new IntVector(x, 0, z));
										}
									}

									var pushDownY = 0.0f;
									foreach (var pushDownAxis in pushDownTestAxis) {
										var delta = pushDownAxis * distanceFromEdge;
										var x = point.x + Mathf.RoundToInt(delta.x);
										var z = point.z + Mathf.RoundToInt(delta.z);
										var testCellInfo = model.GetGridCellLookup(x, z);
										if (testCellInfo.CellType != CellType.Unknown) {
											pushDownY = pushDownAmount;
										}
									}

									var position = point * gridSize + new Vector3(gridSize.x, 0, gridSize.z) * 0.5f;
									position.y -= pushDownY;
									var transform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);

									builder.EmitMarker(markerName, transform, point, -1);
								}
							}
							else {
								// Occupied by a cell
								occupied.Add(hash);
							}
						}
					}
				}
			}
		}


	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\MarkerEmitters\MarkerEmitterGridWall2D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.Grid
{
    public class MarkerEmitterGridWall2D : DungeonMarkerEmitter
    {
        public enum WallPushType
        {
            WallsOutside,
            WallsInside
        }
        public WallPushType wallPushType = WallPushType.WallsOutside;
        public bool fixCorners = true;

        class Wall2DMarkerInfo
        {
            public string markerName;
            public Matrix4x4 transform;
            public IntVector gridPosition;
            public int cellId;
        }

        public override void EmitMarkers(DungeonBuilder builder)
        {
            var gridModel = builder.Model as GridDungeonModel;
            if (gridModel == null)
            {
                Debug.LogWarning("invalid builder used with this marker emitter");
                return;
            }

            var config = gridModel.Config;
            var gridSize = config.GridCellSize;
            var wall2DMarkers = new List<Wall2DMarkerInfo>();
            var occupied = new Dictionary<string, HashSet<IntVector>>();

            foreach (var prop in builder.Markers)
            {
                if (prop.SocketType == GridDungeonMarkerNames.Wall)
                {
                    var markerInfo = GetMarker2D(prop, GridDungeonMarkerNames.Wall2D, gridSize);
                    RegisterMarker(markerInfo, wall2DMarkers, occupied);
                }
                else if (prop.SocketType == GridDungeonMarkerNames.Fence)
                {
                    var markerInfo = GetMarker2D(prop, GridDungeonMarkerNames.Wall2D, gridSize);
                    RegisterMarker(markerInfo, wall2DMarkers, occupied);
                }
                else if (prop.SocketType == GridDungeonMarkerNames.Door)
                {
                    var rotation = Matrix.GetRotation(ref prop.Transform);
                    var angleStep = (Mathf.RoundToInt(rotation.eulerAngles.y / 90.0f) + 4) % 4;
                    var doorMarker = GridDungeonMarkerNames.Door2D;
                    if (angleStep == 1 || angleStep == 3) { 
                        // Angle is 90 or 270
                        doorMarker = GridDungeonMarkerNames.Door2D_90;
                    }

                    var markerInfo = GetMarker2D(prop, doorMarker, gridSize);
                    RegisterMarker(markerInfo, wall2DMarkers, occupied);
                }
            }

            // fix the corners 
            if (fixCorners)
            {
                FixCornerWalls(wall2DMarkers, builder.Markers, occupied, gridSize);
            }

            {
                // Add Ground2d markers. These are the same as ground markers, except that are not placed over 2d walls
                AddGround2DMarkers(wall2DMarkers, occupied, builder.Markers, gridSize);
            }

            foreach (var markerInfo in wall2DMarkers)
            {
                builder.EmitMarker(markerInfo.markerName, markerInfo.transform, markerInfo.gridPosition, markerInfo.cellId);
            }
        }

        void AddGround2DMarkers(List<Wall2DMarkerInfo> markerList, Dictionary<string, HashSet<IntVector>> occupied, LevelMarkerList gridMarkers, Vector3 gridSize)
        {
            var walls = GetHashSet(GridDungeonMarkerNames.Wall2D, occupied);

            foreach (var marker in gridMarkers)
            {
                if (marker.SocketType == GridDungeonMarkerNames.Ground)
                {
                    // Make sure we don't have a wall here
                    if (walls.Contains(marker.gridPosition))
                    {
                        // Contains a wall here. We don't want a 2D ground here
                        continue;
                    }

                    var wall2D = new Wall2DMarkerInfo();
                    wall2D.cellId = marker.cellId;
                    wall2D.gridPosition = marker.gridPosition;
                    wall2D.markerName = GridDungeonMarkerNames.Ground2D;
                    var position = marker.gridPosition * gridSize + gridSize / 2.0f;
                    wall2D.transform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);

                    RegisterMarker(wall2D, markerList, occupied);
                }
            }
        }


        HashSet<IntVector> GetHashSet(string name, Dictionary<string, HashSet<IntVector>> occupied)
        {
            if (occupied.ContainsKey(name))
            {
                return occupied[name];
            }
            return new HashSet<IntVector>();
        }

        void FixCornerWalls(List<Wall2DMarkerInfo> wall2DMarkers, LevelMarkerList gridMarkers, Dictionary<string, HashSet<IntVector>> occupied, Vector3 gridSize) {
            HashSet<IntVector> wall2DPositions = GetHashSet(GridDungeonMarkerNames.Wall2D, occupied);
            HashSet<IntVector> door2DPositions = GetHashSet(GridDungeonMarkerNames.Door2D, occupied);
            {
                HashSet<IntVector> door2DPositions90 = GetHashSet(GridDungeonMarkerNames.Door2D_90, occupied);
                foreach (var door90Pos in door2DPositions90)
                {
                    door2DPositions.Add(door90Pos);
                }
            }


            if (occupied.ContainsKey(GridDungeonMarkerNames.Door2D))
            {
                door2DPositions = occupied[GridDungeonMarkerNames.Door2D];
            }
            else
            {
                door2DPositions = new HashSet<IntVector>();
            }

            foreach (var marker in gridMarkers)
            {
                if (marker.SocketType == GridDungeonMarkerNames.Ground)
                {
                    if (wallPushType == WallPushType.WallsInside)
                    {
                        var center = marker.gridPosition;
                        var insertCorner = false;
                        if (!wall2DPositions.Contains(center))
                        {
                            insertCorner = HasValidCornerNeighbors(wall2DPositions, door2DPositions, center, -1, 0, 0, 1) ||
                                HasValidCornerNeighbors(wall2DPositions, door2DPositions, center, 0, 1, 1, 0) ||
                                HasValidCornerNeighbors(wall2DPositions, door2DPositions, center, 1, 0, 0, -1) ||
                                HasValidCornerNeighbors(wall2DPositions, door2DPositions, center, 0, -1, -1, 0);
                            if (insertCorner)
                            {
                                InsertCornerMarker(marker.cellId, marker.gridPosition, gridSize, wall2DMarkers, occupied);
                            }
                        }
                    }
                    else if (wallPushType == WallPushType.WallsOutside)
                    {
                        var center = marker.gridPosition;
                        if (!wall2DPositions.Contains(center))
                        {
                            if (HasValidCornerNeighbors(wall2DPositions, door2DPositions, center, -1, 0, 0, 1))
                            {
                                var corner = center + new IntVector(-1, 0, 1);
                                InsertCornerMarker(marker.cellId, corner, gridSize, wall2DMarkers, occupied);
                            }
                            if (HasValidCornerNeighbors(wall2DPositions, door2DPositions, center, 0, 1, 1, 0))
                            {
                                var corner = center + new IntVector(1, 0, 1);
                                InsertCornerMarker(marker.cellId, corner, gridSize, wall2DMarkers, occupied);
                            }
                            if (HasValidCornerNeighbors(wall2DPositions, door2DPositions, center, 1, 0, 0, -1))
                            {
                                var corner = center + new IntVector(1, 0, -1);
                                InsertCornerMarker(marker.cellId, corner, gridSize, wall2DMarkers, occupied);
                            }
                            if (HasValidCornerNeighbors(wall2DPositions, door2DPositions, center, 0, -1, -1, 0))
                            {
                                var corner = center + new IntVector(-1, 0, -1);
                                InsertCornerMarker(marker.cellId, corner, gridSize, wall2DMarkers, occupied);
                            }
                        }
                    }
                }
            }
        }

        void InsertCornerMarker(int cellId, IntVector gridPosition, Vector3 gridSize, List<Wall2DMarkerInfo> wall2DMarkers, Dictionary<string, HashSet<IntVector>> occupied)
        {
            var markerInfo = new Wall2DMarkerInfo();
            markerInfo.markerName = GridDungeonMarkerNames.Wall2D;
            markerInfo.cellId = cellId;
            markerInfo.gridPosition = gridPosition;
            var position = gridPosition * gridSize + (gridSize / 2.0f);
            var transform = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
            markerInfo.transform = transform;
            RegisterMarker(markerInfo, wall2DMarkers, occupied);
        }

        bool ContainsWall2D(HashSet<IntVector> walls, HashSet<IntVector> doors, IntVector position)
        {
            return walls.Contains(position) || doors.Contains(position);
        }

        bool HasValidCornerNeighbors(HashSet<IntVector> walls, HashSet<IntVector> doors, IntVector center, int dx1, int dz1, int dx2, int dz2)
        {
            var d1 = new IntVector(dx1, 0, dz1);
            var d2 = new IntVector(dx2, 0, dz2);
            var pos1 = center + d1;
            var pos2 = center + d2;
            var pos12 = center + d1 + d2;
            return ContainsWall2D(walls, doors, pos1) && ContainsWall2D(walls, doors, pos2) && !ContainsWall2D(walls, doors, pos12);
        }

        void RegisterMarker(Wall2DMarkerInfo markerInfo, List<Wall2DMarkerInfo> markerList, Dictionary<string, HashSet<IntVector>> occupied)
        {
            if (!occupied.ContainsKey(markerInfo.markerName))
            {
                occupied.Add(markerInfo.markerName, new HashSet<IntVector>());
            }
            if (occupied[markerInfo.markerName].Contains(markerInfo.gridPosition))
            {
                // Already added
                return;
            }

            occupied[markerInfo.markerName].Add(markerInfo.gridPosition);
            markerList.Add(markerInfo);
        }

        Wall2DMarkerInfo GetMarker2D(PropSocket prop, string markerName, Vector3 gridSize)
        {
            var position = Matrix.GetTranslation(ref prop.Transform);
            var x = Mathf.FloorToInt(position.x / gridSize.x);
            var z = Mathf.FloorToInt(position.z / gridSize.z);

            var rotation = Matrix.GetRotation(ref prop.Transform);
            var offset = rotation * new Vector3(0, 0, 1);

            if (wallPushType == WallPushType.WallsInside)
            {
                if (offset.z > 0.5f) z--;
                if (offset.x > 0.5f) x--;
            }
            else if (wallPushType == WallPushType.WallsOutside)
            {

                if (offset.z < -0.5f) z--;
                if (offset.x < -0.5f) x--;
            }


            var gridPosition = new IntVector(x, 0, z);
            var wall2DPosition = gridPosition * gridSize;
            wall2DPosition += gridSize / 2.0f;
            wall2DPosition.y = 0;



            var markerInfo = new Wall2DMarkerInfo();
            markerInfo.transform = Matrix4x4.TRS(wall2DPosition, Quaternion.identity, Vector3.one);
            markerInfo.gridPosition = gridPosition;
            markerInfo.cellId = prop.cellId;
            markerInfo.markerName = markerName;
            return markerInfo;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Metadata\GridItemDoorMetadata.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Grid
{
    public class GridItemDoorMetadata : MonoBehaviour
    {
        public int cellA;
        public int cellB;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Metadata\GridItemMetadataHandler.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.Grid
{
    public class GridItemMetadataHandler : DungeonItemSpawnListener
    {
        public override void SetMetadata(GameObject dungeonItem, DungeonNodeSpawnData spawnData)
        {
            if (spawnData.socket.SocketType == GridDungeonMarkerNames.Door)
            {
                var doorMeta = dungeonItem.GetComponent<GridItemDoorMetadata>();
                if (doorMeta == null)
                {
                    doorMeta = dungeonItem.AddComponent<GridItemDoorMetadata>();
                }

                if (spawnData.socket.metadata is GridBuilderDoorMetadata)
                {
                    var builderDoorMeta = spawnData.socket.metadata as GridBuilderDoorMetadata;
                    doorMeta.cellA = builderDoorMeta.CellA;
                    doorMeta.cellB = builderDoorMeta.CellB;
                }
            }
            else
            {
                if (dungeonItem != null)
                {
                    // Not a door. Make sure we don't have the door metadata attached to it 
                    // (this object might be reused when the theme graph changes)
                    var doorMeta = dungeonItem.GetComponent<GridItemDoorMetadata>();
                    if (doorMeta)
                    {
                        Destroy(doorMeta);
                    }
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Mirroring\GridDungeonMirror.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Grid.Mirroring
{
    public class GridDungeonMirrorAxisX : GridDungeonMirror
    {
        public GridDungeonMirrorAxisX(Vector3 mirrorBasePosition, Vector3 gridSize) 
            : base(mirrorBasePosition.x, gridSize.x)
        {
        }

        protected override Vector3 GetMirrorTangent()
        {
            return new Vector3(1, 0, 0);
        }

        protected override float GetComponent(Vector3 value)
        {
            return value.x;
        }

        protected override int GetComponent(IntVector value)
        {
            return value.x;
        }

        protected override void SetComponent(ref Vector3 v, float value)
        {
            v.x = value;
        }

        protected override void SetComponent(ref IntVector v, int value)
        {
            v.x = value;
        }
        
        protected override Vector3 CreateVector(Vector3 template, float value)
        {
            var v = template;
            v.x = value;
            return v;
        }

        protected override IntVector CreateVector(IntVector template, int value)
        {
            var v = template;
            v.x = value;
            return v;
        }

    }
    
    public class GridDungeonMirrorAxisZ : GridDungeonMirror
    {
        public GridDungeonMirrorAxisZ(Vector3 mirrorBasePosition, Vector3 gridSize) 
            : base(mirrorBasePosition.z, gridSize.z)
        {
        }

        protected override Vector3 GetMirrorTangent()
        {
            return new Vector3(0, 0, 1);
        }

        protected override float GetComponent(Vector3 value)
        {
            return value.z;
        }

        protected override int GetComponent(IntVector value)
        {
            return value.z;
        }

        protected override void SetComponent(ref Vector3 v, float value)
        {
            v.z = value;
        }

        protected override void SetComponent(ref IntVector v, int value)
        {
            v.z = value;
        }

        protected override Vector3 CreateVector(Vector3 template, float value)
        {
            var v = template;
            v.z = value;
            return v;
        }

        protected override IntVector CreateVector(IntVector template, int value)
        {
            var v = template;
            v.z = value;
            return v;
        }
    }

    
    public abstract class GridDungeonMirror
    {
        private readonly float mirrorBasePosition;
        private readonly float gridSize;

        protected abstract Vector3 GetMirrorTangent();
        protected abstract float GetComponent(Vector3 value);
        protected abstract int GetComponent(IntVector value);
        protected abstract void SetComponent(ref Vector3 v, float value);
        protected abstract void SetComponent(ref IntVector v, int value);
        protected abstract Vector3 CreateVector(Vector3 template, float value);
        protected abstract IntVector CreateVector(IntVector template, int value);
        
        public static GridDungeonMirror Create(Vector3 mirrorBasePosition, Vector3 gridSize, MirrorVolumeDirection direction)
        {
            switch (direction)
            {
                case MirrorVolumeDirection.AxisX:
                    return new GridDungeonMirrorAxisX(mirrorBasePosition, gridSize);

                case MirrorVolumeDirection.AxisZ:
                default:
                    return new GridDungeonMirrorAxisZ(mirrorBasePosition, gridSize);
            }
        }
        
        protected GridDungeonMirror(float mirrorBasePosition, float gridSize)
        {
            this.mirrorBasePosition = mirrorBasePosition;
            this.gridSize = gridSize;
        }

        int GetCutoff()
        {
            return Mathf.RoundToInt(mirrorBasePosition / gridSize);
        }
        
        public bool CanMergeCells(Rectangle a, Rectangle b, ref Rectangle mergedBounds)
        {
            int a0 = GetComponent(a.Location);
            int a1 = a0 + GetComponent(a.Size);

            int b0 = GetComponent(b.Location);
            int b1 = b0 + GetComponent(b.Size);

            if (a1 == b0 || b1 == a0)
            {
                var start = Mathf.Min(a0, b0);
                var end = Mathf.Max(a1, b1);
                var location = a.Location;
                var size = a.Size;
                SetComponent(ref location, start);
                SetComponent(ref size, end - start);
                mergedBounds = new Rectangle(location, size);
                return true;
            }
            
            return false;
        }

        public Rectangle CalculateMirrorReflection(Rectangle bounds)
        {
            var start = GetComponent(bounds.Location);
            var end = GetComponent(bounds.Location) + GetComponent(bounds.Size);

            var cutoff = GetCutoff();
            var distanceToCutoff = cutoff - end;
            var newX0 = cutoff + distanceToCutoff;
            return new Rectangle(CreateVector(bounds.Location, newX0), bounds.Size);
        }

        public bool CanDiscardBounds(Rectangle bounds)
        {
            var start = GetComponent(bounds.Location);
            var end = GetComponent(bounds.Location) + GetComponent(bounds.Size);

            int cutoff = GetCutoff();
            return (start >= cutoff && end >= cutoff);
        }

        public bool CanCropBounds(Rectangle bounds)
        {
            var x0 = GetComponent(bounds.Location);
            var x1 = GetComponent(bounds.Location) + GetComponent(bounds.Size);

            int cutoffX = GetCutoff();
            return (x0 < cutoffX && x1 > cutoffX);
        }

        public void CropCell(Cell cell)
        {
            int cutoffX = GetCutoff();
            var newWidth = cutoffX - GetComponent(cell.Bounds.Location);
            if (newWidth > 0)
            {
                var bounds = cell.Bounds;
                var size = bounds.Size;
                SetComponent(ref size, newWidth);
                bounds.Size = size;
                cell.Bounds = bounds;
            }
        }

        public Quaternion CalculateMirrorReflection(Quaternion rotation)
        {
            var mirrorTangent = GetMirrorTangent();
            var forward = rotation * Vector3.forward;

            var dot = Vector3.Dot(mirrorTangent, forward);
            dot = Mathf.Abs(dot);

            if (Mathf.Approximately(dot, 1.0f))
            {
                // The lines are parallel, do not rotate
                return rotation;
            }

            // rotate by 180
            return Quaternion.Euler(0, 180, 0) * rotation;
        }

        public Vector3 CalculateMirrorReflection(Vector3 position)
        {
            var cutoffX = GetCutoff() * gridSize;
            if (GetComponent(position) >= cutoffX)
            {
                Debug.Log("Invalid mirror input");
                return Vector3.zero;
            }

            var distanceToCutoff = cutoffX - GetComponent(position);
            var mirroredDistance = cutoffX + distanceToCutoff;

            var mirroredPosition = position;
            SetComponent(ref mirroredPosition, mirroredDistance);
            return mirroredPosition;
        }

        public IntVector CalculateMirrorReflection(IntVector position)
        {
            var cutoffX = GetCutoff();
            var distanceToCutoff = cutoffX - GetComponent(position);
            var mirroredDistance = cutoffX + distanceToCutoff - 1;

            var mirroredPosition = position;
            SetComponent(ref mirroredPosition, mirroredDistance);
            return mirroredPosition;
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Navigation_SN\LayoutFloorTriangleProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using STE = SharpNav.Geometry.TriangleEnumerable;
using SVector3 = SharpNav.Geometry.Vector3;
using Triangle3 = SharpNav.Geometry.Triangle3;
using DungeonArchitect.Builders.Grid;

namespace DungeonArchitect.Navigation {
	public class LayoutFloorTriangleProvider : NavigationTriangleProvider {
		public Dungeon dungeon;

		public override void AddNavTriangles(List<Triangle3> triangles) {
			if (dungeon == null) {
				Debug.LogWarning("LayoutFloorTriangleProvider: Dungeon is not assigned");
				return;
			}

			var model = dungeon.ActiveModel as GridDungeonModel;
			if (model == null) {
				Debug.LogWarning("LayoutFloorTriangleProvider: Dungeon model is invalid. Rebuild the dungeon");
				return;
			}

			var config = model.Config;
			var verts = new SVector3[4];
			for (int i = 0; i < verts.Length; i++) {
				verts[i] = new SVector3();
			}

			foreach (var cell in model.Cells) {
				//if (cell.CellType == CellType.Unknown) continue;

				var bounds = cell.Bounds;
				var location = MathUtils.GridToWorld(config.GridCellSize, bounds.Location);
				var size = MathUtils.GridToWorld(config.GridCellSize, bounds.Size);

				verts[0].Set (location.x, location.y, location.z);
				verts[1].Set (location.x + size.x, location.y, location.z);
				verts[2].Set (location.x + size.x, location.y, location.z + size.z);
				verts[3].Set (location.x, location.y, location.z + size.z);

				triangles.Add (new Triangle3(
					verts[0],
					verts[1],
					verts[2]));

				triangles.Add (new Triangle3(
					verts[2],
					verts[3],
					verts[0]));
			}
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\PaintTool\DungeonPaintModeGrid.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Grid
{
    /// <summary>
    /// Editor tooling for the grid based dungeon builder. Lets you paint with a grid based brush
    /// </summary>
    [ExecuteInEditMode]
    public class DungeonPaintModeGrid : DungeonPaintMode
    {
        /// <summary>
        /// The height of the cursor in grid cooridnates. Can also be changed with the mouse wheel in the editor when activated
        /// </summary>
        public int cursorLogicalHeight = 0;

        /// <summary>
        /// The opacity of the overlay colored tiles
        /// </summary>
        public float overlayOpacity = 0.1f;

		/// <summary>
		/// Indicates if the painting is to be done in 2D mode (for 2D dungeons)
		/// This flag is used for the editor tooling.  The model still stores it in 3D
		/// </summary>
		public bool mode2D = false;

		/// <summary>
		/// The size of the brush.  This would create a brush of size NxN
		/// </summary>
		public int brushSize = 1;

        /// <summary>
        /// Reference to the grid model used by the grid builder
        /// </summary>
        private GridDungeonModel gridModel;

        public float GetCursorHeight()
        {
            var gridConfig = GetDungeonConfig() as GridDungeonConfig;
            if (gridConfig == null) return 0;
            return cursorLogicalHeight * gridConfig.GridCellSize.y;
        }

        public void SetElevationDelta(int delta)
        {
            cursorLogicalHeight += delta;
        }

        
        public GridDungeonModel GetDungeonModelGrid()
        {
            var model = base.GetDungeonModel();
            gridModel = model as GridDungeonModel;
            if (gridModel == null)
            {
                Debug.LogWarning("Invalid dungeon model type for this type of paint tool.  Expected DungeonModelGrid.  Received:" + (model != null ? model.GetType().ToString() : "null"));
            }

            return gridModel;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Query\GridDungeonQuery.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;

using UnityEngine;

namespace DungeonArchitect.Builders.Grid
{
    public class GridDungeonQuery : DungeonQuery
    {
        [HideInInspector]
        public Dictionary<int, GameObject[]> DoorObjectsByCellId = new Dictionary<int, GameObject[]>();

        public override void OnPostDungeonBuild()
        {
            GenerateQuery();
        }

        public override void Release()
        {
            DoorObjectsByCellId.Clear();
        }

        private void GenerateQuery()
        {
            DoorObjectsByCellId.Clear();

            var dungeon = GetComponent<Dungeon>();
            if (dungeon == null)
            {
                return;
            }
            var doorsByCells = new Dictionary<int, HashSet<GameObject>>();
            var doorMetaArray = GameObject.FindObjectsOfType<GridItemDoorMetadata>();
            foreach (var doorMeta in doorMetaArray)
            {
                // Make sure this belongs to the same dungeon
                var itemData = doorMeta.gameObject.GetComponent<DungeonSceneProviderData>();
                if (itemData && itemData.dungeon == dungeon)
                {
                    if (!doorsByCells.ContainsKey(doorMeta.cellA))
                    {
                        doorsByCells.Add(doorMeta.cellA, new HashSet<GameObject>());
                    }
                    if (!doorsByCells.ContainsKey(doorMeta.cellB))
                    {
                        doorsByCells.Add(doorMeta.cellB, new HashSet<GameObject>());
                    }

                    doorsByCells[doorMeta.cellA].Add(doorMeta.gameObject);
                    doorsByCells[doorMeta.cellB].Add(doorMeta.gameObject);
                }
            }

            foreach (var entry in doorsByCells)
            {
                DoorObjectsByCellId.Add(entry.Key, entry.Value.ToArray());
            }
        }

        public void GetDoorsForCell(int cellId, out GameObject[] doorGameObjects)
        {
            if (DoorObjectsByCellId.ContainsKey(cellId))
            {
                doorGameObjects = DoorObjectsByCellId[cellId];
            }
            else
            {
                doorGameObjects = new GameObject[0];
            }
        }

        public bool GetCellAtPosition(Vector3 position, out Cell outCell)
        {
            var config = GetComponent<GridDungeonConfig>();
            var model = GetComponent<GridDungeonModel>();
            if (config != null && model != null)
            {
                var bounds = new Bounds();
                foreach (var cell in model.Cells)
                {
                    bounds = cell.GetWorldBounds(config.GridCellSize);
                    if (bounds.Contains(position))
                    {
                        outCell = cell;
                        return true;
                    }
                }
            }
            outCell = null;
            return false;
        }

        public Bounds GetCellBounds(Cell cell)
        {
            var bounds = new Bounds();
            var config = GetComponent<GridDungeonConfig>();
            if (config != null)
            {
                bounds = cell.GetWorldBounds(config.GridCellSize);
            }
            return bounds;
        }
        
        public Cell GetRandomCell()
        {
            var model = GetComponent<GridDungeonModel>();
            if (model == null || model.Cells.Count == 0)
            {
                return null;
            }

            return model.Cells[Random.Range(0, model.Cells.Count)];
        }

        public Cell[] FindFurthestRooms()
        {
            var model = GetComponent<GridDungeonModel>();
            return GridDungeonModelUtils.FindFurthestRooms(model);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\SpatialConstraints\SpatialConstraintProcessorGrid2D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Builders.Grid.SpatialConstraints
{
    public class SpatialConstraintProcessorGrid2D : SpatialConstraintProcessor
    {

        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var gridConfig = context.config as GridDungeonConfig;

            // TODO: Confirm if the YZ needs to be swapped for this
            var domain = base.GetDomain(context);
            domain.gridSize = gridConfig.GridCellSize;
            return domain;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\SpatialConstraints\SpatialConstraintProcessorGrid3D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Builders.Grid.SpatialConstraints
{
    public class SpatialConstraintProcessorGrid3D : SpatialConstraintProcessor
    {
        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var gridConfig = context.config as GridDungeonConfig;

            var domain = base.GetDomain(context);
            domain.gridSize = gridConfig.GridCellSize;
            return domain;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Utils\GridBuilderUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;

namespace DungeonArchitect.Builders.Grid
{
    public class GridBuilderUtils
    {
        public static bool IsCorridor(CellType type)
        {
            return type == CellType.Corridor || type == CellType.CorridorPadding;
        }

        public static bool IsRoomCorridor(CellType typeA, CellType typeB)
        {
            return (typeA == CellType.Room && IsCorridor(typeB))
                || (typeB == CellType.Room && IsCorridor(typeA));
        }


        public static void GetRoomConnectionPointsForTiledMode(Rectangle bounds, ref List<IntVector> positions, bool skipCornersOnPathSelection)
        {
            int sx = bounds.X;
            int ex = bounds.X + bounds.Width;
            int sz = bounds.Z;
            int ez = bounds.Z + bounds.Length;
            if (skipCornersOnPathSelection)
            {
                sx++; sz++;
                ex--; ez--;
            }

            for (int x = sx; x < ex; x++)
            {
                positions.Add(new IntVector(x, 0, bounds.Z - 1));
                positions.Add(new IntVector(x, 0, bounds.Z + bounds.Length));
            }

            for (int z = sz; z < ez; z++)
            {
                positions.Add(new IntVector(bounds.X - 1, 0, z));
                positions.Add(new IntVector(bounds.X + bounds.Width, 0, z));
            }
        }


        public static bool AreAdjacentCellsReachable(GridDungeonModel gridModel, int cellIdA, int cellIdB)
        {
            var cellA = gridModel.GetCell(cellIdA);
            var cellB = gridModel.GetCell(cellIdB);

            if (cellA == null || cellB == null)
            {
                return false;
            }


            // If any one is a room, make sure we have a door between them
            if (cellA.CellType == CellType.Room || cellB.CellType == CellType.Room)
            {
                if (!gridModel.DoorManager.ContainsDoorBetweenCells(cellIdA, cellIdB))
                {
                    // We don't have a door between them and is blocked by a room wall
                    return false;
                }
            }

            // if their height is different, make sure we have a stair between them
            if (cellA.Bounds.Location.y != cellB.Bounds.Location.y)
            {
                if (!gridModel.ContainsStair(cellIdA, cellIdB))
                {
                    // Height difference with no stairs. not reachable
                    return false;
                }
            }

            // reachable
            return true;
        }

        /// <summary>
        /// Finds all the nearby tiles that belong to the same cluster
        /// </summary>
        /// <param name="gridModel"></param>
        /// <param name="corridorTileCellId"></param>
        /// <returns></returns>
        public static int[] GetCellCluster(GridDungeonModel gridModel, int sampleCellId)
        {
            var clusters = new List<int>();

            // Check if we are in a room.  Rooms don't need to be clustered as they form a single group
            var startCell = gridModel.GetCell(sampleCellId);
            if (startCell == null || startCell.CellType == CellType.Room)
            {
                clusters.Add(sampleCellId);
                return clusters.ToArray();
            }

            var visited = new HashSet<int>();
            var stack = new Stack<int>();
            stack.Push(sampleCellId);

            while (stack.Count > 0)
            {
                var topId = stack.Pop();
                if (visited.Contains(topId)) continue;
                visited.Add(topId);

                var top = gridModel.GetCell(topId);
                if (top == null) continue;
                if (top.CellType == CellType.Unknown || top.CellType == CellType.Room) continue;

                if (IsCorridor(top.CellType))
                {
                    clusters.Add(topId);
                }

                // search adjacent cells
                foreach (var adjacentId in top.AdjacentCells)
                {
                    // make sure the adjacent cell is reachable
                    if (AreAdjacentCellsReachable(gridModel, topId, adjacentId))
                    {
                        stack.Push(adjacentId);
                    }
                }
            }
            
            return clusters.ToArray();
        }

        public static void GetAdjacentCorridors(GridDungeonModel gridModel, int startCellId, ref List<int> OutConnectedCorridors, ref List<int> OutConnectedRooms)
        {
            OutConnectedCorridors.Clear();
            OutConnectedRooms.Clear();

            // search all nearby cells till we reach a dead end (or a room)
            var visited = new HashSet<int>();
            var stack = new Stack<int>();
            stack.Push(startCellId);

            while (stack.Count > 0)
            {
                var topId = stack.Pop();
                if (visited.Contains(topId)) continue;
                visited.Add(topId);

                var top = gridModel.GetCell(topId);
                if (top == null) continue;
                if (top.CellType == CellType.Unknown) continue;

                if (top.CellType == CellType.Room && top.Id != startCellId)
                {
                    OutConnectedRooms.Add(topId);
                    continue;
                }

                if (IsCorridor(top.CellType))
                {
                    OutConnectedCorridors.Add(topId);
                }

                // search adjacent cells
                foreach (var adjacentId in top.AdjacentCells)
                {
                    // make sure the adjacent cell is reachable
                    if (AreAdjacentCellsReachable(gridModel, topId, adjacentId))
                    {
                        stack.Push(adjacentId);
                    }
                }
            }
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Utils\GridDebugDrawUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.Grid
{
    /// <summary>
    /// Helper functions to draw debug information of the dungeon layout in the scene view 
    /// </summary>
    public class GridDebugDrawUtils
    {

        public static void DrawCell(Cell cell, Color color, Vector3 gridScale, bool mode2D)
        {
            DebugDrawUtils.DrawBounds(cell.Bounds, color, gridScale, mode2D);
        }

        public static void DrawCellId(Cell cell, Vector3 gridScale, bool mode2D)
        {
            var center = Vector3.Scale(cell.Bounds.CenterF(), gridScale); // + new Vector3(0, .2f, 0);
            var screenCoord = Camera.main.WorldToScreenPoint(center);
            if (screenCoord.z > 0)
            {
                GUI.Label(new Rect(screenCoord.x, Screen.height - screenCoord.y, 100, 50), "" + cell.Id);
            }
        }
        
        public static void DrawCellConnectionPoints(Cell cell, GridDungeonModel model, Color color, bool mode2D)
        {
            if (model == null) return;
            var gridConfig = model.Config as GridDungeonConfig;
            if (gridConfig == null) return;

            if (cell.CellType == CellType.Room)
            {
                var skipCornerConnectionPoints = (gridConfig.WallLayoutType == GridDungeonWallType.WallsAsTileBlocks);
                var connectionPoints = new List<IntVector>();
                GridBuilderUtils.GetRoomConnectionPointsForTiledMode(cell.Bounds, ref connectionPoints, skipCornerConnectionPoints);
                foreach (var point in connectionPoints)
                {
                    var bounds = new Rectangle(point.x, point.z, 1, 1);
                    DebugDrawUtils.DrawBounds(bounds, color, gridConfig.GridCellSize, mode2D);
                }
            }
        }

        public static void DrawAdjacentCells(Cell cell, GridDungeonModel model, Color color, bool mode2D)
        {
            if (model == null) return;
            var gridConfig = model.Config as GridDungeonConfig;
            if (gridConfig == null) return;

            foreach (var adjacentId in cell.AdjacentCells)
            {
                var adjacentCell = model.GetCell(adjacentId);
                if (adjacentCell == null) return;
                var centerA = Vector3.Scale(cell.Bounds.CenterF(), gridConfig.GridCellSize);
                var centerB = Vector3.Scale(adjacentCell.Bounds.CenterF(), gridConfig.GridCellSize);
                DebugDrawUtils.DrawLine(centerA, centerB, color, 0, false, mode2D);
            }

            foreach (var adjacentId in cell.FixedRoomConnections)
            {
                var adjacentCell = model.GetCell(adjacentId);
                if (adjacentCell == null) return;
                var centerA = Vector3.Scale(cell.Bounds.CenterF(), gridConfig.GridCellSize) + new Vector3(0, 0.2f, 0);
                var centerB = Vector3.Scale(adjacentCell.Bounds.CenterF(), gridConfig.GridCellSize) + new Vector3(0, 0.2f, 0);
                DebugDrawUtils.DrawLine(centerA, centerB, Color.red, 0, false, mode2D);
            }

        }
        
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\Volumes\PlatformVolume.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Builders.Grid
{
    /// <summary>
    /// Platform volumes add a platform in the scene encompassing the volume
    /// </summary>
    public class PlatformVolume : Volume
    {
        public CellType cellType = CellType.Corridor;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\GridFlow\Minimap\GridFlowMinimap.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.MiniMaps;
using DungeonArchitect.Utils;
using System.Linq;
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Tilemap;
using UnityEngine;

namespace DungeonArchitect.Builders.GridFlow
{
    [System.Serializable]
    public enum GridFlowMinimapInitMode
    {
        OnDungeonRebuild,
        OnPlay,
        Manual
    }

    [System.Serializable]
    public struct GridFlowMinimapIcons
    {
        public Texture2D iconOneWayDoor;
    }

    public class GridFlowMinimap : DungeonMiniMap
    {
        public Shader tileShader;
        public GridFlowMinimapInitMode initMode = GridFlowMinimapInitMode.Manual;
        public GridFlowMinimapIcons icons;
        public bool seeThroughWalls = false;

        FlowTilemapRenderResources resources;
        GridFlowDungeonModel model;
        GridFlowDungeonConfig config;
        int tileSize = 1;
        List<GridFlowMinimapTrackedObject> trackedObjects = new List<GridFlowMinimapTrackedObject>();
        Color[] fogMask;

        protected override bool SupportsFogOfWar { get { return true; } }

        private void Reset()
        {
            compositeShader = Shader.Find("DungeonArchitect/MiniMap/Composite");
            tileShader = Shader.Find("DungeonArchitect/MiniMap/Tile");
            initMode = GridFlowMinimapInitMode.OnDungeonRebuild;
            
        }

        private void Awake()
        {
        }

        private void Start()
        {
            if (initMode == GridFlowMinimapInitMode.OnPlay)
            {
                Initialize();
            }
        }

        public void AddTrackedObject(GridFlowMinimapTrackedObject trackedObject)
        {
            trackedObjects.Add(trackedObject);
        }

        protected override void CreateTextures(IntVector2 desiredSize, out Texture staticImage, out Texture fogOfWar, out Texture overlayImage, out IntVector2 targetTextureSize)
        {
            resources = new FlowTilemapRenderResources();
            resources.materials = new TexturedMaterialInstances(tileShader);
            resources.iconOneWayDoor = icons.iconOneWayDoor;

            if (model == null)
            {
                model = GetComponent<GridFlowDungeonModel>();
            }

            if (config == null)
            {
                config = GetComponent<GridFlowDungeonConfig>();
            }

            if (model == null || config == null)
            {
                Debug.LogError("Cannot find GridFlowDungeonModel component along side the minimap script");
                staticImage = null;
                fogOfWar = null;
                overlayImage = null;
                targetTextureSize = IntVector2.Zero;
                return;
            }

            var tilemap = model.Tilemap;
            if (tilemap == null)
            {
                staticImage = null;
                fogOfWar = null;
                overlayImage = null;
                targetTextureSize = IntVector2.Zero;
                return;
            }

            // Calculate the tile size
            {
                var desiredTileSize2D = new Vector2();
                desiredTileSize2D.x = (float)desiredSize.x / model.Tilemap.Width;
                desiredTileSize2D.y = (float)desiredSize.y / model.Tilemap.Height;
                var desiredTileSizeF = Mathf.Min(desiredTileSize2D.x, desiredTileSize2D.y);
                tileSize = Mathf.FloorToInt(desiredTileSizeF);
            }

            var texWidth = tilemap.Width * tileSize;
            var texHeight = tilemap.Height * tileSize;

            targetTextureSize = new IntVector2(texWidth, texHeight);
            staticImage = new RenderTexture(texWidth, texHeight, 0);
            overlayImage = new RenderTexture(texWidth, texHeight, 0);
            fogOfWar = new Texture2D(tilemap.Width, tilemap.Height, TextureFormat.R8, false, true);
            fogMask = new Color[tilemap.Width * tilemap.Height];
        }

        protected override void UpdateStaticTexture(Texture texture)
        {
            var rtt = texture as RenderTexture;
            if (rtt == null || model == null) return;

            var tilemap = model.Tilemap;
            if (tilemap != null)
            {
                FlowTilemapRenderer.Render(rtt, tilemap, tileSize, resources, cell => false);
            }
        }

        struct FogOfWarItem
        {
            public Vector2 position;
            public float radius;
            public float falloffStart;
        }


        IntVector2[] FogOfWarFilterVisibility(IntVector2[] tiles, IntVector2 player)
        {
            if (seeThroughWalls)
            {
                return tiles;
            }

            var tilemap = model.Tilemap;
            if (tilemap == null)
            {
                return tiles;
            }

            var result = new List<IntVector2>();
            var valid = new HashSet<IntVector2>(tiles);
            var visited = new HashSet<IntVector2>();
            var queue = new Queue<IntVector2>();
            queue.Enqueue(player);
            visited.Add(player);
            while (queue.Count > 0)
            {
                var coord = queue.Dequeue();
                result.Add(coord);

                var cell = tilemap.Cells.GetCell(coord.x, coord.y);
                if (cell == null) continue;
                if (cell.CellType == FlowTilemapCellType.Wall) continue;
                if (cell.CellType == FlowTilemapCellType.Door) continue;

                for (int dy = -1; dy <= 1; dy++)
                {
                    for (int dx = -1; dx <= 1; dx++)
                    {
                        if (dx == 0 && dy == 0)
                        {
                            continue;
                        }

                        var cx = coord.x + dx;
                        var cy = coord.y + dy;

                        if (cx < 0 || cy < 0 || cx >= tilemap.Width || cy >= tilemap.Height) continue;
                        
                        var childCoord = new IntVector2(cx, cy);
                        if (visited.Contains(childCoord) || !valid.Contains(childCoord))
                        {
                            continue;
                        }
                        visited.Add(childCoord);
                        queue.Enqueue(childCoord);
                    }
                }
            }

            return result.ToArray();
        }

        protected override void UpdateFogOfWarTexture(Texture texture)
        {
            var fogTex = texture as Texture2D;
            var tilemap = model.Tilemap;
            if (fogTex == null || model == null || fogMask == null || tilemap == null) return;

            var items = new List<FogOfWarItem>();
            foreach (var trackedObject in trackedObjects)
            {
                if (trackedObject == null) continue;
                if (trackedObject.exploresFogOfWar)
                {
                    var item = new FogOfWarItem();
                    var localPosition = transform.InverseTransformPoint(trackedObject.transform.position);
                    var gridCoord = new Vector2(
                        localPosition.x / config.gridSize.x,
                        localPosition.z / config.gridSize.z);

                    item.position = gridCoord;
                    item.radius = trackedObject.fogOfWarNumTileRadius;
                    item.falloffStart = trackedObject.fogOfWarLightFalloffStart;
                    items.Add(item);
                }
            }

            foreach (var item in items)
            {
                int cx = Mathf.FloorToInt(item.position.x);
                int cy = Mathf.FloorToInt(item.position.y);

                int x0 = Mathf.FloorToInt(item.position.x - item.radius);
                int x1 = Mathf.FloorToInt(item.position.x + item.radius);
                int y0 = Mathf.FloorToInt(item.position.y - item.radius);
                int y1 = Mathf.FloorToInt(item.position.y + item.radius);

                cx = Mathf.Clamp(cx, 0, tilemap.Width - 1);
                cy = Mathf.Clamp(cy, 0, tilemap.Height - 1);

                x0 = Mathf.Clamp(x0, 0, tilemap.Width - 1);
                x1 = Mathf.Clamp(x1, 0, tilemap.Width - 1);
                y0 = Mathf.Clamp(y0, 0, tilemap.Height - 1);
                y1 = Mathf.Clamp(y1, 0, tilemap.Height - 1);
                var falloff = Mathf.Clamp01(1 - item.falloffStart);
                var tilesToProcess = new List<IntVector2>();
                for (int y = y0; y <= y1; y++)
                {
                    for (int x = x0; x <= x1; x++)
                    {
                        tilesToProcess.Add(new IntVector2(x, y));
                    }
                }

                var visibleTiles = FogOfWarFilterVisibility(tilesToProcess.ToArray(), new IntVector2(cx, cy));
                foreach (var tile in visibleTiles)
                {
                    float distance = (new Vector2(tile.x, tile.y) - item.position).magnitude;
                    distance = Mathf.Clamp01(distance / item.radius);
                    var weight = 1 - distance;

                    weight = weight / falloff;

                    weight = Mathf.Clamp01(weight);

                    int index = tile.y * tilemap.Width + tile.x;
                    fogMask[index].r = Mathf.Max(weight, fogMask[index].r);
                }
            }


            fogTex.SetPixels(fogMask);
            fogTex.Apply(false);
        }

        protected override void UpdateOverlayTexture(Texture texture)
        {
            var rtt = texture as RenderTexture;
            if (rtt == null || model == null || model.Tilemap == null) return;

            trackedObjects = (from trackedObject in trackedObjects
                              where trackedObject != null
                              select trackedObject).ToList();

            var oldRTT = RenderTexture.active;
            RenderTexture.active = rtt;
            
            GL.PushMatrix();
            GL.LoadOrtho();
            GL.Clear(true, true, new Color(0, 0, 0, 0), 0);

            var tilemap = model.Tilemap;
            var tileSizeUV = tileSize / (float)texture.width;
            foreach (var trackedObject in trackedObjects)
            {
                if (trackedObject == null || trackedObject.icon == null) continue;
                var color = trackedObject.tint;

                var positionUV = WorldToUVCoord(trackedObject.transform.position, tilemap.Width, tilemap.Height, texture.width, texture.height);
                var iconSize = tileSizeUV * trackedObject.iconScale;
                var hs = iconSize * 0.5f;

                float cx = positionUV.x;
                float cy = positionUV.y;
                var x0 = -hs;
                var x1 = +hs;
                var y0 = -hs;
                var y1 = +hs;

                Quaternion rotation;
                if (trackedObject.rotateIcon)
                {
                    var forward = trackedObject.transform.forward;
                    forward.y = 0;
                    forward = forward.normalized;
                    rotation = Quaternion.LookRotation(forward);
                }
                else
                {
                    rotation = Quaternion.identity;
                }

                var material = resources.materials.GetMaterial(trackedObject.icon);
                material.SetPass(0);

                
                GL.Begin(GL.QUADS);
                EmitVertex(cx, cy, x0, y0, 0, 0, color, rotation);
                EmitVertex(cx, cy, x0, y1, 0, 1, color, rotation);
                EmitVertex(cx, cy, x1, y1, 1, 1, color, rotation);
                EmitVertex(cx, cy, x1, y0, 1, 0, color, rotation);
                GL.End();
            }

            GL.PopMatrix();

            RenderTexture.active = oldRTT;
        }

        Vector2 WorldToUVCoord(Vector3 position, int tilemapWidth, int tilemapHeight, int textureWidth, int textureHeight)
        {
            var minimapWorldPosition = transform.InverseTransformPoint(position);
            var minimapGridCoord = new Vector2(
                minimapWorldPosition.x / config.gridSize.x,
                minimapWorldPosition.z / config.gridSize.z);
            var minimapPixelCoord = minimapGridCoord * tileSize;
            var minimapUVCoord = new Vector2(
                minimapPixelCoord.x / textureWidth,
                minimapPixelCoord.y / textureHeight);

            return minimapUVCoord;
        }

        void EmitVertex(float cx, float cy, float x, float y, float u, float v, Color color, Quaternion rotation)
        {
            var vertex = new Vector3(x, 0, y);
            vertex = rotation * vertex;
            x = vertex.x;
            y = vertex.z;
            GL.Color(color);
            GL.TexCoord2(u, v);
            GL.Vertex3(cx + x, cy + y, 0);

        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\GridFlow\Minimap\GridFlowMinimapTrackedObject.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;


namespace DungeonArchitect.Builders.GridFlow
{
    public class GridFlowMinimapTrackedObject : MonoBehaviour
    {
        public Texture2D icon;
        public float iconScale = 1.0f;
        public bool rotateIcon = false;
        public Color tint = Color.white;
        public bool exploresFogOfWar = false;
        public float fogOfWarNumTileRadius = 5;
        public float fogOfWarLightFalloffStart = 0.5f;

        // Start is called before the first frame update
        void Start()
        {
            var minimap = FindObjectOfType<GridFlowMinimap>();
            if (minimap != null)
            {
                minimap.AddTrackedObject(this);
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\GridFlow\SpatialConstraints\SpatialConstraintProcessorGridFlow2D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.SpatialConstraints;
using DungeonArchitect.Builders.GridFlow;

namespace DungeonArchitect.Builders.Grid.SpatialConstraints
{
    public class SpatialConstraintProcessorGridFlow2D : SpatialConstraintProcessor
    {
        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var gridConfig = context.config as GridFlowDungeonConfig;

            // TODO: Confirm if the YZ needs to be swapped for this
            var domain = base.GetDomain(context);
            domain.gridSize = gridConfig.gridSize;
            return domain;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\GridFlow\SpatialConstraints\SpatialConstraintProcessorGridFlow3D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.SpatialConstraints;
using DungeonArchitect.Builders.GridFlow;

namespace DungeonArchitect.Builders.Grid.SpatialConstraints
{
    public class SpatialConstraintProcessorGridFlow3D : SpatialConstraintProcessor
    {
        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var gridConfig = context.config as GridFlowDungeonConfig;

            var domain = base.GetDomain(context);
            domain.gridSize = gridConfig.gridSize;
            return domain;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Isaac\RoomLayout\IsaacRoomLayoutBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Isaac
{
    public abstract class IsaacRoomLayoutBuilder : MonoBehaviour
    {

        public abstract IsaacRoomLayout GenerateLayout(IsaacRoom room, System.Random random, int roomWidth, int roomHeight);
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Isaac\RoomLayout\StylizedIsaacRoomLayoutBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.Isaac
{
    public class StylizedIsaacRoomLayoutBuilder : IsaacRoomLayoutBuilder
    {
        public int minBrushSize = 1;
        public int maxBrushSize = 3;
        public override IsaacRoomLayout GenerateLayout(IsaacRoom room, System.Random random, int roomWidth, int roomHeight)
        {
            var doors = room.doorPositions;
            var layout = new IsaacRoomLayout();
            layout.InitializeTiles(roomWidth, roomHeight, IsaacRoomTileType.Empty);

            if (doors.Count > 1)
            {
                for (int i = 0; i < doors.Count; i++)
                {
                    for (int j = i + 1; j < doors.Count; j++)
                    {
                        var brushSize = random.Range(minBrushSize, maxBrushSize + 1);
                        ConnectDoors(layout, doors[i], doors[j], brushSize);
                    }
                }
            }
            else
            {
                var brushSize = random.Range(minBrushSize, maxBrushSize + 1);
                ConnectDoors(layout, doors[0], doors[0], brushSize);
            }

            return layout;
        }

        void ConnectDoors(IsaacRoomLayout layout, IntVector doorA, IntVector doorB, int brushSize)
        {
            var minX = Mathf.Min(doorA.x, doorB.x);
            var minZ = Mathf.Min(doorA.z, doorB.z);
            var maxX = Mathf.Max(doorA.x, doorB.x);
            var maxZ = Mathf.Max(doorA.z, doorB.z);
            var width = layout.Tiles.GetLength(0);
            var height = layout.Tiles.GetLength(1);

            minX = Mathf.Clamp(minX, 0, width - 1);
            maxX = Mathf.Clamp(maxX, 0, width - 1);
            minZ = Mathf.Clamp(minZ, 0, height - 1);
            maxZ = Mathf.Clamp(maxZ, 0, height - 1);


            for (int x = minX; x <= maxX; x++)
            {
                var doorZ = Mathf.Clamp(doorA.z, 0, height - 1);
                PaintTile(layout, x, doorZ, brushSize, IsaacRoomTileType.Floor);
            }

            for (int z = minZ; z <= maxZ; z++)
            {
                var doorX = Mathf.Clamp(doorB.x, 0, width - 1);
                PaintTile(layout, doorX, z, brushSize, IsaacRoomTileType.Floor);
            }
        }

        void PaintTile(IsaacRoomLayout layout, int x, int z, int brushSize, IsaacRoomTileType tileType)
        {
            // TODO: Implement brush size
            var w = layout.Tiles.GetLength(0);
            var h = layout.Tiles.GetLength(1);
            if (x < 0 || x >= w || z < 0 || z >= h) return;

            var sx = x - Mathf.FloorToInt(brushSize / 2.0f);
            var sz = z - Mathf.FloorToInt(brushSize / 2.0f);

            for (int dx = 0; dx < brushSize; dx++)
            {
                for (int dz = 0; dz < brushSize; dz++)
                {
                    var xx = sx + dx;
                    var zz = sz + dz;

                    SetTile(layout, xx, zz, w, h, IsaacRoomTileType.Floor);
                }
            }
        }

        void SetTile(IsaacRoomLayout layout, int x, int z, int width, int height, IsaacRoomTileType tileType)
        {
            if (x < 0 || x >= width || z < 0 || z >= height) return;
            layout.Tiles[x, z].tileType = tileType;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Isaac\SpatialConstraints\SpatialConstraintProcessorIsaac.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.SpatialConstraints.Isaac
{
    public class SpatialConstraintProcessorIsaac : SpatialConstraintProcessor
    {
        public override SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            return null;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Isaac\Utils\IsaacBuilderUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Builders.Isaac
{
    public class IsaacBuilderUtils
    {

        public static IsaacRoomTile GetTileAt(int x, int z, IsaacRoomLayout layout)
        {
            if (x < 0 || x >= layout.Tiles.GetLength(0) || z < 0 || z >= layout.Tiles.GetLength(1))
            {
                var invalidTile = new IsaacRoomTile();
                invalidTile.tileType = IsaacRoomTileType.Empty;
                return invalidTile;
            }
            return layout.Tiles[x, z];
        }


        public static bool ContainsDoorAt(int x, int z, IsaacRoom room)
        {
            return room.doorPositions.Contains(new IntVector(x, 0, z));
        }

        public static IsaacRoom GetRoom(IsaacDungeonModel model, int roomId)
        {
            foreach (var room in model.rooms)
            {
                if (room.roomId == roomId)
                {
                    return room;
                }
            }
            return null;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SimpleCity\Landscape\LandscapeTransformerCity.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Landscape;

namespace DungeonArchitect.Builders.SimpleCity
{

    /// <summary>
    /// The type of the texture defined in the landscape paint settings.  
    /// This determines how the specified texture would be painted in the modified terrain
    /// </summary>
    public enum SimpleCityLandscapeTextureType
    {
        Road,
        Park,
        CityWallPadding
    }

    /// <summary>
    /// Data-structure to hold the texture settings.  This contains enough information to paint the texture 
    /// on to the terrain
    /// </summary>
    [System.Serializable]
    public class SimpleCityLandscapeTexture
    {
        public SimpleCityLandscapeTextureType textureType;
        public TerrainLayer terrainLayer;
        public AnimationCurve curve;
    }

    [System.Serializable]
    public class SimpleCityFoliageEntry
    {
        public int grassIndex;
        public float density;
    }

    [System.Serializable]
    public class SimpleCityFoliageTheme
    {
        public SimpleCityLandscapeTextureType textureType = SimpleCityLandscapeTextureType.Park;
        public SimpleCityFoliageEntry[] foliageEntries;
        public AnimationCurve curve;
        public float density;
    }

    /// <summary>
    /// The terrain modifier that works with the grid based dungeon builder (DungeonBuilderGrid)
    /// It modifies the terrain by adjusting the height around the layout of the dungeon and painting 
    /// it based on the specified texture settings 
    /// </summary>
    public class LandscapeTransformerCity : LandscapeTransformerBase
    {
        public SimpleCityLandscapeTexture[] textures;

        public SimpleCityFoliageTheme[] foliage;
        //SimpleCityFoliageTheme roadFoliage;
        //SimpleCityFoliageTheme openSpaceFoliage;

        public int roadBlurDistance = 6;
        public float corridorBlurThreshold = 0.5f;
        public float roomBlurThreshold = 0.5f;

        public float flatten = 1;

        public int blendingUnits = 6;
        public AnimationCurve smoothingCurve;

        protected override void BuildTerrain(DungeonModel model)
        {
            if (model is SimpleCityDungeonModel && terrain != null)
            {
                var cityModel = model as SimpleCityDungeonModel;
                SetupTextures();
                UpdateHeights(cityModel);
                UpdateTerrainTextures(cityModel);
            }
        }

        void UpdateHeights(SimpleCityDungeonModel model)
        {
            if (terrain == null || terrain.terrainData == null) return;

            var bounds = GetDungeonBounds(model, blendingUnits);
            var rasterizer = new LandscapeDataRasterizer(terrain, bounds);
            rasterizer.LoadData();
            var gridSize = model.Config.CellSize;

            var layoutBounds = GetDungeonBounds(model, 0);
            float y = transform.position.y;
            rasterizer.DrawCell(layoutBounds.x, layoutBounds.y, layoutBounds.width, layoutBounds.height, y, flatten);
            rasterizer.SmoothCell(layoutBounds.x, layoutBounds.y, layoutBounds.width - 1, layoutBounds.height - 1, y, blendingUnits, smoothingCurve, flatten);

            RemoveFoliageFromBaseLayout(model);

            rasterizer.SaveData();
        }

        void RemoveFoliageFromBaseLayout(SimpleCityDungeonModel model)
        {
            if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;

            var bounds = GetDungeonBounds(model, 0);
            int gx1, gy1, gx2, gy2;
            LandscapeDataRasterizer.WorldToTerrainCoord(terrain, bounds.x, bounds.y, out gx1, out gy1, RasterizerTextureSpace.DetailMap);
            LandscapeDataRasterizer.WorldToTerrainCoord(terrain, bounds.xMax, bounds.yMax, out gx2, out gy2, RasterizerTextureSpace.DetailMap);

            int sx = gx2 - gx1 + 1;
            int sy = gy2 - gy1 + 1;
            int[,] clearPatch = new int[sy, sx];
            for (int d = 0; d < data.detailPrototypes.Length; d++)
            {
                data.SetDetailLayer(gx1, gy1, d, clearPatch);
            }
        }

        protected override Rect GetDungeonBounds(DungeonModel model)
        {
            return GetDungeonBounds(model, blendingUnits);
        }

        private Rect GetDungeonBounds(DungeonModel model, int extraPadding)
        {
            var cityModel = model as SimpleCityDungeonModel;
            var cityConfig = cityModel.Config;

            Rect result = Rect.zero;

            if (cityModel && cityConfig)
            {
                int padding = cityConfig.cityWallPadding * 2 + extraPadding;
                var worldPadding2D = cityConfig.CellSize * padding;

                var worldSize2D = new Vector2();
                worldSize2D.x = cityModel.CityWidth * cityConfig.CellSize.x;
                worldSize2D.y = cityModel.CityHeight * cityConfig.CellSize.y;
                worldSize2D += worldPadding2D * 2;

                var basePosition3D = transform.position;
                var worldPosition2D = new Vector2(basePosition3D.x, basePosition3D.z);
                worldPosition2D -= worldPadding2D;

                result.position = worldPosition2D;
                result.size = worldSize2D;
            }

            return result;
        }

        void SetupTextures()
        {
            if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;

            // Add the specified terrain layers on the terrain data, if they have not been added already
            {
                var targetLayers = new List<TerrainLayer>(data.terrainLayers);
                foreach (var texture in textures)
                {
                    if (!targetLayers.Contains(texture.terrainLayer))
                    {
                        targetLayers.Add(texture.terrainLayer);
                    }
                }

                data.terrainLayers = targetLayers.ToArray();
            }
        }

        void UpdateTerrainTextures(SimpleCityDungeonModel model)
        {
            if (terrain == null || terrain.terrainData == null) return;

            var data = terrain.terrainData;
            var map = data.GetAlphamaps(0, 0, data.alphamapWidth, data.alphamapHeight);
            UpdateBaseTexture(model, map);

            data.SetAlphamaps(0, 0, map);
        }
        

        void UpdateBaseTexture(SimpleCityDungeonModel model, float[,,] map)
        {
            if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;
            
            var activeTextureTypes = new SimpleCityLandscapeTextureType[] {
                SimpleCityLandscapeTextureType.Park,
                SimpleCityLandscapeTextureType.Road,
                SimpleCityLandscapeTextureType.CityWallPadding,
            };

            var activeCellTypes = new SimpleCityCellType[] {
                SimpleCityCellType.Park,
                SimpleCityCellType.Road,
                SimpleCityCellType.CityWallPadding,
            };

            var dataMaps = new List<float[,]>();
            for (int i = 0; i < activeTextureTypes.Length; i++)
            {
                dataMaps.Add(new float[map.GetLength(0), map.GetLength(1)]);
            }
            
            var gridSize2D = model.Config.CellSize;
            var gridSize = new Vector3(gridSize2D.x, 0, gridSize2D.y);
            var cells = new List<SimpleCityCell>();
            foreach (var cell in model.Cells)
            {
                cells.Add(cell);
            }
            cells.AddRange(model.WallPaddingCells);

            var basePosition = transform.position;

            foreach (var cell in cells)
            {
                var locationGrid = cell.Position;
                var location = basePosition + locationGrid * gridSize - gridSize / 2.0f;
                var size = gridSize;
                int gx1, gy1, gx2, gy2;
                LandscapeDataRasterizer.WorldToTerrainTextureCoord(terrain, location.x, location.z, out gx1, out gy1);
                LandscapeDataRasterizer.WorldToTerrainTextureCoord(terrain, location.x + size.x, location.z + size.z, out gx2, out gy2);
                for (int i = 0; i < activeTextureTypes.Length; i++)
                {
                    //SimpleCityLandscapeTextureType activeTexType = activeTextureTypes[i];
                    SimpleCityCellType activeCellType = activeCellTypes[i];
                    //int textureIndex = GetTextureIndex(activeTexType);
                    var dataMap = dataMaps[i];

                    for (var gx = gx1; gx <= gx2; gx++)
                    {
                        for (var gy = gy1; gy <= gy2; gy++)
                        {
                            dataMap[gy, gx] = (cell.CellType == activeCellType) ? 1 : 0;
                        }
                    }
                }
            }

            // Blur the layout data
            var filter = new BlurFilter(roadBlurDistance);
            for (int i = 0; i < dataMaps.Count; i++) 
            {
                dataMaps[i] = filter.ApplyFilter(dataMaps[i]);
            }

            int numMaps = map.GetLength(2);

            for (int i = 0; i < dataMaps.Count; i++)
            {
                var dataMap = dataMaps[i];
                int textureIndex = GetTextureIndex(activeTextureTypes[i]);
                if (textureIndex < 0) continue;
                for (var y = 0; y < data.alphamapHeight; y++)
                {
                    for (var x = 0; x < data.alphamapWidth; x++)
                    {
                        float value = dataMap[y, x];
                        if (value > 0)
                        {
                            map[y, x, textureIndex] = value;
                            float remaining = 1 - dataMap[y, x];
                            float sum = 0;
                            for (int m = 0; m < numMaps; m++)
                            {
                                if (m != textureIndex)
                                {
                                    sum += map[y, x, m];
                                }
                            }
                            if (sum > 0)
                            {
                                for (int m = 0; m < numMaps; m++)
                                {
                                    if (m != textureIndex)
                                    {
                                        map[y, x, m] = map[y, x, m] / sum * remaining;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Normalize
            for (var y = 0; y < data.alphamapHeight; y++)
            {
                for (var x = 0; x < data.alphamapWidth; x++)
                {
                    // Apply the curves
                    for (int t = 0; t < textures.Length; t++)
                    {
                        var curve = textures[t].curve;
                        if (curve != null && curve.keys.Length > 0)
                        {
                            map[y, x, t] = curve.Evaluate(map[y, x, t]);
                        }
                    }

                    float sum = 0;
                    for (int t = 0; t < textures.Length; t++)
                    {
                        sum += map[y, x, t];
                    }

                    for (int t = 0; t < textures.Length; t++)
                    {
                        map[y, x, t] /= sum;
                    }
                }
            }

            for (int layer = 0; layer < data.detailPrototypes.Length; layer++)
            {
                var foliageMap = data.GetDetailLayer(0, 0, data.detailWidth, data.detailHeight, layer);

                for (int x = 0; x < data.detailWidth; x++)
                {
                    float nx = x / (float)(data.detailWidth - 1);
                    int sampleX = Mathf.RoundToInt(nx * (data.alphamapWidth - 1));
                    for (int y = 0; y < data.detailHeight; y++)
                    {
                        float ny = y / (float)(data.detailHeight - 1);
                        int sampleY = Mathf.RoundToInt(ny * (data.alphamapHeight - 1));

                        bool bIsValid = false;
                        float influence = 0;
                        foreach (var foliageTheme in foliage)
                        {
                            var textureIndex = GetTextureIndex(foliageTheme.textureType);
                            if (textureIndex < 0) continue;
                            float[,] paintMap = dataMaps[textureIndex];
                            bIsValid |= paintMap[sampleY, sampleX] > 0;

                            foreach (var entry in foliageTheme.foliageEntries)
                            {
                                if (entry.grassIndex == layer)
                                {
                                    
                                    float mapData = map[sampleY, sampleX, textureIndex];
                                    bIsValid |= mapData > 0;

                                    if (foliageTheme.curve != null && foliageTheme.curve.length > 0)
                                    {
                                        mapData = foliageTheme.curve.Evaluate(mapData);
                                    }
                                    float alpha = mapData * entry.density * foliageTheme.density;
                                    influence += alpha;
                                }
                            }
                        }

                        if (bIsValid)
                        {
                            int value = Mathf.FloorToInt(influence);
                            float frac = influence - value;
                            if (Random.value < frac) value++;
                            foliageMap[y, x] = value;
                        }
                    }
                }

                data.SetDetailLayer(0, 0, layer, foliageMap);
            }

            /*
            // Update foliage
            foreach (var foliageTheme in foliage)
            {
                var textureIndex = GetTextureIndex(foliageTheme.textureType);
                if (textureIndex < 0) continue;
                foreach (var entry in foliageTheme.foliageEntries)
                {
                    int layer = entry.grassIndex;
                    var foliageMap = data.GetDetailLayer(0, 0, data.detailWidth, data.detailHeight, layer);
                    for (int x = 0; x < data.detailWidth; x++)
                    {
                        float nx = x / (float)(data.detailWidth - 1);
                        int sampleX = Mathf.RoundToInt(nx * (data.alphamapWidth - 1));
                        for (int y = 0; y < data.detailHeight; y++)
                        {
                            float ny = y / (float)(data.detailHeight - 1);
                            int sampleY = Mathf.RoundToInt(ny * (data.alphamapHeight - 1));

                            float alpha = map[sampleY, sampleX, textureIndex] * entry.density * foliageTheme.density;
                            int value = Mathf.FloorToInt(alpha);
                            float frac = alpha - value;
                            if (Random.value < frac) value++;
                            foliageMap[y, x] = value;
                        }
                    }

                    data.SetDetailLayer(0, 0, layer, foliageMap);
                }
            }
            */
        }

        /// <summary>
        /// Returns the index of the landscape texture.  -1 if not found
        /// </summary>
        /// <returns>The texture index. -1 if not found</returns>
        /// <param name="textureType">Texture type.</param>
        int GetTextureIndex(SimpleCityLandscapeTextureType textureType)
        {
            if (terrain == null || terrain.terrainData == null) return -1;
            var data = terrain.terrainData;
            for (int i = 0; i < textures.Length; i++)
            {
                if (textures[i].textureType == textureType)
                {
                    return System.Array.IndexOf(data.terrainLayers, textures[i].terrainLayer);
                }
            }
            return -1;	// Doesn't exist
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SimpleCity\Navigation_SN\CityLayoutTriangleProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using SVector3 = SharpNav.Geometry.Vector3;
using Triangle3 = SharpNav.Geometry.Triangle3;
using DungeonArchitect.Builders.SimpleCity;

namespace DungeonArchitect.Navigation
{
    public class CityLayoutTriangleProvider : NavigationTriangleProvider
    {
        public Dungeon dungeon;

        public override void AddNavTriangles(List<Triangle3> triangles)
        {
            if (dungeon == null)
            {
                Debug.LogWarning("CityLayoutTriangleProvider: Dungeon is not assigned");
                return;
            }

            var model = dungeon.ActiveModel as SimpleCityDungeonModel;
            if (model == null)
            {
                Debug.LogWarning("CityLayoutTriangleProvider: Dungeon model is invalid. Rebuild the dungeon");
                return;
            }

            var width = model.CityWidth;
            var height = model.CityHeight;
            
            var config = dungeon.Config as SimpleCityDungeonConfig;
            var cellSize2D = config.CellSize;
            var cellSize = new Vector3(cellSize2D.x, 0, cellSize2D.y);

            var verts = new SVector3[4];
            for (int i = 0; i < verts.Length; i++)
            {
                verts[i] = new SVector3();
            }

            int padding = config.cityWallPadding;

            for (int cx = -padding; cx < width + padding; cx++)
            {
                for (int cz = -padding; cz < height + padding; cz++)
                {
                    var location = Vector3.Scale(new Vector3(cx, 0, cz), cellSize);
                    var size = cellSize;
                    //var bounds = cell.Bounds;
                    //var location = MathUtils.GridToWorld(config.GridCellSize, bounds.Location);
                    //var size = MathUtils.GridToWorld(config.GridCellSize, bounds.Size);

                    verts[0].Set(location.x, location.y, location.z);
                    verts[1].Set(location.x + size.x, location.y, location.z);
                    verts[2].Set(location.x + size.x, location.y, location.z + size.z);
                    verts[3].Set(location.x, location.y, location.z + size.z);

                    triangles.Add(new Triangle3(
                        verts[0],
                        verts[1],
                        verts[2]));

                    triangles.Add(new Triangle3(
                        verts[2],
                        verts[3],
                        verts[0]));
                }
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SimpleCity\Utils\RoadBeautifier.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.SimpleCity
{
    public class RoadBeautifier {
        public static string GetRoadMarkerName(int x, int z, SimpleCityCell[,] cells, out float angle)
        {
            angle = 0;

            if (MatchesConfig(x, z, cells, out angle,
                1, 0,
                0, 1,
                -1, 0,
                0, -1
            )) return SimpleCityDungeonMarkerNames.Road_X;

            if (MatchesConfig(x, z, cells, out angle,
                1, 0, 
                0, 1,
                -1, 0
            )) return SimpleCityDungeonMarkerNames.Road_T;

            if (MatchesConfig(x, z, cells, out angle,
                1, 0, 
                0, 1 
            )) return SimpleCityDungeonMarkerNames.Road_Corner;

            if (MatchesConfig(x, z, cells, out angle,
                1, 0,
                -1, 0
            )) return SimpleCityDungeonMarkerNames.Road_S;

            if (MatchesConfig(x, z, cells, out angle,
                1, 0
            )) return SimpleCityDungeonMarkerNames.Road_E;

            return SimpleCityDungeonMarkerNames.Road;
        }

        static bool MatchesConfig(int x, int z, SimpleCityCell[,] cells, out float angle, params int[] neighbors)
        {
            angle = 0;
            for (var da = 0; da < 4; da++)
            {
                bool rejected = false;
                for (int i = 0; i + 1 < neighbors.Length; i += 2)
                {
                    var dirX = neighbors[i];
                    var dirZ = neighbors[i + 1];
                    var direction = new Vector3(dirX, 0, dirZ);
                    direction = Quaternion.Euler(0, da * 90, 0) * direction;

                    var nx = Mathf.RoundToInt(x + direction.x);
                    var nz = Mathf.RoundToInt(z + direction.z);

                    if (!ContainsRoad(nx, nz, cells))
                    {
                        rejected = true;
                        break;
                    }
                }
                if (!rejected)
                {
                    angle = da * 90;
                    return true;
                }
            }
            return false;   // Not found
        }

        static bool ContainsRoad(int x, int z, SimpleCityCell[,] cells)
        {
            var lx = cells.GetLength(0);
            var lz = cells.GetLength(1);
            if (x < 0 || z < 0 || x >= lx || z >= lz)
            {
                return false;
            }
            return cells[x, z].CellType == SimpleCityCellType.Road;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SimpleCity\Utils\StrongholdWallEmitter.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Builders.SimpleCity
{
    /// <summary>
    /// Adds a wall around the edge of the city .  This makes it look like a stronghold defending the city
    /// </summary>
    public class StrongholdWallEmitter : DungeonMarkerEmitter
    {
        /// <summary>
        /// The distance to move the wall away from the city boundary
        /// </summary>
        public int padding = 0;
        public int doorSize = 2;
        public string WallMarkerName = "CityWall";
        public string DoorMarkerName = "CityDoor";
        public string GroundMarkerName = "CityGround";
        public string CornerTowerMarkerName = "CornerTower";
        public string WallPaddingMarkerName = "CityWallPadding";

        /// <summary>
        /// Called by the dungeon object right after the dungeon is created
        /// </summary>
        /// <param name="builder">reference to the builder object used to build the dungeon</param>
        public override void EmitMarkers(DungeonBuilder builder)
        {
            base.EmitMarkers(builder);

            var model = builder.Model as SimpleCityDungeonModel;
            var config = model.Config;
            var cells = model.Cells;

            var width = cells.GetLength(0);
            var length = cells.GetLength(1);

            var cellSize = new Vector3(config.CellSize.x, 0, config.CellSize.y);
            for (int p = 1; p <= padding; p++)
            {

                var currentPadding = p;

                var sx = -currentPadding;
                var sz = -currentPadding;
                var ex = width + currentPadding - 1;
                var ez = length + currentPadding - 1;

                if (currentPadding == padding)
                {
                    var halfDoorSize = doorSize / 2.0f;
                    // Insert markers along the 4 wall sides
                    for (float x = sx; x < ex; x++)
                    {
                        if ((int)x == (int)((sx + ex) / 2 - halfDoorSize))
                        {
                            EmitDoorMarker(builder, cellSize, x + halfDoorSize, sz, 0);
                            EmitDoorMarker(builder, cellSize, x + halfDoorSize, ez + 0.5f, 180);
                            x += halfDoorSize;
                            continue;
                        }
                        EmitWallMarker(builder, cellSize, x + 0.5f, sz, 0);
                        EmitWallMarker(builder, cellSize, x + 0.5f, ez + 0.5f, 180);
                    }

                    for (float z = sz; z < ez; z++)
                    {
                        if ((int)z == (int)((sz + ez) / 2 - halfDoorSize))
                        {
                            EmitDoorMarker(builder, cellSize, sx, z + halfDoorSize, 90);
                            EmitDoorMarker(builder, cellSize, ex + 0.5f, z + halfDoorSize, 270);
                            z += halfDoorSize;
                            continue;
                        }
                        EmitWallMarker(builder, cellSize, sx, z + 0.5f, 90);
                        EmitWallMarker(builder, cellSize, ex + 0.5f, z + 0.5f, 270);
                    }


                    EmitMarkerAt(builder, cellSize, CornerTowerMarkerName, sx, sz, 0);
                    EmitMarkerAt(builder, cellSize, CornerTowerMarkerName, ex + 0.5f, sz, 0);
                    EmitMarkerAt(builder, cellSize, CornerTowerMarkerName, sx, ez + 0.5f, 0);
                    EmitMarkerAt(builder, cellSize, CornerTowerMarkerName, ex + 0.5f, ez + 0.5f, 0);
                }
                else
                {
                    // Fill it with city wall padding marker
                    for (float x = sx; x < ex; x++)
                    {
                        EmitMarkerAt(builder, cellSize, WallPaddingMarkerName, x + 0.5f, sz, 0);
                        EmitMarkerAt(builder, cellSize, WallPaddingMarkerName, x + 0.5f, ez + 0.5f, 180);
                    }

                    for (float z = sz; z < ez; z++)
                    {
                        EmitMarkerAt(builder, cellSize, WallPaddingMarkerName, sx, z + 0.5f, 90);
                        EmitMarkerAt(builder, cellSize, WallPaddingMarkerName, ex + 0.5f, z + 0.5f, 270);
                    }
                }
            }

            // Emit a ground marker since the city builder doesn't emit any ground.  
            // The theme can add a plane here if desired (won't be needed if building on a landscape)
            EmitGroundMarker(builder, width, length, cellSize);


        }

        void EmitWallMarker(DungeonBuilder builder, Vector3 cellSize, float x, float z, float angle)
        {
            EmitMarkerAt(builder, cellSize, WallMarkerName, x, z, angle);
        }

        void EmitDoorMarker(DungeonBuilder builder, Vector3 cellSize, float x, float z, float angle)
        {
            EmitMarkerAt(builder, cellSize, DoorMarkerName, x, z, angle);
        }

        void EmitGroundMarker(DungeonBuilder builder, int sizeX, int sizeZ, Vector3 cellSize)
        {
            var position = Vector3.Scale(new Vector3(sizeX, 0, sizeZ) / 2.0f, cellSize) + transform.position;
            var scale = new Vector3(sizeX, 1, sizeZ);
            var trans = Matrix4x4.TRS(position, Quaternion.identity, scale);
            builder.EmitMarker(GroundMarkerName, trans, IntVector.Zero, -1);
        }

        void EmitMarkerAt(DungeonBuilder builder, Vector3 cellSize, string markerName, float x, float z, float angle)
        {
            var worldPosition = Vector3.Scale(new Vector3(x, 0, z), cellSize) + transform.position;
            var rotation = Quaternion.Euler(0, angle, 0);
            var transformation = Matrix4x4.TRS(worldPosition, rotation, Vector3.one);
            var gridPosition = new IntVector((int)x, 0, (int)z); // Optionally provide where this marker is in the grid position
            builder.EmitMarker(markerName, transformation, gridPosition, -1);
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\SnapGridFlow\Landscape\LandscapeTransformerSGF.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections;
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Landscape;
using UnityEditor;
using UnityEngine;
using MathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Builders.SnapGridFlow
{
        
	/// <summary>
	/// The type of the texture defined in the landscape paint settings.  
	/// This determines how the specified texture would be painted in the modified terrain
	/// </summary>
	public enum LandscapeTextureType
	{
		Room,
		Cliff
	}

	/// <summary>
	/// Data-structure to hold the texture settings.  This contains enough information to paint the texture 
	/// on to the terrain
	/// </summary>
	[System.Serializable]
	public class LandscapeTexture
	{
		public LandscapeTextureType textureType;
		public TerrainLayer terrainLayer;
	}
	
    /// <summary>
    /// The terrain modifier that works with the grid based dungeon builder (DungeonBuilderGrid)
    /// It modifies the terrain by adjusting the height around the layout of the dungeon and painting 
    /// it based on the specified texture settings 
    /// </summary>
	public class LandscapeTransformerSGF : LandscapeTransformerBase
    {
		public LandscapeTexture[] textures;

		// The offset to apply on the terrain at the rooms and corridors. 
		// If 0, then it would touch the rooms / corridors so players can walk over it
		// Give a negative value if you want it to be below it (e.g. if you already have a ground mesh supported by pillars standing on this terrain)
		public float layoutLevelOffset = 0;

		public int smoothingDistance = 5;
		public AnimationCurve roomElevationCurve;
        public int roadBlurDistance = 6;
        public float roomBlurThreshold = 0.5f;

        private Vector3 chunkSize = Vector3.zero;
        private HashSet<Vector3Int> nodesToRasterize = new HashSet<Vector3Int>();
        private Vector3Int min = Vector3Int.zero;
        private Vector3Int max = Vector3Int.zero;
        private IntVector[] terrainBases;
        private float offsetY = 0;
        
        protected override void BuildTerrain(DungeonModel model) {

	        var sgfModel = model as SnapGridFlowModel;
	        if (terrain == null || sgfModel == null || sgfModel.layoutGraph == null) return;
            var sgfConfig = GetComponent<SnapGridFlowConfig>();
            if (sgfConfig == null || sgfConfig.moduleDatabase == null || sgfConfig.moduleDatabase.ModuleBoundsAsset == null) return;

            nodesToRasterize.Clear();
            chunkSize = sgfConfig.moduleDatabase.ModuleBoundsAsset.chunkSize;
            offsetY = sgfConfig.moduleDatabase.ModuleBoundsAsset.doorOffsetY;
            
            var graph = sgfModel.layoutGraph;
            if (graph == null || graph.Nodes.Count == 0) return;

            
            {
	            var occupiedNodes = new HashSet<Vector3Int>();
	            bool foundValid = false;
	            foreach (var node in graph.Nodes) 
	            {
		            if (!node.active) continue;
		            
		            FlowLayoutGraphNode[] subNodes = node.MergedCompositeNodes.Count == 0 ? new FlowLayoutGraphNode[]{ node } : node.MergedCompositeNodes.ToArray();
		            foreach (var subNode in subNodes)
		            {   
			            Vector3Int coord = new Vector3Int(
				            Mathf.RoundToInt(subNode.coord.x),
				            Mathf.RoundToInt(subNode.coord.y),
				            Mathf.RoundToInt(subNode.coord.z));

			            occupiedNodes.Add(coord);
			            
			            if (!foundValid)
			            {
				            min = coord;
				            max = coord;
				            foundValid = true;
			            }
			            else
			            {
				            min.x = Mathf.Min(min.x, coord.x);
				            min.y = Mathf.Min(min.y, coord.y);
				            min.z = Mathf.Min(min.z, coord.z);
			            
				            max.x = Mathf.Max(max.x, coord.x);
				            max.y = Mathf.Max(max.y, coord.y);
				            max.z = Mathf.Max(max.z, coord.z);
			            }
		            }
	            }

	            // Along the XZ plane, find the lowest Y coord for each point so we can rasterize the landscape on it
	            for (int x = min.x; x <= max.x; x++)
	            {
		            for (int z = min.z; z <= max.z; z++)
		            {
			            for (int y = min.y; y <= max.y; y++)
			            {
				            var coord = new Vector3Int(x, y, z);
				            if (occupiedNodes.Contains(coord))
				            {
					            nodesToRasterize.Add(coord);
					            break;
				            }
			            }
		            }
	            }
            }
            
            SetupTextures();
            UpdateHeights(sgfModel);
            //UpdateTerrainTextures();
		}

        protected override Rect GetDungeonBounds(DungeonModel model) {
            var sgfConfig = GetComponent<SnapGridFlowConfig>();
            var sgfModel = model as SnapGridFlowModel;

            var basePosition = GetBasePosition();
            var worldPos = new Vector2((min.x - 0.5f) * chunkSize.x, (min.z - 0.5f) * chunkSize.z) + new Vector2(basePosition.x, basePosition.z);
            var worldSize = new Vector2((max.x - min.x + 1) * chunkSize.x, (max.z - min.z + 1) * chunkSize.z);


            float expandX, expandY;
            {
                int expandByLogical = smoothingDistance * 2;
                LandscapeDataRasterizer.TerrainToWorldDistance(terrain, expandByLogical, expandByLogical, out expandX, out expandY);
            }

            var result = new Rect(worldPos, worldSize);
            result.x -= expandX;
            result.y -= expandY;
            result.width += expandX * 2;
            result.height += expandY * 2;
            
            return result;
        }

        void SetupTextures() {
            if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;

            // Add the specified terrain layers on the terrain data, if they have not been added already
            {
                var targetLayers = new List<TerrainLayer>(data.terrainLayers);
                foreach (var texture in textures)
                {
                    if (!targetLayers.Contains(texture.terrainLayer))
                    {
                        targetLayers.Add(texture.terrainLayer);
                    }
                }

                data.terrainLayers = targetLayers.ToArray();
            }
        }

        Vector3 GetBasePosition()
        {
	        return transform.position; // + new Vector3(0, -offsetY, 0);
        }
        
		void UpdateHeights(SnapGridFlowModel model) {
			if (terrain == null || terrain.terrainData == null) return;
			var rasterizer = new LandscapeDataRasterizer(terrain, GetDungeonBounds(model));
			rasterizer.LoadData();

			var basePosition = GetBasePosition();
			
			// Raise the terrain
			foreach (var coord in nodesToRasterize)
			{
				var coordF = MathUtils.ToVector3(coord) - new Vector3(0.5f, 0, 0.5f);
				var worldPos = Vector3.Scale(coordF, chunkSize) + basePosition;
				var cellY = worldPos.y + layoutLevelOffset;
				rasterizer.DrawCell(worldPos.x, worldPos.z, chunkSize.x, chunkSize.z, cellY);
			}

            // Smooth the terrain
            ApplySmoothing(model, rasterizer);
            
			rasterizer.SaveData();
		}

        protected virtual void ApplySmoothing(SnapGridFlowModel model, LandscapeDataRasterizer rasterizer)
        {
	        var basePosition = GetBasePosition();
	        foreach (var coord in nodesToRasterize)
	        {
		        var coordF = MathUtils.ToVector3(coord) - new Vector3(0.5f, 0.5f, 0.5f);
		        var worldPos = Vector3.Scale(coordF, chunkSize) + basePosition;
		        var cellY = worldPos.y + layoutLevelOffset;
		        var curve = roomElevationCurve;
		        rasterizer.SmoothCell(worldPos.x, worldPos.z, chunkSize.x, chunkSize.z, cellY, smoothingDistance, curve);
	        }
        }

		void UpdateTerrainTextures() {
            if (terrain == null || terrain.terrainData == null) return;

			var data = terrain.terrainData;
			//var map = new float[data.alphamapWidth, data.alphamapHeight, numTextures];
            var map = data.GetAlphamaps(0, 0, data.alphamapWidth, data.alphamapHeight);
			UpdateBaseTexture(map);
			UpdateCliffTexture(map);
            RemoveFoliage();

			data.SetAlphamaps(0, 0, map);
		}

        void RemoveFoliage()
        {
            if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;

            var basePosition = GetBasePosition();
            foreach (var coord in nodesToRasterize)
            {
	            var coordF = MathUtils.ToVector3(coord) - new Vector3(0.5f, 0.5f, 0.5f);
	            var worldPos = Vector3.Scale(coordF, chunkSize) + basePosition;
                int gx1, gy1, gx2, gy2;
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldPos.x, worldPos.z, out gx1, out gy1, RasterizerTextureSpace.DetailMap);
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldPos.x + chunkSize.x, worldPos.z + chunkSize.z, out gx2, out gy2, RasterizerTextureSpace.DetailMap);

                int sx = gx2 - gx1 + 1;
                int sy = gy2 - gy1 + 1;
                int[,] clearPatch = new int[sy, sx];
                for (int d = 0; d < data.detailPrototypes.Length; d++)
                {
                    data.SetDetailLayer(gx1, gy1, d, clearPatch);
                }
            }
        }

		void UpdateBaseTexture(float[,,] map) {
			if (terrain == null || terrain.terrainData == null) return;
            var data = terrain.terrainData;

            int roomIndex = GetTextureIndex(LandscapeTextureType.Room);

            // Apply the room/corridor texture
            {
                var roomMap = new float[map.GetLength(0), map.GetLength(1)];
                var basePosition = GetBasePosition();
                foreach (var coord in nodesToRasterize)
                {
	                var coordF = MathUtils.ToVector3(coord) - new Vector3(0.5f, 0.5f, 0.5f);
	                var worldPos = Vector3.Scale(coordF, chunkSize) + basePosition;
					int gx1, gy1, gx2, gy2;
					LandscapeDataRasterizer.WorldToTerrainTextureCoord(terrain, worldPos.x, worldPos.z, out gx1, out gy1);
					LandscapeDataRasterizer.WorldToTerrainTextureCoord(terrain, worldPos.x + chunkSize.x, worldPos.z + chunkSize.z, out gx2, out gy2);
					for (var gx = gx1; gx <= gx2; gx++) {
						for (var gy = gy1; gy <= gy2; gy++) {
                            roomMap[gy, gx] = 1;
						}
					}
				}

                // Blur the layout data
                var filter = new BlurFilter(roadBlurDistance);
                roomMap = filter.ApplyFilter(roomMap);

                // Fill up the inner region with corridor index
                int numMaps = map.GetLength(2);
				for (var y = 0; y < data.alphamapHeight; y++) {
					for (var x = 0; x < data.alphamapWidth; x++) {
                        bool wroteData = false;
                        bool isRoom = (roomMap[y, x] > roomBlurThreshold);
                        if (isRoom && roomIndex >= 0)
                        {
                            map[y, x, roomIndex] = 1;
                            wroteData = true;
                        }

                        if (wroteData)
                        {
                            // Clear out other masks
                            for (int m = 0; m < numMaps; m++)
                            {
                                if (m == roomIndex)
                                {
                                    continue;
                                }

                                map[y, x, m] = 0;
                            }
                        }
                    }
				}
			}
		}

		void UpdateCliffTexture(float[,,] map) {
			if (terrain == null) return;
			int cliffIndex = GetTextureIndex(LandscapeTextureType.Cliff);
			if (cliffIndex < 0) return;
			
			var data = terrain.terrainData;
			
			// For each point on the alphamap...
			for (var y = 0; y < data.alphamapHeight; y++) {
				for (var x = 0; x < data.alphamapWidth; x++) {
					// Get the normalized terrain coordinate that
					// corresponds to the the point.
					var normX = x * 1.0f / (data.alphamapWidth - 1);
					var normY = y * 1.0f / (data.alphamapHeight - 1);
					
					// Get the steepness value at the normalized coordinate.
					var angle = data.GetSteepness(normX, normY);
					
					// Steepness is given as an angle, 0..90 degrees. Divide
					// by 90 to get an alpha blending value in the range 0..1.
					var frac = angle / 90.0f;
					frac *= 2;
					frac = Mathf.Clamp01(frac);
					var cliffRatio = frac;
					var nonCliffRatio = 1 - frac;
					
					for (int t = 0; t < textures.Length; t++) {
						if (t == cliffIndex) {
							map[y, x, t] = cliffRatio;
						} else {
							map[y, x, t] *= nonCliffRatio;
						}
					}
				}
			}
		}
		
		/// <summary>
		/// Returns the index of the landscape texture.  -1 if not found
		/// </summary>
		/// <returns>The texture index. -1 if not found</returns>
		/// <param name="textureType">Texture type.</param>
		int GetTextureIndex(LandscapeTextureType textureType) {
            if (terrain == null || terrain.terrainData == null) return -1;
            var data = terrain.terrainData;
            for (int i = 0; i < textures.Length; i++) {
				if (textures[i].textureType == textureType) {
                    return System.Array.IndexOf(data.terrainLayers, textures[i].terrainLayer);
				}
			}
			return -1;	// Doesn't exist
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Markers\PlaceableMarker.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    public class PlaceableMarker : MonoBehaviour
    {
        public string[] supportedMarkers;

        public Color debugColor = Color.red;
        public string debugText = "Marker Description";

        [HideInInspector]
        public bool drawDebugVisuals = true;
        
        void OnDrawGizmos()
        {
            if (drawDebugVisuals && transform != null)
            {
                Gizmos.color = debugColor;
                
                var center = transform.position;
                var radius = 0.2f;
                Gizmos.DrawSphere(center, radius);

                var start = center;
                var end = start + transform.forward;
                Gizmos.DrawLine(start, end);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Rules\SelectorRule.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Selector rule allow you to attach selection behavior to decide if a visual node should be inserted into the scene
    /// </summary>
    public class SelectorRule : ScriptableObject
    {
        /// <summary>
        /// Implementations should override this and determine if the node should be selected (inserted into the scene)
        /// </summary>
        /// <param name="socket">The marker data-structure</param>
        /// <param name="propTransform">The combined transform of the visual node that invoked this rule</param>
        /// <param name="model">The dungeon model</param>
        /// <param name="random">The random stream used by the builder. User this random stream for any randomness for consistancy</param>
        /// <returns></returns>
        public virtual bool CanSelect(PropSocket socket, Matrix4x4 propTransform, DungeonModel model, System.Random random)
        {
            return true;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Rules\TransformationRule.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Selector rule allow you to attach selection behavior to decide if a visual node should be inserted into the scene
    /// </summary>
    public class TransformationRule : ScriptableObject
    {
        /// <summary>
        /// Implement this method to provide a transform based on your logic.
        /// </summary>
        /// <param name="socket">The marker data structure</param>
        /// <param name="model">The dungeon model</param>
        /// <param name="propTransform">The combined transform of the visual node that invoked this rule</param>
        /// <param name="random">The random stream used by the builder. User this random stream for any randomness for consistancy</param>
        /// <param name="outPosition">Set your position offset here</param>
        /// <param name="outRotation">Set your rotation offset here</param>
        /// <param name="outScale">Set your scale offset here</param>
        public virtual void GetTransform(PropSocket socket, DungeonModel model, Matrix4x4 propTransform, System.Random random, out Vector3 outPosition, out Quaternion outRotation, out Vector3 outScale)
        {
            outPosition = Vector3.zero;
            outRotation = Quaternion.identity;
            outScale = Vector3.one;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Terrain\LandscapeDataRasterizer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Landscape
{
    public enum RasterizerTextureSpace
    {
        HeightMap,
        AlphaMap,
        DetailMap
    }

    /// <summary>
    /// Manages the landscape data and performs various rasterization algorithms (draw cells, lines etc)
    /// </summary>
    public class LandscapeDataRasterizer
    {
        Terrain terrain;
        float[,] heights;
        bool[,] lockedCells;

        Rect worldBounds;
        Vector2Int heightmapFrameStart;
        Vector2Int heightmapFrameSize;

        /// <summary>
        /// Creates a new instance
        /// </summary>
        /// <param name="terrain">The terrain object to modify</param>
        /// <param name="elevation">The prefered ground level elevation</param>
        public LandscapeDataRasterizer(Terrain terrain, Rect worldBounds)
        {
            this.terrain = terrain;
            this.worldBounds = worldBounds;

            int x1, y1, x2, y2;
            WorldToTerrainCoord(terrain, worldBounds.x, worldBounds.y, out x1, out y1, RasterizerTextureSpace.HeightMap);
            WorldToTerrainCoord(terrain, worldBounds.xMax, worldBounds.yMax, out x2, out y2, RasterizerTextureSpace.HeightMap);

            heightmapFrameStart = new Vector2Int(x1, y1);
            heightmapFrameSize = new Vector2Int(x2 - x1 + 1, y2 - y1 + 1);
        }

        /// <summary>
        /// Loads the data from the terrain into memory for modification
        /// </summary>
        public void LoadData()
        {
            var data = terrain.terrainData;

            var fx = heightmapFrameStart.x;
            var fy = heightmapFrameStart.y;
            var fw = heightmapFrameSize.x;
            var fh = heightmapFrameSize.y;

            heights = data.GetHeights(fx, fy, fw, fh);

            lockedCells = new bool[fh, fw];

            for (int ix = 0; ix < fw; ix++)
            {
                for (int iy = 0; iy < fh; iy++)
                {
                    lockedCells[iy, ix] = false;
                }
            }
        }

        /// <summary>
        /// Gets the elevation in normalized space
        /// </summary>
        /// <param name="worldElevation"></param>
        /// <returns></returns>
        float GetElevation(float worldElevation)
        {
            var resolution = terrain.terrainData.size.y;
            return (worldElevation - terrain.transform.position.y) / resolution;
        }

        /// <summary>
        /// Gets the height of the terrain at the specified world space
        /// </summary>
        /// <param name="terrain">The terrain object</param>
        /// <param name="worldX">X cooridnate in world space</param>
        /// <param name="worldZ">Z cooridnate in world space</param>
        /// <returns>The Y height of the terrain at the specified location</returns>
        public static float GetHeight(Terrain terrain, float worldX, float worldZ)
        {
            int gx, gy;
            LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldX, worldZ, out gx, out gy);
            var height = terrain.terrainData.GetHeight(gx, gy);

            return height + terrain.transform.position.y;
        }

        public static void WorldToTerrainDistance(Terrain terrain, float worldDistX, float worldDistZ, out int terrainDistX, out int terrainDistZ)
        {
            var terrainSize = terrain.terrainData.size;
            var data = terrain.terrainData;

            var terrainWidth = data.heightmapResolution;
            var terrainHeight = data.heightmapResolution;

            var multiplierX = (terrainWidth - 1) / terrainSize.x;
            var multiplierZ = (terrainHeight - 1) / terrainSize.z;

            terrainDistX = Mathf.RoundToInt(worldDistX * multiplierX);
            terrainDistZ = Mathf.RoundToInt(worldDistZ * multiplierZ);
        }

        public static void TerrainToWorldDistance(Terrain terrain, int terrainDistX, int terrainDistZ, out float worldDistX, out float worldDistZ)
        {
            var terrainSize = terrain.terrainData.size;
            var data = terrain.terrainData;

            var terrainWidth = data.heightmapResolution;
            var terrainHeight = data.heightmapResolution;

            worldDistX = Mathf.RoundToInt(terrainDistX * terrainSize.x / (terrainWidth - 1));
            worldDistZ = Mathf.RoundToInt(terrainDistZ * terrainSize.z / (terrainHeight - 1));
        }

        /// <summary>
        /// Converts the world coordinate to internal terrain coordinate where the data is loaded
        /// </summary>
        /// <param name="terrain">The terrain to query</param>
        /// <param name="x">x coordinate in world coordinate</param>
        /// <param name="y">z coordinate in world coordinate</param>
        /// <param name="gx">x cooridnate in the 2D terrain height data coordinate</param>
        /// <param name="gy">y cooridnate in the 2D terrain height data coordinate</param>
        public static void WorldToTerrainCoord(Terrain terrain, float x, float y, out int gx, out int gy)
        {
            WorldToTerrainCoord(terrain, x, y, out gx, out gy, RasterizerTextureSpace.HeightMap);
        }

        /// <summary>
        /// Converts the world coordinate to internal terrain coordinate where the data is loaded
        /// </summary>
        /// <param name="terrain">The terrain to query</param>
        /// <param name="x">x coordinate in world coordinate</param>
        /// <param name="y">z coordinate in world coordinate</param>
        /// <param name="gx">x cooridnate in the 2D terrain height data coordinate</param>
        /// <param name="gy">y cooridnate in the 2D terrain height data coordinate</param>
        public static void WorldToTerrainCoord(Terrain terrain, float x, float y, out int gx, out int gy, RasterizerTextureSpace textureSpace)
        {
            var terrainSize = terrain.terrainData.size;
            var data = terrain.terrainData;

            var terrainWidth = 0;
            var terrainHeight = 0;

            if (textureSpace == RasterizerTextureSpace.HeightMap)
            {
                terrainWidth = data.heightmapResolution;
                terrainHeight = data.heightmapResolution;
            }
            else if (textureSpace == RasterizerTextureSpace.AlphaMap)
            {
                terrainWidth = data.alphamapWidth;
                terrainHeight = data.alphamapHeight;
            }
            else if (textureSpace == RasterizerTextureSpace.DetailMap)
            {
                terrainWidth = data.detailWidth;
                terrainHeight = data.detailHeight;
            }

            var multiplierX = (terrainWidth - 1) / terrainSize.x;
            var multiplierZ = (terrainHeight - 1) / terrainSize.z;

            var offset = new Vector2();
            offset.x = -terrain.transform.position.x;
            offset.y = -terrain.transform.position.z;
            var xf = (x + offset.x) * multiplierX;
            var yf = (y + offset.y) * multiplierZ;

            gx = Mathf.RoundToInt(xf);
            gy = Mathf.RoundToInt(yf);
        }

        /// <summary>
        /// Converts the world coordinate to terrain texture coordinate
        /// </summary>
        /// <param name="terrain">The terrain to query</param>
        /// <param name="x">x coordinate in world coordinate</param>
        /// <param name="y">z coordinate in world coordinate</param>
        /// <param name="tx">x cooridnate in the 2D terrain texture data coordinate</param>
        /// <param name="ty">y cooridnate in the 2D terrain texture data coordinate</param>
        public static void WorldToTerrainTextureCoord(Terrain terrain, float x, float y, out int tx, out int ty)
        {
            var terrainSize = terrain.terrainData.size;
            var data = terrain.terrainData;

            var terrainWidth = data.alphamapWidth;
            var terrainHeight = data.alphamapHeight;

            var multiplierX = (terrainWidth - 1) / terrainSize.x;
            var multiplierZ = (terrainHeight - 1) / terrainSize.z;

            var offset = new Vector2();
            offset.x = -terrain.transform.position.x;
            offset.y = -terrain.transform.position.z;
            var xf = (x + offset.x) * multiplierX;
            var yf = (y + offset.y) * multiplierZ;

            tx = Mathf.RoundToInt(xf);
            ty = Mathf.RoundToInt(yf);
        }

        /// <summary>
        /// Converts the world coordinate to terrain texture coordinate
        /// </summary>
        /// <param name="terrain">The terrain to query</param>
        /// <param name="x">x coordinate in world coordinate</param>
        /// <param name="y">z coordinate in world coordinate</param>
        /// <param name="tx">x cooridnate in the 2D terrain texture data coordinate</param>
        /// <param name="ty">y cooridnate in the 2D terrain texture data coordinate</param>
        public static void WorldToTerrainDetailCoord(Terrain terrain, float x, float y, out int tx, out int ty)
        {
            var terrainSize = terrain.terrainData.size;
            var data = terrain.terrainData;

            var terrainWidth = data.detailWidth;
            var terrainHeight = data.detailHeight;

            var multiplierX = (terrainWidth - 1) / terrainSize.x;
            var multiplierZ = (terrainHeight - 1) / terrainSize.z;

            var offset = new Vector2();
            offset.x = -terrain.transform.position.x;
            offset.y = -terrain.transform.position.z;
            var xf = (x + offset.x) * multiplierX;
            var yf = (y + offset.y) * multiplierZ;

            tx = Mathf.RoundToInt(xf);
            ty = Mathf.RoundToInt(yf);
        }


        public void DrawCell(float x, float y, float w, float h, float elevation)
        {
            DrawCell(x, y, w, h, elevation, 1);
        }

        /// <summary>
        /// Rasterizes the terrain height along the specified world cooridnate with the specified elevation height
        /// </summary>
        /// <param name="x">x cooridnate in world space</param>
        /// <param name="y">z coordinate in world space</param>
        /// <param name="w">width in world space</param>
        /// <param name="h">height in world space</param>
        /// <param name="elevation">The elevation to set in the specified bounds</param>
        public void DrawCell(float x, float y, float w, float h, float elevation, float flatten)
        {
            var data = terrain.terrainData;
            var terrainWidth = data.heightmapResolution;
            var terrainHeight = data.heightmapResolution;

            var fx = heightmapFrameStart.x;
            var fy = heightmapFrameStart.y;
            var fw = heightmapFrameSize.x;
            var fh = heightmapFrameSize.y;

            flatten = Mathf.Clamp01(flatten);

            int x1, y1, x2, y2;
            WorldToTerrainCoord(terrain, x, y, out x1, out y1);
            WorldToTerrainCoord(terrain, x + w, y + h, out x2, out y2);

            for (int ix = x1; ix <= x2; ix++)
            {
                for (int iy = y1; iy <= y2; iy++)
                {
                    if (ix < 0 || ix >= terrainWidth || iy < 0 || iy >= terrainHeight)
                    {
                        // Out of terrain boundaries. Ignore
                        continue;
                    }
                    int tx = Mathf.Clamp(ix - fx, 0, fw - 1);
                    int ty = Mathf.Clamp(iy - fy, 0, fh - 1);
                    var normalizedElevation = GetElevation(elevation);
                    float e0 = heights[ty, tx];
                    float e1 = normalizedElevation;
                    float e = Mathf.Lerp(e0, e1, flatten);
                    heights[ty, tx] = e;
                    lockedCells[ty, tx] = true;
                }
            }
        }

        public void SmoothCell(float x, float y, float w, float h, float elevation, int smoothingDistance, AnimationCurve smoothingCurve)
        {
            SmoothCell(x, y, w, h, elevation, smoothingDistance, smoothingCurve, 1);
        }

        /// <summary>
        /// Applies a smoothing blur filter based on the user-defined smoothing curve 
        /// </summary>
        /// <param name="x">x cooridnate in world space</param>
        /// <param name="y">z coordinate in world space</param>
        /// <param name="w">width in world space</param>
        /// <param name="h">height in world space</param>
        /// <param name="elevation">The elevation to set in the specified bounds</param>
        /// <param name="smoothingDistance">The distance to apply the smoothing transition on.  For e.g. if the distance it 5, the smoothing would occur over 5 units</param>
        /// <param name="smoothingCurve">The user defined curve to control the steepness of cliffs</param>
        public void SmoothCell(float x, float y, float w, float h, float elevation, int smoothingDistance, AnimationCurve smoothingCurve, float flatten)
        {
            var fx = heightmapFrameStart.x;
            var fy = heightmapFrameStart.y;
            var fw = heightmapFrameSize.x;
            var fh = heightmapFrameSize.y;

            flatten = Mathf.Clamp01(flatten);

            int x1, y1, x2, y2;
            WorldToTerrainCoord(terrain, x, y, out x1, out y1);
            WorldToTerrainCoord(terrain, x + w, y + h, out x2, out y2);
            var bounds = new Rectangle(x1, y1, x2 - x1, y2 - y1);
            var startElevation = GetElevation(elevation);
            for (int i = 1; i <= smoothingDistance; i++)
            {
                bounds = Rectangle.ExpandBounds(bounds, 1);
                var borderPoints = bounds.GetBorderPoints();
                foreach (var borderPoint in borderPoints)
                {
                    var ix = borderPoint.x;
                    var iy = borderPoint.z;
                    int tx = Mathf.Clamp(ix - fx, 0, fw - 1);
                    int ty = Mathf.Clamp(iy - fy, 0, fh - 1);

                    if (lockedCells[ty, tx])
                    {
                        continue;
                    }

                    var endElevation = heights[ty, tx];
                    var frameFlatten = (float)(smoothingDistance - i) / (smoothingDistance);
                    //frameSmooth = Mathf.Clamp01(smoothingCurve.Evaluate(frameSmooth));
                    frameFlatten = Remap(frameFlatten, 0, 1, 0, flatten, true);
                    var cellElevation = endElevation + (startElevation - endElevation) * frameFlatten;
                    heights[ty, tx] = cellElevation;
                }
            }
        }

        float Remap(float value, float oldMin, float oldMax, float newMin, float newMax, bool clamp)
        {
            var ratio = (value - oldMin) / (oldMax - oldMin);
            if (clamp)
            {
                ratio = Mathf.Clamp01(ratio);
            }
            return newMin + (newMax - newMin) * ratio;
        }


        /// <summary>
        /// Saves the data in memory back into the terrain. This modifies the terrain object
        /// </summary>
        public void SaveData()
        {
            var fx = heightmapFrameStart.x;
            var fy = heightmapFrameStart.y;

            terrain.terrainData.SetHeights(fx, fy, heights);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Terrain\TerrainTexture.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;


namespace DungeonArchitect.Landscape
{
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Volumes\MarkerReplaceVolume.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;


namespace DungeonArchitect
{
    [System.Serializable]
    public class MarkerReplacementEntry
    {
        public string fromMarker;
        public string toMarker;
    }

    /// <summary>
    /// This volume replaces any specified markers found in the scene before theming is applied to it. 
    /// This helps in having more control over the generated dungeon, e.g. remove / add doors, walls etc
    /// </summary>
    [ExecuteInEditMode]
    public class MarkerReplaceVolume : Volume
    {
        void Awake()
        {
            COLOR_WIRE = new Color(1, 0.25f, 0.5f, 1);
            COLOR_SOLID_DESELECTED = new Color(1, 0.25f, 0.5f, 0.0f);
            COLOR_SOLID = new Color(1, 0.25f, 0.5f, 0.1f);
        }

        public MarkerReplacementEntry[] replacements;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Volumes\MirrorVolume.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect
{
    [System.Serializable]
    public enum MirrorVolumeDirection
    {
        AxisX,
        AxisZ,
        AxisXZ
    }
    
    public class MirrorVolume : Volume
    {
        public MirrorVolumeDirection direction = MirrorVolumeDirection.AxisX;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Volumes\NegationVolume.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Negation volumes remove procedural geometries from the scene that lie with it's bounds
    /// </summary>
    [ExecuteInEditMode]
    public class NegationVolume : Volume
    {
        public bool inverse = false;

        void Awake()
        {
            COLOR_WIRE = new Color(1, 0.5f, 0, 1);
            COLOR_SOLID_DESELECTED = new Color(1, 0.5f, 0, 0.0f);
            COLOR_SOLID = new Color(1, 0.5f, 0, 0.1f);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Volumes\ThemeOverrideVolume.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect
{
    /// <summary>
    /// Dungeon layout that lies within this volumes bounds picks up the theme set in this volume
    /// </summary>
    public class ThemeOverrideVolume : Volume
    {
        public Graph overrideTheme;

        /// <summary>
        /// Uses the base theme's markers if the overriden them doesn't have any game objects for a marker
        /// </summary>
        public bool useBaseThemeForMissingMarkers = false;

        void Awake()
        {
            COLOR_WIRE = new Color(0.1f, 0.5f, 1, 1);
            COLOR_SOLID_DESELECTED = new Color(0, 0.5f, 1, 0.0f);
            COLOR_SOLID = new Color(0, 0.5f, 1, 0.1f);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Volumes\Volume.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect
{
    /// <summary>
    /// A volume is an abstract representation of space in the world.  
    /// A volume can be scaled and moved around like any other game object and custom
    /// functionality can be added to volumes to influence the dungeon with it's spatial volume
    /// </summary>
    public class Volume : MonoBehaviour
    {
        public Dungeon dungeon;
		public bool mode2D = false;

        /// <summary>
        /// Gets the bounds of the volume
        /// </summary>
        /// <returns>The bounds of the dungeon</returns>
        public Bounds GetBounds()
        {
            var bounds = new Bounds();
            var transform = gameObject.transform;
            bounds.center = transform.position;
            var size = transform.rotation * transform.localScale;
            MathUtils.Abs(ref size);
            bounds.size = size;

			if (mode2D) {
				MathUtils.FlipYZ(ref bounds);
			}
            return bounds;
        }


        /// <summary>
        /// Gets the position and scale of the volume in grid space
        /// </summary>
        /// <param name="positionGrid">The grid position (out)</param>
        /// <param name="scaleGrid">The grid scale (out)</param>
        public void GetVolumeGridTransform(out IntVector positionGrid, out IntVector scaleGrid, Vector3 LogicalGridSize)
        {
            if (dungeon == null)
            {
                positionGrid = IntVector.Zero;
                scaleGrid = IntVector.Zero;
                return;
            }

            var transform = gameObject.transform;
            var position = transform.position;
            var scale = transform.rotation * transform.localScale;
            MathUtils.Abs(ref scale);

            var positionGridF = DungeonArchitect.Utils.MathUtils.Divide(position, LogicalGridSize);
            var scaleGridF = DungeonArchitect.Utils.MathUtils.Divide(scale, LogicalGridSize);

            positionGrid = DungeonArchitect.Utils.MathUtils.ToIntVector(positionGridF);
            scaleGrid = DungeonArchitect.Utils.MathUtils.ToIntVector(scaleGridF);

            if (mode2D)
            {
                positionGrid = MathUtils.FlipYZ(positionGrid);
                scaleGrid = MathUtils.FlipYZ(scaleGrid);
            }
        }

        protected Color COLOR_WIRE = Color.yellow;
        protected Color COLOR_SOLID_DESELECTED = new Color(1, 1, 0, 0.0f);
        protected Color COLOR_SOLID = new Color(1, 1, 0, 0.1f);
        void OnDrawGizmosSelected()
        {
            DrawGizmo(true);
        }

        void OnDrawGizmos()
        {
            DrawGizmo(false);
        }

        void DrawGizmo(bool selected)
        {
            var transform = gameObject.transform;
            var position = transform.position;
            var scale = transform.localScale;
            scale = transform.rotation * scale;

            // Draw the wireframe
            Gizmos.color = COLOR_WIRE;
            Gizmos.DrawWireCube(position, scale);

            Gizmos.color = selected ? COLOR_SOLID : COLOR_SOLID_DESELECTED;
            Gizmos.DrawCube(position, scale);
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Infinity\InfinityDungeon.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.Utils;

namespace DungeonArchitect
{
    [ExecuteInEditMode]
    public class InfinityDungeon : MonoBehaviour
    {
        public Transform buildPositionTracker;
        public float buildDistance = 40;

        public List<Graph> dungeonThemes;
        public Transform parentGameObject;
        public GameObject chunkDungeonTemplate;

        [SerializeField]
        List<InfinityDungeonConfig> spawnedChunks = new List<InfinityDungeonConfig>();

        [SerializeField]
        [HideInInspector]
        bool dungeonBuilt = false;

        InfinityDungeonConfig config;

        private void Awake()
        {
            config = GetComponent<InfinityDungeonConfig>();
        }

        public void EditorUpdate()
        {
            spawnedChunks.RemoveAll(c => c == null || c.gameObject == null);
            foreach (var chunk in spawnedChunks)
            {
                var dungeon = chunk.gameObject.GetComponent<Dungeon>();
                dungeon.Update();
            }
        }

        private void Update()
        {
            if (dungeonBuilt)
            {
                UpdateChunks();
            }
        }

        public void BuildDungeonRandomSeed()
        {
            config = GetComponent<InfinityDungeonConfig>();
            config.Seed = (uint)Random.Range(1, 1000000000);
            DestroyDungeon();

            dungeonBuilt = true;
            UpdateChunks();
        }

        public void BuildDungeon()
        {
            config = GetComponent<InfinityDungeonConfig>();

            DestroyDungeon();

            dungeonBuilt = true;
            UpdateChunks();
        }

        void UpdateChunks()
        {
            var position = (buildPositionTracker != null) ? buildPositionTracker.position : Vector3.zero;
            UpdateChunks(position);
        }

        void UpdateChunks(Vector3 buildPosition)
        {
            if (!dungeonBuilt)
            {
                return;
            }
            var buildExtents = new Vector3(buildDistance, buildDistance, buildDistance);
            var boundsMin = buildPosition - buildExtents;
            var boundsMax = buildPosition + buildExtents;

            // Convert to logical coords (divide by the grid size, if it exists)
            boundsMin = config.GetLogicalCoord(boundsMin);
            boundsMax = config.GetLogicalCoord(boundsMax);

            boundsMin = ClampOnBuildAxis(boundsMin);
            boundsMax = ClampOnBuildAxis(boundsMax);

            var size = config.chunkSize;
            size.x = Mathf.Max(size.x, 1);
            size.y = Mathf.Max(size.y, 1);
            size.z = Mathf.Max(size.z, 1);

            // convert to chunk coords
            boundsMin = MathUtils.V3FloorToInt(MathUtils.Divide(boundsMin, size));
            boundsMax = MathUtils.V3FloorToInt(MathUtils.Divide(boundsMax, size));

            var imin = new IntVector(boundsMin);
            var imax = new IntVector(boundsMax);

            var chunksToSpawn = new List<Vector3>();
            for (int x = imin.x; x <= imax.x; x++)
            {
                for (int y = imin.y; y <= imax.y; y++)
                {
                    for (int z = imin.z; z <= imax.z; z++)
                    {
                        var position = Vector3.Scale(new Vector3(x, y, z), config.chunkSize);
                        chunksToSpawn.Add(position);
                    }
                }
            }
            
            var chunksToDestroy = new List<InfinityDungeonConfig>();
            
            foreach (var existingChunk in spawnedChunks)
            {
                if (existingChunk == null) continue;
                if (chunksToSpawn.Contains(existingChunk.chunkPosition))
                {
                    // Already contains this chunk. No need to spawn
                    chunksToSpawn.Remove(existingChunk.chunkPosition);
                }
                else
                {
                    // Do not contain an entry for this chunk. We no longer need this chunk
                    chunksToDestroy.Add(existingChunk);
                }
            }

            // Destroy the existing chunks
            foreach (var chunkToDestroy in chunksToDestroy)
            {
                spawnedChunks.Remove(chunkToDestroy);

                if (chunkToDestroy.gameObject != null)
                {
                    var dungeon = chunkToDestroy.gameObject.GetComponent<Dungeon>();
                    if (dungeon != null)
                    {
                        dungeon.DestroyDungeon();
                    }
                    DungeonUtils.DestroyObject(chunkToDestroy.gameObject);
                }
            }

            // Build the new chunks
            foreach (var chunkToSpawn in chunksToSpawn)
            {
                var dungeon = BuildDungeonChunk(chunkToSpawn);
                var config = dungeon.GetComponent<InfinityDungeonConfig>();
                spawnedChunks.Add(config);
            }
        }

        Vector3 ClampOnBuildAxis(Vector3 p)
        {
            if (!config.BuildAlongX()) p.x = 0;
            if (!config.BuildAlongY()) p.y = 0;
            if (!config.BuildAlongZ()) p.z = 0;
            return p;
        }

        public Dungeon BuildDungeonChunk(Vector3 chunkPosition)
        {
            var dungeonObject = GameObject.Instantiate(chunkDungeonTemplate);
            dungeonObject.isStatic = true;

            if (parentGameObject != null)
            {
                dungeonObject.transform.parent = parentGameObject;
            }

            // Set up the parent for this object
            var sceneProvider = dungeonObject.GetComponent<DungeonSceneProvider>();
            sceneProvider.itemParent = dungeonObject;

            // copy the config
            var config = dungeonObject.GetComponent<InfinityDungeonConfig>();
            CopyDungeonConfig(config);

            // Setup the position for this chunk
            config.chunkPosition = chunkPosition;

            // Setup the position tracker
            var builder = dungeonObject.GetComponent<DungeonBuilder>();
            builder.asyncBuildStartPosition = buildPositionTracker;

            // Copy over the theme files
            var dungeon = dungeonObject.GetComponent<Dungeon>();
            dungeon.dungeonThemes = new List<Graph>(dungeonThemes);

            dungeon.Build();

            return dungeon;
        }

        public void DestroyDungeon()
        {
            foreach (var chunkConfig in spawnedChunks)
            {
                if (chunkConfig == null || chunkConfig.gameObject == null) continue;
                var dungeon = chunkConfig.gameObject.GetComponent<Dungeon>();
                if (dungeon != null)
                {
                    dungeon.DestroyDungeon();
                    DungeonUtils.DestroyObject(dungeon.gameObject);
                }
            }

            spawnedChunks.Clear();
            dungeonBuilt = false;
        }

        public void CopyDungeonConfig(InfinityDungeonConfig targetConfig)
        {
            var sourceConfig = GetComponent<InfinityDungeonConfig>();

            var fields = sourceConfig.GetType().GetFields();
            foreach (var field in fields)
            {
                field.SetValue(targetConfig, field.GetValue(sourceConfig));
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Infinity\InfinityDungeonCameraTracker.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect
{

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Infinity\InfinityDungeonConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    public abstract class InfinityDungeonConfig : DungeonConfig
    {
        [HideInInspector]
        public Vector3 chunkPosition;

        //[HideInInspector]
        public Vector3 chunkSize;
        
        public abstract Vector3 GetLogicalCoord(Vector3 p);
        public abstract bool BuildAlongX();
        public abstract bool BuildAlongY();
        public abstract bool BuildAlongZ();
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Infinity\InfinityDungeonEditorUpdate.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    public class InfinityDungeonEditorUpdate : MonoBehaviour
    {
        public InfinityDungeon infinityDungeon;

        public void EditorUpdate()
        {
            if (infinityDungeon != null)
            {
                infinityDungeon.EditorUpdate();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Landscape\DungeonLandscapeRestorationCache.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Landscape
{
    [System.Serializable]
    public class DLCacheBounds
    {
        [HideInInspector]
        [SerializeField]
        public int x1;

        [HideInInspector]
        [SerializeField]
        public int x2;

        [HideInInspector]
        [SerializeField]
        public int y1;

        [HideInInspector]
        [SerializeField]
        public int y2;
    }

    /// <summary>
    /// Before building a dungeon, we find the bounds of the dungeon and save
    /// the heightmap data within that bounds before we modify the landscape
    /// This way, the next rebuild of dungeon with another layout would first 
    /// restore this data (thereby removing the older layout that was baked in the landscape)
    /// and apply the new layout on the landscape
    /// </summary>
    [System.Serializable]
    public class DungeonLandscapeRestorationCache : ScriptableObject
    {
        [HideInInspector]
        [SerializeField]
        float[] dataHeights;

        [HideInInspector]
        [SerializeField]
        DLCacheBounds boundsHeight = new DLCacheBounds();

        [HideInInspector]
        [SerializeField]
        float[] dataAlphamap;

        [HideInInspector]
        [SerializeField]
        int numAlphaMaps = 0;

        [HideInInspector]
        [SerializeField]
        DLCacheBounds boundsAlpha = new DLCacheBounds();

        [HideInInspector]
        [SerializeField]
        int[] dataDetails;

        [HideInInspector]
        [SerializeField]
        int numDetailMaps = 0;

        [HideInInspector]
        [SerializeField]
        DLCacheBounds boundsDetails = new DLCacheBounds();

        static void SerializeArray(float[,] array, out float[] result)
        {
            int sx = array.GetLength(1);
            int sy = array.GetLength(0);

            result = new float[sx * sy];
            for (int y = 0; y < sy; y++)
            {
                for (int x = 0; x < sx; x++)
                {
                    int idx = y * sx + x;
                    result[idx] = array[y, x];
                }
            }
        }

        static void SerializeArray(float[,,] array, int numAlphaMaps, out float[] result)
        {
            int sx = array.GetLength(1);
            int sy = array.GetLength(0);
            int sm = numAlphaMaps;

            result = new float[sx * sy * sm];
            for (int m = 0; m < sm; m++)
            {
                for (int y = 0; y < sy; y++)
                {
                    for (int x = 0; x < sx; x++)
                    {
                        int idx = (sx * sy) * m + sx * y + x;
                        result[idx] = array[y, x, m];
                    }
                }
            }
        }

        static void DeserializeArray(float[] array, int sx, int sy, out float[,] result)
        {
            result = new float[sy, sx];
            if (array.Length != sx * sy)
            {
                Debug.LogError("Invalid array deserialization");
                return;
            }

            for (int y = 0; y < sy; y++)
            {
                for (int x = 0; x < sx; x++)
                {
                    int idx = y * sx + x;
                    result[y, x] = array[idx];
                }
            }
        }

        static void DeserializeArray(float[] array, int sx, int sy, int sm, int desiredSM, out float[,,] result)
        {
            if (array.Length != sx * sy * sm)
            {
                Debug.LogError("Invalid array deserialization");
                result = new float[0, 0, 0];
                return;
            }

            desiredSM = Mathf.Max(sm, desiredSM);
            result = new float[sy, sx, desiredSM];

            for (int m = 0; m < sm; m++)
            {
                for (int y = 0; y < sy; y++)
                {
                    for (int x = 0; x < sx; x++)
                    {
                        int idx = (sx * sy) * m + sx * y + x;
                        result[y, x, m] = array[idx];
                    }
                }
            }
        }

        public void SaveLandscapeData(Terrain terrain, Rect worldBounds)
        {
            var data = terrain.terrainData;

            // Save the heights
            {
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldBounds.x, worldBounds.y, out boundsHeight.x1, out boundsHeight.y1);
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldBounds.x + worldBounds.width, worldBounds.y + worldBounds.height, out boundsHeight.x2, out boundsHeight.y2);

                int cacheWidth = boundsHeight.x2 - boundsHeight.x1;
                int cacheHeight = boundsHeight.y2 - boundsHeight.y1;
                float[,] heights = data.GetHeights(boundsHeight.x1, boundsHeight.y1, cacheWidth, cacheHeight);
                SerializeArray(heights, out dataHeights);
            }

            // Save the alpha maps
            {
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldBounds.x, worldBounds.y, out boundsAlpha.x1, out boundsAlpha.y1, RasterizerTextureSpace.AlphaMap);
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldBounds.x + worldBounds.width, worldBounds.y + worldBounds.height, out boundsAlpha.x2, out boundsAlpha.y2, RasterizerTextureSpace.AlphaMap);

                int cacheWidth = boundsAlpha.x2 - boundsAlpha.x1;
                int cacheHeight = boundsAlpha.y2 - boundsAlpha.y1;
                float[,,] maps = data.GetAlphamaps(boundsAlpha.x1, boundsAlpha.y1, cacheWidth, cacheHeight);
                numAlphaMaps = data.terrainLayers.Length;

                SerializeArray(maps, numAlphaMaps, out dataAlphamap);
            }

            // Save the details map (foliage)
            {
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldBounds.x, worldBounds.y, out boundsDetails.x1, out boundsDetails.y1, RasterizerTextureSpace.DetailMap);
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldBounds.x + worldBounds.width, worldBounds.y + worldBounds.height, out boundsDetails.x2, out boundsDetails.y2, RasterizerTextureSpace.DetailMap);

                int cacheWidth = boundsDetails.x2 - boundsDetails.x1;
                int cacheHeight = boundsDetails.y2 - boundsDetails.y1;

                numDetailMaps = data.detailPrototypes.Length;
                int arraySize = numDetailMaps * cacheWidth * cacheHeight;
                dataDetails = new int[arraySize];

                int index = 0;
                for (int d = 0; d < numDetailMaps; d++)
                {
                    int[,] map = data.GetDetailLayer(boundsDetails.x1, boundsDetails.y1, cacheWidth, cacheHeight, d);
                    for (int y = 0; y < cacheHeight; y++)
                    {
                        for (int x = 0; x < cacheWidth; x++)
                        {
                            dataDetails[index] = map[y, x];
                            index++;
                        }
                    }
                }
            }
        }

        public void RestoreLandscapeData(Terrain terrain, Rect worldBounds)
        {
            if (terrain == null || terrain.terrainData == null) return;

            var data = terrain.terrainData;

            // Restore the heightmap
            if (dataHeights != null)
            {
                float[,] heights;
                DeserializeArray(dataHeights, boundsHeight.x2 - boundsHeight.x1, boundsHeight.y2 - boundsHeight.y1, out heights);
                data.SetHeights(boundsHeight.x1, boundsHeight.y1, heights);
            }

            // Restore the alpha maps (paint data)
            if (dataAlphamap != null)
            {
                int w = boundsAlpha.x2 - boundsAlpha.x1;
                int h = boundsAlpha.y2 - boundsAlpha.y1;
                int numLayers = terrain.terrainData.terrainLayers.Length;

                float[,,] maps;
                DeserializeArray(dataAlphamap, w, h, numAlphaMaps, numLayers, out maps);
                if (data.alphamapLayers == maps.GetLength(2))
                {
                    data.SetAlphamaps(boundsAlpha.x1, boundsAlpha.y1, maps);
                }
                else
                {
                    Debug.LogError("Cannot restore old landscape layout. The landscape settings have since been changed");
                }
            }

            // Restore the details map (foliage)
            {
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldBounds.x, worldBounds.y, out boundsDetails.x1, out boundsDetails.y1, RasterizerTextureSpace.DetailMap);
                LandscapeDataRasterizer.WorldToTerrainCoord(terrain, worldBounds.x + worldBounds.width, worldBounds.y + worldBounds.height, out boundsDetails.x2, out boundsDetails.y2, RasterizerTextureSpace.DetailMap);

                int cacheWidth = boundsDetails.x2 - boundsDetails.x1;
                int cacheHeight = boundsDetails.y2 - boundsDetails.y1;

                int index = 0;
                for (int d = 0; d < numDetailMaps; d++)
                {
                    int[,] map = new int[cacheHeight, cacheWidth];
                    for (int y = 0; y < cacheHeight; y++)
                    {
                        for (int x = 0; x < cacheWidth; x++)
                        {
                            map[y, x] = dataDetails[index];
                            index++;
                        }
                    }
                    data.SetDetailLayer(boundsDetails.x1, boundsDetails.y1, d, map);
                }
            }
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Landscape\LandscapeTransformerBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Landscape
{
    public class LandscapeTransformerBase : DungeonEventListener
    {
        public Terrain terrain;

        [HideInInspector]
        [SerializeField]
        bool cachedTerrainDataRestored = false;

        [HideInInspector]
        [SerializeField]
        Rect worldBounds;

        public DungeonLandscapeRestorationCache landscapeRestorationCache;

        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            if (!landscapeRestorationCache)
            {
                Debug.LogError("Landscape restoration cache asset is not specified. Landscape generation will not proceed");
                return;
            }

            // First restore the landscape before baking the new dungeon layout (this removes the old layout)
            if (!cachedTerrainDataRestored)
            {
                // Restore the data
                RestoreLandscapeData(model);
                cachedTerrainDataRestored = true;
            }

            // Save the new layout on the cache asset
            SaveLandscapeData(model);

            // Bake the new dungeon layout on to the terrain
            BuildTerrain(model);
            cachedTerrainDataRestored = false;
        }

        public override void OnDungeonDestroyed(Dungeon dungeon) {
            // Restore the landscape data (by removing the baked dungeon) when the dungeon is destroyed
            RestoreLandscapeData(dungeon.ActiveModel);
            cachedTerrainDataRestored = true;
        }

        protected virtual void BuildTerrain(DungeonModel model) { }
        protected virtual Rect GetDungeonBounds(DungeonModel model) { return Rect.zero; }

        void SaveLandscapeData(DungeonModel model)
        {
            if (landscapeRestorationCache)
            {
                worldBounds = GetDungeonBounds(model);
                landscapeRestorationCache.SaveLandscapeData(terrain, worldBounds);
            }
        }

        void RestoreLandscapeData(DungeonModel model)
        {
            if (landscapeRestorationCache)
            {
                landscapeRestorationCache.RestoreLandscapeData(terrain, worldBounds);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\LevelStreaming\DungeonItemGroup.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.LevelStreaming
{
    public class DungeonItemGroup : DungeonEventListener
    {
        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            var dungeonObjects = DungeonUtils.GetDungeonObjects(dungeon);

            // Group the dungeon items by cell ids
            Dictionary<int, List<GameObject>> gameObjectsByCellId = new Dictionary<int, List<GameObject>>();
            foreach (var dungeonObject in dungeonObjects)
            {
                var data = dungeonObject.GetComponent<DungeonSceneProviderData>();
                var cellId = data.userData;
                if (cellId == -1) continue;

                if (!gameObjectsByCellId.ContainsKey(cellId))
                {
                    gameObjectsByCellId.Add(cellId, new List<GameObject>());
                }

                gameObjectsByCellId[cellId].Add(dungeonObject);
            }

            // Create new prefabs and group them under it
            foreach (var cellId in gameObjectsByCellId.Keys)
            {
                var cellItems = gameObjectsByCellId[cellId];
                var groupName = "Group_Cell_" + cellId;
                GroupItems(cellItems.ToArray(), groupName, dungeon, cellId);
            }

            // Destroy the old group objects
            DestroyOldGroupObjects(dungeon);

            // Subclasses will override this and perform builder specific grouping
        }

        /// <param name="model">The dungeon model</param>
        public override void OnDungeonDestroyed(Dungeon dungeon)
        {
            DestroyOldGroupObjects(dungeon);
        }

        protected DungeonItemGroupInfo GroupItems(GameObject[] items, string groupName, Dungeon dungeon, int groupId)
        {
            if (items.Length == 0) return null;
            var position = items[0].transform.position;
            for (int i = 1; i < items.Length; i++)
            {
                position += items[i].transform.position;
            }

            position /= items.Length;

            var groupObject = new GameObject(groupName);
            groupObject.transform.position = position;

            // Re-parent all the cell items to this group object
            foreach (var cellItem in items)
            {
                cellItem.transform.SetParent(groupObject.transform, true);
            }

            var groupInfo = groupObject.AddComponent<DungeonItemGroupInfo>();
            groupInfo.dungeon = dungeon;
            groupInfo.groupId = groupId;

            GameObject dungeonItemParent = null;
            var sceneProvider = dungeon.GetComponent<DungeonSceneProvider>();
            if (sceneProvider != null)
            {
                dungeonItemParent = sceneProvider.itemParent;
            }

            groupInfo.transform.SetParent(dungeonItemParent.transform, true);

            return groupInfo;
        }

        void DestroyOldGroupObjects(Dungeon dungeon)
        {
            var groupInfoArray = GameObject.FindObjectsOfType<DungeonItemGroupInfo>();

            foreach (var groupInfo in groupInfoArray)
            {
                if (groupInfo.dungeon == dungeon)
                {
                    var go = groupInfo.gameObject;
                    if (go.transform.childCount == 0)
                    {
                        EditorDestroyObject(go);
                    }
                }
            }
        }

        protected void EditorDestroyObject(Object obj)
        {
            if (Application.isPlaying)
            {
                Destroy(obj);
            }
            else
            {
                DestroyImmediate(obj);
            }
        }

    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\LevelStreaming\DungeonItemGroupInfo.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.LevelStreaming
{

    /// <summary>
    /// Meta-data added to group game objects. A group contains all the meshes that belong to a room / corridor
    /// </summary>
    public class DungeonItemGroupInfo : MonoBehaviour
    {
        public Dungeon dungeon;

        public int groupId;

        public string groupType;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\GridMarkerGenRuleUserScript.cs:
 using DungeonArchitect.MarkerGenerator.Rule.Grid;
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Inherit from this class to attach custom 
    /// </summary>
    public class GridMarkerGenRuleUserScript : ScriptableObject
    {
        public struct ValidateSettings
        {
            public Vector3 Position;
            public Vector2Int Coord;
            public GridMarkerGenRuleType CoordType;
            public Matrix4x4 DungeonTransform;
            public DungeonBuilder Builder;
            public DungeonModel Model;
            public DungeonConfig Config;
            public DungeonQuery Query;
        }

        public virtual bool Validate(ValidateSettings settings)
        {
            return true;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\MarkerGeneratorAsset.cs:
 using System;
using UnityEngine;
using UnityEngine.Serialization;

namespace DungeonArchitect.MarkerGenerator
{
    [Serializable]
    public enum MarkerGeneratorLayoutType
    {
        Grid,
    }
    
    [System.Serializable]
    public class MarkerGeneratorAsset : ScriptableObject
    {
        [FormerlySerializedAs("layers")]
        public MarkerGenPattern[] patterns = Array.Empty<MarkerGenPattern>();

        public MarkerGeneratorLayoutType layoutType = MarkerGeneratorLayoutType.Grid;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\MarkerGenPattern.cs:
 using System;
using DungeonArchitect.MarkerGenerator.Rule;
using UnityEngine;
using UnityEngine.Serialization;

namespace DungeonArchitect.MarkerGenerator
{
    public class MarkerGenPattern : ScriptableObject
    {
        public string patternName;
        
        [Tooltip(@"The probability of running the patter matcher on the scene. Set to 1.0 to run it everywhere (100% of the time), 0.5 to insert this randomly 50% of the time, 0.0 to disable it")]
        public float probability = 1.0f;
	
        [Tooltip(@"Rotate the pattern as many times as needed to fit in all directions (e.g. rotate the pattern in 0, 90, 180 and 270 degrees and try to fit there. You might want to disable this if your fitting needs to happen in a fixed direction, e.g. a top down diablo-like game where you'd want to consider the camera angle before placing the assets")]
        public bool rotateToFit = true;

        [Tooltip(@"If disabled, the system tries to match the pattern from left to right, top to bottom in the generated level, which would create a ordered fitting pattern (e.g. a 2x1 tile would all face the same way). Enable this to create a more organic randomized fitting order")]
        public bool randomizeFittingOrder = true;

        [Tooltip(@"As the pattern is matched on a layer, cell by cell, some cells will be skipped if the rule inserts a marker which might overlap with another marker that was inserted same layer previously (HintWillInsertAssetHere flag on the rule block). Enable this to allow overlaps")]
        public bool allowInsertionOverlaps = false;
        
        [HideInInspector]
        public MarkerGenRule[] rules = Array.Empty<MarkerGenRule>();
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\MarkerGenProcessor.cs:
 using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Processor
{
    
    public interface IMarkerGenProcessor
    {
        bool Process(MarkerGenPattern pattern, PropSocket[] markers, System.Random random, out PropSocket[] newMarkers);
        void Release();
    }
    
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MeshMerge\MeshMerger.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect;
using DungeonArchitect.Utils;

namespace DungeonArchitect
{
    public class MeshMerger : DungeonEventListener
    {
        class MergeMeshItem
        {
            public Mesh mesh;
            public Matrix4x4 transform;
        }

        public bool mergeMeshes = true;
        public float mergePatchSize = 60;
        public Transform mergedMeshParent;

        private int GetMaterialHash(Material[] materials)
        {
            if (materials == null) return 0;
            var builder = new System.Text.StringBuilder();
            foreach (var material in materials)
            {
                builder.Append(material.GetHashCode().ToString());
                builder.Append("_");
            }

            return builder.ToString().GetHashCode();
        }

        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            if (!mergeMeshes)
            {
                return;
            }

            mergePatchSize = Mathf.Max(mergePatchSize, 20);

            var sceneProvider = GetComponentInParent<DungeonSceneProvider>();
            var parentToMerge = sceneProvider.itemParent;

            var itemsByMaterialHash = new Dictionary<int, List<MergeMeshItem>>();
            var hashToMaterials = new Dictionary<int, Material[]>();

            var meshFilters = parentToMerge.GetComponentsInChildren<MeshFilter>();
            foreach (var meshFilter in meshFilters)
            {
                var gameObject = meshFilter.gameObject;
                if (!gameObject.isStatic)
                {
                    continue;
                }

                var renderer = gameObject.GetComponent<MeshRenderer>();

                if (renderer != null && renderer.sharedMaterials != null)
                {
                    var materialHash = GetMaterialHash(renderer.sharedMaterials);
                    if (!itemsByMaterialHash.ContainsKey(materialHash))
                    {
                        itemsByMaterialHash.Add(materialHash, new List<MergeMeshItem>());
                        hashToMaterials.Add(materialHash, renderer.sharedMaterials);
                    }

                    var item = new MergeMeshItem();
                    item.mesh = meshFilter.sharedMesh;
                    item.transform = Matrix4x4.TRS(gameObject.transform.position, gameObject.transform.rotation, gameObject.transform.localScale);
                    itemsByMaterialHash[materialHash].Add(item);
                }

                if (Application.isPlaying)
                {
                    GameObject.Destroy(renderer);
                    GameObject.Destroy(meshFilter);
                }
                else
                {
                    GameObject.DestroyImmediate(renderer);
                    GameObject.DestroyImmediate(meshFilter);
                }

            }

            // Clear out the dungeon node Id so they are not reused
            var sceneItemInfoList = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
            foreach (var sceneItemInfo in sceneItemInfoList)
            {
                if (sceneItemInfo.dungeon == dungeon)
                {
                    sceneItemInfo.NodeId = "";
                }
            }

            foreach (var entry in itemsByMaterialHash)
            {
                var materialHash = entry.Key;
                if (!hashToMaterials.ContainsKey(materialHash))
                {
                    continue;
                }

                var materials = hashToMaterials[materialHash];
                var allItems = entry.Value;
                var patchItemMap = SpatialPartitionByPatchSize(allItems);
                foreach (var patchItemEntry in patchItemMap)
                {
                    var allPatchItems = patchItemEntry.Value;
                    var patchItemsWithinLimit = SplitPerVertexLimit(allPatchItems, 65532);
                    foreach (var patchItems in patchItemsWithinLimit)
                    {
                        var mergedMesh = CreateMergedMesh(patchItems);
                        var mergedHost = new GameObject();
                        mergedHost.isStatic = true;
                        var sceneData = mergedHost.AddComponent<DungeonSceneProviderData>();
                        sceneData.affectsNavigation = false;
                        sceneData.dungeon = dungeon;
                        sceneData.NodeId = System.Guid.NewGuid().ToString();

                        var mergedFilter = mergedHost.AddComponent<MeshFilter>();
                        mergedFilter.sharedMesh = mergedMesh;

                        var mergedRenderer = mergedHost.AddComponent<MeshRenderer>();
                        mergedRenderer.sharedMaterials = materials;

                        if (mergedMeshParent != null)
                        {
                            mergedHost.transform.parent = mergedMeshParent;
                        }
                    }
                }
            }
        }

        List<MergeMeshItem[]> SplitPerVertexLimit(List<MergeMeshItem> patchItems, int vertexLimit)
        {
            var result = new List<MergeMeshItem[]>();
            var currentList = new List<MergeMeshItem>();
            int vertexCount = 0;
            foreach (var item in patchItems)
            {
                if (item == null || item.mesh == null) continue;

                if (vertexCount + item.mesh.vertexCount >= vertexLimit)
                {
                    if (currentList.Count > 0)
                    {
                        result.Add(currentList.ToArray());
                    }

                    currentList = new List<MergeMeshItem>();
                    vertexCount = 0;
                }

                currentList.Add(item);
                vertexCount += item.mesh.vertexCount;
            }

            if (currentList.Count > 0)
            {
                result.Add(currentList.ToArray());
            }

            return result;
        }

        Dictionary<IntVector2, List<MergeMeshItem>> SpatialPartitionByPatchSize(List<MergeMeshItem> items)
        {
            var patches = new Dictionary<IntVector2, List<MergeMeshItem>>();
            foreach (var item in items)
            {
                var position = Matrix.GetTranslation(ref item.transform);
                var patchIndex = new IntVector2(
                    Mathf.FloorToInt(position.x / mergePatchSize),
                    Mathf.FloorToInt(position.z / mergePatchSize));

                if (!patches.ContainsKey(patchIndex))
                {
                    patches.Add(patchIndex, new List<MergeMeshItem>());
                }

                patches[patchIndex].Add(item);
            }

            return patches;
        }

        static Mesh CreateMergedMesh(MergeMeshItem[] items)
        {
            var vertices = new List<Vector3>();
            var uv = new List<Vector2>();
            var triangles = new List<int>();

            int baseIndex = 0;
            foreach (var item in items)
            {
                foreach (var localVertex in item.mesh.vertices)
                {
                    var worldVertex = item.transform.MultiplyPoint(localVertex);
                    vertices.Add(worldVertex);
                }

                foreach (var index in item.mesh.triangles)
                {
                    triangles.Add(baseIndex + index);
                }

                baseIndex += item.mesh.vertices.Length;

                uv.AddRange(item.mesh.uv);
            }

            var mesh = new Mesh();
            mesh.SetVertices(vertices);
            mesh.SetUVs(0, uv);
            mesh.SetTriangles(triangles.ToArray(), 0);
            mesh.RecalculateNormals();
            return mesh;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MiniMap\DungeonMiniMap.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.MiniMaps
{
    public abstract class DungeonMiniMap : MonoBehaviour
    {
        public float updateFrequency = 0.05f;
        public bool enableFogOfWar = false;
        public RenderTexture minimapTexture;
        public Shader compositeShader;

        IntVector2 textureSize;
        Texture staticImage = null;
        Texture fogOfWar = null;
        Texture overlayImage = null;
        float timeSinceLastUpdate = 0;
        bool initialized = false;

        protected Vector4 uvTransform;
        protected abstract bool SupportsFogOfWar { get; }
        protected abstract void CreateTextures(IntVector2 desiredSize, out Texture staticImage, out Texture fogOfWar, out Texture overlayImage, out IntVector2 targetTextureSize);

        protected abstract void UpdateStaticTexture(Texture texture);
        protected abstract void UpdateFogOfWarTexture(Texture texture);
        protected abstract void UpdateOverlayTexture(Texture texture);

        public void Initialize()
        {
            if (minimapTexture != null)
            {
                IntVector2 desiredSize = new IntVector2(minimapTexture.width, minimapTexture.height);
                CreateTextures(desiredSize, out staticImage, out fogOfWar, out overlayImage, out textureSize);
                timeSinceLastUpdate = 0;

                UpdateStaticTexture(staticImage);
                UpdateDynamicTextures();
                RenderFinalImage();
                uvTransform = GetCompositeUVTransform();
                initialized = true;
            }
        }

        void UpdateDynamicTextures()
        {
            UpdateOverlayTexture(overlayImage);
            if (enableFogOfWar)
            {
                UpdateFogOfWarTexture(fogOfWar);
            }
        }

        private bool RequiresUpdate()
        {
            if (!initialized) return false;

            var currentTime = Time.time;
            return (currentTime - timeSinceLastUpdate > updateFrequency);
        }

        private void Update()
        {
            if (RequiresUpdate())
            {
                UpdateDynamicTextures();
                RenderFinalImage();
                timeSinceLastUpdate = Time.time;
            }
        }

        Vector4 GetCompositeUVTransform()
        {
            var maxSize = (float)Mathf.Max(textureSize.x, textureSize.y);
            var uvw = textureSize.x / maxSize;
            var uvh = textureSize.y / maxSize;
            var uvx = (1.0f - uvw) * 0.5f;
            var uvy = (1.0f - uvh) * 0.5f;
            return new Vector4(uvx, uvy, uvw, uvh);
        }

        void RenderFinalImage()
        {
            if (staticImage == null || minimapTexture == null) return;

            var oldRTT = RenderTexture.active;
            RenderTexture.active = minimapTexture;

            GL.PushMatrix();
            GL.LoadOrtho();
            GL.Clear(true, true, new Color(0, 0, 0, 0), 0);

            var material = new Material(compositeShader);
            material.SetTexture("_LayoutTex", staticImage);
            material.SetTexture("_OverlayTex", overlayImage);
            material.SetTexture("_FowTex", fogOfWar);
            material.SetVector("_UVTransform", uvTransform);
            material.SetInt("_FowEnabled", enableFogOfWar ? 1 : 0);
            material.SetPass(0);

            GL.Begin(GL.QUADS);

            GL.Color(Color.white);
            GL.TexCoord2(0, 0);
            GL.Vertex3(0, 0, 0);

            GL.Color(Color.white);
            GL.TexCoord2(0, 1);
            GL.Vertex3(0, 1, 0);

            GL.Color(Color.white);
            GL.TexCoord2(1, 1);
            GL.Vertex3(1, 1, 0);

            GL.Color(Color.white);
            GL.TexCoord2(1, 0);
            GL.Vertex3(1, 0, 0);

            GL.End();
            GL.PopMatrix();

            RenderTexture.active = oldRTT;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Navigation\DungeonNavMeshSourceCollector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;


namespace DungeonArchitect
{
    public class DungeonNavMeshSourceCollector
    {

        static NavMeshBuildSource CreateMeshSource(Mesh mesh, Matrix4x4 transform)
        {
            var source = new NavMeshBuildSource();
            source.shape = NavMeshBuildSourceShape.Mesh;
            source.sourceObject = mesh;
            source.transform = transform;
            source.area = 0;
            return source;
        }

        public static void CollectSources(Dungeon dungeon, DungeonNavMeshSourceType MeshSourceType, ref List<NavMeshBuildSource> sources) 
        {
            sources.Clear();

            if (dungeon == null) return;
            
            var components = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
            foreach (var component in components)
            {
                if (component.dungeon == dungeon && component.affectsNavigation)
                {
                    var gameObject = component.gameObject;
                    if (MeshSourceType == DungeonNavMeshSourceType.Collision)
                    {
                        var colliders = gameObject.GetComponentsInChildren<Collider>();
                        foreach (var collider in colliders)
                        {
                            if (collider is MeshCollider)
                            {
                                var meshCollider = collider as MeshCollider;
                                NavMeshBuildSource source = CreateMeshSource(meshCollider.sharedMesh, meshCollider.transform.localToWorldMatrix);
                                sources.Add(source);
                            }
                            else
                            {
                                var source = new NavMeshBuildSource();
                                source.component = collider;
                                source.transform = collider.transform.localToWorldMatrix;
                                if (collider is BoxCollider) source.shape = NavMeshBuildSourceShape.Box;
                                else if (collider is SphereCollider) source.shape = NavMeshBuildSourceShape.Sphere;
                                else if (collider is CapsuleCollider) source.shape = NavMeshBuildSourceShape.Capsule;
                                sources.Add(source);
                            }
                        }

                    }
                    else if (MeshSourceType == DungeonNavMeshSourceType.MeshData)
                    {
                        var meshFilters = gameObject.GetComponentsInChildren<MeshFilter>();
                        foreach (var meshFilter in meshFilters)
                        {
                            if (meshFilter == null || meshFilter.sharedMesh == null) continue;
                            NavMeshBuildSource source = CreateMeshSource(meshFilter.sharedMesh, meshFilter.transform.localToWorldMatrix);
                            sources.Add(source);
                        }
                    }
                }
            }

        }

    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Navigation\DungeonRuntimeNavigation.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using NavMeshBuilder = UnityEngine.AI.NavMeshBuilder;

namespace DungeonArchitect
{
    [System.Serializable]
    public enum DungeonNavMeshSourceType
    {
        MeshData,
        Collision
    }

    public class DungeonRuntimeNavigation : MonoBehaviour
    {
        /// <summary>
        /// Should dynamic navigation be created during runtime (For NPC AI)
        /// </summary>
        public bool enableRuntimeNavigation = false;

        public Vector3 boundsPadding = Vector3.zero;

        public bool bakeTerrain = true;
        public Terrain terrain;

        DungeonNavMeshSourceType meshSourceType = DungeonNavMeshSourceType.MeshData;

        // The size of the build bounds
        Bounds dungeonBounds;

        NavMeshData m_NavMesh;
        //AsyncOperation m_Operation;
        NavMeshDataInstance m_Instance;
        List<NavMeshBuildSource> meshSources = new List<NavMeshBuildSource>();

        public void BuildNavMesh()
        {
            DestroyNavMesh();

            if (enableRuntimeNavigation && Application.isPlaying)
            {
                m_NavMesh = new NavMeshData();
                m_Instance = NavMesh.AddNavMeshData(m_NavMesh);
                var dungeon = GetComponent<Dungeon>();
                if (!dungeon)
                {
                    Debug.LogError("DungeonRuntimeNavigation should be attached to a Dungeon prefab. Missing Dungeon Script in the game object");
                    return;
                }

                dungeonBounds = DungeonUtils.GetDungeonBounds(dungeon);
                dungeonBounds.size = dungeonBounds.size + boundsPadding;

                UpdateNavMesh(false);
            }
        }

        public void DestroyNavMesh()
        {
            // Unload navmesh and clear handle
            m_Instance.Remove();
            m_NavMesh = null;
            meshSources.Clear();

            dungeonBounds = new Bounds();
        }
        

        void CollectMeshSources() {
            meshSources.Clear();

            var dungeon = GetComponent<Dungeon>();
            if (!dungeon)
            {
                Debug.LogError("DungeonRuntimeNavigation should be attached to a Dungeon prefab. Missing Dungeon Script in the game object");
                return;
            }

            DungeonNavMeshSourceCollector.CollectSources(dungeon, meshSourceType, ref meshSources);

            if (bakeTerrain && terrain != null)
            {
                var source = new NavMeshBuildSource();
                source.shape = NavMeshBuildSourceShape.Terrain;
                source.sourceObject = terrain.terrainData;
                source.transform = terrain.transform.localToWorldMatrix;
                source.area = 0;
                meshSources.Add(source);
            }
        }

        void UpdateNavMesh(bool asyncUpdate = false)
        {
            CollectMeshSources();


            //NavMeshSourceTag.Collect(ref m_Sources);
            var defaultBuildSettings = NavMesh.GetSettingsByID(0);

            if (asyncUpdate)
            {
                /*m_Operation = */ NavMeshBuilder.UpdateNavMeshDataAsync(m_NavMesh, defaultBuildSettings, meshSources, dungeonBounds);
            }
            else
            {
                NavMeshBuilder.UpdateNavMeshData(m_NavMesh, defaultBuildSettings, meshSources, dungeonBounds);
            }
        }
        
        void OnDrawGizmosSelected()
        {
            if (!enableRuntimeNavigation) return;

            if (m_NavMesh)
            {
                Gizmos.color = Color.green;
                Gizmos.DrawWireCube(m_NavMesh.sourceBounds.center, m_NavMesh.sourceBounds.size);
            }
            
            Gizmos.color = Color.green;
            var center = dungeonBounds.center;
            var size = dungeonBounds.size;
            Gizmos.DrawWireCube(center, size);
        }


        void OnDisable()
        {
            DestroyNavMesh();
        }

    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\RoadNetworks\RoadGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.RoadNetworks
{
    //[System.Serializable]
    public class RoadGraphEdge
    {
        //[SerializeField]
        public int edgeId;

        //[SerializeField]
        public int ownerNodeId;

        //[SerializeField]
        public int otherNodeId;

        //[SerializeField]
        public float thickness;

        //[SerializeField]
        public float angleToXAxis;
        
    }

    //[System.Serializable]
    public class RoadGraphNode
    {
        //[SerializeField]
        public int nodeId;

        //[SerializeField]
        public Vector3 position;

        // The edges will be sorted based on their angle
        //[SerializeField]
        public RoadGraphEdge[] adjacentEdges;
    }

    //[System.Serializable]
    public class RoadGraph
    {
        //[SerializeField]
        public RoadGraphNode[] nodes = new RoadGraphNode[0];
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\RoadNetworks\RoadGraphBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.RoadNetworks
{
    public class RoadGraphBuilderSettings
    {
        public float interNodeDistance = 10;
    }


    public class RoadGraphBuilder
    {
        public RoadGraphBuilder()
        {
            this.settings = new RoadGraphBuilderSettings();
        }

        public RoadGraphBuilder(RoadGraphBuilderSettings settings)
        {
            this.settings = settings;
        }

        public void Initialize(RoadGraph graph)
        {
            nodes.Clear();

            // Create the node instances
            foreach (var nodeInfo in graph.nodes)
            {
                var node = new RoadGraphBuildNode(nodeInfo);
                nodes.Add(node.nodeId, node);
                _nodeIdCounter = Mathf.Max(_nodeIdCounter, node.nodeId);
            }

            // Generate the node adjacency list
            foreach (var nodeInfo in graph.nodes)
            {
                var node = nodes[nodeInfo.nodeId];
                foreach (var edge in nodeInfo.adjacentEdges)
                {
                    var adjacentNode = nodes[edge.otherNodeId];
                    node.connectedNodes.Add(adjacentNode);
                }
            }
        }

        RoadGraphBuildNode FindNearestNode(Vector3 position, float searchRadius)
        {
            // TODO: Optimize me with a spatial grid
            RoadGraphBuildNode bestMatch = null;
            float bestDistanceSq = float.MaxValue;
            foreach (var node in nodes.Values)
            {
                var distanceSq = (node.position - position).sqrMagnitude;
                if (distanceSq < bestDistanceSq)
                {
                    bestMatch = node;
                    bestDistanceSq = distanceSq;
                }
            }

            return bestMatch;
        }

        public void CreateLine(Vector3 start, Vector3 end, float thickness)
        {
            float searchDistance = settings.interNodeDistance * 2;
            var startNode = FindNearestNode(start, searchDistance);
            var endNode = FindNearestNode(end, searchDistance);

            if (startNode == null)
            {
                startNode = CreateNode(start);
            }
            if (endNode == null)
            {
                endNode = CreateNode(end);
            }

            var lineLength = (endNode.position - startNode.position).magnitude;
            int numSegments = Mathf.RoundToInt(lineLength / settings.interNodeDistance);
            numSegments = Mathf.Max(numSegments, 1);
            var segmentLength = lineLength / numSegments;

            // we want the start / end positions to match the node positions
            startNode.position = start;
            endNode.position = end;

            var direction = (end - start).normalized;
            var previousNode = startNode;
            for (int i = 1; i < numSegments; i++)
            {
                var position = start + direction * segmentLength * i;
                var segmentNode = CreateNode(position);
                ConnectNodes(previousNode, segmentNode, thickness);
                previousNode = segmentNode;
            }
            // Connect the last node
            ConnectNodes(previousNode, endNode, thickness);
        }

        public void CreateCircle(Vector3 center, float radius, float thickness)
        {
            float circumference = 2 * Mathf.PI * radius;
            if (settings.interNodeDistance <= 0)
            {
                settings.interNodeDistance = 10;
            }
            int numSegments = Mathf.RoundToInt(circumference / settings.interNodeDistance);

            RoadGraphBuildNode firstNode = null;
            RoadGraphBuildNode previousNode = null;
            for (int i = 0; i < numSegments; i++)
            {
                float angle = i / (float)numSegments * (2 * Mathf.PI);
                var offset = Vector3.zero;
                offset.x = Mathf.Cos(angle) * radius;
                offset.z = Mathf.Sin(angle) * radius;
                var position = center + offset;
                var node = CreateNode(position);
                if (i == 0)
                {
                    firstNode = node;
                }
                else
                {
                    ConnectNodes(previousNode, node, thickness);
                }
                previousNode = node;
            }

            // Connect the last node with the first node
            ConnectNodes(previousNode, firstNode, thickness);
        }

        public RoadGraph BakeRoadGraph()
        {
            return RoadGraphBuilderUtils.BakeRoadGraph(nodes.Values);
        }

        public RoadGraphBuildNode CreateNode(Vector3 position)
        {
            int nodeId = ++_nodeIdCounter;
            var node = new RoadGraphBuildNode(nodeId, position);
            nodes.Add(node.nodeId, node);
            return node;
        }

        public void ConnectNodes(RoadGraphBuildNode a, RoadGraphBuildNode b, float thickness)
        {
            if (!a.connectedNodes.Contains(b))
            {
                a.connectedNodes.Add(b);
                a.edgeThickness.Add(thickness);
            }

            if (!b.connectedNodes.Contains(a))
            {
                b.connectedNodes.Add(a);
                b.edgeThickness.Add(thickness);
            }
        }

        RoadGraphBuilderSettings settings;
        Dictionary<int, RoadGraphBuildNode> nodes = new Dictionary<int, RoadGraphBuildNode>();
        int _nodeIdCounter = 0;
    }


    // This node structure contains more data for easier and faster graph traversal, as opposed to the serializable RoadGraphNode structure
    public class RoadGraphBuildNode
    {
        public RoadGraphBuildNode(int nodeId, Vector3 position)
        {
            this.nodeId = nodeId;
            this.position = position;
        }

        public RoadGraphBuildNode(RoadGraphNode graphNode)
        {
            nodeId = graphNode.nodeId;
            position = graphNode.position;
        }


        public int nodeId;
        public Vector3 position;
        public List<RoadGraphBuildNode> connectedNodes = new List<RoadGraphBuildNode>();
        public List<float> edgeThickness = new List<float>();
    }



    class RoadGraphBuilderUtils
    {
        public static RoadGraph BakeRoadGraph(IEnumerable<RoadGraphBuildNode> buildNodes)
        {
            var bakedNodes = new List<RoadGraphNode>();
            int _edgeIdCounter = 0;

            foreach (var node in buildNodes)
            {
                var bakedNode = new RoadGraphNode();
                bakedNode.nodeId = node.nodeId;
                bakedNode.position = node.position;

                var edges = new List<RoadGraphEdge>();
                for (int i = 0; i < node.connectedNodes.Count; i++)
                {
                    var connectedNode = node.connectedNodes[i];
                    var edgeThickness = node.edgeThickness[i];
                    var edge = new RoadGraphEdge();
                    edge.edgeId = ++_edgeIdCounter;
                    edge.ownerNodeId = node.nodeId;
                    edge.otherNodeId = connectedNode.nodeId;
                    edge.thickness = edgeThickness;

                    // Find the dot product with the x axis
                    Vector3 direction = (connectedNode.position - node.position).normalized;
                    var dot = Vector3.Dot(new Vector3(1, 0, 0), direction);
                    float angle = Mathf.Acos(dot);
                    if (direction.z < 0)
                    {
                        angle = 2 * Mathf.PI - angle;
                    }

                    edge.angleToXAxis = angle;

                    edges.Add(edge);
                }

                bakedNode.adjacentEdges = edges.ToArray();
                System.Array.Sort(bakedNode.adjacentEdges, SortEdgesByAngle);
                bakedNodes.Add(bakedNode);
            }

            var graph = new RoadGraph();
            graph.nodes = bakedNodes.ToArray();
            return graph;
        }

        private static int SortEdgesByAngle(RoadGraphEdge a, RoadGraphEdge b)
        {
            if (a.angleToXAxis == b.angleToXAxis) return 0;
            return a.angleToXAxis < b.angleToXAxis ? -1 : 1;
        }

    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\RoadNetworks\RoadLayoutBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.RoadNetworks
{
    public delegate void RoadBlockLayoutBuiltDelegate(ref Vector3[] layout);

    public class RoadLayoutBuilder
    {
        public event RoadBlockLayoutBuiltDelegate RoadBlockLayoutBuilt;

        Dictionary<int, RoadGraphNode> graphNodes = new Dictionary<int, RoadGraphNode>();
        MeshFilter meshFilter;
        public RoadLayoutBuilder(RoadGraph roadGraph, MeshFilter meshFilter)
        {
            this.meshFilter = meshFilter;
            meshFilter.mesh = new Mesh();
            
            foreach (var node in roadGraph.nodes)
            {
                graphNodes.Add(node.nodeId, node);
            }
        }

        void GenerateBoundaryMesh(RoadGraphEdge[] edges, Vector3[] boundaryPoints, List<Vector3> vertices, List<Vector2> uv)
        {
            for (int i = 0; i < edges.Length; i++)
            {
                var nextIndex = (i + 1) % edges.Length;
                var edge0 = edges[i];
                var edge1 = edges[nextIndex];

                var node0 = graphNodes[edge0.ownerNodeId];
                var node1 = graphNodes[edge1.ownerNodeId];

                var p0 = node0.position;
                var p1 = node1.position;

                var b0 = boundaryPoints[i];
                var b1 = boundaryPoints[nextIndex];

                vertices.Add(p0);
                vertices.Add(p1);
                vertices.Add(b1);

                vertices.Add(p0);
                vertices.Add(b1);
                vertices.Add(b0);

                var uvP0 = new Vector2(0, 0);
                var uvP1 = new Vector2(0, 1);
                var uvB0 = new Vector2(1, 0);
                var uvB1 = new Vector2(1, 1);

                uv.Add(uvP0);
                uv.Add(uvP1);
                uv.Add(uvB1);

                uv.Add(uvP0);
                uv.Add(uvB1);
                uv.Add(uvB0);
            }
        }
        Vector3[] GenerateBlockBoundary(RoadGraphEdge[] edges)
        {
            if (edges.Length == 0)
            {
                return new Vector3[0];
            }

            var boundary = new List<Vector3>();
            for (int i = 0; i < edges.Length; i++)
            {
                int previousIndex = (i == 0 ? edges.Length - 1 : i - 1);
                var edge = edges[i];
                var previousEdge = edges[previousIndex];

                var node0 = graphNodes[previousEdge.ownerNodeId];
                var node1 = graphNodes[edge.ownerNodeId];
                var node2 = graphNodes[edge.otherNodeId];

                if (previousEdge.otherNodeId != edge.ownerNodeId)
                {
                    Debug.Log("invalid node edge config");
                }
                var dir0 = (node0.position - node1.position).normalized;
                var dir1 = (node1.position - node2.position).normalized;

                var normalRotator = Quaternion.Euler(0, -90, 0);
                var normal0 = normalRotator * dir0;
                var normal1 = normalRotator * dir1;

                var thickness0 = previousEdge.thickness;
                var thickness1 = edge.thickness;

                float curvature = 1.0f;
                {
                    float cos = Vector3.Dot(normal0, normal1);
                    curvature = 1.0f / (1 + cos);
                }
                
                var owningNode = graphNodes[edge.ownerNodeId];
                var offset = (normal0 * thickness0 + normal1 * thickness1);
                var position = owningNode.position + offset * curvature;
                
                boundary.Add(position);
            }

            // Apply offset to the boundary
            return boundary.ToArray();
        }

        public RoadGraph BakeLayoutGraph()
        {
            var vertices = new List<Vector3>();
            var uvs = new List<Vector2>();

            var graphBuilder = new RoadGraphBuilder();
            var edgeVisited = new HashSet<int>();
            foreach (var node in graphNodes.Values)
            {
                foreach (var edge in node.adjacentEdges)
                {
                    if (!edgeVisited.Contains(edge.edgeId))
                    {
                        var blockEdges = TraverseEdgeBlock(edge, edgeVisited);
                        var boundary = GenerateBlockBoundary(blockEdges);

                        if (RoadBlockLayoutBuilt != null)
                        {
                            RoadBlockLayoutBuilt(ref boundary);
                        }

                        GenerateBoundaryMesh(blockEdges, boundary, vertices, uvs);

                        var boundaryBuildNodes = new List<RoadGraphBuildNode>();
                        foreach (var point in boundary)
                        {
                            var buildNode = graphBuilder.CreateNode(point);
                            boundaryBuildNodes.Add(buildNode);
                        }

                        // Connect the build nodes
                        for (int i = 0; i < boundaryBuildNodes.Count; i++)
                        {
                            RoadGraphBuildNode start = boundaryBuildNodes[i];
                            RoadGraphBuildNode end = boundaryBuildNodes[(i + 1) % boundaryBuildNodes.Count];
                            graphBuilder.ConnectNodes(start, end, 0);
                        }
                    }
                }

            }

            //var vertexMap = new Dictionary<Vector3, int>();
            //var vertexBuffer = new List<Vector3>();
            //var uvBuffer = new List<Vector2>();
            var indexBuffer = new List<int>();

            // Populate the vertex buffer
            for (int i = 0; i < vertices.Count; i++)
            {
                indexBuffer.Add(i);
            }
            
            var mesh = meshFilter.sharedMesh;
            mesh.vertices = vertices.ToArray();
            mesh.uv = uvs.ToArray();
            mesh.triangles = indexBuffer.ToArray();
            mesh.RecalculateNormals();
            mesh.RecalculateBounds();

            return graphBuilder.BakeRoadGraph();
        }

        RoadGraphEdge[] TraverseEdgeBlock(RoadGraphEdge startEdge, HashSet<int> edgeVisited)
        {
            var edges = new List<RoadGraphEdge>();
            RoadGraphEdge edge = startEdge;
            while (edge != null && !edgeVisited.Contains(edge.edgeId))
            {
                edges.Add(edge);
                edgeVisited.Add(edge.edgeId);

                // Move to the next edge
                var owningNode = graphNodes[edge.ownerNodeId];
                var otherNode = graphNodes[edge.otherNodeId];

                // Find the opposite edge
                RoadGraphEdge nextEdge = null;
                int numOtherNodeEdges = otherNode.adjacentEdges.Length;
                for (int i = 0; i < numOtherNodeEdges; i++) {
                    var otherNodeEdge = otherNode.adjacentEdges[i];
                    if (otherNodeEdge.otherNodeId == owningNode.nodeId)
                    {
                        // This is the opposite edge.  Grab the adjacent one
                        nextEdge = otherNode.adjacentEdges[(i + 1) % numOtherNodeEdges];
                    }
                }

                edge = nextEdge;
            }

            return edges.ToArray();
        }


    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\RoomDesigner\DungeonRoomDesigner.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect.RoomDesigner
{
    [System.Serializable]
    public struct DungeonRoomDoorDesigner
    {
        [SerializeField]
        public Vector3 logicalCursorPosition;

        [SerializeField]
        public Vector3 logicalPosition;

        [SerializeField]
        public Quaternion rotation;

        [SerializeField]
        public IntVector logicalSize;

        [SerializeField]
        public string markerName;
    }

    public class DungeonRoomDesigner : MonoBehaviour
    {
        public Vector3 gridSize = new Vector3(4, 2, 4);
        public IntVector roomPosition = IntVector.Zero;
        public IntVector roomSize = new IntVector(2, 1, 2);
        public Dungeon dungeon;
        public bool realtimeUpdate = true;
        public bool generateBoundaryMarkers = true;

        public DungeonRoomDoorDesigner[] doors;
        DungeonRoomVoxel voxelWorld = null;

        List<FloorIsland> islands = new List<FloorIsland>();

        public void GenerateLayout()
        {
            voxelWorld = new DungeonRoomVoxel(roomSize.x, roomSize.y, roomSize.z);

            CreateDoorPlatforms();
            FillSmallGaps();

            islands = new List<FloorIsland>();
            for (int y = roomSize.y - 1; y >= 0; y--)
            {
                islands.AddRange(FloorIsland.FindIslands(voxelWorld, y));
            }
            
        }

        void OnDrawGizmosSelected()
        {
            DebugDrawGizmos();
        }

        public void CreateDoorPlatforms()
        {
            var doorCarvings = new CarvingCommand[]
            {
                // Make sure the entrance is empty
                new CarvingCommand(new Vector3(0, 0, 0.5f), DungeonRoomVoxelCellType.Empty, true),
                new CarvingCommand(new Vector3(0, 1, 0.5f), DungeonRoomVoxelCellType.Empty, true),

                // Place a platform beneath the door
                new CarvingCommand(new Vector3( 0, -1, 0.5f), DungeonRoomVoxelCellType.Occupied, true), // Make sure we have a platform underneath the door entrance
                new CarvingCommand(new Vector3(-1, -1, 0.5f), DungeonRoomVoxelCellType.Occupied, false),
                new CarvingCommand(new Vector3( 1, -1, 0.5f), DungeonRoomVoxelCellType.Occupied, false),
            };

            // Carve out the door platforms
            foreach (var door in doors)
            {
                foreach (var carvingCommand in doorCarvings)
                {
                    var platformPos = door.logicalPosition + door.rotation * carvingCommand.localPosition;
                    var coord = MathUtils.ToIntVector(platformPos);
                    voxelWorld.SetState(coord, carvingCommand.cellType, carvingCommand.stateLocked);
                    voxelWorld.SetData(coord, DungeonRoomVoxelCellData.Door);
                }
            }
        }

        public void FillSmallGaps()
        {
            voxelWorld.IterateCells((cell, coord) =>
            {
                if (voxelWorld.IsEmpty(coord.x, coord.y, coord.z) &&
                    !voxelWorld.IsEmpty(coord.x, coord.y - 1, coord.z) &&
                    !voxelWorld.IsEmpty(coord.x, coord.y + 1, coord.z))
                {
                    cell.cellType = DungeonRoomVoxelCellType.Occupied;
                }
            });
        }

        public void EmitMarkers(LevelMarkerList markerList)
        {
            if (voxelWorld != null)
            {
                voxelWorld.EmitMarkers(markerList, roomPosition, doors, gridSize);
            }
        }

        void DebugDrawGizmos()
        {
            var debugColors = new Color[]
            {
                Color.red,
                Color.green,
                Color.blue,
                Color.cyan,
                Color.magenta,
                Color.yellow,
            };
            if (islands != null)
            {
                var slabSize = new Vector3(gridSize.x, 0.1f, gridSize.z);
                for (int i = 0; i < islands.Count; i++)
                {
                    var island = islands[i];

                    var drawColor = (i < debugColors.Length) ? debugColors[i] : Random.ColorHSV();
                    drawColor.a = 0.5f;
                    Gizmos.color = drawColor;

                    foreach (var cellPosition in island.IslandCells)
                    {
                        var position = Vector3.Scale((roomPosition + cellPosition).ToVector3(), gridSize);
                        Gizmos.DrawCube(position + slabSize / 2.0f, slabSize);
                    }
                }
            }
        }

    }

    struct CarvingCommand
    {
        public CarvingCommand(Vector3 localPosition, DungeonRoomVoxelCellType cellType, bool stateLocked)
        {
            this.localPosition = localPosition;
            this.cellType = cellType;
            this.stateLocked = stateLocked;
        }

        public Vector3 localPosition;
        public DungeonRoomVoxelCellType cellType;
        public bool stateLocked;
    }

    class FloorIsland
    {
        List<IntVector> islandCells = new List<IntVector>();
        public List<IntVector> IslandCells
        {
            get { return islandCells; }
        }
        
        /// <summary>
        /// Merges the islands in the same level
        /// </summary>
        public static FloorIsland MergeIslands(FloorIsland[] islands)
        {
            return null;
        }
        
        

        public static FloorIsland[] FindIslands(DungeonRoomVoxel voxelWorld, int y)
        {
            int width = voxelWorld.Cells.GetLength(0);
            int height = voxelWorld.Cells.GetLength(2);

            bool[,] visited = new bool[width, height];
            var islands = new List<FloorIsland>();

            var bfsOffset = new IntVector[]
            {
                    new IntVector(-1, 0,  0),
                    new IntVector( 1, 0,  0),
                    new IntVector( 0, 0, -1),
                    new IntVector( 0, 0,  1)
            };

            for (int x = 0; x < width; x++)
            {
                for (int z = 0; z < height; z++)
                {
                    if (voxelWorld.IsValidPlatform(new IntVector(x, y, z)) && !visited[x, z])
                    {
                        // Find an island from this occupied cell
                        var island = new FloorIsland();

                        var queue = new Queue<IntVector>();
                        queue.Enqueue(new IntVector(x, y, z));
                        visited[x, z] = true;

                        while (queue.Count > 0)
                        {
                            var position = queue.Dequeue();
                            island.IslandCells.Add(position);

                            for (int io = 0; io < bfsOffset.Length; io++)
                            {
                                var p = position + bfsOffset[io];
                                if (voxelWorld.IsValidPlatform(p) && !visited[p.x, p.z])
                                {
                                    visited[p.x, p.z] = true;
                                    queue.Enqueue(p);
                                }
                            }
                        }
                        if (island.IslandCells.Count > 0)
                        {
                            islands.Add(island);
                        }
                    }
                }
            }

            return islands.ToArray();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\RoomDesigner\DungeonRoomDesignerHook.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Linq;
using UnityEngine;

namespace DungeonArchitect.RoomDesigner
{
    public class DungeonRoomDesignerHook : DungeonEventListener
    {

        public override void OnPostDungeonLayoutBuild(Dungeon dungeon, DungeonModel model)
        {
            var rooms = GameObject.FindObjectsOfType<DungeonRoomDesigner>().Where(p => p.dungeon == dungeon).ToList();
            rooms.ForEach(r => r.GenerateLayout());
        }

        public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers)
        {
            var rooms = GameObject.FindObjectsOfType<DungeonRoomDesigner>().Where(p => p.dungeon == dungeon).ToList();
            rooms.ForEach(r => r.EmitMarkers(markers));
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\RoomDesigner\DungeonRoomMarkerEmitter.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.RoomDesigner
{
    public class DungeonRoomMarkerEmitter
    {
        public static void EmitMarkers(DungeonRoomDesigner room, LevelMarkerList markerList)
        {
            var min = room.roomPosition;
            var max = room.roomPosition + room.roomSize;

            var markers = new List<PropSocket>();
            markers.AddRange(RectFillMarkers(min, max, min.y, "Ground", room.gridSize));
            int y;
            for (y = min.y; y < max.y; y += 2)
            {
                string markerName = (y == max.y - 1) ? "WallHalf" : "Wall";
                markers.AddRange(RectBoundaryMarkers(min, max, y, markerName, room.gridSize));
            }
            markers.AddRange(RectFillMarkers(min, max, y, "Ceiling", room.gridSize));

            markerList.AddRange(markers.ToArray());
        }

        private static PropSocket[] RectFillMarkers(IntVector min, IntVector max, int y, string markerName, Vector3 gridSize)
        {
            var result = new List<PropSocket>();
            for (int x = min.x; x < max.x; x++)
            {
                for (int z = min.z; z < max.z; z++)
                {
                    var gridCoord = Vector3.Scale(new Vector3(x + 0.5f, y, z + 0.5f), gridSize);
                    result.Add(CreateMarker(gridCoord, Quaternion.identity, markerName));
                }
            }
            return result.ToArray();
        }

        private static PropSocket[] RectBoundaryMarkers(IntVector min, IntVector max, int y, string markerName, Vector3 gridSize)
        {
            var result = new List<PropSocket>();
            for (int x = min.x; x < max.x; x++)
            {
                var p0 = new Vector3(x + 0.5f, y, min.z);
                var p1 = new Vector3(x + 0.5f, y, max.z);
                var r0 = Quaternion.Euler(0, 180, 0);
                var r1 = Quaternion.Euler(0, 0, 0);
                result.Add(CreateMarker(Vector3.Scale(p0, gridSize), r0, markerName));
                result.Add(CreateMarker(Vector3.Scale(p1, gridSize), r1, markerName));
            }

            for (int z = min.z; z < max.z; z++)
            {
                var p0 = new Vector3(min.x, y, z + 0.5f);
                var p1 = new Vector3(max.x, y, z + 0.5f);
                var r0 = Quaternion.Euler(0, 270, 0);
                var r1 = Quaternion.Euler(0, 90, 0);
                result.Add(CreateMarker(Vector3.Scale(p0, gridSize), r0, markerName));
                result.Add(CreateMarker(Vector3.Scale(p1, gridSize), r1, markerName));
            }

            return result.ToArray();
        }

        private static PropSocket CreateMarker(Vector3 position, Quaternion rotation, string name)
        {
            var marker = new PropSocket();
            marker.Id = 0;
            marker.SocketType = name;
            marker.Transform = Matrix4x4.TRS(position, rotation, Vector3.one);
            return marker;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\RoomDesigner\DungeonRoomVoxel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace DungeonArchitect.RoomDesigner
{
    class DungeonRoomDesignerConstants
    {
        public static readonly string Ground    = "Ground";
        public static readonly string Wall      = "Wall";
        public static readonly string WallHalf  = "WallHalf";
        public static readonly string Door      = "Door";
        public static readonly string Ceiling   = "Ceiling";
    }

    public enum DungeonRoomVoxelCellData
    {
        None    = 0,
        Door    = 1 << 0,
        Stair   = 1 << 1,
    }

    public enum DungeonRoomVoxelCellType
    {
        Empty,
        Occupied
    }

    [System.Serializable]
    public class DungeonRoomVoxelCell
    {
        [SerializeField]
        public DungeonRoomVoxelCellType cellType = DungeonRoomVoxelCellType.Empty;

        [SerializeField]
        public bool stateLocked = false;

        [SerializeField]
        public int cellData = (int)DungeonRoomVoxelCellData.None;
    }

    public class DungeonRoomVoxel
    {
        DungeonRoomVoxelCell[,,] cells;
        public DungeonRoomVoxelCell[,,] Cells
        {
            get { return cells; }
        }

        public DungeonRoomVoxel(int sizeX, int sizeY, int sizeZ)
        {
            cells = new DungeonRoomVoxelCell[sizeX, sizeY, sizeZ];
            for (int x = 0; x < cells.GetLength(0); x++)
            {
                for (int y = 0; y < cells.GetLength(1); y++)
                {
                    for (int z = 0; z < cells.GetLength(2); z++)
                    {
                        var cell = new DungeonRoomVoxelCell();
                        cell.cellType = DungeonRoomVoxelCellType.Empty;
                        cell.cellData = 0;
                        cells[x, y, z] = cell;
                    }
                }
            }
        }
        
        public void TagDoorCells(Vector3 logicalPosition)
        {

        }

        public bool IsValidCoord(IntVector coord)
        {
            return IsValidCoord(coord.x, coord.y, coord.z);
        }

        public bool IsValidCoord(int x, int y, int z)
        {
            return !(x < 0 || y < 0 || z < 0 || x >= cells.GetLength(0) || y >= cells.GetLength(1) || z >= cells.GetLength(2));
        }

        public void SetState(IntVector coord, DungeonRoomVoxelCellType cellType)
        {
            SetState(coord, cellType, false);
        }

        public void SetData(IntVector coord, DungeonRoomVoxelCellData cellData)
        {
            if (IsValidCoord(coord.x, coord.y, coord.z))
            {
                var cell = cells[coord.x, coord.y, coord.z];
                cell.cellData |= (int)cellData;
            }
        }

        public bool IsValidPlatform(IntVector p)
        {
            return IsEmpty(p.x, p.y, p.z)
                && IsEmpty(p.x, p.y + 1, p.z)
                && !IsEmpty(p.x, p.y - 1, p.z);
        }

        public bool ContainsData(IntVector coord, DungeonRoomVoxelCellData cellData)
        {
            if (!IsValidCoord(coord.x, coord.y, coord.z))
            {
                return false;
            }
            var cell = cells[coord.x, coord.y, coord.z];
            return (cell.cellData &= (int)cellData) > 0;
        }

        public void SetState(IntVector coord, DungeonRoomVoxelCellType cellType, bool lockState)
        {
            if (IsValidCoord(coord.x, coord.y, coord.z))
            {
                var cell = cells[coord.x, coord.y, coord.z];
                if (!cell.stateLocked)
                {
                    cell.cellType = cellType;
                    cell.stateLocked = lockState;
                }
            }
        }

        public bool IsEmpty(int x, int y, int z)
        {
            if (!IsValidCoord(x, y, z))
            {
                return false;
            }
            return cells[x, y, z].cellType == DungeonRoomVoxelCellType.Empty;
        }

        class MarkerEmitCommand
        {
            public string markerName;
            public Vector3 position;
            public Quaternion rotation;
        }

        class MarkerEmitCommandList
        {
            public Dictionary<Vector3, MarkerEmitCommand> Map = new Dictionary<Vector3, MarkerEmitCommand>();
            public void Add(MarkerEmitCommand command)
            {
                Map.Add(command.position, command);
            }

            public void Remove(Vector3 position)
            {
                Map.Remove(position);
            }

            public bool Contains(Vector3 position, string markerName)
            {
                if (Map.ContainsKey(position))
                {
                    return Map[position].markerName == markerName;
                }
                return false;
            }
        }

        public void EmitMarkers(LevelMarkerList markerList, IntVector roomPosition, DungeonRoomDoorDesigner[] doors, Vector3 gridSize)
        {
            var commands = new MarkerEmitCommandList();

            for (int x = -1; x < cells.GetLength(0); x++)
            {
                for (int y = -1; y < cells.GetLength(1); y++)
                {
                    for (int z = -1; z < cells.GetLength(2); z++)
                    {
                        bool empty0 = IsEmpty(x, y, z);
                        bool emptyX = IsEmpty(x + 1, y, z);
                        bool emptyY = IsEmpty(x, y + 1, z);
                        bool emptyZ = IsEmpty(x, y, z + 1);

                        var markerName = DungeonRoomDesignerConstants.WallHalf;
                        if (!empty0 && emptyX) EmitMarker(markerName, x + 1, y, z + 0.5f, 90, commands);
                        if (empty0 && !emptyX) EmitMarker(markerName, x + 1, y, z + 0.5f, 270, commands);

                        if (!empty0 && emptyZ) EmitMarker(markerName, x + 0.5f, y, z + 1, 0, commands);
                        if (empty0 && !emptyZ) EmitMarker(markerName, x + 0.5f, y, z + 1, 180, commands);
                        
                        if (!empty0 && emptyY) EmitMarker(DungeonRoomDesignerConstants.Ground, x + 0.5f, y + 1, z + 0.5f, 0, commands);
                        if (empty0 && !emptyY) EmitMarker(DungeonRoomDesignerConstants.Ceiling, x + 0.5f, y + 1, z + 0.5f, Quaternion.Euler(180, 0, 0), commands);
                    }
                }
            }

            Pass_AddDoorMarkers(commands, doors);
            Pass_UpgradeWalls(commands);

            var roomPositionF = roomPosition.ToVector3();
            foreach (var command in commands.Map.Values)
            {
                var worldPosition = Vector3.Scale(command.position + roomPositionF, gridSize);

                var marker = new PropSocket();
                marker.Id = 0;
                marker.SocketType = command.markerName;
                marker.Transform = Matrix4x4.TRS(worldPosition, command.rotation, Vector3.one);
                markerList.Add(marker);
            }
        }

        void Pass_UpgradeWalls(MarkerEmitCommandList commands)
        {
            // Convert WallHalf to Walls where ever possible
            // This is done by checking if the existing WallHalf contains another WallHalf above it

            // First sort all the markers by Y
            var markers = commands.Map.Values.ToArray();
            markers.OrderBy(c => c.position.y);

            foreach (var marker in markers)
            {
                if (marker.markerName == DungeonRoomDesignerConstants.WallHalf)
                {
                    if (!commands.Contains(marker.position, DungeonRoomDesignerConstants.WallHalf))
                    {
                        // Already removed in the previous pass
                        continue;
                    }

                    var positionAbove = marker.position + new Vector3(0, 1, 0);
                    if (commands.Contains(positionAbove, DungeonRoomDesignerConstants.WallHalf))
                    {
                        // Remove the half wall above this
                        commands.Remove(positionAbove);

                        // Convert this WallHalf to a full Wall
                        commands.Map[marker.position].markerName = DungeonRoomDesignerConstants.Wall;
                    }
                }
            }
        }

        void Pass_AddDoorMarkers(MarkerEmitCommandList commands, DungeonRoomDoorDesigner[] doors)
        {
            foreach (var door in doors)
            {
                // Remove the existing markers at this position
                commands.Remove(door.logicalPosition);
                commands.Remove(door.logicalPosition + new Vector3(0, 1, 0));

                var command = new MarkerEmitCommand();
                command.markerName = DungeonRoomDesignerConstants.Door;
                command.position = door.logicalPosition;
                command.rotation = door.rotation;
                commands.Add(command);
            }
        }

        void EmitMarker(string markerName, float x, float y, float z, float angleY, MarkerEmitCommandList commands)
        {
            var rotation = Quaternion.Euler(0, angleY, 0);
            EmitMarker(markerName, x, y, z, rotation, commands);
        }

        void EmitMarker(string markerName, float x, float y, float z, Quaternion rotation, MarkerEmitCommandList commands)
        {
            var command = new MarkerEmitCommand();
            command.markerName = markerName;
            command.position = new Vector3(x, y, z);
            command.rotation = rotation;
            commands.Add(command);
        }


        public void IterateCells(System.Action<DungeonRoomVoxelCell, IntVector> callback)
        {
            for (int x = 0; x < cells.GetLength(0); x++)
            {
                for (int y = 0; y < cells.GetLength(1); y++)
                {
                    for (int z = 0; z < cells.GetLength(2); z++)
                    {
                        callback(cells[x, y, z], new IntVector(x, y, z));
                    }
                }
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Snap\SnapConnection.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Frameworks.Snap
{
    public enum SnapConnectionState
    {
        Wall,
        Door,
        DoorOneWay,
        DoorLocked,
        None
    }

    [System.Serializable]
    public struct SnapConnectionLockedDoorInfo
    {
        public string markerName;
        public GameObject lockedDoorObject;
    }

    public class SnapConnection : MonoBehaviour
    {
        public GameObject doorObject;
        public GameObject wallObject;
        public string category;

        public GameObject oneWayDoorObject;
        public SnapConnectionLockedDoorInfo[] lockedDoors;
        public SnapConnectionState connectionState = SnapConnectionState.None;

        public GameObject UpdateDoorState(SnapConnectionState state)
        {
            return UpdateDoorState(state, "");
        }

        public GameObject UpdateDoorState(SnapConnectionState state, string markerName)
        {
            connectionState = state;
            DeactivateAll();
            if (state == SnapConnectionState.Door)
            {
                SafeSetActive(doorObject, true);
                //DestroyImmediate(wallObject);
                //DestroyImmediate(oneWayDoorObject);
                return doorObject;
            }
            else if (state == SnapConnectionState.Wall)
            {
                SafeSetActive(wallObject, true);
                //DestroyImmediate(doorObject);
                //DestroyImmediate(oneWayDoorObject);
                return wallObject;
            }
            else if (state == SnapConnectionState.DoorOneWay)
            {
                SafeSetActive(oneWayDoorObject, true);
                //DestroyImmediate(doorObject);
                //DestroyImmediate(wallObject);
                return oneWayDoorObject;
            }
            else if (state == SnapConnectionState.DoorLocked)
            {
                if (lockedDoors != null)
                {
                    foreach (var lockInfo in lockedDoors)
                    {
                        if (lockInfo.markerName == markerName)
                        {
                            SafeSetActive(lockInfo.lockedDoorObject, true);
                            return lockInfo.lockedDoorObject;
                        }
                    }
                }
            }

            return null;
        }

        void DeactivateAll()
        {
            SafeSetActive(doorObject, false);
            SafeSetActive(wallObject, false);
            SafeSetActive(oneWayDoorObject, false);
            if (lockedDoors != null)
            {
                foreach (var lockedDoor in lockedDoors)
                {
                    SafeSetActive(lockedDoor.lockedDoorObject, false);
                }
            }
        }

        void SafeSetActive(GameObject obj, bool active)
        {
            if (obj != null)
            {
                obj.SetActive(active);
            }
        }

        void OnDrawGizmos()
        {
            if (transform != null)
            {
                var start = transform.position;
                var end = start + transform.forward;
                Gizmos.color = Color.red;
                Gizmos.DrawLine(start, end);
            }

        }
        
        public bool IsWallState()
        {
            return connectionState == SnapConnectionState.Wall;
        }
        
        public bool IsDoorState()
        {
            return connectionState == SnapConnectionState.Door
                   || connectionState == SnapConnectionState.DoorLocked
                   || connectionState == SnapConnectionState.DoorOneWay;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Snap\SnapUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Frameworks.Snap
{
    public class SnapUtils
    {
        public static Bounds GetSnapModuleBounds(GameObject target)
        {
            var bounds = new Bounds();
            if (target == null)
            {
                return bounds;
            }

            var stack = new Stack<GameObject>();
            stack.Push(target);
            
            //var renderers = target.GetComponentsInChildren<Renderer>();
            var renderers = new List<Renderer>();
            while (stack.Count > 0)
            {
                var top = stack.Pop();
                if (top == null) continue;

                var connectionComponent = top.GetComponent<SnapConnection>();
                if (connectionComponent != null)
                {
                    // Ignore this for the bounds calculation
                    continue;
                }

                var rendererComponent = top.GetComponent<Renderer>();
                if (rendererComponent != null)
                {
                    renderers.Add(rendererComponent);
                }

                for (int i = 0; i < top.transform.childCount; i++)
                {
                    stack.Push(top.transform.GetChild(i).gameObject);
                }
            }
            
            bool firstEntry = true;
            foreach (var renderer in renderers)
            {
                if (!renderer.enabled)
                {
                    continue;
                }
                
                if (firstEntry)
                {
                    firstEntry = false;
                    bounds = renderer.bounds;
                }
                else
                {
                    var renderBounds = renderer.bounds;
                    if (renderBounds.extents != Vector3.zero)
                    {
                        bounds.Encapsulate(renderer.bounds);
                    }
                }
            }

            return bounds;
        }
        
        public static void FindConnectionTransforms(GameObject moduleGameObject, out Matrix4x4[] outTransforms, out string[] outCategories)
        {
            if (moduleGameObject == null)
            {
                outTransforms = new Matrix4x4[0];
                outCategories = new string[0];
                return;
            }

            var connections = moduleGameObject.GetComponentsInChildren<SnapConnection>();
            var transforms = new List<Matrix4x4>();
            var categories = new List<string>();
            foreach (var connection in connections)
            {
                var transform = connection.transform;
                var worldTransform = Matrix4x4.TRS(transform.localPosition, transform.localRotation, transform.localScale);

                transforms.Add(worldTransform);
                categories.Add(connection.category);
            }

            outTransforms = transforms.ToArray();
            outCategories = categories.ToArray();
        }
        
        
        public static Matrix4x4[] FindAttachmentTransforms(ref Matrix4x4 ParentModuleTransform, ref Matrix4x4 IncomingDoorTransform, ref Matrix4x4 AttachmentDoorTransform) 
        {
            Matrix4x4 DesiredDoorTransform = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0, 180, 0), Vector3.one) * IncomingDoorTransform * ParentModuleTransform;
            
            // Calculate the rotation
            Quaternion DesiredRotation;
            {
                Vector3 TargetVector = Matrix.GetRotation(ref DesiredDoorTransform) * new Vector3(1, 0, 0);
                Vector3 SourceVector = Matrix.GetRotation(ref AttachmentDoorTransform) * new Vector3(1, 0, 0);

                Quaternion TargetRot = Quaternion.LookRotation(TargetVector, Vector3.up);
                Quaternion SourceRot = Quaternion.LookRotation(SourceVector, Vector3.up);
                DesiredRotation = TargetRot * Quaternion.Inverse(SourceRot);
            }

            // Calculate the translation
            Vector3 DesiredOffset;
            {
                Vector3 IncomingDoorPosition = Matrix.GetTranslation(ref IncomingDoorTransform);
                IncomingDoorPosition = ParentModuleTransform.MultiplyPoint3x4(IncomingDoorPosition);
                Vector3 ClampTarget = IncomingDoorPosition;

                Vector3 LocalDoorPosition = DesiredRotation * Matrix.GetTranslation(ref AttachmentDoorTransform);
                DesiredOffset = ClampTarget - LocalDoorPosition;
            }
            
            var ModuleTransform = Matrix4x4.TRS(DesiredOffset, DesiredRotation, Vector3.one);
            return new Matrix4x4[] { ModuleTransform };
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\ConstraintRule.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Linq;
using DungeonArchitect.Graphs.SpatialConstraints;

namespace DungeonArchitect.SpatialConstraints
{
    public class SpatialConstraintRuleDomain
    {
        public SCReferenceNode referenceNode;
        public Vector3 gridSize = Vector3.one;
    }
    
    public class RuleMetaAttribute : System.Attribute
    {
        public string name;
    }

    public class ConstraintRuleContext
    {
        public SpatialConstraintProcessorContext processorContext;
        public SpatialConstraintRuleDomain domain;
        public SCRuleNode ruleNode;
        public Vector3 ruleNodeWorldPosition;
        public Matrix4x4 rotationFrame;
    }

    public abstract class ConstraintRule : ScriptableObject
    {
        [SerializeField]
        [HideInInspector]
        public bool enabled = true;

        [SerializeField]
        [HideInInspector]
        public string ruleName;

        [SerializeField]
        public bool inverseRule = false;

        public virtual void OnEnable()
        {
            hideFlags = HideFlags.HideInHierarchy;
            ruleName = GetScriptName();
        }

        public abstract bool Process(ConstraintRuleContext context);

        public static string GetFullMenuPath(System.Type type)
        {
            var attribute = type.GetCustomAttributes(typeof(RuleMetaAttribute), true).FirstOrDefault() as RuleMetaAttribute;
            string path = (attribute != null) ? attribute.name : type.Name;
            return path;
        }

        public static string GetScriptName(System.Type type)
        {
            var path = GetFullMenuPath(type);
            var fileInfo = new System.IO.FileInfo(path);
            return fileInfo.Name;
        }

        public string GetFullMenuPath()
        {
            return GetFullMenuPath(GetType());
        }

        public string GetScriptName()
        {
            return GetScriptName(GetType());
        }

        public override string ToString()
        {
            if (inverseRule)
            {
                return ruleName + " Inverse";
            }
            else
            {
                return ruleName;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\ExclusionRule.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.SpatialConstraints
{
    /*
    [System.Serializable]
    public class ExclusionRule
    {
        [SerializeField]
        public float searchRadius = 0.1f;

        [SerializeField]
        public string[] markersToRemove;
    }
    */
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\SpatialConstraintAsset.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.SpatialConstraints
{
    [System.Serializable]
    public class SpatialConstraintAsset : ScriptableObject
    {
        [SerializeField]
        public bool rotateToFit = true;

        [SerializeField]
        public bool applyFitRotation = false;

        [SerializeField]
        public bool applyMarkerRotation = true;

        [SerializeField]
        public bool checkRelativeToMarkerRotation = true;

        [SerializeField]
        public GraphNode hostThemeNode;
        
        [HideInInspector]
        [SerializeField]
        private SpatialConstraintGraph graph;

        public SpatialConstraintGraph Graph
        {
            get { return graph; }
        }

        public void Init(GraphNode hostThemeNode)
        {
            this.hostThemeNode = hostThemeNode;

            graph = CreateInstance<SpatialConstraintGraph>();
            graph.asset = this;
            graph.hideFlags = HideFlags.HideInHierarchy;
        }

        public void OnEnable()
        {
            hideFlags = HideFlags.HideInHierarchy;
        }
        
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\SpatialConstraintProcessor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Linq;
using System.Collections.Generic;
using DungeonArchitect.Graphs.SpatialConstraints;
using DungeonArchitect.Utils;

namespace DungeonArchitect.SpatialConstraints
{
    public class SpatialConstraintProcessorUtils
    {

        public static Vector2 GetPosition2D(Vector3 position)
        {
            return new Vector2(position.x, position.z);
        }

        public static Vector3 RotateVector(Vector3 position, Matrix4x4 matrix)
        {
            var rotation = Matrix.GetRotation(ref matrix);
            return rotation * position;
        }

        public static Vector3 GetRuleNodeWorldPosition(SCRuleNode ruleNode, SCReferenceNode referenceNode, PropSocket marker, Vector3 gridSize, ref Matrix4x4 rotationFrame)
        {
            var scGraph = ruleNode.Graph as SpatialConstraintGraph;
            var relativeToMarkerRotation = scGraph.asset.checkRelativeToMarkerRotation;

            var markerTransform = marker.Transform;

            Vector2 offset2D = (ruleNode.Bounds.center - referenceNode.Bounds.center) / SCBaseDomainNode.TileSize;
            Vector3 offset = new Vector3(offset2D.x, 0, offset2D.y);
            if (relativeToMarkerRotation)
            {
                offset = RotateVector(offset, markerTransform);
            }
            offset = RotateVector(offset, rotationFrame);
            
            // Find the world position of the marker and the location to search (relative to the spatial constraint node from the SC reference node)
            var baseMarkerPosition = Matrix.GetTranslation(ref marker.Transform);
            var ruleNodePosition = baseMarkerPosition + Vector3.Scale(offset, gridSize);
            return ruleNodePosition;
       }

    }

    public class SpatialConstraintProcessorContext
    {
        public SpatialConstraintAsset constraintAsset;
        public PropSocket marker;
        public DungeonModel model;
        public DungeonConfig config;
        public DungeonBuilder builder;
        public LevelMarkerList levelMarkers;
    }

    public abstract class SpatialConstraintProcessor : MonoBehaviour
    {
        public virtual SpatialConstraintRuleDomain GetDomain(SpatialConstraintProcessorContext context)
        {
            var domain = new SpatialConstraintRuleDomain();
            var nodes = context.constraintAsset.Graph.Nodes;
            domain.referenceNode = nodes.Where(node => node is SCReferenceNode).FirstOrDefault() as SCReferenceNode;
            return domain;
        }

        bool ProcessSpatialConstraintFrame(SpatialConstraintProcessorContext context, SpatialConstraintRuleDomain domain, Matrix4x4 rotationFrame, out PropSocket[] outMarkersToRemove)
        {
            var nodes = context.constraintAsset.Graph.Nodes.Where(node => node is SCRuleNode);
            outMarkersToRemove = new PropSocket[0];

            if (nodes.Count() == 0)
            {
                // No rules specified.  Return true by default
                return true;
            }

            var nodeWorldPositions = new Dictionary<SCRuleNode, Vector3>();

            foreach (var node in nodes)
            {
                var ruleNode = node as SCRuleNode;

                var nodePosition = SpatialConstraintProcessorUtils.GetRuleNodeWorldPosition(ruleNode, domain.referenceNode,
                        context.marker, domain.gridSize, ref rotationFrame);
                nodeWorldPositions.Add(ruleNode, nodePosition);

                var constraints = ruleNode.constraints.Where(c => c != null);
                if (constraints.Count() == 0) continue;

                bool allRulesPassed = true;
                bool atleastOneRulePassed = false;

                foreach (var constraint in constraints)
                {
                    var ruleContext = new ConstraintRuleContext();
                    ruleContext.processorContext = context;
                    ruleContext.domain = domain;
                    ruleContext.ruleNode = ruleNode;
                    ruleContext.rotationFrame = rotationFrame;
                    ruleContext.ruleNodeWorldPosition = nodePosition;


                    bool success = constraint.Process(ruleContext);
                    if (constraint.inverseRule)
                    {
                        success = !success;
                    }

                    allRulesPassed &= success;
                    atleastOneRulePassed |= success;
                }

                if (ruleNode.constraintEvaluationMode == SCRuleNodeEvaluationMode.AllRulesMustPass && !allRulesPassed)
                {
                    return false;
                }
                else if (ruleNode.constraintEvaluationMode == SCRuleNodeEvaluationMode.AtleastOneRuleShouldPass && !atleastOneRulePassed)
                {
                    return false;
                }
            }

            // The spatial constraint setup has passed
            // Process removal rules
            var markersToRemove = new List<PropSocket>();
            foreach (var node in nodes)
            {
                var ruleNode = node as SCRuleNode;
                if (ruleNode.exclusionRuleMarkersToRemove.Length == 0)
                {
                    continue;
                }

                var radius = ruleNode.exclusionRuleSearchRadius;
                float searchRadiusSq = radius * radius;
                var nodePosition3D = nodeWorldPositions[ruleNode];
                var searchPosition = SpatialConstraintProcessorUtils.GetPosition2D(nodePosition3D);
                foreach (var markerToRemove in ruleNode.exclusionRuleMarkersToRemove)
                {
                    var markerSearchSpace = context.levelMarkers.GetMarkersInSearchArea(searchPosition, radius);
                    foreach (var candidateMarker in markerSearchSpace)
                    {
                        var candidateMarkerName = candidateMarker.SocketType;
                        if (ruleNode.exclusionRuleMarkersToRemove.Contains(candidateMarkerName))
                        {
                            var candidateMarkerPosition = SpatialConstraintProcessorUtils.GetPosition2D(Matrix.GetTranslation(ref candidateMarker.Transform));
                            float distanceSq = (searchPosition - candidateMarkerPosition).sqrMagnitude;
                            if (distanceSq < searchRadiusSq)
                            {
                                markersToRemove.Add(candidateMarker);
                            }
                        }
                    }
                }
            }
            outMarkersToRemove = markersToRemove.ToArray();

            return true;
        }

        public bool ProcessSpatialConstraint(SpatialConstraintProcessorContext context, out Matrix4x4 outOffset, out PropSocket[] outMarkersToRemove)
        {
            outOffset = Matrix4x4.identity;
            var domain = GetDomain(context);
            if (context.constraintAsset != null && context.constraintAsset.Graph != null)
            {
                Matrix4x4[] rotationFrames;
                if (context.constraintAsset.rotateToFit)
                {
                    rotationFrames = new Matrix4x4[]
                    {
                        Matrix4x4.identity,
                        Matrix4x4.Rotate(Quaternion.Euler(0, 90, 0)),
                        Matrix4x4.Rotate(Quaternion.Euler(0, 180, 0)),
                        Matrix4x4.Rotate(Quaternion.Euler(0, 270, 0)),
                    };
                }
                else
                {
                    rotationFrames = new Matrix4x4[]
                    {
                        Matrix4x4.identity
                    };
                }
                
                foreach (var rotationFrame in rotationFrames)
                {
                    if (ProcessSpatialConstraintFrame(context, domain, rotationFrame, out outMarkersToRemove))
                    {
                        if (context.constraintAsset.applyFitRotation)
                        {
                            outOffset = rotationFrame;
                        }
                        return true;
                    }
                }
            }

            outMarkersToRemove = new PropSocket[0];
            return false;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Splatmaps\DungeonSplatAsset.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Splatmap
{
    public class DungeonSplatAsset : ScriptableObject
    {
        [SerializeField]
        public Texture2D[] splatTextures = new Texture2D[0];
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Splatmaps\DungeonSplatmap.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Splatmap
{
    [System.Serializable]
    public struct DungeonSplatmapTextureInfo
    {
        [SerializeField]
        public string id;

        [SerializeField]
        public TextureFormat textureFormat;

        [SerializeField]
        public int textureSize;
    }

    public class DungeonSplatmap : MonoBehaviour
    {
        public DungeonSplatmapTextureInfo[] textures;
        public DungeonSplatAsset splatmap;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\DungeonThemeData.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Themeing {
    /// <summary>
    /// The data-structure for serializing the theme graph to disk
    /// </summary>
	public class DungeonThemeData {
		public List<DungeonThemeItem> Props = new List<DungeonThemeItem>();

		public void BuildFromGraph(Graph graph) {
			Props.Clear();
			if (graph == null) {
				return;
			}
			var nodes = graph.Nodes.ToArray();
			Array.Sort (nodes, new LeftToRightNodeComparer ());

			foreach (var node in nodes) {
				if (node is VisualNode) {
					var visualNode = node as VisualNode;

					foreach (var meshParentNode in visualNode.GetParentNodes()) {
						if (meshParentNode is MarkerNode) {
							var markerNode = meshParentNode as MarkerNode;
							
							DungeonThemeItem item = null;
							if (visualNode is GameObjectNode) {
								var meshItem = new GameObjectDungeonThemeItem ();
								var goNode = visualNode as GameObjectNode;

								meshItem.Template = goNode.Template;

								item = meshItem;
							}
							else if (visualNode is GameObjectArrayNode) {
								var arrayPropData = new GameObjectArrayDungeonThemeItem ();
								var arrayNode = visualNode as GameObjectArrayNode;

								if (arrayNode == null || arrayNode.Templates == null) {
									arrayPropData.Templates = new GameObject[0];
								} else {
									var count = arrayNode.Templates.Length;
									arrayPropData.Templates = new GameObject[count];
									System.Array.Copy (arrayNode.Templates, arrayPropData.Templates, count);
								}
								item = arrayPropData;
							}
							else if (visualNode is SpriteNode) {
								var spriteItem = new SpriteDungeonThemeItem();
								var spriteNode = visualNode as SpriteNode;

								spriteItem.sprite = spriteNode.sprite;
								spriteItem.color = spriteNode.color;
								spriteItem.materialOverride = spriteNode.materialOverride;
								spriteItem.sortingLayerName = spriteNode.sortingLayerName;
								spriteItem.orderInLayer = spriteNode.orderInLayer;

								spriteItem.collisionType = spriteNode.collisionType;
								spriteItem.physicsMaterial = spriteNode.physicsMaterial;
								spriteItem.physicsOffset = spriteNode.physicsOffset;
								spriteItem.physicsSize = spriteNode.physicsSize;
								spriteItem.physicsRadius = spriteNode.physicsRadius;

								item = spriteItem;
							}
							else {
								// Unsupported visual node type
								continue;
							}

							// Set the common settings
							item.NodeId = visualNode.Id.ToString();
							item.AttachToSocket = markerNode.Caption;
							item.Affinity = visualNode.attachmentProbability;
							item.ConsumeOnAttach = visualNode.consumeOnAttach;
							item.Offset = visualNode.offset;
							item.StaticState = visualNode.IsStatic ? DungeonThemeItemStaticMode.ForceStatic : DungeonThemeItemStaticMode.Unchanged;
							item.affectsNavigation = visualNode.affectsNavigation;
							item.UseSelectionRule = visualNode.selectionRuleEnabled;
							item.SelectorRuleClassName = visualNode.selectionRuleClassName;
							item.UseTransformRule = visualNode.transformRuleEnabled;
							item.TransformRuleClassName = visualNode.transformRuleClassName;
                            item.useSpatialConstraint = visualNode.useSpatialConstraint;
                            item.spatialConstraint = visualNode.spatialConstraint;

							var emitterNodes = visualNode.GetChildNodes();
							foreach (var childNode in emitterNodes) {
								if (childNode is MarkerEmitterNode) {
									var emitterNode = childNode as MarkerEmitterNode;
									if (emitterNode.Marker != null) {
										PropChildSocketData childData = new PropChildSocketData();
										childData.Offset = emitterNode.offset;
										childData.SocketType = emitterNode.Marker.Caption;
										item.ChildSockets.Add (childData);
									}
								}
							}
							Props.Add(item);
						}
					}
				}
			}
		}
	}
	
	/// <summary>
	/// Sorts the nodes from left to right based on the X-axis.
    /// This is used for sorting the visual nodes for execution, 
    /// since they are executed from left to right
	/// </summary>
	public class LeftToRightNodeComparer : IComparer<GraphNode>
	{
		public int Compare(GraphNode a, GraphNode b)  
		{
			if (a.Bounds.x == b.Bounds.x) {
				return 0;
			}
			return (a.Bounds.x < b.Bounds.x) ? -1 : 1;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\DungeonThemeEngine.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Utils;
using DungeonArchitect.Graphs;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Themeing
{
    using PropBySocketType_t = Dictionary<string, List<DungeonThemeItem>>;
    using PropBySocketTypeByTheme_t = Dictionary<DungeonThemeData, Dictionary<string, List<DungeonThemeItem>>>;

    public struct DungeonThemeExecutionContext
    {
        public DungeonBuilder builder;
        public DungeonConfig config;
        public DungeonModel model;
        public SpatialConstraintProcessor spatialConstraintProcessor;
        public ThemeOverrideVolume[] themeOverrideVolumes;
        public DungeonSceneProvider sceneProvider;
        public DungeonSceneObjectSpawner objectSpawner;
        public DungeonItemSpawnListener[] spawnListeners;
        public IDungeonSceneObjectInstantiator objectInstantiator;
    }

    public class DungeonThemeEngine
    {
        DungeonThemeExecutionContext context;
        PMRandom random;

        public DungeonThemeEngine(DungeonThemeExecutionContext context)
        {
            this.context = context;
            random = new PMRandom(context.config.Seed);
        }

        public void ApplyTheme(LevelMarkerList markers, List<DungeonThemeData> Themes)
        {
            var instanceCache = new InstanceCache();
            var constraintProcessor = context.spatialConstraintProcessor;

            if (random == null)
            {
                random = new PMRandom(context.config.Seed);
            }

            PropBySocketTypeByTheme_t PropBySocketTypeByTheme = new PropBySocketTypeByTheme_t();
            foreach (DungeonThemeData Theme in Themes)
            {
                CreatePropLookup(Theme, PropBySocketTypeByTheme);
            }

            // Collect all the theme override volumes and prepare their theme lookup
            var overrideVolumes = new List<ThemeOverrideVolume>();
            Dictionary<Graph, DungeonThemeData> GraphToThemeMapping = new Dictionary<Graph, DungeonThemeData>();

            // Process the theme override volumes
            var themeOverrides = context.themeOverrideVolumes;
            foreach (var volume in themeOverrides)
            {
                overrideVolumes.Add(volume);
                var graph = volume.overrideTheme;
                if (graph != null && !GraphToThemeMapping.ContainsKey(graph))
                {
                    DungeonThemeData theme = new DungeonThemeData();
                    theme.BuildFromGraph(volume.overrideTheme);
                    GraphToThemeMapping.Add(volume.overrideTheme, theme);

                    CreatePropLookup(theme, PropBySocketTypeByTheme);
                }
            }

            var srandom = new PMRandom(context.config.Seed);

            var nodesExecutionContext = new NodeListExecutionContext();
            nodesExecutionContext.instanceCache = instanceCache;
            nodesExecutionContext.constraintProcessor = constraintProcessor;
            nodesExecutionContext.srandom = srandom;
            nodesExecutionContext.SceneProvider = context.sceneProvider;
            nodesExecutionContext.objectInstantiator = context.objectInstantiator;

            var spawnDataList = new List<DungeonNodeSpawnData>();

            var delayedExecutionList = new Queue<NodeListExecutionData>();
            // Fill up the markers with the defined mesh data 
            for (int i = 0; i < markers.Count; i++)
            {
                PropSocket socket = markers[i];
                if (!socket.markForDeletion)
                {
                    DungeonThemeData themeToUse = GetBestMatchedTheme(Themes, socket, PropBySocketTypeByTheme); // PropAsset;
                    DungeonThemeData fallbackThemeToUse = themeToUse;

                    // Check if this socket resides within a override volume
                    {
                        var socketPosition = Matrix.GetTranslation(ref socket.Transform);
                        foreach (var volume in overrideVolumes)
                        {
                            if (volume.GetBounds().Contains(socketPosition))
                            {
                                var graph = volume.overrideTheme;
                                if (graph != null && GraphToThemeMapping.ContainsKey(graph))
                                {
                                    themeToUse = GraphToThemeMapping[volume.overrideTheme];
                                    if (!volume.useBaseThemeForMissingMarkers)
                                    {
                                        fallbackThemeToUse = themeToUse;
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    if (themeToUse != null)
                    {
                        PropBySocketType_t PropBySocketType = PropBySocketTypeByTheme[themeToUse];
                        if (!PropBySocketType.ContainsKey(socket.SocketType) && fallbackThemeToUse != null && fallbackThemeToUse != themeToUse)
                        {
                            PropBySocketType = PropBySocketTypeByTheme[fallbackThemeToUse];
                        }

                        if (PropBySocketType.ContainsKey(socket.SocketType))
                        {
                            var data = new NodeListExecutionData();
                            data.socket = socket;
                            data.nodeDataList = PropBySocketType[socket.SocketType];

                            if (ShouldDelayExecution(data.nodeDataList))
                            {
                                delayedExecutionList.Enqueue(data);
                            }
                            else
                            {
                                ExecuteNodesUnderMarker(data, nodesExecutionContext, markers, spawnDataList);
                            }
                        }
                    }
                }

                // We execute the delayed node list (that have spatial constraints) at the very end of the list
                // Each execution of the delayed node however, can add more items to this list
                bool isLastIndex = (i == markers.Count - 1);
                while (isLastIndex && delayedExecutionList.Count > 0)
                {
                    var data = delayedExecutionList.Dequeue();
                    if (!data.socket.markForDeletion)
                    {
                        ExecuteNodesUnderMarker(data, nodesExecutionContext, markers, spawnDataList);
                    }

                    isLastIndex = (i == markers.Count - 1);
                }
            }

            RecursivelyTagMarkersForDeletion(markers);

            if (context.objectSpawner != null)
            {
                context.objectSpawner.Destroy();
            }

            
            context.objectSpawner.Spawn(spawnDataList.ToArray(), nodesExecutionContext.SceneProvider,
                    random, nodesExecutionContext.objectInstantiator, context.spawnListeners);
        }
        
        // Picks a theme from the list that has a definition for the defined socket
        DungeonThemeData GetBestMatchedTheme(List<DungeonThemeData> Themes, PropSocket socket, PropBySocketTypeByTheme_t PropBySocketTypeByTheme)
        {
            var ValidThemes = new List<DungeonThemeData>();
            foreach (DungeonThemeData Theme in Themes)
            {
                if (PropBySocketTypeByTheme.ContainsKey(Theme))
                {
                    PropBySocketType_t PropBySocketType = PropBySocketTypeByTheme[Theme];
                    if (PropBySocketType.Count > 0)
                    {
                        if (PropBySocketType.ContainsKey(socket.SocketType) && PropBySocketType[socket.SocketType].Count > 0)
                        {
                            ValidThemes.Add(Theme);
                        }
                    }
                }
            }
            if (ValidThemes.Count == 0)
            {
                return null;
            }

            int index = Mathf.FloorToInt(random.GetNextUniformFloat() * ValidThemes.Count) % ValidThemes.Count;
            return ValidThemes[index];
        }

        bool ProcessSpatialConstraint(SpatialConstraintProcessor constraintProcessor, SpatialConstraintAsset constraint, PropSocket marker, LevelMarkerList markers, out Matrix4x4 OutOffset, out PropSocket[] outMarkersToRemove)
        {
            if (constraintProcessor == null)
            {
                OutOffset = Matrix4x4.identity;
                outMarkersToRemove = new PropSocket[0];
                return false;
            }
            var spatialContext = new SpatialConstraintProcessorContext();
            spatialContext.constraintAsset = constraint;
            spatialContext.marker = marker;
            spatialContext.model = context.model;
            spatialContext.config = context.config;
            spatialContext.builder = context.builder;
            spatialContext.levelMarkers = markers;
            return constraintProcessor.ProcessSpatialConstraint(spatialContext, out OutOffset, out outMarkersToRemove);
        }


        void RecursivelyTagMarkerForDeletion(PropSocket marker, HashSet<int> visited)
        {
            visited.Add(marker.Id);
            marker.markForDeletion = true;
            foreach (var childMarker in marker.childMarkers)
            {
                if (!visited.Contains(childMarker.Id))
                {
                    RecursivelyTagMarkerForDeletion(childMarker, visited);
                }
            }
        }

        void RecursivelyTagMarkersForDeletion(LevelMarkerList markers)
        {
            var visited = new HashSet<int>();
            foreach (var marker in markers)
            {
                if (marker.markForDeletion && !visited.Contains(marker.Id))
                {
                    RecursivelyTagMarkerForDeletion(marker, visited);
                }
            }
        }

        // The data for executing all the nodes attached under a marker
        struct NodeListExecutionData
        {
            public List<DungeonThemeItem> nodeDataList;
            public PropSocket socket;
        }

        // The context required for executing all the nodes attached under a marker
        struct NodeListExecutionContext
        {
            public InstanceCache instanceCache;
            public SpatialConstraintProcessor constraintProcessor;
            public PMRandom srandom;
            public DungeonSceneProvider SceneProvider;
            public IDungeonSceneObjectInstantiator objectInstantiator;
        };
        
        bool ShouldDelayExecution(List<DungeonThemeItem> nodeDataList)
        {
            // If we use a spatial constraint, delay the execution
            foreach (DungeonThemeItem nodeData in nodeDataList)
            {
                if (nodeData.useSpatialConstraint && nodeData.spatialConstraint != null)
                {
                    return true;
                }
            }
            return false;
        }

        void CreatePropLookup(DungeonThemeData theme, PropBySocketTypeByTheme_t PropBySocketTypeByTheme)
        {
            if (theme == null || PropBySocketTypeByTheme.ContainsKey(theme))
            {
                // Lookup for this theme has already been built
                return;
            }

            PropBySocketType_t PropBySocketType = new PropBySocketType_t();
            PropBySocketTypeByTheme.Add(theme, PropBySocketType);

            foreach (DungeonThemeItem Prop in theme.Props)
            {
                if (!PropBySocketType.ContainsKey(Prop.AttachToSocket))
                {
                    PropBySocketType.Add(Prop.AttachToSocket, new List<DungeonThemeItem>());
                }
                PropBySocketType[Prop.AttachToSocket].Add(Prop);
            }
        }

        void ExecuteNodesUnderMarker(NodeListExecutionData data, NodeListExecutionContext nodeContext, LevelMarkerList markers, List<DungeonNodeSpawnData> spawnDataList)
        {
            var marker = data.socket;
            var nodeDataList = data.nodeDataList;
            foreach (DungeonThemeItem nodeData in nodeDataList)
            {
                bool insertMesh = false;
                Matrix4x4 transform = marker.Transform * nodeData.Offset;

                if (nodeData.UseSelectionRule && nodeData.SelectorRuleClassName != null)
                {
                    var selectorRule = nodeContext.instanceCache.GetInstance(nodeData.SelectorRuleClassName) as SelectorRule;
                    if (selectorRule != null)
                    {
                        // Run the selection rule logic to determine if we need to insert this mesh in the scene
                        insertMesh = selectorRule.CanSelect(marker, transform, context.model, random.UniformRandom);
                    }
                }
                else
                {
                    // Perform probability based selection logic
                    float probability = nodeContext.srandom.GetNextUniformFloat();
                    insertMesh = (probability < nodeData.Affinity);
                }

                if (insertMesh && nodeData.useSpatialConstraint && nodeData.spatialConstraint != null)
                {
                    Matrix4x4 spatialOffset;
                    PropSocket[] markersToRemove;
                    if (!ProcessSpatialConstraint(nodeContext.constraintProcessor, nodeData.spatialConstraint, marker, markers, out spatialOffset, out markersToRemove))
                    {
                        // Fails spatial constraint
                        insertMesh = false;
                    }
                    else
                    {
                        // Apply the offset
                        var markerOffset = marker.Transform;
                        if (nodeData.spatialConstraint != null && !nodeData.spatialConstraint.applyMarkerRotation)
                        {
                            var markerPosition = Matrix.GetTranslation(ref markerOffset);
                            var markerScale = Matrix.GetScale(ref markerOffset);
                            markerOffset = Matrix4x4.TRS(markerPosition, Quaternion.identity, markerScale);
                        }
                        transform = markerOffset * spatialOffset * nodeData.Offset;

                        foreach (var markerToRemove in markersToRemove)
                        {
                            markerToRemove.markForDeletion = true;
                        }
                    }
                }

                if (insertMesh)
                {
                    // Attach this prop to the socket
                    // Apply transformation logic, if specified
                    if (nodeData.UseTransformRule && nodeData.TransformRuleClassName != null && nodeData.TransformRuleClassName.Length > 0)
                    {
                        var transformer = nodeContext.instanceCache.GetInstance(nodeData.TransformRuleClassName) as TransformationRule;
                        if (transformer != null)
                        {
                            Vector3 _position, _scale;
                            Quaternion _rotation;
                            transformer.GetTransform(marker, context.model, transform, random.UniformRandom, out _position, out _rotation, out _scale);
                            var offset = Matrix4x4.TRS(_position, _rotation, _scale);
                            transform = transform * offset;
                        }
                    }

                    // Create a spawn request
                    var spawnData = new DungeonNodeSpawnData();
                    spawnData.nodeData = nodeData;
                    spawnData.transform = transform;
                    spawnData.socket = marker;
                    spawnDataList.Add(spawnData);

                    // Add child markers if any
                    foreach (PropChildSocketData ChildSocket in nodeData.ChildSockets)
                    {
                        Matrix4x4 childTransform = transform * ChildSocket.Offset;
                        var childMarker = markers.EmitMarker(ChildSocket.SocketType, childTransform, marker.gridPosition, marker.cellId);
                        data.socket.childMarkers.Add(childMarker);
                    }

                    if (nodeData.ConsumeOnAttach)
                    {
                        // Attach no more on this socket
                        break;
                    }
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\DungeonThemeItems.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect
{
	/// <summary>
	/// The data structure for a marker
	/// </summary>
	[System.Serializable]
	public class PropSocket {
		public int Id;
		public string SocketType;
		public Matrix4x4 Transform;
		public IntVector gridPosition;
		public int cellId;
		public bool markForDeletion = false;
		public List<PropSocket> childMarkers = new List<PropSocket>();
		public object metadata;

		public PropSocket() {}

		public PropSocket(PropSocket other)
		{
			Id = other.Id;
			SocketType = other.SocketType;
			Transform = other.Transform;
			gridPosition = other.gridPosition;
			cellId = other.cellId;
			markForDeletion = other.markForDeletion;
			childMarkers = other.childMarkers;
			metadata = other.metadata;
		}
        
		public override string ToString()
		{
			return SocketType;
		}
	}
}

namespace DungeonArchitect.Themeing
{
	/// <summary>
    /// Props can emit new sockets when they are inserted, to add more child props relative to them
	/// </summary>
	public class PropChildSocketData {
		public string SocketType;
		public Matrix4x4 Offset;
	}

	public enum DungeonThemeItemStaticMode
	{
		Unchanged,
		ForceStatic,
		ForceNonStatic,
	}

    /// <summary>
    /// The data structure to hold information about a single node in the asset file
    /// </summary>
	public abstract class DungeonThemeItem {
		/// <summary>
        /// The unique guid of the node that generated this prop
		/// </summary>
		public string NodeId;

		/// <summary>
        /// The socket to attach to
		/// </summary>
		public string AttachToSocket;

		/// <summary>
        /// The probability of attachment
		/// </summary>
		public float Affinity;

		/// <summary>
        /// Should this prop consume the node (i.e. stop further processing of the sibling nodes)
		/// </summary>
		public bool ConsumeOnAttach;

		/// <summary>
        /// The offset to apply from the node's marker position
		/// </summary>
		public Matrix4x4 Offset;

		/// <summary>
        /// The child socket markers emitted from this node
		/// </summary>
		public List<PropChildSocketData> ChildSockets = new List<PropChildSocketData>();

        /// <summary>
        /// Indicates if the object's static flag is to be set
        /// </summary>
        public DungeonThemeItemStaticMode StaticState = DungeonThemeItemStaticMode.Unchanged;

		/// <summary>
		/// Flag to indicate if this node's geometry affects the navmesh
		/// </summary>
		public bool affectsNavigation;

		/// <summary>
        /// Flag to indicate if a selection rule script is used to determine if this prop is selected for insertion
		/// </summary>
		public bool UseSelectionRule;

		/// <summary>
        /// The script to to determine if this prop is selected for insertion. This holds the class of type SelectorRule
		/// </summary>
		public string SelectorRuleClassName;
		
		/// <summary>
        /// Flag to indicate if a transformation rule script is used to determine the transform offset while inserting this mesh
		/// </summary>
		public bool UseTransformRule;

		/// <summary>
        /// The script that calculates the transform offset to be used when inserting this mesh. This holds a class of type TransformationRule
		/// </summary>
		public string TransformRuleClassName;

        /// <summary>
        /// Flag to indicate if spatial constraints are to be used
        /// </summary>
        public bool useSpatialConstraint = false;

        /// <summary>
        /// Spatial constraints lets you select a node based on nearby neighbor constraints
        /// </summary>
        public SpatialConstraintAsset spatialConstraint;

        /// <summary>
        /// If externally managed, the theme engine will not destroy the object 
        /// </summary>
        public bool externallyManaged = false;
    }

    /// <summary>
    /// Game Object node data asset attributes
    /// </summary>
	public class GameObjectDungeonThemeItem : DungeonThemeItem {
		// The template to instantiate
		public GameObject Template;
	}

	/// <summary>
	/// Game Object node data asset attributes
	/// </summary>
	public class GameObjectArrayDungeonThemeItem : DungeonThemeItem {
		// The template to instantiate
		public GameObject[] Templates;
	}

    /// <summary>
    /// Sprite node data asset attributes
    /// </summary>
    public class SpriteDungeonThemeItem : DungeonThemeItem
    {
		public Sprite sprite;
		public Color color;
		public Material materialOverride;
		public string sortingLayerName;
		public int orderInLayer;

		// Physics2D attributes
		public DungeonSpriteCollisionType collisionType;
		public PhysicsMaterial2D physicsMaterial;
		public Vector2 physicsOffset;
		public Vector2 physicsSize;
		public float physicsRadius;

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Triangulator\Delauney.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
//Credit to Paul Bourke (pbourke@swin.edu.au) for the original Triangulator Fortran 77 Program :))
//Converted to a standalone C# 2.0 library by Morten Nielsen (www.iter.dk)
//Check out: http://astronomy.swin.edu.au/~pbourke/terrain/triangulate/
//You can use this triangulator code however you like providing the above credits remain in tact

using System;
using System.Collections.Generic;

namespace DungeonArchitect.Triangulator
{
	/// <summary>
	/// Performs the Delauney triangulation on a set of vertices.
	/// </summary>
	/// <remarks>
	/// Based on Paul Bourke's "An Algorithm for Interpolating Irregularly-Spaced Data
	/// with Applications in Terrain Modelling"
	/// http://astronomy.swin.edu.au/~pbourke/modelling/triangulate/
	/// </remarks>
	public class Delauney	
	{
		/// <summary>
		/// Performs Delauney triangulation on a set of points.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The triangulation doesn't support multiple points with the same planar location.
		/// Vertex-lists with duplicate points may result in strange triangulation with intersecting edges.
		/// To avoid adding multiple points to your vertex-list you can use the following anonymous predicate
		/// method:
		/// <code>
		/// if(!Vertices.Exists(delegate(Triangulator.Geometry.Point p) { return pNew.Equals2D(p); }))
		///		Vertices.Add(pNew);
		/// </code>
		/// </para>
		/// <para>The triangulation algorithm may be described in pseudo-code as follows:
		/// <code>
		/// subroutine Triangulate
		/// input : vertex list
		/// output : triangle list
		///    initialize the triangle list
		///    determine the supertriangle
		///    add supertriangle vertices to the end of the vertex list
		///    add the supertriangle to the triangle list
		///    for each sample point in the vertex list
		///       initialize the edge buffer
		///       for each triangle currently in the triangle list
		///          calculate the triangle circumcircle center and radius
		///          if the point lies in the triangle circumcircle then
		///             add the three triangle edges to the edge buffer
		///             remove the triangle from the triangle list
		///          endif
		///       endfor
		///       delete all doubly specified edges from the edge buffer
		///          this leaves the edges of the enclosing polygon only
		///       add to the triangle list all triangles formed between the point 
		///          and the edges of the enclosing polygon
		///    endfor
		///    remove any triangles from the triangle list that use the supertriangle vertices
		///    remove the supertriangle vertices from the vertex list
		/// end
		/// </code>
		/// </para>
		/// </remarks>
		/// <param name="Vertex">List of vertices to triangulate.</param>
		/// <returns>Triangles referencing vertex indices arranged in clockwise order</returns>
		public static List<Geometry.Triangle> Triangulate(List<Triangulator.Geometry.Point> Vertex)
		{
			int nv = Vertex.Count;
			if (nv < 3)
				throw new ArgumentException("Need at least three vertices for triangulation");

			int trimax = 4 * nv;

			// Find the maximum and minimum vertex bounds.
			// This is to allow calculation of the bounding supertriangle
			double xmin = Vertex[0].X;
			double ymin = Vertex[0].Y;
			double xmax = xmin;
			double ymax = ymin;
			for (int i = 1; i < nv; i++)
			{
				if (Vertex[i].X < xmin) xmin = Vertex[i].X;
				if (Vertex[i].X > xmax) xmax = Vertex[i].X;
				if (Vertex[i].Y < ymin) ymin = Vertex[i].Y;
				if (Vertex[i].Y > ymax) ymax = Vertex[i].Y;
			}

			double dx = xmax - xmin;
			double dy = ymax - ymin;
			double dmax = (dx > dy) ? dx : dy;

			double xmid = (xmax + xmin) * 0.5;
			double ymid = (ymax + ymin) * 0.5;

			
			// Set up the supertriangle
			// This is a triangle which encompasses all the sample points.
			// The supertriangle coordinates are added to the end of the
			// vertex list. The supertriangle is the first triangle in
			// the triangle list.
			Vertex.Add(new Triangulator.Geometry.Point((xmid - 2 * dmax), (ymid - dmax)));
			Vertex.Add(new Triangulator.Geometry.Point(xmid, (ymid + 2 * dmax)));
			Vertex.Add(new Triangulator.Geometry.Point((xmid + 2 * dmax), (ymid - dmax)));
			List<Geometry.Triangle> Triangle = new List<Geometry.Triangle>();
			Triangle.Add(new Geometry.Triangle(nv, nv + 1, nv + 2)); //SuperTriangle placed at index 0
			
			// Include each point one at a time into the existing mesh
			for (int i = 0; i < nv; i++)
			{
				List<Geometry.Edge> Edges = new List<Geometry.Edge>(); //[trimax * 3];
				// Set up the edge buffer.
				// If the point (Vertex(i).x,Vertex(i).y) lies inside the circumcircle then the
				// three edges of that triangle are added to the edge buffer and the triangle is removed from list.
				for (int j = 0; j < Triangle.Count; j++)
				{
					if (InCircle(Vertex[i], Vertex[Triangle[j].p1], Vertex[Triangle[j].p2], Vertex[Triangle[j].p3]))
					{
						Edges.Add(new Geometry.Edge(Triangle[j].p1, Triangle[j].p2));
						Edges.Add(new Geometry.Edge(Triangle[j].p2, Triangle[j].p3));
						Edges.Add(new Geometry.Edge(Triangle[j].p3, Triangle[j].p1));
						Triangle.RemoveAt(j);
						j--;
					}
				}
				if (i >= nv) continue; //In case we the last duplicate point we removed was the last in the array

				// Remove duplicate edges
				// Note: if all triangles are specified anticlockwise then all
				// interior edges are opposite pointing in direction.
				for (int j = Edges.Count - 2; j >= 0; j--)
				{
					for (int k = Edges.Count - 1; k >= j + 1; k--)
					{
						if (Edges[j].Equals(Edges[k]))
						{
							Edges.RemoveAt(k);
							Edges.RemoveAt(j);
							k--;
							continue;
						}
					}
				}
				// Form new triangles for the current point
				// Skipping over any tagged edges.
				// All edges are arranged in clockwise order.
				for (int j = 0; j < Edges.Count; j++)
				{
					if (Triangle.Count >= trimax)
						throw new ApplicationException("Exceeded maximum edges");
					Triangle.Add(new Geometry.Triangle(Edges[j].p1, Edges[j].p2, i));
				}
				Edges.Clear();
				Edges = null;
			}
			// Remove triangles with supertriangle vertices
			// These are triangles which have a vertex number greater than nv
			for (int i = Triangle.Count - 1; i >= 0; i--)
			{
				if (Triangle[i].p1 >= nv || Triangle[i].p2 >= nv || Triangle[i].p3 >= nv)
					Triangle.RemoveAt(i);
			}
			//Remove SuperTriangle vertices
			Vertex.RemoveAt(Vertex.Count - 1);
			Vertex.RemoveAt(Vertex.Count - 1);
			Vertex.RemoveAt(Vertex.Count - 1);
			Triangle.TrimExcess();
			return Triangle;
		}

		/// <summary>
		/// Returns true if the point (p) lies inside the circumcircle made up by points (p1,p2,p3)
		/// </summary>
		/// <remarks>
		/// NOTE: A point on the edge is inside the circumcircle
		/// </remarks>
		/// <param name="p">Point to check</param>
		/// <param name="p1">First point on circle</param>
		/// <param name="p2">Second point on circle</param>
		/// <param name="p3">Third point on circle</param>
		/// <returns>true if p is inside circle</returns>
		private static bool InCircle(Geometry.Point p, Geometry.Point p1, Geometry.Point p2, Geometry.Point p3)
		{
			//Return TRUE if the point (xp,yp) lies inside the circumcircle
			//made up by points (x1,y1) (x2,y2) (x3,y3)
			//NOTE: A point on the edge is inside the circumcircle

			if (System.Math.Abs(p1.Y - p2.Y) <= double.Epsilon && System.Math.Abs(p2.Y - p3.Y) <= double.Epsilon)
			{
				//INCIRCUM - F - Points are coincident !!
				return false;
			}

			double m1, m2;
			double mx1, mx2;
			double my1, my2;
			double xc, yc;
						
			if (System.Math.Abs(p2.Y - p1.Y) <= double.Epsilon)
			{
				m2 = -(p3.X - p2.X) / (p3.Y - p2.Y);
				mx2 = (p2.X + p3.X) * 0.5;
				my2 = (p2.Y + p3.Y) * 0.5;
				//Calculate CircumCircle center (xc,yc)
				xc = (p2.X + p1.X) * 0.5;
				yc = m2 * (xc - mx2) + my2;
			}
			else if (System.Math.Abs(p3.Y - p2.Y) <= double.Epsilon)
			{
				m1 = -(p2.X - p1.X) / (p2.Y - p1.Y);
				mx1 = (p1.X + p2.X) * 0.5;
				my1 = (p1.Y + p2.Y) * 0.5;
				//Calculate CircumCircle center (xc,yc)
				xc = (p3.X + p2.X) * 0.5;
				yc = m1 * (xc - mx1) + my1;
			}
			else
			{
				m1 = -(p2.X - p1.X) / (p2.Y - p1.Y);
				m2 = -(p3.X - p2.X) / (p3.Y - p2.Y);
				mx1 = (p1.X + p2.X) * 0.5;
				mx2 = (p2.X + p3.X) * 0.5;
				my1 = (p1.Y + p2.Y) * 0.5;
				my2 = (p2.Y + p3.Y) * 0.5;
				//Calculate CircumCircle center (xc,yc)
				xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
				yc = m1 * (xc - mx1) + my1;
			}

			double dx = p2.X - xc;
			double dy = p2.Y - yc;
			double rsqr = dx * dx + dy * dy;
			//double r = Math.Sqrt(rsqr); //Circumcircle radius
			dx = p.X - xc;
			dy = p.Y - yc;
			double drsqr = dx * dx + dy * dy;

			return (drsqr <= rsqr);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Triangulator\DelauneyV2.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
// Delaunay Triangulation by Paul Bourke
// http://paulbourke.net/papers/triangulate/

using UnityEngine;

namespace DungeonArchitect.Triangulator
{
    public struct DelauneyTriangle
    {
        public int p1;
        public int p2;
        public int p3;
    }

    struct IEDGE
    {
        public int p1;
        public int p2;
    }

    public class DelauneyV2
    {
        private static float EPSILON = 1e-6f;
        public static DelauneyTriangle[] Triangulate(Vector2[] vertices)
        {
            var nv = vertices.Length;

            {
                var paddedVerts = new Vector2[vertices.Length + 3];
                System.Array.Copy(vertices, paddedVerts, vertices.Length);
                paddedVerts[nv + 0] = Vector2.zero;
                paddedVerts[nv + 1] = Vector2.zero;
                paddedVerts[nv + 2] = Vector2.zero;
                vertices = paddedVerts;
            }

            var triangles = new DelauneyTriangle[nv * 3];
            for (int m = 0; m < triangles.Length; m++) triangles[m] = new DelauneyTriangle();
            
            int ntri = 0;


            bool[] complete = null;
            IEDGE[] edges = null;
            IEDGE[] p_EdgeTemp = null;
            int nedge = 0;
            int trimax, emax = 200;
            bool inside;
            int i, j, k;
            float xp, yp, x1, y1, x2, y2, x3, y3, xc = 0, yc = 0, r = 0;
            float xmin, xmax, ymin, ymax, xmid, ymid;
            float dx, dy, dmax;

            trimax = 4 * nv;
            complete = new bool[trimax];
            edges = new IEDGE[emax];
            for (int m = 0; m < edges.Length; m++) edges[m] = new IEDGE();

            xmin = vertices[0].x;
            ymin = vertices[0].y;
            xmax = xmin;
            ymax = ymin;
            for (i = 1; i < nv; i++)
            {
                if (vertices[i].x < xmin) xmin = vertices[i].x;
                if (vertices[i].x > xmax) xmax = vertices[i].x;
                if (vertices[i].y < ymin) ymin = vertices[i].y;
                if (vertices[i].y > ymax) ymax = vertices[i].y;
            }
            dx = xmax - xmin;
            dy = ymax - ymin;
            dmax = (dx > dy) ? dx : dy;
            xmid = (xmax + xmin) / 2.0f;
            ymid = (ymax + ymin) / 2.0f;
            vertices[nv + 0].x = xmid - 20 * dmax;
            vertices[nv + 0].y = ymid - dmax;
            vertices[nv + 1].x = xmid;
            vertices[nv + 1].y = ymid + 20 * dmax;
            vertices[nv + 2].x = xmid + 20 * dmax;
            vertices[nv + 2].y = ymid - dmax;
            triangles[0].p1 = nv;
            triangles[0].p2 = nv + 1;
            triangles[0].p3 = nv + 2;
            complete[0] = false;
            ntri = 1;

            for (i = 0; i < nv; i++)
            {
                xp = vertices[i].x;
                yp = vertices[i].y;
                nedge = 0;

                for (j = 0; j < ntri; j++)
                {
                    if (complete[j])
                        continue;
                    x1 = vertices[triangles[j].p1].x;
                    y1 = vertices[triangles[j].p1].y;
                    x2 = vertices[triangles[j].p2].x;
                    y2 = vertices[triangles[j].p2].y;
                    x3 = vertices[triangles[j].p3].x;
                    y3 = vertices[triangles[j].p3].y;
                    inside = CircumCircle(xp, yp, x1, y1, x2, y2, x3, y3, ref xc, ref yc, ref r);
                    if (xc + r < xp)
                        complete[j] = true;
                    if (inside)
                    {
                        if (nedge + 3 >= emax)
                        {
                            emax += 100;
                            p_EdgeTemp = new IEDGE[emax];
                            for (int m = 0; m < p_EdgeTemp.Length; m++) p_EdgeTemp[m] = new IEDGE();

                            for (int ik = 0; ik < nedge; ik++)
                            {
                                p_EdgeTemp[ik] = edges[ik];
                            }
                            edges = p_EdgeTemp;
                        }
                        edges[nedge + 0].p1 = triangles[j].p1;
                        edges[nedge + 0].p2 = triangles[j].p2;
                        edges[nedge + 1].p1 = triangles[j].p2;
                        edges[nedge + 1].p2 = triangles[j].p3;
                        edges[nedge + 2].p1 = triangles[j].p3;
                        edges[nedge + 2].p2 = triangles[j].p1;
                        nedge += 3;
                        triangles[j] = triangles[ntri - 1];
                        complete[j] = complete[ntri - 1];
                        ntri--;
                        j--;
                    }
                }
                for (j = 0; j < nedge - 1; j++)
                {
                    for (k = j + 1; k < nedge; k++)
                    {
                        if ((edges[j].p1 == edges[k].p2) && (edges[j].p2 == edges[k].p1))
                        {
                            edges[j].p1 = -1;
                            edges[j].p2 = -1;
                            edges[k].p1 = -1;
                            edges[k].p2 = -1;
                        }
                        if ((edges[j].p1 == edges[k].p1) && (edges[j].p2 == edges[k].p2))
                        {
                            edges[j].p1 = -1;
                            edges[j].p2 = -1;
                            edges[k].p1 = -1;
                            edges[k].p2 = -1;
                        }
                    }
                }
                for (j = 0; j < nedge; j++)
                {
                    if (edges[j].p1 < 0 || edges[j].p2 < 0)
                        continue;
                    triangles[ntri].p1 = edges[j].p1;
                    triangles[ntri].p2 = edges[j].p2;
                    triangles[ntri].p3 = i;
                    complete[ntri] = false;
                    ntri++;
                }
            }
            for (i = 0; i < ntri; i++)
            {
                if (triangles[i].p1 >= nv || triangles[i].p2 >= nv || triangles[i].p3 >= nv)
                {
                    triangles[i] = triangles[ntri - 1];
                    ntri--;
                    i--;
                }
            }

            var result = new DelauneyTriangle[ntri];
            System.Array.Copy(triangles, result, ntri);
            return result;
        }

        static bool CircumCircle(float xp, float yp, float x1, float y1, float x2,
            float y2, float x3, float y3, ref float xc, ref float yc, ref float r)
        {
            float m1, m2, mx1, mx2, my1, my2;
            float dx, dy, rsqr, drsqr;

            /* Check for coincident points */
            if (Mathf.Abs(y1 - y2) < EPSILON && Mathf.Abs(y2 - y3) < EPSILON)
            {
                return false;
            }

            if (Mathf.Abs(y2 - y1) < EPSILON)
            {
                m2 = -(x3 - x2) / (y3 - y2);
                mx2 = (x2 + x3) / 2.0f;
                my2 = (y2 + y3) / 2.0f;
                xc = (x2 + x1) / 2.0f;
                yc = m2 * (xc - mx2) + my2;
            }
            else if (Mathf.Abs(y3 - y2) < EPSILON)
            {
                m1 = -(x2 - x1) / (y2 - y1);
                mx1 = (x1 + x2) / 2.0f;
                my1 = (y1 + y2) / 2.0f;
                xc = (x3 + x2) / 2.0f;
                yc = m1 * (xc - mx1) + my1;
            }
            else
            {
                m1 = -(x2 - x1) / (y2 - y1);
                m2 = -(x3 - x2) / (y3 - y2);
                mx1 = (x1 + x2) / 2.0f;
                mx2 = (x2 + x3) / 2.0f;
                my1 = (y1 + y2) / 2.0f;
                my2 = (y2 + y3) / 2.0f;
                xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
                yc = m1 * (xc - mx1) + my1;
            }
            dx = x2 - xc;
            dy = y2 - yc;
            rsqr = dx * dx + dy * dy;
            r = Mathf.Sqrt(rsqr);
            dx = xp - xc;
            dy = yp - yc;
            drsqr = dx * dx + dy * dy;
            return (drsqr <= rsqr) ? true : false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\Math\IntVector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Represent an integer vector
    /// </summary>
	[System.Serializable]
	public struct IntVector {
		[SerializeField]
		public int x;

		[SerializeField]
		public int y;

		[SerializeField]
		public int z;

        public IntVector(Vector3 v)
        {
            x = Mathf.RoundToInt(v.x);
            y = Mathf.RoundToInt(v.y);
            z = Mathf.RoundToInt(v.z);
        }

        public IntVector(int x, int y, int z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public void Set(int x, int y, int z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public float DistanceSq() {
			return x * x + y * y + z * z;
		}

		public float Distance() {
			return Mathf.Sqrt(x * x + y * y + z * z);
		}

        public Vector3 ToVector3()
        {
            return new Vector3(x, y, z);
        }

		public static IntVector operator+(IntVector a, IntVector b) {
			var result = new IntVector();
			result.x = a.x + b.x;
			result.y = a.y + b.y;
			result.z = a.z + b.z;
			return result;
		}
		public static IntVector operator-(IntVector a, IntVector b) {
			var result = new IntVector();
			result.x = a.x - b.x;
			result.y = a.y - b.y;
			result.z = a.z - b.z;
			return result;
		}
		public static IntVector operator*(IntVector a, IntVector b) {
			var result = new IntVector();
			result.x = a.x * b.x;
			result.y = a.y * b.y;
			result.z = a.z * b.z;
			return result;
		}
        public static Vector3 operator *(IntVector a, Vector3 b)
        {
            var result = new Vector3();
            result.x = a.x * b.x;
            result.y = a.y * b.y;
            result.z = a.z * b.z;
            return result;
        }
		public static IntVector operator/(IntVector a, IntVector b) {
			var result = new IntVector();
			result.x = a.x / b.x;
			result.y = a.y / b.y;
			result.z = a.z / b.z;
			return result;
		}
		
		public static IntVector operator+(IntVector a, int b) {
			var result = new IntVector();
			result.x = a.x + b;
			result.y = a.y + b;
			result.z = a.z + b;
			return result;
		}
		public static IntVector operator-(IntVector a, int b) {
			var result = new IntVector();
			result.x = a.x - b;
			result.y = a.y - b;
			result.z = a.z - b;
			return result;
		}
		public static IntVector operator*(IntVector a, int b) {
			var result = new IntVector();
			result.x = a.x * b;
			result.y = a.y * b;
			result.z = a.z * b;
			return result;
		}
		public static IntVector operator/(IntVector a, int b) {
			var result = new IntVector();
			result.x = a.x / b;
			result.y = a.y / b;
			result.z = a.z / b;
			return result;
        }
        public static bool operator==(IntVector a, IntVector b)
        {
            return a.x == b.x &&
                a.y == b.y &&
                a.z == b.z;
        }

        public static bool operator !=(IntVector a, IntVector b)
        {
            return !(a == b);
        }

        public override bool Equals(System.Object obj)
		{
			if (obj is IntVector) {
				var other = (IntVector)obj;
				return this.x == other.x &&
					this.y == other.y &&
					this.z == other.z;
			}
			return false;
		}
		public override int GetHashCode()
		{
			return (x ^ (y << 16)) ^ (z << 24);
		}

		public static Vector3 ToV3(IntVector iv) {
			return new Vector3(iv.x, iv.y, iv.z);
		}


        public override string ToString()
        {
            return string.Format("({0}, {1}, {2})", x, y, z);
        }

        public static readonly IntVector Zero = new IntVector(0, 0, 0);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\Math\IntVector2.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Represent an integer vector
    /// </summary>
	[System.Serializable]
    public struct IntVector2
    {
        [SerializeField]
        public int x;

        [SerializeField]
        public int y;

        public IntVector2(Vector3 v)
        {
            x = Mathf.RoundToInt(v.x);
            y = Mathf.RoundToInt(v.y);
        }

        public IntVector2(int x, int y)
        {
            this.x = x;
            this.y = y;
        }

        public void Set(int x, int y)
        {
            this.x = x;
            this.y = y;
        }

        public int ManhattanDistance()
        {
            return x + y;
        }
        public float DistanceSq()
        {
            return x * x + y * y;
        }

        public IntVector2 Abs()
        {
            return new IntVector2(Mathf.Abs(x), Mathf.Abs(y));
        }

        public float Distance()
        {
            return Mathf.Sqrt(x * x + y * y);
        }

        public Vector2 ToVector2()
        {
            return new Vector2(x, y);
        }

        public static IntVector2 operator +(IntVector2 a, IntVector2 b)
        {
            var result = new IntVector2();
            result.x = a.x + b.x;
            result.y = a.y + b.y;
            return result;
        }
        public static IntVector2 operator -(IntVector2 a, IntVector2 b)
        {
            var result = new IntVector2();
            result.x = a.x - b.x;
            result.y = a.y - b.y;
            return result;
        }
        public static IntVector2 operator *(IntVector2 a, IntVector2 b)
        {
            var result = new IntVector2();
            result.x = a.x * b.x;
            result.y = a.y * b.y;
            return result;
        }
        public static Vector3 operator *(IntVector2 a, Vector3 b)
        {
            var result = new Vector3();
            result.x = a.x * b.x;
            result.y = a.y * b.y;
            return result;
        }
        public static IntVector2 operator /(IntVector2 a, IntVector2 b)
        {
            var result = new IntVector2();
            result.x = a.x / b.x;
            result.y = a.y / b.y;
            return result;
        }

        public static IntVector2 operator +(IntVector2 a, int b)
        {
            var result = new IntVector2();
            result.x = a.x + b;
            result.y = a.y + b;
            return result;
        }
        public static IntVector2 operator -(IntVector2 a, int b)
        {
            var result = new IntVector2();
            result.x = a.x - b;
            result.y = a.y - b;
            return result;
        }
        public static IntVector2 operator *(IntVector2 a, int b)
        {
            var result = new IntVector2();
            result.x = a.x * b;
            result.y = a.y * b;
            return result;
        }
        public static IntVector2 operator /(IntVector2 a, int b)
        {
            var result = new IntVector2();
            result.x = a.x / b;
            result.y = a.y / b;
            return result;
        }

        public static bool operator ==(IntVector2 a, IntVector2 b)
        {
            return a.x == b.x && a.y == b.y;
        }
        
        public static bool operator !=(IntVector2 a, IntVector2 b)
        {
            return !(a == b);
        }

        public override bool Equals(System.Object obj)
        {
            if (obj is IntVector2)
            {
                var other = (IntVector2)obj;
                return this.x == other.x &&
                    this.y == other.y;
            }
            return false;
        }
        public override int GetHashCode()
        {
            return (x ^ (y << 16));
        }

        public static Vector2 ToV2(IntVector2 iv)
        {
            return new Vector2(iv.x, iv.y);
        }

        public static readonly IntVector2 Zero = new IntVector2(0, 0);
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\Math\Rectangle.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect
{
    /// <summary>
    /// Represents an integer rectangle
    /// </summary>
	[System.Serializable]
	public struct Rectangle {
		public Rectangle(int x, int z, int width, int length) {
			location = new IntVector(x, 0, z);
			size = new IntVector(width, 0, length);
		}
		public Rectangle(IntVector location, IntVector size) {
			this.location = location;
			this.size = size;
		}

		[SerializeField]
		IntVector location;
		public IntVector Location {
			get {
				return location;
			}
			set {
				location = value;
			}
		}
		
		[SerializeField]
		IntVector size;
		public IntVector Size {
			get {
				return size;
			}
			set {
				size = value;
			}
		}

		public int X {
			get { return Location.x; }
		}
		public int Z {
			get { return Location.z; }
		}
		public int Width {
			get { return Size.x; }
		}
		public int Length {
			get { return Size.z; }
		}

		public int Left { get { return X; } }
		public int Right { get { return X + Width; } }
		public int Back { get { return Z; } }
		public int Front { get { return Z + Length; } }

		public void SetY(int y) {
			location.y = y;
		}

		public IntVector Center() {
			return Location + Size / 2;
		}

		static Vector3 ToVector3(IntVector iv) {
			return new Vector3(iv.x, iv.y, iv.z);
		}

		public Vector3 CenterF() {
			return ToVector3(Location) + ToVector3(Size) / 2.0f;
		}

		public bool Contains(Rectangle rect) {
			return(X <= rect.X) &&
				((rect.X + rect.Width) <= (X + Width)) &&
					(Z <= rect.Z) &&
					((rect.Z + rect.Length) <= (Z + Length));
		}
		
		public bool Contains(IntVector Point) {
			return Contains(Point.x, Point.z);
		}
		
		public bool Contains(int x, int z) {
			return this.X <= x &&
				x < this.X + this.Width &&
					this.Z <= z &&
					z < this.Z + this.Length;
		}
		
		public static Rectangle Intersect(Rectangle a, Rectangle b) {
			int x1 = Mathf.Max(a.X, b.X);
			int x2 = Mathf.Min(a.X + a.Width, b.X + b.Width);
			int z1 = Mathf.Max(a.Z, b.Z);
			int z2 = Mathf.Min(a.Z + a.Length, b.Z + b.Length);
			
			if (x2 >= x1 && z2 >= z1) {
				return new Rectangle(x1, z1, x2 - x1, z2 - z1);
			}
			return new Rectangle();
		}
		
		public bool IntersectsWith(Rectangle rect) {
			return(rect.X < X + Width) &&
				(X < (rect.X + rect.Width)) &&
					(rect.Z < Z + Length) &&
					(Z < rect.Z + rect.Length);
		}

        

        public static Rectangle ExpandBounds(Rectangle rect, int distance)
        {
            
            var location = rect.Location;
            var size = rect.Size;

            location.x -= distance;
            location.z -= distance;

            size.x += distance * 2;
            size.z += distance * 2;

            var result = rect;
            result.location = location;
            result.size = size;

            return result;
        }

        public IntVector[] GetBorderPoints()
        {
            var result = new List<IntVector>();
            for (int dx = 0; dx < size.x; dx++)
            {
                var x = location.x + dx;
                var y = location.y;
                var z = location.z;
                var point = new IntVector(x, y, z);
                result.Add(point);

				if (size.z > 1) {
	                z = location.z + size.z - 1;
	                point = new IntVector(x, y, z);
	                result.Add(point);
				}
            }

            for (int dz = 1; dz < size.z - 1; dz++)
            {
                var x = location.x;
                var y = location.y;
                var z = location.z + dz;
                var point = new IntVector(x, y, z);
                result.Add(point);

				if (size.x > 1) {
	                x = location.x + size.x - 1;
	                point = new IntVector(x, y, z);
	                result.Add(point);
				}
            }

            return result.ToArray();
        }
	};

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Common\Noise\GradientNoise.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Utils.Noise
{

    public interface INoiseTable<T>
    {
        void Init(int InSize, System.Random random);
        float GetNoise(float u, float v);
        NoiseTableCell<T> GetCell(float x, float y);
    }

    public interface INoisePolicy<T>
    {
        float Sample(float x, float y, INoiseTable<T> NoiseTable);
        T GetRandom(System.Random random);
    }

    public struct NoiseTableCell<T>
    {
        public T N00;
        public T N10;
        public T N01;
        public T N11;
    };

    public abstract class NoiseTable<T> : INoiseTable<T>
    {
        private int size;
        private List<T> data = new List<T>();
        protected INoisePolicy<T> noisePolicy;

        protected abstract INoisePolicy<T> CreateNoisePolicy();

	    public void Init(int size, System.Random random) {
		    this.size = size;
            noisePolicy = CreateNoisePolicy();

            int NumElements = size * size;
            data = new List<T>(new T[NumElements]);

		    int LastIdx = size - 1;
			for (int y = 0; y < size; y++) {
				for (int x = 0; x < size; x++) {
					if (x == LastIdx || y == LastIdx) {
						int ix = x % LastIdx;
						int iy = y % LastIdx;
						data[IDX(x, y)] = data[IDX(ix, iy)];
					}
					else {
                        data[IDX(x, y)] = noisePolicy.GetRandom(random);
					}
				}
			}
	    }

        public NoiseTableCell<T> GetCell(float x, float y)
        {
            int x0 = Mathf.FloorToInt(x) % size;
            int y0 = Mathf.FloorToInt(y) % size;
            int x1 = (x0 + 1) % size;
            int y1 = (y0 + 1) % size;

            var cell = new NoiseTableCell<T>();
            cell.N00 = data[IDX(x0, y0)];
            cell.N10 = data[IDX(x1, y0)];
            cell.N01 = data[IDX(x0, y1)];
            cell.N11 = data[IDX(x1, y1)];
            return cell;
        }

        public float GetNoise(float u, float v)
        {
            float x = u * (size - 1);
            float y = v * (size - 1);

            return noisePolicy.Sample(x, y, this);
        }

        public float GetNoiseFBM(Vector2 p, int octaves)
        {
            p /= size;
            float noise = 0;
            float amp = 1; // 0.457345f;
            for (int i = 0; i < octaves; i++)
            {
                noise += amp * GetNoise(p.x, p.y);
                p *= 1.986576f;
                amp *= 0.5f;
            }
            noise = 0.5f + noise * 0.5f;
            return Mathf.Clamp01(noise);
        }

        T GetTableData(int x, int y)
        {
            return data[IDX(x, y)];
        }

        int GetSize()
        {
            return size;
        }

        int IDX(int x, int y)
        {
            return y * size + x;
        }
    }

    public class GradientNoisePolicy : INoisePolicy<Vector2>
    {
        public float Sample(float x, float y, INoiseTable<Vector2> NoiseTable)
        {
            var Cell = NoiseTable.GetCell(x, y);

            float fx = x % 1;
            float fy = y % 1;
            var P = new Vector2(fx, fy);

            return Mathf.Lerp(
                Mathf.Lerp(
                    Vector2.Dot(Cell.N00, P - new Vector2(0, 0)),
                    Vector2.Dot(Cell.N10, P - new Vector2(1, 0)),
                    fx),
                Mathf.Lerp(
                    Vector2.Dot(Cell.N01, P - new Vector2(0, 1)),
                    Vector2.Dot(Cell.N11, P - new Vector2(1, 1)),
                    fx),
                fy);
        }

        public Vector2 GetRandom(System.Random random)
        {
            var angle = random.NextFloat() * Mathf.PI * 2.0f;
            return new Vector2(
                Mathf.Cos(angle),
                Mathf.Sin(angle));
        }
    }

    public class GradientNoiseTable : NoiseTable<Vector2>
    {
        protected override INoisePolicy<Vector2> CreateNoisePolicy()
        {
            return new GradientNoisePolicy();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\FlowAssetBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Exec;
using UnityEngine;

namespace DungeonArchitect.Flow
{
    [System.Serializable]
    public class FlowAssetBase : ScriptableObject
    {
        [HideInInspector]
        [SerializeField]
        public FlowExecGraph execGraph;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\FlowExecutor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains;
using UnityEngine;

namespace DungeonArchitect.Flow.Exec
{
    public class FlowExecutionContext
    {
        public System.Random Random { get; set; }
        public FlowExecGraph ExecGraph { get; set; }
        public FlowExecNodeOutputRegistry NodeOutputRegistry { get; set; }
        public FlowDomainExtensions DomainExtensions { get; set; }
        public HashSet<FlowExecRuleGraphNode> Visited { get; private set; }

        public FlowExecutionContext()
        {
            Visited = new HashSet<FlowExecRuleGraphNode>();
        }
    }

    public class FlowExecutor
    {
        public int RetriesUsed { get; set; } = 0;
        
        public bool Execute(FlowExecGraph execGraph, System.Random random, FlowDomainExtensions domainExtensions, int numTries, out FlowExecNodeOutputRegistry nodeOutputRegistry)
        {
            if (execGraph == null || random == null)
            {
                Debug.LogError("Invalid asset state");
                nodeOutputRegistry = null;
                return false;
            }

            if (execGraph.resultNode == null)
            {
                Debug.LogError("Cannot find result node in Execution Graph");
                nodeOutputRegistry = null;
                return false;
            }

            RetriesUsed = 0;
            FlowTaskExecutionResult lastRunStatus = FlowTaskExecutionResult.FailHalt;
            while (RetriesUsed < numTries) {
                RetriesUsed++;

                var context = new FlowExecutionContext();
                context.ExecGraph = execGraph;
                context.Random = random;
                context.DomainExtensions = domainExtensions;
                context.NodeOutputRegistry = new FlowExecNodeOutputRegistry(); 

                var taskOutput = ExecuteGraph(context);
                lastRunStatus = (taskOutput != null) ? taskOutput.ExecutionResult : FlowTaskExecutionResult.FailHalt; 
                if (lastRunStatus == FlowTaskExecutionResult.Success)
                {
                    //if (tries > 1) {
                    //    Debug.Log("Num Tries: " + tries);
                    //}
                    nodeOutputRegistry = context.NodeOutputRegistry;
                    return true;
                }
                else if (lastRunStatus == FlowTaskExecutionResult.FailHalt)
                {
                    break;
                }
            }

            nodeOutputRegistry = null;
            return false;
        }

        private FlowTaskExecOutput ExecuteGraph(FlowExecutionContext context)
        {
            foreach (var node in context.ExecGraph.Nodes)
            {
                var execNode = node as FlowExecRuleGraphNode;
                if (execNode != null)
                {
                    execNode.executionStatus = new GridFlowGraphNodeExecutionStatus();
                }
            }
            return ExecuteNode(context, context.ExecGraph.resultNode);
        }

        private FlowTaskExecOutput ExecuteNode(FlowExecutionContext context, FlowExecRuleGraphNode execNode)
        {
            context.Visited.Add(execNode);

            execNode.executionStatus.ExecutionStage = GridFlowGraphNodeExecutionStage.WaitingToExecute;

            var incomingNodes = FlowExecGraphUtils.GetIncomingNodes(execNode);
            var incomingTaskOutputs = new List<FlowTaskExecOutput>();
            foreach (var incomingNode in incomingNodes)
            {
                FlowTaskExecOutput incomingTaskOutput = null;
                if (!context.Visited.Contains(incomingNode))
                {
                    incomingTaskOutput = ExecuteNode(context, incomingNode);
                    if (incomingTaskOutput.ExecutionResult != FlowTaskExecutionResult.Success)
                    {
                        return incomingTaskOutput;
                    }
                }
                else
                {
                    incomingTaskOutput = context.NodeOutputRegistry.Get(incomingNode.Id);
                }
                
                incomingTaskOutputs.Add(incomingTaskOutput);
                Debug.Assert(incomingTaskOutput != null);
            }

            var taskContext = new FlowTaskExecContext();
            taskContext.Random = context.Random;
            taskContext.DomainExtensions = context.DomainExtensions;
            
            var taskInput = new FlowTaskExecInput();
            taskInput.IncomingTaskOutputs = incomingTaskOutputs.ToArray();

            var taskOutput = execNode.task.Execute(taskContext, taskInput);
            {
                execNode.executionStatus.ErrorMessage = taskOutput.ErrorMessage;
                execNode.executionStatus.Success = taskOutput.ExecutionResult;
                execNode.executionStatus.ExecutionStage = GridFlowGraphNodeExecutionStage.Executed;
                context.NodeOutputRegistry.Register(execNode.Id, taskOutput);
            }

            return taskOutput;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\FlowDomainData.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;

namespace DungeonArchitect.Flow.Domains
{
    public interface IFlowDomainData
    {
        IFlowDomainData Clone();
    }
    
    [System.Serializable]
    public class FlowDomainDataRegistry
    {
        private Dictionary<System.Type, IFlowDomainData> crossDomainData = new Dictionary<System.Type, IFlowDomainData>();
        
        public T Get<T>() where T : IFlowDomainData, new()
        {
            if (crossDomainData.ContainsKey(typeof(T)))
            {
                return (T)crossDomainData[typeof(T)];
            }

            T data = new T();
            crossDomainData.Add(typeof(T), data);
            return data;
        }

        public void Set<T>(T data) where T : IFlowDomainData, new()
        {
            crossDomainData[typeof(T)] = data;
        }
        
        public FlowDomainDataRegistry Clone()
        {
            var clone = new FlowDomainDataRegistry();
            foreach (var entry in crossDomainData)
            {
                var type = entry.Key;
                var clonedData = entry.Value.Clone();
                clone._Internal_AddDomainData(type, clonedData as IFlowDomainData);
            }

            return clone;
        }
        
        private void _Internal_AddDomainData(System.Type type, IFlowDomainData data)
        {
            if (crossDomainData.ContainsKey(type))
            {
                crossDomainData.Remove(type);
            }
            
            crossDomainData.Add(type, data);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\FlowDomainExtensions.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;

namespace DungeonArchitect.Flow.Domains
{
    public interface IFlowDomainExtension
    {
    }

    public class FlowDomainExtensions
    {
        private Dictionary<System.Type, IFlowDomainExtension> extensions = new Dictionary<System.Type, IFlowDomainExtension>();
        
        public T GetExtension<T>() where T : IFlowDomainExtension, new()
        {
            if (extensions.ContainsKey(typeof(T)))
            {
                return (T)extensions[typeof(T)];
            }

            T data = new T();
            extensions.Add(typeof(T), data);
            return data;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\IFlowDomain.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Flow.Domains
{
    public interface IFlowDomain
    {
        System.Type[] SupportedTasks { get; }
        string DisplayName { get; }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\GridFlowAsset.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Flow.Impl.GridFlow
{
    [System.Serializable]
    public class GridFlowAsset : FlowAssetBase
    {
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\GridFlowConstants.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Flow.Impl.GridFlow
{
    public class GridFlowConstants
    {
        public static readonly float LayoutNodeEditorSpacing = 120.0f;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\GridFlowDomains.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Linq;
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;

namespace DungeonArchitect.Flow.Impl.GridFlow
{
    public class GridFlowTilemapDomain : IFlowDomain
    {
        public Type[] SupportedTasks { get => supportedTypes; }
        public string DisplayName { get => displayName; }
        
        private static readonly string displayName = "Tilemap";
        private static readonly Type[] supportedTypes = new Type[]
        {
            typeof(GridFlowTilemapTaskInitialize),
            typeof(GridFlowTilemapTaskCreateOverlay),
            typeof(GridFlowTilemapTaskCreateElevations),
            typeof(GridFlowTilemapTaskMerge),
            typeof(GridFlowTilemapTaskOptimize),
            typeof(GridFlowTilemapTaskFinalize)
        };
    }
    
    public class GridFlowLayoutGraphDomain : IFlowDomain
    {
        public Type[] SupportedTasks { get => supportedTypes; }
        public string DisplayName { get => displayName; }
        
        private static readonly string displayName = "Layout Graph";
        private static readonly Type[] internalTaskTypes = new Type[]
        {
            typeof(GridFlowLayoutTaskCreateGrid),
            typeof(GridFlowLayoutTaskCreateMainPath),
            typeof(GridFlowLayoutTaskCreatePath),
            typeof(GridFlowLayoutTaskSpawnItems),
            typeof(GridFlowLayoutTaskCreateKeyLock),
            typeof(GridFlowLayoutTaskMirrorGraph),
            typeof(GridFlowLayoutTaskFinalizeGraph)
        };

        private static readonly Type[] supportedTypes;
        static GridFlowLayoutGraphDomain()
        {
            var assemblies = System.AppDomain.CurrentDomain.GetAssemblies();
            var handlers = new List<System.Type>();
            handlers.AddRange(internalTaskTypes);
            foreach (var assembly in assemblies)
            {
                var asmHandlers = (from t in assembly.GetTypes()
                    where t.IsClass && t.IsSubclassOf(typeof(FlowExecTask)) && Attribute.GetCustomAttribute(t, typeof(GridFlowCustomTaskAttribute)) != null
                    select t).ToArray();

                if (asmHandlers.Length > 0)
                {
                    handlers.AddRange(asmHandlers.ToArray());
                }
            }

            supportedTypes = handlers.ToArray();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\GridFlowDomainStructures.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;

namespace DungeonArchitect.Flow.Impl.GridFlow
{
    [System.Serializable]
    public enum GridFlowLayoutNodeRoomType
    {
        Unknown,
        Room,
        Corridor,
        Cave
    }
    
    public class GridFlowTilemapDomainData : IFlowDomainData
    {
        public GridFlowLayoutNodeRoomType RoomType = GridFlowLayoutNodeRoomType.Unknown;
        public IFlowDomainData Clone()
        {
            var clone = new GridFlowTilemapDomainData();
            clone.RoomType = RoomType;
            return clone;
        }
    }


    public class GridFlowTilemapState : ICloneable
    {
        public TilemapFlowNodeWallGenerationMethod WallGenerationMethod = TilemapFlowNodeWallGenerationMethod.WallAsTiles;

        public object Clone()
        {
            var clone = new GridFlowTilemapState();
            clone.WallGenerationMethod = WallGenerationMethod;
            return clone;
        }
    }
    
    public class GridFlowLayoutNodeState : IFlowDomainData
    {
        public bool CanPerturb = true;
        public IFlowDomainData Clone()
        {
            var clone = new GridFlowLayoutNodeState();
            clone.CanPerturb = CanPerturb;
            return clone;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\SnapGridFlowDomains.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{
    public class SnapGridFlowLayoutGraph3DDomain : IFlowDomain
    {
        public Type[] SupportedTasks { get; } = supportedTypes;
        public string DisplayName { get; } = "Layout Graph";
        
        private static readonly Type[] supportedTypes = new Type[]
        {
            typeof(SGFLayoutTaskCreateGrid),
            typeof(SGFLayoutTaskCreatePath),
            typeof(SGFLayoutTaskCreateMainPath),
            typeof(SGFLayoutTaskSpawnItems),
            typeof(SGFLayoutTaskCreateKeyLock),
            typeof(SGFLayoutTaskFinalizeGraph),
            typeof(SGFLayoutTaskExpandGridSize),
            typeof(SGFLayoutTaskAddPadding),
        };
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\SnapGridFlowLayoutGraphSupport.cs:
  //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{	
	struct NodeGroupSettings
	{
		public float Weight;
		public Vector3Int GroupSize;

		public SgfModuleDatabaseItem Module;
		public int ModuleAssemblyIdx;
		public string Category;
            
		public Vector3Int[] LocalSurfaceCoords;
		public Vector3Int[] LocalVolumeCoords;
	}

	/*
	internal struct SGFGroupConnectionInfo
	{
		public Vector3Int EdgeNodeCoord;
		public Vector3Int RemoteNodeCoord;
		public string Category;
	}
	*/
	
	internal class SGFNodeGroupUserData : IFlowDomainData
	{
		public SgfModuleDatabaseItem Module;
		public int ModuleAssemblyIdx;
		//public SGFGroupConnectionInfo[] ModuleAssemblyConnections;

		public IFlowDomainData Clone()
		{
			var clone = new SGFNodeGroupUserData()
			{
				Module = Module,
				ModuleAssemblyIdx = ModuleAssemblyIdx,
				//ModuleAssemblyConnections = new SGFGroupConnectionInfo[ModuleAssemblyConnections.Length]
			};
			//Array.Copy(ModuleAssemblyConnections, clone.ModuleAssemblyConnections, ModuleAssemblyConnections.Length);
			
			return clone;
		}
	}
	
    public class SnapFlowLayoutNodeGroupGenerator : FlowLayoutNodeGroupGenerator
    {
        private NodeGroupSettings[] groupSettings;
        //private static FLocalCoordBuilder coordBuilder = new FLocalCoordBuilder();
        private int minGroupSize = 1;
        private ISGFLayoutTaskPathBuilder pathingTask;
        private SnapGridFlowModuleDatabase moduleDatabase;
        
        public SnapFlowLayoutNodeGroupGenerator(SnapGridFlowModuleDatabase moduleDatabase, ISGFLayoutTaskPathBuilder pathingTask, System.Random random)
        {
	        this.moduleDatabase = moduleDatabase;
	        this.pathingTask = pathingTask;
            if (moduleDatabase != null)
            {
	            var settings = new List<NodeGroupSettings>();
	            foreach (var module in moduleDatabase.Modules)
	            {
		            for (int AsmIdx = 0; AsmIdx < module.RotatedAssemblies.Length; AsmIdx++)
		            {
			            var assembly = module.RotatedAssemblies[AsmIdx];
			            var groupSize = assembly.numChunks;
			            var setting = new NodeGroupSettings()
			            {
				            Weight = module.SelectionWeight,
				            GroupSize = groupSize,
				            Module = module,
				            ModuleAssemblyIdx = AsmIdx,
				            Category = module.Category
			            };
			            settings.Add(setting);
		            }

		            groupSettings = settings.ToArray();
	            }

	            if (groupSettings != null)
	            {
		            minGroupSize = int.MaxValue;
		            foreach (var setting in groupSettings)
		            {
			            var groupSize = setting.GroupSize.x * setting.GroupSize.y * setting.GroupSize.z;
			            minGroupSize = Mathf.Min(minGroupSize, groupSize);
		            }
	            }
	            else
	            {
		            groupSettings = new NodeGroupSettings[0];
	            }

	            /*
	            // Build the group weights
                var groupWeights = new Dictionary<Vector3Int, float>();
                {
	                var groupCounts = new Dictionary<Vector3Int, int>();
	                foreach (var module in moduleDatabase.Modules)
	                {
		                var chunkSizes = new List<Vector3Int>();
		                chunkSizes.Add(module.NumChunks);
		                if (module.allowRotation)
		                {
			                var rotatedNumChunks = new Vector3Int(module.NumChunks.z, module.NumChunks.y, module.NumChunks.x);
			                chunkSizes.Add(rotatedNumChunks);
		                }
		                foreach (var chunkSize in chunkSizes)
		                {
			                if (!groupWeights.ContainsKey(chunkSize))
			                {
				                groupWeights[chunkSize] = 0;
			                }

			                groupWeights[chunkSize] += module.SelectionWeight;

			                if (!groupCounts.ContainsKey(chunkSize))
			                {
				                groupCounts[chunkSize] = 0;
			                }

			                groupCounts[chunkSize] = groupCounts[chunkSize] + 1;
		                }
	                }

	                // Average out the weights
	                var keys = groupWeights.Keys.ToArray();
	                foreach (var key in keys)
	                {
		                var value = groupWeights[key];
		                var count = groupCounts[key];
		                groupWeights[key] = value / count;
	                }
                }

                var settingList = new List<NodeGroupSettings>();
                foreach (var entry in groupWeights) {
                    
                    var setting = new NodeGroupSettings()
                    {
                        Weight = entry.Value,
                        GroupSize = entry.Key
                    };
                    settingList.Add(setting);
                }

                groupSettings = settingList.ToArray();
                */
            }
            else
            {
                var setting = new NodeGroupSettings()
                {
                    Weight = 1,
                    GroupSize = new Vector3Int(1, 1, 1)
                };
                groupSettings = new NodeGroupSettings[] {setting};
            }
            
            for (int i = 0; i < groupSettings.Length; i++)
            {
	            var setting = groupSettings[i];
	            var assembly = setting.Module.RotatedAssemblies[setting.ModuleAssemblyIdx];
	            FLocalCoordBuilder.GetCoords(assembly, out groupSettings[i].LocalVolumeCoords, out groupSettings[i].LocalSurfaceCoords);
            }
        }

        public override int GetMinNodeGroupSize()
        {
            return minGroupSize;
        }

        
        public override FlowLayoutPathNodeGroup[] Generate(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode currentNode, int pathIndex, int pathLength, System.Random random, HashSet<DungeonUID> visited)
        {
	        if (currentNode == null) {
		        return new FlowLayoutPathNodeGroup[0];
	        }

	        if (groupSettings.Length == 0 || moduleDatabase == null) {
		        var nullGenerator = new NullFlowLayoutNodeGroupGenerator();
		        return nullGenerator.Generate(graphQuery, currentNode, pathIndex, pathLength, random, visited);
	        }

	        var allowedCategories = new HashSet<string>(pathingTask.GetCategoriesAtNode(pathIndex, pathLength));
	        
	        var filteredGroupSettings = new List<NodeGroupSettings>();
            foreach (var groupSetting in groupSettings)
            {
	            if (allowedCategories.Contains(groupSetting.Category))
	            {
		            filteredGroupSettings.Add(groupSetting);
	            }
            }

            var currentNodeCoord = MathUtils.RoundToVector3Int(currentNode.coord);
            var result = new List<FlowLayoutPathNodeGroup>();
	        foreach (var groupSetting in filteredGroupSettings)
            {
		        foreach (var localSurfaceCoord in groupSetting.LocalSurfaceCoords) {
			        bool valid = true;
			        var baseCoord = currentNodeCoord - localSurfaceCoord;
			        foreach (var localVolumeCoord in groupSetting.LocalVolumeCoords) {
				        var groupNodeCoord = baseCoord + localVolumeCoord;
                        var testNode = graphQuery.GetNodeObjAtCoord(groupNodeCoord);
 				        if (testNode == null || visited.Contains(testNode.nodeId) || testNode.active) {
					        valid = false;
					        break;
				        }
			        }

			        if (valid) {
				        // Add this group
                        var newGroup = new FlowLayoutPathNodeGroup();
				        newGroup.IsGroup = true;
				        newGroup.Weight = groupSetting.Weight;
				        foreach (var localVolumeCoord in groupSetting.LocalVolumeCoords) {
					        var nodeCoord = baseCoord + localVolumeCoord;
                            var groupNode = graphQuery.GetNodeObjAtCoord(nodeCoord);
                            if (groupNode != null)
                            {
                                newGroup.GroupNodes.Add(groupNode.nodeId);
                            }
                        }
				        foreach (var surfCoord in groupSetting.LocalSurfaceCoords) {
					        var nodeCoord = baseCoord + surfCoord;
                            var groupNode = graphQuery.GetNodeObjAtCoord(nodeCoord);
					        newGroup.GroupEdgeNodes.Add(groupNode.nodeId);
				        }

				        var userdata = new SGFNodeGroupUserData();
				        userdata.Module = groupSetting.Module;
				        userdata.ModuleAssemblyIdx = groupSetting.ModuleAssemblyIdx;
				        newGroup.userdata = userdata;
				        
                        result.Add(newGroup);
			        }
		        }
	        }

            return result.ToArray();
        }

        class FLocalCoordBuilder {
            public static void GetCoords(SgfModuleAssembly assembly, out Vector3Int[] outVolumeCoords, out Vector3Int[] outSurfaceCoords) {
	            var numChunks = assembly.numChunks;
	            List<Vector3Int> volumeCoords;

	            // Process the volume coords
	            if (_volumeCoordsMap.ContainsKey(numChunks))
                {
	                volumeCoords = _volumeCoordsMap[numChunks];
                }
	            else
	            {
		            volumeCoords = new List<Vector3Int>();
		            for (int dz = 0; dz < numChunks.z; dz++) {
			            for (int dy = 0; dy < numChunks.y; dy++) {
				            for (int dx = 0; dx < numChunks.x; dx++) {
					            volumeCoords.Add(new Vector3Int(dx, dy, dz));
				            }
			            }
		            }
		            _volumeCoordsMap.Add(numChunks, volumeCoords);		            
	            }

	            // Process the surface coords
	            var surfaceCoords = new HashSet<Vector3Int>();
	            {
		            // Process along the X-axis
		            {
		                for (int x = 0; x < numChunks.x; x++)
		                {
		                    for (int y = 0; y < numChunks.y; y++)
		                    {
			                    var cellFront = assembly.front.Get(x, y);
			                    var cellBack = assembly.back.Get(numChunks.x - 1 - x, y);
			                    if (cellFront.HasConnection()) surfaceCoords.Add(new Vector3Int(x, y, 0));
			                    if (cellBack.HasConnection()) surfaceCoords.Add(new Vector3Int(x, y, numChunks.z - 1));
		                    }
		                }
		            }

		            // Process along the Z-axis
		            {
		                for (int z = 0; z < numChunks.z; z++)
		                {
		                    for (int y = 0; y < numChunks.y; y++)
		                    {
			                    var cellRight = assembly.right.Get(numChunks.z - 1 - z, y);
			                    var cellLeft = assembly.left.Get(z, y);
			                    if (cellRight.HasConnection()) surfaceCoords.Add(new Vector3Int(0, y, z));
			                    if (cellLeft.HasConnection()) surfaceCoords.Add(new Vector3Int(numChunks.x - 1, y, z));
		                    }
		                }
		            }

		            // Process along the Y-axis
		            {
		                for (int x = 0; x < numChunks.x; x++)
		                {
		                    for (int z = 0; z < numChunks.z; z++)
		                    {
			                    var cellDown = assembly.down.Get(x, z);
			                    var cellTop = assembly.top.Get(x, z);
			                    if (cellDown.HasConnection()) surfaceCoords.Add(new Vector3Int(x, 0, z));
			                    if (cellTop.HasConnection()) surfaceCoords.Add(new Vector3Int(x, numChunks.y - 1, z));
		                    }
		                }
		            }
	            }

	            outVolumeCoords = volumeCoords.ToArray();
                outSurfaceCoords = surfaceCoords.ToArray();
            }
	
            private static Dictionary<Vector3Int, List<Vector3Int>> _volumeCoordsMap = new Dictionary<Vector3Int, List<Vector3Int>>();
        };
    }

    public class SnapFlowLayoutGraphConstraints : IFlowLayoutGraphConstraints
    {
        private SnapGridFlowModuleDatabase moduleDatabase;
        private ISGFLayoutTaskPathBuilder pathingTask;
        private System.Random random;

        public SnapFlowLayoutGraphConstraints(SnapGridFlowModuleDatabase moduleDatabase, ISGFLayoutTaskPathBuilder pathingTask, System.Random random)
        {
            this.moduleDatabase = moduleDatabase;
            this.pathingTask = pathingTask;
            this.random = random;
        }
        
        public bool IsValid(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode node, FlowLayoutGraphNode[] incomingNodes)
        {
            var graph = graphQuery.Graph;
            if (graph == null) return false;
            Debug.Assert(node != null && node.pathIndex != -1);


            var allIncomingNodes = new HashSet<FlowLayoutGraphNode>(incomingNodes);

            foreach (var link in graph.Links)
            {
	            if (link.state.type == FlowLayoutGraphLinkType.Unconnected)
	            {
		            continue;
	            }

	            if (link.destination == node.nodeId)
	            {
		            var sourceNode = link.sourceSubNode.IsValid() 
							? graphQuery.GetSubNode(link.sourceSubNode)
							: graphQuery.GetNode(link.source);
		            
		            Debug.Assert(sourceNode != null, "Invalid source node");
		            allIncomingNodes.Add(sourceNode);
	            }
	            if (link.source == node.nodeId)
	            {
		            var destNode = link.destinationSubNode.IsValid()
						? graphQuery.GetSubNode(link.destinationSubNode)
						: graphQuery.GetNode(link.destination);
		            
		            Debug.Assert(destNode != null, "Invalid dest node");
		            allIncomingNodes.Add(destNode);
	            }
            }

            FlowLayoutPathNodeGroup group;
            FFAGConstraintsLink[] constraintLinks;
            BuildNodeGroup(graphQuery, node, allIncomingNodes.ToArray(), out group, out constraintLinks);
            
            var nodeSnapData = node.GetDomainData<FlowLayoutNodeSnapDomainData>();
            if (nodeSnapData == null || nodeSnapData.Categories.Length == 0) {
                return false;
            }

            return IsValid(graphQuery, group, constraintLinks, nodeSnapData.Categories);
        }

        public bool IsValid(FlowLayoutGraphQuery graphQuery, FlowLayoutPathNodeGroup group, int pathIndex, int pathLength, FFAGConstraintsLink[] incomingNodes)
        {
            var allowedCategories = pathingTask.GetCategoriesAtNode(pathIndex, pathLength);
            return IsValid(graphQuery, group, incomingNodes.ToArray(), allowedCategories);
        }

        private bool IsValid(FlowLayoutGraphQuery graphQuery, FlowLayoutPathNodeGroup group, FFAGConstraintsLink[] incomingNodes, string[] allowedCategories)	// TODO: Get rid of allowedCategory
        {
            if (group == null || group.GroupEdgeNodes.Count == 0 || group.GroupNodes.Count == 0) return false;


            SGFNodeGroupUserData sgfUserData = group.userdata as SGFNodeGroupUserData;
            Debug.Assert(sgfUserData != null, "Invalid SGF user group data");
            
            var registeredAssembly = sgfUserData.Module.RotatedAssemblies[sgfUserData.ModuleAssemblyIdx];
            
            // Build the input node assembly
            SgfModuleAssembly assembly;
            SGFModuleAssemblyBuilder.Build(graphQuery, group, incomingNodes, out assembly);
            
            SgfModuleAssemblySideCell[] doorIndices;
            if (registeredAssembly.CanFit(assembly, out doorIndices)) {
	            return true;
            }
        
            return false;
        }
        
        public static void BuildNodeGroup(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode node, FlowLayoutGraphNode[] incomingNodes, 
                out FlowLayoutPathNodeGroup outGroup, out FFAGConstraintsLink[] outConstraintLinks)
        {
	        var graph = graphQuery.Graph;
	        outGroup = new FlowLayoutPathNodeGroup();
	        if (graph == null)
	        {
		        outGroup = null;
		        outConstraintLinks = new FFAGConstraintsLink[0];
		        return;
	        }
	        

			Vector3Int minCoord = Vector3Int.zero;
			Vector3Int maxCoord = Vector3Int.zero;
			if (node.MergedCompositeNodes.Count <= 1) {
				outGroup.IsGroup = false;
				outGroup.GroupNodes.Add(node.nodeId);
				outGroup.GroupEdgeNodes.Add(node.nodeId);
				minCoord = maxCoord = MathUtils.RoundToVector3Int(node.coord);
			}
			else {
				outGroup.IsGroup = true;
				var minCoordF = node.MergedCompositeNodes[0].coord;
				var maxCoordF = minCoordF;

				foreach (var subNode in node.MergedCompositeNodes) {
					minCoordF = MathUtils.ComponentMin(minCoordF, subNode.coord);
					maxCoordF = MathUtils.ComponentMax(maxCoordF, subNode.coord);
					outGroup.GroupNodes.Add(subNode.nodeId);
				}
				minCoord = MathUtils.RoundToVector3Int(minCoordF);
				maxCoord = MathUtils.RoundToVector3Int(maxCoordF);

				foreach (var subNode in node.MergedCompositeNodes) {
					var coord = MathUtils.RoundToVector3Int(subNode.coord);
					if (coord.x == minCoord.x || coord.y == minCoord.y || coord.z == minCoord.z ||
						coord.x == maxCoord.x || coord.y == maxCoord.y || coord.z == maxCoord.z) {
						outGroup.GroupEdgeNodes.Add(subNode.nodeId);
					}
				}
			}
			
			var sgfUserData = node.GetDomainData<SGFNodeGroupUserData>();
			outGroup.userdata = sgfUserData;
			Debug.Assert(sgfUserData.Module != null, "SGF node group doesn't have correct module user data assigned");

			var constraintLinkList = new List<FFAGConstraintsLink>();
			
			foreach (var link in graph.Links) {
				if (link.state.type == FlowLayoutGraphLinkType.Unconnected) continue;

				var source = link.sourceSubNode.IsValid() ? link.sourceSubNode : link.source;
				var destination = link.destinationSubNode.IsValid() ? link.destinationSubNode : link.destination;

				var bHostsSource = outGroup.GroupNodes.Contains(source);
				var bHostsDest = outGroup.GroupNodes.Contains(destination);
				if (!bHostsSource && !bHostsDest) continue;
				if (bHostsSource && bHostsDest) continue;

				if (bHostsSource) {
					if (outGroup.GroupEdgeNodes.Contains(source)) {
						var sourceNode = graphQuery.GetNode(source);
						if (sourceNode == null) sourceNode = graphQuery.GetSubNode(source);
						var destinationNode = graphQuery.GetNode(destination);
						if (destinationNode == null) destinationNode = graphQuery.GetSubNode(destination);
						if (sourceNode != null && destinationNode != null) {
							constraintLinkList.Add(new FFAGConstraintsLink(sourceNode, destinationNode, link));
						}
					}
				}
				else if (bHostsDest) {
					if (outGroup.GroupEdgeNodes.Contains(destination)) {
						var sourceNode = graphQuery.GetNode(source);
						if (sourceNode == null) sourceNode = graphQuery.GetSubNode(source);
						var destinationNode = graphQuery.GetNode(destination);
						if (destinationNode == null) destinationNode = graphQuery.GetSubNode(destination);
						if (sourceNode != null && destinationNode != null) {
							constraintLinkList.Add(new FFAGConstraintsLink(destinationNode, sourceNode, link));
						}
					}
				}
			}

			var nodeByCoords = new Dictionary<Vector3Int, FlowLayoutGraphNode>();
			foreach (var graphNode in graph.Nodes) {
				if (graphNode.MergedCompositeNodes.Count > 0) {
					foreach (var subNode in graphNode.MergedCompositeNodes) {
						var coord = MathUtils.RoundToVector3Int(subNode.coord);
						nodeByCoords[coord] = subNode;
					}
				}
				else {
					var coord = MathUtils.RoundToVector3Int(graphNode.coord);
					nodeByCoords[coord] = graphNode;
				}
			}

			foreach (var incomingNode in incomingNodes) {
				if (incomingNode == null) continue;
				var innerCoord = MathUtils.RoundToVector3Int(incomingNode.coord);
				innerCoord.x = Mathf.Clamp(innerCoord.x, minCoord.x, maxCoord.x);
				innerCoord.y = Mathf.Clamp(innerCoord.y, minCoord.y, maxCoord.y);
				innerCoord.z = Mathf.Clamp(innerCoord.z, minCoord.z, maxCoord.z);
				if (nodeByCoords.ContainsKey(innerCoord))
				{
					var innerNode = nodeByCoords[innerCoord];
					var innerNodeLink = graphQuery.GetConnectedLink(incomingNode.nodeId, innerNode.nodeId);
					Debug.Assert(innerNodeLink != null, "BuildNodeGroup: Cannot find link");
					constraintLinkList.Add(new FFAGConstraintsLink(innerNode, incomingNode, innerNodeLink));
				}
			}

			outConstraintLinks = constraintLinkList.ToArray();
        }
    }
    
    public class SnapFlowLayoutNodeCreationConstraint : IFlowLayoutNodeCreationConstraint
    {
        public bool CanCreateNodeAt(FlowLayoutGraphNode node, int totalPathLength, int currentPathPosition)
        {
            return true;
        }
    }

    public class FlowLayoutNodeSnapDomainData : IFlowDomainData
    {
        public string[] Categories = new string[0];
        public IFlowDomainData Clone()
        {
            var clone = new FlowLayoutNodeSnapDomainData();
            clone.Categories = new string[Categories.Length];
            Array.Copy(Categories, clone.Categories, Categories.Length);
            return clone;
        }
    }
    
    
    public class SnapGridFlowDomainExtension : IFlowDomainExtension
    {
	    public SnapGridFlowModuleDatabase ModuleDatabase;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\SnapGridFlowModuleResolver.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{
    class SgfModuleItemFitnessCalculator {
        public SgfModuleItemFitnessCalculator(SgfModuleDatabasePlaceableMarkerInfo[] moduleMarkers) {
            foreach (var info in moduleMarkers)
            {
                ModuleMarkers[info.placeableMarkerTemplate] = info.count;
            }
        }

        public int Calculate(string[] markerNames) {
            var availableMarkers = new Dictionary<PlaceableMarker, int>(ModuleMarkers);
            return Solve(markerNames, availableMarkers);
        }

        private static int Solve(string[] markerNames, Dictionary<PlaceableMarker, int> availableMarkers) {
            int numFailed;
            if (availableMarkers.Count > 0) {
                numFailed = SolveImpl(markerNames, 0, availableMarkers);
                Debug.Assert(numFailed >= 0);
            }
            else
            {
                numFailed = markerNames.Length;
            }

            const int FAIL_WEIGHT = 1000000;
            return numFailed * FAIL_WEIGHT;
        }

        // Returns the no. of items failed in the processed sub tree
        private static int SolveImpl(string[] markerNames, int index, Dictionary<PlaceableMarker, int> availableMarkers) {
            if (index == markerNames.Length) {
                return 0;
            }
            
            Debug.Assert(index >= 0 || index < markerNames.Length);

            int bestFrameFailCount = markerNames.Length;
            var markerName = markerNames[index];
            var keys = availableMarkers.Keys.ToArray();
            foreach (var key in keys) {
                var availableMarkerAsset = key;
                int count = availableMarkers[key];
                
                bool canAttachHere = count > 0 && availableMarkerAsset.supportedMarkers.Contains(markerName);
                int frameFailCount = canAttachHere ? 0 : 1;
                if (canAttachHere) {
                    count--;
                }
                frameFailCount += SolveImpl(markerNames, index + 1, availableMarkers);
                if (canAttachHere) {
                    count++;
                }

                availableMarkers[availableMarkerAsset] = count;

                if (frameFailCount < bestFrameFailCount) {
                    bestFrameFailCount = frameFailCount;
                }
                
                if (availableMarkerAsset.supportedMarkers.Length == 1 && availableMarkerAsset.supportedMarkers[0] == markerName) {
                    // Faster bailout
                    break;
                }
            } 
            
            return bestFrameFailCount;
        }

        private Dictionary<PlaceableMarker, int> ModuleMarkers = new Dictionary<PlaceableMarker, int>();
    };
    
    public struct SgfLayoutModuleResolverSettings
    {
        public int Seed;
        public Matrix4x4 BaseTransform;
        public float ModulesWithMinimumDoorsProbability;
        public SnapGridFlowModuleDatabase ModuleDatabase;
        public FlowLayoutGraph LayoutGraph;
        public int MaxResolveFrames;
        public int NonRepeatingRooms;
    }
    
    public class SgfLayoutModuleResolver
    {
        class FModuleFitCandidate {
            public SgfModuleDatabaseItem ModuleItem;
            public Quaternion ModuleRotation;
            public int AssemblyIndex;
            public SgfModuleAssemblySideCell[] DoorIndices;
            public int ItemFitness = 0;
            public int ConnectionWeight = 0;
            public int ModuleLastUsedDepth = int.MaxValue;
            public float ModuleWeight = 0;
            public float ModuleWeightInstance = 0;
        };

        class NodeGroupData
        {
            public FlowLayoutPathNodeGroup Group;
            public FFAGConstraintsLink[] ConstraintLinks;
        }

        class ResolveState
        {
            public FlowLayoutGraphQuery GraphQuery;
            public System.Random Random;
            public Dictionary<DungeonUID, SgfModuleNode> ModuleNodesById = new Dictionary<DungeonUID, SgfModuleNode>();
            public Dictionary<DungeonUID, SgfModuleAssemblySideCell[]> ActiveModuleDoorIndices = new Dictionary<DungeonUID, SgfModuleAssemblySideCell[]>();
            public Dictionary<FlowLayoutGraphNode, NodeGroupData> NodeGroups = new Dictionary<FlowLayoutGraphNode, NodeGroupData>();
            public Dictionary<SgfModuleDatabaseItem, Stack<int>> ModuleLastUsedDepth = new Dictionary<SgfModuleDatabaseItem, Stack<int>>();
            public int FrameIndex = 0;
        }
        
        public static bool Resolve(SgfLayoutModuleResolverSettings settings, out SgfModuleNode[] outModuleNodes)
        {
            if (settings.LayoutGraph == null || settings.ModuleDatabase == null || settings.ModuleDatabase.ModuleBoundsAsset == null)
            {
                outModuleNodes = new SgfModuleNode[]{};
                return false;
            }

            var graph = settings.LayoutGraph;
            var resolveState = new ResolveState
            {
                GraphQuery = new FlowLayoutGraphQuery(graph),
                Random = new System.Random(settings.Seed)
            };
            
            foreach (var node in graph.Nodes)
            {
                if (node.active)
                {
                    var nodeGroupData = new NodeGroupData();
                    SnapFlowLayoutGraphConstraints.BuildNodeGroup(resolveState.GraphQuery, node, new FlowLayoutGraphNode[] { }, out nodeGroupData.Group, out nodeGroupData.ConstraintLinks);
                    resolveState.NodeGroups.Add(node, nodeGroupData);
                }
            }

            if (!ResolveNodes(settings, resolveState))
            {
                outModuleNodes = new SgfModuleNode[] { };
                return false;
            }
            
            foreach (var entry in resolveState.ActiveModuleDoorIndices) {
                var moduleId = entry.Key;
                var doorSideCells = entry.Value;
                for (var i = 0; i < doorSideCells.Length; i++)
                {
                    foreach (var graphLink in graph.Links) {
                        if (graphLink.state.type == FlowLayoutGraphLinkType.Unconnected) continue;
                        if ((graphLink.source == doorSideCells[i].nodeId || graphLink.sourceSubNode == doorSideCells[i].nodeId)
                            && (graphLink.destination == doorSideCells[i].linkedNodeId || graphLink.destinationSubNode == doorSideCells[i].linkedNodeId)) {
                            // Outgoing Node
                            doorSideCells[i].linkId = graphLink.linkId;
                            break;
                        }
                        else if ((graphLink.source == doorSideCells[i].linkedNodeId || graphLink.sourceSubNode == doorSideCells[i].linkedNodeId)
                                 && (graphLink.destination == doorSideCells[i].nodeId || graphLink.destinationSubNode == doorSideCells[i].nodeId)) {
                            // Incoming Node
                            doorSideCells[i].linkId = graphLink.linkId;
                            break;
                        }
                    }
                }
            }

            foreach (var entry in resolveState.ActiveModuleDoorIndices)
            {
                var nodeId = entry.Key;
                var moduleDoorCells = entry.Value;
                
                if (!resolveState.ModuleNodesById.ContainsKey(nodeId))
                {
                    continue;
                }

                var moduleInfo = resolveState.ModuleNodesById[nodeId];
                foreach (var doorInfo in moduleInfo.Doors)
                {
                    doorInfo.CellInfo = SgfModuleAssemblySideCell.Empty;
                }
                
                foreach (var doorCell in moduleDoorCells)
                {
                    var doorInfo = moduleInfo.Doors[doorCell.connectionIdx];
                    doorInfo.CellInfo = doorCell;
                }
            }
            
            // Link the module nodes together
            foreach (var graphLink in graph.Links) {
                if (graphLink == null || graphLink.state.type == FlowLayoutGraphLinkType.Unconnected) continue;
                
                var sourceId = graphLink.source;
                var destId = graphLink.destination;

                SgfModuleAssemblySideCell srcCell = SgfModuleAssemblySideCell.Empty;
                SgfModuleAssemblySideCell dstCell = SgfModuleAssemblySideCell.Empty;
                bool foundSrcCell = false;
                bool foundDstCell = false;
                
                {
                    if (resolveState.ActiveModuleDoorIndices.ContainsKey(sourceId))
                    {
                        var sourceDoorCells = resolveState.ActiveModuleDoorIndices[sourceId];
                        foreach (var sourceDoorCell in sourceDoorCells)
                        {
                            if (sourceDoorCell.linkId == graphLink.linkId)
                            {
                                srcCell = sourceDoorCell;
                                foundSrcCell = true;
                                break;
                            }
                        }
                    }

                    if (resolveState.ActiveModuleDoorIndices.ContainsKey(destId))
                    {
                        var destDoorCells = resolveState.ActiveModuleDoorIndices[destId];
                        foreach (var destDoorCell in destDoorCells)
                        {
                            if (destDoorCell.linkId == graphLink.linkId)
                            {
                                dstCell = destDoorCell;
                                foundDstCell = true;
                                break;
                            }
                        }
                    }
                }

                if (!foundSrcCell || !foundDstCell) {
                    outModuleNodes = new SgfModuleNode[]{};
                    return false;
                }
                
                if (!resolveState.ModuleNodesById.ContainsKey(sourceId) || !resolveState.ModuleNodesById.ContainsKey(destId)) {
                    outModuleNodes = new SgfModuleNode[]{};
                    return false;
                }

                var srcModule = resolveState.ModuleNodesById[sourceId];
                var dstModule = resolveState.ModuleNodesById[destId];
                var srcDoor = srcModule.Doors[srcCell.connectionIdx];
                var dstDoor = dstModule.Doors[dstCell.connectionIdx];

                srcDoor.ConnectedDoor = dstDoor;
                dstDoor.ConnectedDoor = srcDoor;

                srcModule.Outgoing.Add(srcDoor);
                dstModule.Incoming.Add(dstDoor);
            }

            outModuleNodes = resolveState.ModuleNodesById.Values.ToArray();
            return true;
        }

        private static SgfModuleNode CreateModuleNode(FlowLayoutGraphNode layoutNode, SgfModuleDatabaseItem item)
        {
            var node = new SgfModuleNode();
            node.ModuleInstanceId = layoutNode.nodeId;
            node.ModuleDBItem = item;
            node.LayoutNode = layoutNode;

            var nodeDoors = new List<SgfModuleDoor>();
            foreach (var doorInfo in item.Connections) {
                var door = new SgfModuleDoor();
                door.LocalTransform = doorInfo.Transform;
                door.Owner = node;
                nodeDoors.Add(door);
            }

            node.Doors = nodeDoors.ToArray();

            return node;
        }
        
        private static bool ResolveNodes(SgfLayoutModuleResolverSettings settings, ResolveState resolveState)
        {
            return ResolveNodesRecursive(settings, resolveState);
            ////return ResolveNodesLinear(settings, resolveState);
        }

        private static bool ResolveNodesRecursive(SgfLayoutModuleResolverSettings settings, ResolveState resolveState)
        {
            var graph = settings.LayoutGraph;
            
            // Find the spawn room node
            FlowLayoutGraphNode startNode = null;
            foreach (var node in graph.Nodes)
            {
                if (node.active)
                {
                    foreach (var nodeItem in node.items)
                    {
                        if (nodeItem.type == FlowGraphItemType.Entrance)
                        {
                            startNode = node;
                            break;
                        }
                    }
                }
            }

            if (startNode == null)
            {
                return false;
            }
            
            var visited = new HashSet<FlowLayoutGraphNode>();
            return ResolveNodeRecursive(startNode, 0, settings, resolveState, visited);
        }

        private static bool ResolveNodeRecursive(FlowLayoutGraphNode node, int depth, SgfLayoutModuleResolverSettings settings, 
            ResolveState resolveState, HashSet<FlowLayoutGraphNode> visited)
        {
            if (resolveState.FrameIndex > settings.MaxResolveFrames)
            {
                return false;
            }
            resolveState.FrameIndex++;
            
            if (visited.Contains(node))
            {
                // Already resolved
                return true;
            }

            var nodeGroupData = resolveState.NodeGroups[node];
            SgfModuleAssembly nodeAssembly;
            SGFModuleAssemblyBuilder.Build(resolveState.GraphQuery, nodeGroupData.Group, nodeGroupData.ConstraintLinks, out nodeAssembly);
            
            var candidates = GetCandidates(node, depth, settings, resolveState, nodeAssembly);
            if (candidates.Length == 0) return false;
            
            //IncrementModuleLastUsedDepth(resolveState);
            
            visited.Add(node);
            bool success = false;
            foreach (var candidate in candidates)
            {
                // Find the best fit
                RegisterNodeModule(node, candidate, settings, resolveState);

                // Recursively resolve all outgoing nodes
                var outgoingNodes = new List<FlowLayoutGraphNode>();
                {
                    var outgoingNodeIds = resolveState.GraphQuery.GetOutgoingNodes(node.nodeId);
                    foreach (var outgoingNodeId in outgoingNodeIds)
                    {
                        var outgoingNode = resolveState.GraphQuery.GetNode(outgoingNodeId);
                        if (outgoingNode != null && outgoingNode.active)
                        {
                            outgoingNodes.Add(outgoingNode);
                        }
                    }
                }

                // Save the depth of this module so we don't repeat them next to each other
                PushModuleLastUsedDepth(resolveState, candidate.ModuleItem, depth);
                
                bool allBranchesSuccessful = true;
                // Resolve the child branches
                foreach (var outgoingNode in outgoingNodes)
                {
                    if (!ResolveNodeRecursive(outgoingNode, depth + 1, settings, resolveState, visited))
                    {
                        allBranchesSuccessful = false;
                        break;
                    }
                }

                PopModuleLastUsedDepth(resolveState, candidate.ModuleItem);
                
                if (allBranchesSuccessful)
                {
                    success = true;
                    break;
                }

                DeregisterNodeModule(node, resolveState);
            }
            
            //DecrementModuleLastUsedDepth(resolveState);
            
            // Cannot find a solution in this path. Backtrack and find another path
            visited.Remove(node);

            return success;
        }

        private static void PushModuleLastUsedDepth(ResolveState resolveState, SgfModuleDatabaseItem module, int depth)
        {
            if (!resolveState.ModuleLastUsedDepth.ContainsKey(module))
            {
                resolveState.ModuleLastUsedDepth.Add(module, new Stack<int>());
            }
            resolveState.ModuleLastUsedDepth[module].Push(depth);
        }

        private static void PopModuleLastUsedDepth(ResolveState resolveState, SgfModuleDatabaseItem module)
        {
            resolveState.ModuleLastUsedDepth[module].Pop();
        }
        
        private static int GetModuleLastUsedDepth(ResolveState resolveState, SgfModuleDatabaseItem module, int currentDepth, int maxNonRepeatingDepth)
        {
            if (!resolveState.ModuleLastUsedDepth.ContainsKey(module) || resolveState.ModuleLastUsedDepth[module].Count == 0)
            {
                return int.MaxValue;
            }

            var moduleDepthFromCurrentNode = currentDepth - resolveState.ModuleLastUsedDepth[module].Peek();
            return moduleDepthFromCurrentNode < maxNonRepeatingDepth + 1 ? moduleDepthFromCurrentNode : int.MaxValue;
        }
        
        private static FModuleFitCandidate[] GetCandidates(FlowLayoutGraphNode node, int depth, SgfLayoutModuleResolverSettings settings, ResolveState state, SgfModuleAssembly nodeAssembly)
        {
            var categoryNames = new HashSet<string>();
            FlowLayoutNodeSnapDomainData nodeSnapData = node.GetDomainData<FlowLayoutNodeSnapDomainData>();
            if (nodeSnapData != null)
            {
                categoryNames = new HashSet<string>(nodeSnapData.Categories);
            }
            else
            {
                Debug.LogError("Snap Domain data missing in the abstract graph node");
            }

            var possibleModules = new List<SgfModuleDatabaseItem>();
            foreach (string categoryName in categoryNames)
            {
                possibleModules.AddRange(settings.ModuleDatabase.GetCategoryModules(categoryName));
            }

            var desiredNodeMarkers = new List<string>();
            foreach (var nodeItem in node.items)
            {
                if (nodeItem == null) continue;
                var markerName = nodeItem.markerName.Trim();
                if (markerName.Length > 0)
                {
                    desiredNodeMarkers.Add(markerName);
                }
            }

            bool bChooseModulesWithMinDoors = state.Random.NextFloat() < settings.ModulesWithMinimumDoorsProbability;

            var candidates = new List<FModuleFitCandidate>();
            var moduleIndices = MathUtils.GetShuffledIndices(possibleModules.Count, state.Random);
            foreach (var moduleIdx in moduleIndices)
            {
                var moduleInfo = possibleModules[moduleIdx];
                if (moduleInfo == null) continue;

                var numAssemblies = moduleInfo.RotatedAssemblies.Length;
                var shuffledAsmIndices = MathUtils.GetShuffledIndices(numAssemblies, state.Random);
                foreach (var asmIdx in shuffledAsmIndices)
                {
                    var moduleAssembly = moduleInfo.RotatedAssemblies[asmIdx];
                    SgfModuleAssemblySideCell[] doorIndices;
                    if (moduleAssembly.CanFit(nodeAssembly, out doorIndices))
                    {
                        bool doorCategoriesValid = true;
                        // Make sure all the door indices are compatible with the category on the other connected end
                        foreach (var doorInfo in doorIndices)
                        {
                            var nodeConnection = moduleInfo.Connections[doorInfo.connectionIdx];
                            Debug.Assert(nodeConnection != null, "SGF Resolve: Invalid node connection");
                            DungeonUID doorNodeId;
                            if (!state.GraphQuery.GetParentNode(doorInfo.nodeId, out doorNodeId))
                            {
                                doorNodeId = doorInfo.nodeId;
                            }
                            
                            Debug.Assert(doorNodeId == node.nodeId, "Invalid door link node data");
                            DungeonUID otherNodeId;
                            if (!state.GraphQuery.GetParentNode(doorInfo.linkedNodeId, out otherNodeId))
                            {
                                otherNodeId = doorInfo.linkedNodeId;
                            }
                            
                            if (state.ActiveModuleDoorIndices.ContainsKey(otherNodeId))
                            {
                                var otherNodeDoors = state.ActiveModuleDoorIndices[otherNodeId];
                                foreach (var otherNodeDoor in otherNodeDoors)
                                {
                                    DungeonUID otherDoorLinkedNodeId;
                                    if (!state.GraphQuery.GetParentNode(otherNodeDoor.linkedNodeId, out otherDoorLinkedNodeId))
                                    {
                                        otherDoorLinkedNodeId = otherNodeDoor.linkedNodeId;
                                    }

                                    if (otherDoorLinkedNodeId == node.nodeId)
                                    {
                                        var otherNodeModule = state.ModuleNodesById[otherNodeId];
                                        var otherNodeConnection = otherNodeModule.ModuleDBItem.Connections[otherNodeDoor.connectionIdx];
                                        Debug.Assert(otherNodeConnection != null, "SGF Resolve: Invalid remote node connection");

                                        if (nodeConnection.Category != otherNodeConnection.Category)
                                        {
                                            doorCategoriesValid = false;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (!doorCategoriesValid)
                            {
                                break;
                            }
                        }

                        if (doorCategoriesValid)
                        {
                            var candidate = new FModuleFitCandidate();
                            candidates.Add(candidate);

                            candidate.ModuleItem = moduleInfo;
                            candidate.ModuleRotation = Quaternion.AngleAxis(asmIdx * -90, Vector3.up);
                            candidate.AssemblyIndex = asmIdx;
                            candidate.DoorIndices = doorIndices;
                        }
                    }
                }
            }
            
            // Update the weights
            float maxSelectionWeight = 0;
            foreach (var candidate in candidates)
            {
                maxSelectionWeight = Mathf.Max(maxSelectionWeight, candidate.ModuleItem.SelectionWeight);
            }

            if (maxSelectionWeight == 0)
            {
                maxSelectionWeight = 1;
            }
            
            foreach (var candidate in candidates)
            {
                var moduleInfo = candidate.ModuleItem;
                var itemFitnessCalculator = new SgfModuleItemFitnessCalculator(moduleInfo.AvailableMarkers);
                int itemFitness = itemFitnessCalculator.Calculate(desiredNodeMarkers.ToArray());

                int connectionWeight = bChooseModulesWithMinDoors ? moduleInfo.Connections.Length : 0;
                var moduleWeight = Mathf.Clamp(moduleInfo.SelectionWeight / maxSelectionWeight, 0.0f, 1.0f);

                candidate.ItemFitness = itemFitness;
                candidate.ConnectionWeight = connectionWeight;
                candidate.ModuleWeight = moduleWeight;
                candidate.ModuleWeightInstance = state.Random.NextFloat() * moduleWeight;
                candidate.ModuleLastUsedDepth = GetModuleLastUsedDepth(state, moduleInfo, depth, settings.NonRepeatingRooms);
            }
            
            candidates.Sort((a, b) =>
            {
                if (a.ItemFitness == b.ItemFitness)
                {
                    if (Mathf.Approximately(a.ModuleWeight, b.ModuleWeight))
                    {
                        if (a.ConnectionWeight == b.ConnectionWeight)
                        {
                            if (a.ModuleLastUsedDepth == b.ModuleLastUsedDepth)
                            {
                                return 0;
                            }
                            else
                            {
                                return a.ModuleLastUsedDepth < b.ModuleLastUsedDepth ? 1 : -1;
                            }
                        }
                        else
                        {
                            return a.ConnectionWeight < b.ConnectionWeight ? -1 : 1;
                        }
                    }
                    else
                    {
                        return a.ModuleWeightInstance < b.ModuleWeightInstance ? 1 : -1;
                    }
                }
                else
                {
                    return a.ItemFitness < b.ItemFitness ? -1 : 1;
                }
            });
            
            return candidates.ToArray();
        }
        
        private static void DeregisterNodeModule(FlowLayoutGraphNode node, ResolveState resolveState)
        {
            resolveState.ActiveModuleDoorIndices.Remove(node.nodeId);
            
            // Register in lookup
            resolveState.ModuleNodesById.Remove(node.nodeId);
        }
        
        private static void RegisterNodeModule(FlowLayoutGraphNode node, FModuleFitCandidate candidate, SgfLayoutModuleResolverSettings settings, ResolveState resolveState)
        {
            var moduleNode = CreateModuleNode(node, candidate.ModuleItem);
            var moduleRotation = candidate.ModuleRotation;
            var moduleDBItem = candidate.ModuleItem;

            var chunkSize = settings.ModuleDatabase.ModuleBoundsAsset.chunkSize;
            var doorOffsetY = settings.ModuleDatabase.ModuleBoundsAsset.doorOffsetY;


            var halfChunkSize = Vector3.Scale(MathUtils.ToVector3(moduleDBItem.NumChunks), chunkSize) * 0.5f;
            {
                //var localCenter = new Vector3(halfChunkSize.x, doorOffsetY, halfChunkSize.z);
                var localCenter = halfChunkSize;
                localCenter = moduleRotation * localCenter;
                var desiredCenter = Vector3.Scale(node.coord, chunkSize);
                var position = desiredCenter - localCenter;
                moduleNode.WorldTransform = settings.BaseTransform * Matrix4x4.TRS(position, moduleRotation, Vector3.one);
            }

            // Add the doors
            resolveState.ActiveModuleDoorIndices[node.nodeId] = candidate.DoorIndices;
            
            // Register in lookup
            resolveState.ModuleNodesById[node.nodeId] = moduleNode;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Processor\GrammarRuntimeGraphs.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.RuntimeGraphs;
using System.Collections.Generic;


namespace DungeonArchitect.Grammar
{
    public class GrammarRuntimeGraphNodeData
    {
        public GrammarNodeType nodeType;
        public int index;

        public override string ToString()
        {
            if (nodeType != null)
            {
                return nodeType.nodeName + ":" + index;
            }
            else
            {
                return "null";
            }
        }
    }

    public class GrammarRuntimeGraph : RuntimeGraph<GrammarRuntimeGraphNodeData>
    {
        public static GrammarRuntimeGraph BuildFrom(GrammarGraph graph)
        {
            var runtimeGraph = new GrammarRuntimeGraph();
            BuildFrom(graph, runtimeGraph);
            return runtimeGraph;
        }

        public static void BuildFrom(GrammarGraph graph, GrammarRuntimeGraph runtimeGraph)
        {
            runtimeGraph.Nodes.Clear();
            var buildHandlers = GrammarRuntimeGraphHandlers.Create();
            RuntimeGraphBuilder.Build(graph, runtimeGraph, buildHandlers);
        }
    }

    public class GrammarRuntimeGraphUtils
    {
        public static RuntimeGraphNode<GrammarRuntimeGraphNodeData> FindStartNode(GrammarRuntimeGraph graph)
        {
            if (graph.Nodes.Count == 0)
            {
                return null;
            }

            var visited = new HashSet<RuntimeGraphNode<GrammarRuntimeGraphNodeData>>();
            var startNode = graph.Nodes[0];

            while (true)
            {
                visited.Add(startNode);
                if (startNode.Incoming.Count == 0)
                {
                    break;
                }

                var nextNode = startNode.Incoming[0];
                if (visited.Contains(nextNode))
                {
                    break;
                }
                startNode = nextNode;
            }
            return startNode;
        }
    }

    public class GrammarRuntimeGraphHandlers : RuntimeGraphBuilderHandlers<GrammarRuntimeGraphNodeData>
    {
        public static GrammarRuntimeGraphHandlers Create()
        {
            var buildHandlers = new GrammarRuntimeGraphHandlers();
            buildHandlers.GetPayload = graphNode =>
            {
                if (graphNode is GrammarTaskNode)
                {
                    var taskNode = graphNode as GrammarTaskNode;

                    var data = new GrammarRuntimeGraphNodeData();
                    data.nodeType = taskNode.NodeType;
                    data.index = taskNode.executionIndex;
                    return data;
                }
                return new GrammarRuntimeGraphNodeData();
            };

            buildHandlers.CanCreateNode = graphNode =>
            {
                return (graphNode is GrammarTaskNode);
            };

            buildHandlers.NodeCreated = (graphNode, runtimeNode) =>
            {
            };

            return buildHandlers;
        }
    }

    public class ExecutionRuntimeGraphNodeData
    {
        public RuntimeGrammarProduction rule;
        public GrammarExecRuleRunMode runMode;
        public float runProbability;
        public int iterateCount;
        public int minIterateCount;
        public int maxIterateCount;
    }


    public class ExecutionRuntimeGraph : RuntimeGraph<ExecutionRuntimeGraphNodeData>
    {
        public RuntimeGraphNode<ExecutionRuntimeGraphNodeData> EntryNode { get; set; }

        public static ExecutionRuntimeGraph BuildFrom(GrammarExecGraph graph, Dictionary<GrammarProductionRule, RuntimeGrammarProduction> mapping)
        {
            var runtimeGraph = new ExecutionRuntimeGraph();
            var buildHandlers = ExecutionRuntimeGraphHandlers.Create(mapping);
            RuntimeGraphBuilder.Build(graph, runtimeGraph, buildHandlers);
            return runtimeGraph;
        }
    }

    public class ExecutionRuntimeGraphHandlers : RuntimeGraphBuilderHandlers<ExecutionRuntimeGraphNodeData>
    {
        public static ExecutionRuntimeGraphHandlers Create(Dictionary<GrammarProductionRule, RuntimeGrammarProduction> mapping)
        {
            var buildHandlers = new ExecutionRuntimeGraphHandlers();
            buildHandlers.GetPayload = graphNode =>
            {
                if (graphNode is GrammarExecRuleNode)
                {
                    var ruleNode = graphNode as GrammarExecRuleNode;
                    if (mapping.ContainsKey(ruleNode.rule))
                    {
                        var payload = new ExecutionRuntimeGraphNodeData();
                        payload.rule = mapping[ruleNode.rule];
                        payload.runMode = ruleNode.runMode;
                        payload.runProbability = ruleNode.runProbability;
                        payload.iterateCount = ruleNode.iterateCount;
                        payload.minIterateCount = ruleNode.minIterateCount;
                        payload.maxIterateCount = ruleNode.maxIterateCount;
                        return payload;
                    }
                }
                return new ExecutionRuntimeGraphNodeData();
            };

            buildHandlers.CanCreateNode = graphNode =>
            {
                return (graphNode is GrammarExecRuleNode) || (graphNode is GrammarExecEntryNode);
            };

            buildHandlers.NodeCreated = (graphNode, runtimeNode) =>
            {
                if (graphNode is GrammarExecEntryNode)
                {
                    var execRuntimeGraph = runtimeNode.Graph as ExecutionRuntimeGraph;
                    execRuntimeGraph.EntryNode = runtimeNode;
                }
            };
            return buildHandlers;
        }
    }

    public class WeightedGrammarRuntimeGraph : GrammarRuntimeGraph
    {
        public float Weight = 1.0f;
    }

    public class RuntimeGrammarProduction
    {
        public GrammarProductionRule rule;
        public GrammarRuntimeGraph LHS;
        public WeightedGrammarRuntimeGraph[] RHSList;
    }

    public class RuntimeGrammar
    {
        public GrammarRuntimeGraph ResultGraph;
        public ExecutionRuntimeGraph ExecutionGraph;
        public RuntimeGrammarProduction[] Rules;
        public GrammarNodeType[] NodeTypes;

        public static RuntimeGrammar Build(SnapFlowAsset flowAsset)
        {
            if (flowAsset == null)
            {
                return null;
            }
            var grammar = new RuntimeGrammar();
            grammar.NodeTypes = flowAsset.nodeTypes;
            grammar.ResultGraph = new GrammarRuntimeGraph();

            // Build the rules
            var ruleMapping = new Dictionary<GrammarProductionRule, RuntimeGrammarProduction>();
            int numRules = flowAsset.productionRules.Length;
            grammar.Rules = new RuntimeGrammarProduction[numRules];
            for (int i = 0; i < numRules; i++)
            {
                var rule = flowAsset.productionRules[i];
                var runtimeRule = new RuntimeGrammarProduction();
                grammar.Rules[i] = runtimeRule;
                ruleMapping.Add(rule, runtimeRule);

                runtimeRule.rule = rule;
                runtimeRule.LHS = GrammarRuntimeGraph.BuildFrom(rule.LHSGraph);
                int numRHS = rule.RHSGraphs.Count;
                runtimeRule.RHSList = new WeightedGrammarRuntimeGraph[numRHS];
                for (int r = 0; r < numRHS; r++)
                {
                    var rhsGraph = new WeightedGrammarRuntimeGraph();
                    GrammarRuntimeGraph.BuildFrom(rule.RHSGraphs[r].graph, rhsGraph);
                    rhsGraph.Weight = rule.RHSGraphs[r].weight;
                    runtimeRule.RHSList[r] = rhsGraph;
                }
            }

            grammar.ExecutionGraph = ExecutionRuntimeGraph.BuildFrom(flowAsset.executionGraph, ruleMapping);

            return grammar;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Processor\GraphGrammarProcessor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using DungeonArchitect.RuntimeGraphs;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Graphs.Layouts;
using DungeonArchitect.Graphs.Layouts.Spring;
using RGraph = DungeonArchitect.RuntimeGraphs.RuntimeGraph<DungeonArchitect.Grammar.GrammarRuntimeGraphNodeData>;
using RNode = DungeonArchitect.RuntimeGraphs.RuntimeGraphNode<DungeonArchitect.Grammar.GrammarRuntimeGraphNodeData>;


namespace DungeonArchitect.Grammar
{
    public class GraphGrammarProcessorSettings
    {
        public int seed = 0;
        public bool runGraphGenerationScripts = false;
    }

    public class GraphGrammarProcessor 
    {
        public RuntimeGrammar Grammar { get; set; }

        System.Random random;
        public GraphGrammarProcessorSettings settings;

        public GraphGrammarProcessor(SnapFlowAsset asset, GraphGrammarProcessorSettings settings)
        {
            this.settings = settings;
            random = new System.Random(settings.seed);

            if (settings.runGraphGenerationScripts)
            {
                RunGraphGenerationScripts(asset);
            }

            // Build an optimized version of the grammar in memory to work with
            Grammar = RuntimeGrammar.Build(asset);

            // Find the start node
            GrammarNodeType startNodeType = null;
            foreach (var nodeTypeInfo in Grammar.NodeTypes)
            {
                if (nodeTypeInfo.nodeName == "S")
                {
                    startNodeType = nodeTypeInfo;
                    break;
                }
            }

            if (startNodeType != null)
            {
                var nodeData = new GrammarRuntimeGraphNodeData();
                nodeData.nodeType = startNodeType;
                nodeData.index = 0;
                RuntimeGraphBuilder.AddNode(nodeData, Grammar.ResultGraph);
            }
        }

        void RunGraphGenerationScripts(SnapFlowAsset asset)
        {
            foreach (var rule in asset.productionRules)
            {
                if (rule.LHSGraph.useProceduralScript)
                {
                    RunGraphGenerationScript(rule.LHSGraph, asset.nodeTypes);
                }
                foreach (var rhs in rule.RHSGraphs)
                {
                    if (rhs.graph.useProceduralScript)
                    {
                        RunGraphGenerationScript(rhs.graph, asset.nodeTypes);
                    }
                }
            }
        }

        void RunGraphGenerationScript(GrammarGraph graph, GrammarNodeType[] nodeTypes)
        {
            var scriptType = System.Type.GetType(graph.generatorScriptClass);
            if (scriptType != null)
            {
                IGrammarGraphBuildScript generatorScript = ScriptableObject.CreateInstance(scriptType) as IGrammarGraphBuildScript;
                if (generatorScript != null)
                {
                    var graphBuilder = new NonEditorGraphBuilder(graph);
                    GrammarGraphBuilder grammarBuilder = new GrammarGraphBuilder(graph, nodeTypes, graphBuilder);
                    grammarBuilder.ClearGraph();
                    generatorScript.Generate(grammarBuilder);

                    // Layout the generated graph
                    var config = new GraphLayoutSpringConfig();
                    var layout = new GraphLayoutSpring<GraphNode>(config);
                    var nodes = graph.Nodes.ToArray();
                    nodes = nodes.Where(n => !(n is CommentNode)).ToArray();
                    layout.Layout(nodes, new DefaultGraphLayoutNodeActions(graph));
                }
            }
        }

        public void Build()
        {
            var entryNode = Grammar.ExecutionGraph.EntryNode;
            if (Grammar.ExecutionGraph.EntryNode == null)
            {
                Debug.LogWarning("Entry node not found in execution graph");
                return;
            }

            var visited = new HashSet<RuntimeGraphNode<ExecutionRuntimeGraphNodeData>>();
            var node = (entryNode.Outgoing.Count > 0) ? entryNode.Outgoing[0] : null;

            while (node != null)
            {
                if (visited.Contains(node))
                {
                    break;
                }
                visited.Add(node);

                // Execute the node
                var rule = node.Payload.rule;
                int executionCount = GetExecutionCount(node.Payload);
                for (int i = 0; i < executionCount; i++)
                {
                    ApplyRule(Grammar.ResultGraph, rule);
                }

                // Move to the next node
                node = (node.Outgoing.Count > 0) ? node.Outgoing[0] : null;
            }

        }

        int GetExecutionCount(ExecutionRuntimeGraphNodeData data)
        {
            switch (data.runMode)
            {
                case GrammarExecRuleRunMode.Iterate:
                    return data.iterateCount;

                case GrammarExecRuleRunMode.IterateRange:
                    return random.Range(data.minIterateCount, data.maxIterateCount);

                case GrammarExecRuleRunMode.RunWithProbability:
                    return random.NextFloat() <= data.runProbability ? 1 : 0;

                case GrammarExecRuleRunMode.RunOnce:
                default:
                    return 1;
            }
        }

        WeightedGrammarRuntimeGraph GetRandomGraph(WeightedGrammarRuntimeGraph[] graphs)
        {
            if (graphs.Length == 0) return null;
            if (graphs.Length == 1) return graphs[0];

            float totalWeights = 0;
            foreach (var graph in graphs)
            {
                totalWeights += graph.Weight;
            }

            float selectionValue = random.Range(0.0f, totalWeights);
            foreach (var graph in graphs)
            {
                if (selectionValue <= graph.Weight)
                {
                    return graph;
                }
                selectionValue -= graph.Weight;
            }
            return null;
        }

        void ApplyRule(RGraph dataGraph, RuntimeGrammarProduction rule)
        {
            var matches = GraphPatternMatcher.Match(dataGraph, rule.LHS);

            foreach (var match in matches)
            {
                var lhs = rule.LHS;
                var rhs = GetRandomGraph(rule.RHSList);
                if (lhs == null || rhs == null) continue;

                ApplyMatch(dataGraph, lhs, rhs, match.PatternToDataNode);
            }
        }

        Dictionary<int, RNode> CreateNodeByIndexMap(RGraph graph)
        {
            var result = new Dictionary<int, RNode>();
            foreach (var node in graph.Nodes)
            {
                result.Add(node.Payload.index, node);
            }
            return result;
        }

        void ApplyMatch(RGraph dataGraph, RGraph lhs, RGraph rhs, Dictionary<RNode, RNode> LHSToDataNode)
        {
            // Break the links
            {
                var matchedDataNodes = LHSToDataNode.Values.ToArray();
                foreach (var dataNode in matchedDataNodes)
                {
                    var outgoingNodes = new List<RNode>(dataNode.Outgoing);
                    foreach (var outgoingNode in outgoingNodes)
                    {
                        if (matchedDataNodes.Contains(outgoingNode))
                        {
                            // Break this link
                            dataNode.BreakLinkTo(outgoingNode);
                        }
                    }
                }
            }

            var LHSNodesByIndex = CreateNodeByIndexMap(lhs);
            var RHSNodesByIndex = CreateNodeByIndexMap(rhs);

            var RHStoDataNode = new Dictionary<RNode, RNode>();

            // Delete unused nodes 
            {
                var dataNodeDeletionList = new List<RNode>(LHSToDataNode.Values);
                foreach (var entry in RHSNodesByIndex)
                {
                    var indexToRetain = entry.Key;
                    var rhsNode = entry.Value;
                    if (LHSNodesByIndex.ContainsKey(indexToRetain))
                    {
                        var lhsNodeToRetain = LHSNodesByIndex[indexToRetain];
                        if (LHSToDataNode.ContainsKey(lhsNodeToRetain))
                        {
                            var dataNodeToRetain = LHSToDataNode[lhsNodeToRetain];
                            dataNodeDeletionList.Remove(dataNodeToRetain);

                            // Update the caption if this is a wildcard node
                            if (!rhsNode.Payload.nodeType.wildcard)
                            {
                                dataNodeToRetain.Payload.nodeType = rhsNode.Payload.nodeType;
                            }

                            RHStoDataNode.Add(rhsNode, dataNodeToRetain);
                        }
                    }
                }

                // Now delete the unused nodes
                foreach (var dataNodeToDelete in dataNodeDeletionList)
                {
                    dataGraph.RemoveNode(dataNodeToDelete);
                }
            }

            // Add new nodes
            {
                var newRhsIndices = new List<int>(RHSNodesByIndex.Keys);
                foreach (var lhsEntry in LHSNodesByIndex)
                {
                    newRhsIndices.Remove(lhsEntry.Key);
                }

                foreach (var rhsIndexToCreate in newRhsIndices)
                {
                    var rhsNode = RHSNodesByIndex[rhsIndexToCreate];
                    var dataNode = new RNode(dataGraph);

                    var payload = new GrammarRuntimeGraphNodeData();
                    payload.nodeType = rhsNode.Payload.nodeType;

                    dataNode.Payload = payload;
                    dataGraph.Nodes.Add(dataNode);

                    RHStoDataNode.Add(rhsNode, dataNode);
                }
            }

            // Make the links
            {
                foreach (var entry in RHSNodesByIndex)
                {
                    var rhsNode = entry.Value;
                    foreach (var outgoingRHS in rhsNode.Outgoing)
                    {
                        var dataNodeStart = RHStoDataNode[rhsNode];
                        var dataNodeEnd = RHStoDataNode[outgoingRHS];
                        dataNodeStart.MakeLinkTo(dataNodeEnd);
                    }
                }
            }
        }
    }

    class GraphPatternMatch
    {
        public Dictionary<RNode, RNode> PatternToDataNode = new Dictionary<RNode, RNode>();
    }

    class GraphPatternMatcher
    {
        public static GraphPatternMatch[] Match(RGraph dataGraph, RGraph patternGraph)
        {
            if (patternGraph.Nodes.Count == 0)
            {
                return new GraphPatternMatch[0];
            }

            var matches = new List<GraphPatternMatch>();
            var unmatchedNodes = new HashSet<RNode>(dataGraph.Nodes);
            while(true)
            {
                bool foundMatch = false;

                foreach (var dataNode in dataGraph.Nodes)
                {
                    if (!unmatchedNodes.Contains(dataNode))
                    {
                        // Already processed
                        continue;
                    }

                    var match = new GraphPatternMatch();
                    var visited = new HashSet<RNode>();
                    if (MatchRecursive(dataNode, patternGraph.Nodes[0], unmatchedNodes, match, visited))
                    {
                        matches.Add(match);
                        foundMatch = true;

                        // Remove the matched nodes from the list so they are not matched again
                        foreach (var entry in match.PatternToDataNode)
                        {
                            var matchedDataNode = entry.Value;
                            unmatchedNodes.Remove(matchedDataNode);
                        }
                    }
                }
                if (!foundMatch)
                {
                    break;
                }
            }
            return matches.ToArray();
        }

        static bool IsNodeDataEqual(RNode a, RNode b)
        {
            if (a.Payload.nodeType == null || b.Payload.nodeType == null) return false;
            if (a.Payload.nodeType.wildcard || b.Payload.nodeType.wildcard) return true;
            return a.Payload.nodeType == b.Payload.nodeType;
        }

        static bool TraverseChildren(List<RNode> dataChildNodes, List<RNode> patternChildNodes,
                HashSet<RNode> unmatchedNodes, GraphPatternMatch match, HashSet<RNode> visited)
        {
            if (patternChildNodes.Count == 0)
            {
                return true;
            }

            bool foundAllChlidPaths = true;
            // Traverse to children
            foreach (var patternNode in patternChildNodes)
            {
                if (patternNode == null) continue;
                if (visited.Contains(patternNode)) continue;

                bool foundPath = false;
                foreach (var dataNode in dataChildNodes)
                {
                    if (visited.Contains(dataNode)) continue;
                    if (!IsNodeDataEqual(patternNode, dataNode)) continue;

                    if (MatchRecursive(dataNode, patternNode, unmatchedNodes, match, visited))
                    {
                        foundPath = true;
                        break;
                    }
                }

                if (!foundPath)
                {
                    foundAllChlidPaths = false;
                    break;
                }
            }

            return foundAllChlidPaths;
        }

        private static bool MatchRecursive(RNode dataNode, RNode patternNode, HashSet<RNode> unmatchedNodes, GraphPatternMatch match, HashSet<RNode> visited)
        {
            if (dataNode == null || patternNode == null || !IsNodeDataEqual(dataNode, patternNode) || !unmatchedNodes.Contains(dataNode))
            {
                return false;
            }

            visited.Add(dataNode);
            visited.Add(patternNode);

            match.PatternToDataNode.Add(patternNode, dataNode);

            bool success = TraverseChildren(dataNode.Incoming, patternNode.Incoming, unmatchedNodes, match, visited)
                && TraverseChildren(dataNode.Outgoing, patternNode.Outgoing, unmatchedNodes, match, visited);

            if (!success)
            {
                visited.Remove(dataNode);
                visited.Remove(patternNode);
                match.PatternToDataNode.Remove(patternNode);
            }

            return success;
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\CommonNodes\CommentNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Graphs
{
    public class CommentNode : GraphNode
    {
        public string message = "Comment";
        public Color background = new Color(1.0f, 0.714f, 0.992f, 0.175f);
        public int fontSize = 22;

        public override void CopyFrom(GraphNode node)
        {
            base.CopyFrom(node);

            var otherNode = node as CommentNode;
            if (otherNode == null) return;

            message = otherNode.message;
            background = otherNode.background;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphBuilder\GraphBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Graphs
{
    public abstract class GraphBuilder 
    {
        protected Graph graph;
        public Graph Graph { get { return graph; } }

        public GraphBuilder(Graph graph)
        {
            this.graph = graph;
        }

        public abstract void DestroyNode(GraphNode node);
        public abstract GraphNode CreateNode(System.Type nodeType);
        public abstract TLink LinkNodes<TLink>(GraphPin outputPin, GraphPin inputPin) where TLink : GraphLink;
        public T CreateNode<T>() where T : GraphNode
        {
            return CreateNode(typeof(T)) as T;
        }

        public void DestroyAllNodes()
        {
            var nodes = graph.Nodes.ToArray();
            foreach (var node in nodes)
            {
                DestroyNode(node);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphBuilder\NonEditorGraphBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Graphs
{
    public class NonEditorGraphBuilder : GraphBuilder
    {
        public NonEditorGraphBuilder(Graph graph)
            : base(graph)
        {
        }

        public override GraphNode CreateNode(System.Type nodeType)
        {
            GraphNode node = ScriptableObject.CreateInstance(nodeType) as GraphNode;
            var id = System.Guid.NewGuid().ToString();
            node.Initialize(id, graph);
            node.Position = Vector2.zero;
            graph.Nodes.Add(node);
            return node;
        }

        public override TLink LinkNodes<TLink>(GraphPin outputPin, GraphPin inputPin) 
        {
            // Make sure a link doesn't already exists
            foreach (var existingLink in graph.Links)
            {
                if (existingLink != null && existingLink.Input == inputPin && existingLink.Output == outputPin)
                {
                    return null;
                }
            }

            TLink link = ScriptableObject.CreateInstance<TLink>();
            link.Id = graph.IndexCounter.GetNext();
            link.Graph = graph;
            link.Input = inputPin;
            link.Output = outputPin;
            graph.Links.Add(link);
            return link;
        }

        public override void DestroyNode(GraphNode node)
        {
            if (node == null || !node.CanBeDeleted)
            {
                return;
            }

            var graph = node.Graph;

            // Break link connections
            var linksToBreak = new List<GraphLink>();
            foreach (var link in graph.Links) {
                if (link != null && link.Input != null && link.Output != null)
                {
                    if (link.Input.Node == node || link.Output.Node == node)
                    {
                        linksToBreak.Add(link);
                    }
                }
            }

            foreach(var link in linksToBreak)
            {
                graph.Links.Remove(link);
                DestroyObject(link);
            }

            // Destroy the pins
            var pins = new List<GraphPin>();
            pins.AddRange(node.InputPins);
            pins.AddRange(node.OutputPins);
            foreach (var pin in pins)
            {
                DestroyObject(pin);
            }

            graph.Nodes.Remove(node);
            DestroyObject(node);
        }

        void DestroyObject(Object obj)
        {
            if (Application.isEditor)
            {
                Object.DestroyImmediate(obj);
            }
            else
            {
                Object.Destroy(obj);
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphLayout\GraphLayout.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;


namespace DungeonArchitect.Graphs.Layouts
{
    public interface IGraphLayout<T>
    {
        void Layout(T[] nodes, IGraphLayoutNodeActions<T> nodeActions);
    }

    public interface IGraphLayoutNodeActions<T>
    {
        void SetNodePosition(T node, Vector2 position);
        Vector2 GetNodePosition(T node);
        T[] GetOutgoingNodes(T node);
    }

    public enum GraphLayoutType
    {
        Layered,
        Spring
    }

    public class GraphLayoutNode<T>
    {
        public T Payload { get; set; }
        public Vector2 Position { get; set; }
        public List<GraphLayoutNode<T>> Outgoing { get; private set; }
        public List<GraphLayoutNode<T>> Incoming { get; private set; }

        public GraphLayoutNode(T payload, Vector2 position)
        {
            Outgoing = new List<GraphLayoutNode<T>>();
            Incoming = new List<GraphLayoutNode<T>>();

            this.Payload = payload;
            this.Position = position;
        }
    }

    public abstract class GraphLayoutBase<T> : IGraphLayout<T>
    {
        public void Layout(T[] nodes, IGraphLayoutNodeActions<T> nodeActions)
        {
            if (nodeActions == null || nodes == null) { return; }

            var nodeToLayoutMap = new Dictionary<T, GraphLayoutNode<T>>();
            var layoutNodes = new GraphLayoutNode<T>[nodes.Length];

            // Create the nodes
            for (int i = 0; i < nodes.Length; i++) 
            {
                var node = nodes[i];
                var position = nodeActions.GetNodePosition(node);
                var layoutNode = new GraphLayoutNode<T>(node, position);
                layoutNodes[i] = layoutNode;

                nodeToLayoutMap.Add(node, layoutNode);
            }

            // Link the nodes
            foreach (var node in nodes)
            {
                var layoutNode = nodeToLayoutMap[node];
                T[] outgoingNodes = nodeActions.GetOutgoingNodes(node);
                foreach (var outgoingNode in outgoingNodes)
                {
                    if (!nodeToLayoutMap.ContainsKey(outgoingNode)) continue;
                    var layoutOutgoingNode = nodeToLayoutMap[outgoingNode];
                    layoutNode.Outgoing.Add(layoutOutgoingNode);
                    layoutOutgoingNode.Incoming.Add(layoutNode);
                }
            }

            LayoutImpl(layoutNodes);

            foreach (var layoutNode in layoutNodes)
            {
                nodeActions.SetNodePosition(layoutNode.Payload, layoutNode.Position);
            }
        }

        protected abstract void LayoutImpl(GraphLayoutNode<T>[] nodes);
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphLayout\GraphLayoutLayered.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Graphs.Layouts.Layered
{
    class LayoutTreeNode<T>
    {
        public GraphLayoutNode<T> GraphNode;
        public float X;
        public int Depth;
        public float Mod;

        public LayoutTreeNode<T> Parent;
        public List<LayoutTreeNode<T>> Children = new List<LayoutTreeNode<T>>();
    }

    class LayoutTree<T>
    {
        public LayoutTreeNode<T> root;
        public List<LayoutTreeNode<T>> nodes = new List<LayoutTreeNode<T>>();
    }

    [System.Serializable]
    public class GraphLayoutLayeredConfig
    {
        [SerializeField]
        public Vector2 separation = new Vector2(130, 100);
    }

    public class GraphLayoutLayered<T> : GraphLayoutBase<T>
    {
        GraphLayoutLayeredConfig config;
        public GraphLayoutLayered(GraphLayoutLayeredConfig config)
        {
            this.config = config;
        }

        LayoutTreeNode<T> BuildTreeNode(LayoutTree<T> tree, LayoutTreeNode<T> parent, GraphLayoutNode<T> graphNode, HashSet<GraphLayoutNode<T>> visited)
        {
            visited.Add(graphNode);

            var treeNode = new LayoutTreeNode<T>();
            treeNode.GraphNode = graphNode;
            treeNode.Parent = parent;
            tree.nodes.Add(treeNode);

            foreach (var outgoingGraphNode in graphNode.Outgoing)
            {
                if (!visited.Contains(outgoingGraphNode))
                {
                    var childTreeNode = BuildTreeNode(tree, treeNode, outgoingGraphNode, visited);
                    treeNode.Children.Add(childTreeNode);
                }
            }

            return treeNode;
        }

        LayoutTree<T> BuildTree(GraphLayoutNode<T>[] nodes)
        {
            var tree = new LayoutTree<T>();

            // Find the root node
            if (nodes.Length == 0)
            {
                return tree;
            }

            var startNode = nodes[0];
            {
                var visited = new HashSet<GraphLayoutNode<T>>();
                while (startNode.Incoming.Count > 0)
                {
                    if (visited.Contains(startNode))
                    {
                        break;
                    }
                    visited.Add(startNode);

                    startNode = startNode.Incoming[0];
                }
            }

            {
                var visited = new HashSet<GraphLayoutNode<T>>();
                tree.root = BuildTreeNode(tree, null, startNode, visited);
            }
            return tree;
        }

        void TagNodeLevels(LayoutTreeNode<T> node, int depth)
        {
            node.Depth = depth;
            foreach (var child in node.Children)
            {
                TagNodeLevels(child, depth + 1);
            }
        }

        void CalculateInitialX(LayoutTreeNode<T> Node, LayoutTreeNode<T> LeftSibling)
        {
            LayoutTreeNode<T> LeftChild = null;
            foreach (LayoutTreeNode<T> Child in Node.Children)
            {
                CalculateInitialX(Child, LeftChild);
                LeftChild = Child;
            }

            bool bIsLeftMost = LeftSibling == null;
            bool bIsLeaf = (Node.Children.Count == 0);

            if (bIsLeaf)
            {
                if (bIsLeftMost)
                {
                    Node.X = 0;
                }
                else
                {
                    Node.X = LeftSibling.X + 1;
                }
            }
            else if (Node.Children.Count == 1)
            {
                if (bIsLeftMost)
                {
                    Node.X = Node.Children[0].X;
                }
                else
                {
                    Node.X = LeftSibling.X + 1;
                    Node.Mod = Node.X - Node.Children[0].X;
                }
            }
            else
            {
                float LeftX = Node.Children[0].X;
                float RightX = Node.Children[Node.Children.Count - 1].X;
                float MidX = (LeftX + RightX) / 2.0f;

                if (bIsLeftMost)
                {
                    Node.X = MidX;
                }
                else
                {
                    Node.X = LeftSibling.X + 1;
                    Node.Mod = Node.X - MidX;
                }
            }

            if (!bIsLeaf && !bIsLeftMost)
            {
                ResolveConflicts(Node);
            }
        }


        void ResolveConflicts(LayoutTreeNode<T> Node)
        {
            float ShiftValue = 0.0f;
            float MinDistance = 1.0f;

            var NodeContour = new Dictionary<int, float>();
            GetLeftContour(Node, 0, NodeContour);

            var NodeLevels = new List<int>(NodeContour.Keys);
            NodeLevels.Sort();

            LayoutTreeNode<T> Sibling = GetLeftMostSibling(Node);

            while (Sibling != null && Sibling != Node)
            {
                var SiblingContour = new Dictionary<int, float>();
                GetRightContour(Sibling, 0, SiblingContour);

                var SiblingLevels = new List<int>(SiblingContour.Keys);
                SiblingLevels.Sort();

                int MaxNodeLevel = NodeLevels[NodeLevels.Count - 1];
                int MaxSiblingLevel = SiblingLevels[SiblingLevels.Count - 1];

                int StartLevel = Node.Depth + 1;
                int EndLevel = Mathf.Min(MaxNodeLevel, MaxSiblingLevel);
                for (int Level = StartLevel; Level <= EndLevel; Level++)
                {
                    float Distance = NodeContour[Level] - SiblingContour[Level];
                    if (Distance + ShiftValue < MinDistance)
                    {
                        ShiftValue = MinDistance - Distance;
                    }
                }

                if (ShiftValue > 0)
                {
                    Node.X += ShiftValue;
                    Node.Mod += ShiftValue;

                    ShiftValue = 0;
                }

                Sibling = GetNextSibling(Sibling);
            }
        }


        void GetLeftContour(LayoutTreeNode<T> Node, float ModSum, Dictionary<int, float> ContourMap)
        {
            if (!ContourMap.ContainsKey(Node.Depth))
            {
                ContourMap.Add(Node.Depth, Node.X + ModSum);
            }
            else
            {
                ContourMap[Node.Depth] = Mathf.Min(ContourMap[Node.Depth], Node.X + ModSum);
            }

            foreach (var Child in Node.Children)
            {
                GetLeftContour(Child, ModSum + Node.Mod, ContourMap);
            }
        }

        void GetRightContour(LayoutTreeNode<T> Node, float ModSum, Dictionary<int, float> ContourMap)
        {
            if (!ContourMap.ContainsKey(Node.Depth))
            {
                ContourMap.Add(Node.Depth, Node.X + ModSum);
            }
            else
            {
                ContourMap[Node.Depth] = Mathf.Max(ContourMap[Node.Depth], Node.X + ModSum);
            }

            foreach (var Child in Node.Children)
            {
                GetRightContour(Child, ModSum + Node.Mod, ContourMap);
            }
        }

        LayoutTreeNode<T> GetLeftMostSibling(LayoutTreeNode<T> Node)
        {
            if (Node == null || Node.Parent == null)
            {
                return null;
            }

            return Node.Parent.Children[0];
        }

        LayoutTreeNode<T> GetNextSibling(LayoutTreeNode<T> Node)
        {
            if (Node == null || Node.Parent == null)
            {
                return null;
            }

            int NodeIdx = Node.Parent.Children.IndexOf(Node);
            if (NodeIdx == -1 || NodeIdx == Node.Parent.Children.Count - 1)
            {
                return null;
            }

            return Node.Parent.Children[NodeIdx + 1];
        }

        void CalculateFinalX(LayoutTreeNode<T> Node, float TotalMod)
        {
            Node.X += TotalMod;

            foreach (var Child in Node.Children)
            {
                CalculateFinalX(Child, TotalMod + Node.Mod);
            }
        }

        protected override void LayoutImpl(GraphLayoutNode<T>[] nodes)
        {
            var tree = BuildTree(nodes);

            TagNodeLevels(tree.root, 0);
            CalculateInitialX(tree.root, null);
            CalculateFinalX(tree.root, 0);

            float depthDistance = config.separation.x;
            float siblingDistance = config.separation.y;

            foreach (var node in tree.nodes)
            {
                var position = new Vector2(
                    depthDistance * node.Depth,
                    siblingDistance * node.X);

                node.GraphNode.Position = position;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphLayout\GraphLayoutSpring.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Graphs.Layouts.Spring
{
    [System.Serializable]
    public class GraphLayoutSpringConfig
    {
        [SerializeField]
        public float interNodeDistance = 120;

        [SerializeField]
        public float interNodeTension = 0.5f;

        [SerializeField]
        public float springDistance = 30;

        [SerializeField]
        public float springTension = 0.1f;

        [SerializeField]
        public int iterations = 200;

        [SerializeField]
        public float timeStep = 1.0f;
    }

    class SpatialGrid<T>
    {
        Dictionary<IntVector2, List<GraphLayoutNode<T>>> grid = new Dictionary<IntVector2, List<GraphLayoutNode<T>>>();
        float cellSize;
        public SpatialGrid(float cellSize)
        {
            this.cellSize = cellSize;
        }

        public void Refresh(GraphLayoutNode<T>[] nodes)
        {
            grid.Clear();
            foreach (var node in nodes)
            {
                var key = GetKey(node);
                if (!grid.ContainsKey(key))
                {
                    grid.Add(key, new List<GraphLayoutNode<T>>());
                }
                grid[key].Add(node);
            }
        }

        IntVector2 GetKey(GraphLayoutNode<T> node)
        {
            int sx = Mathf.FloorToInt(node.Position.x / cellSize);
            int sy = Mathf.FloorToInt(node.Position.y / cellSize);
            return new IntVector2(sx, sy);
        }

        public GraphLayoutNode<T>[] GetNearbyNodes(GraphLayoutNode<T> node)
        {
            var key = GetKey(node);
            var nearbyNodes = new List<GraphLayoutNode<T>>();
            for (int dx = -1; dx <= 1; dx++)
            {
                for (int dy = -1; dy <= 1; dy++)
                {
                    var nkey = key + new IntVector2(dx, dy);
                    if (grid.ContainsKey(nkey))
                    {
                        nearbyNodes.AddRange(grid[nkey]);
                    }
                }
            }

            nearbyNodes.Remove(node);
            return nearbyNodes.ToArray();
        }
    }

    public class GraphLayoutSpring<T> : GraphLayoutBase<T>
    {
        GraphLayoutSpringConfig config;
        public GraphLayoutSpring(GraphLayoutSpringConfig config)
        {
            this.config = config;
        }

        protected override void LayoutImpl(GraphLayoutNode<T>[] nodes)
        {
            var random = new System.Random(0);
            int initialScatterRadius = 30;
            foreach (var node in nodes)
            {
                float angle = random.NextFloat() * Mathf.PI * 2;
                float distance = random.NextFloat();
                distance = 1 - distance * distance * distance;
                node.Position = new Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * initialScatterRadius * distance;
            }

            var spatialGrid = new SpatialGrid<T>(config.interNodeDistance);

            // separate
            for (int i = 0; i < config.iterations; i++)
            {
                spatialGrid.Refresh(nodes);
                var nearbyNodes = new Dictionary<GraphLayoutNode<T>, GraphLayoutNode<T>[]>();
                foreach (var node in nodes)
                {
                    nearbyNodes.Add(node, spatialGrid.GetNearbyNodes(node));
                }

                float interNodeDistanceSq = config.interNodeDistance * config.interNodeDistance;
                foreach (var node in nodes)
                {
                    foreach (var nearbyNode in nearbyNodes[node])
                    {
                        // Separate by pushing them away
                        var distanceSq = (nearbyNode.Position - node.Position).sqrMagnitude;
                        if (distanceSq < interNodeDistanceSq)
                        {
                            // Needs to be pushed away
                            float distance = Mathf.Sqrt(distanceSq);
                            var direction = (nearbyNode.Position - node.Position) / distance;
                            var pushVector = direction * distance * config.interNodeTension * config.timeStep;
                            nearbyNode.Position += pushVector;
                            node.Position -= pushVector;
                        }
                    }
                }

                // Apply spring tension
                foreach (var node in nodes)
                {
                    foreach (var outgoingNode in node.Outgoing)
                    {
                        var distance = (outgoingNode.Position - node.Position).magnitude;
                        var direction = (outgoingNode.Position - node.Position) / distance;

                        float pushDistance = config.springDistance - distance;
                        var pushThisFrame = direction * pushDistance * config.springTension * config.timeStep;
                        outgoingNode.Position += pushThisFrame;
                        node.Position -= pushThisFrame;
                    }
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\RuntimeGraph\RuntimeGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.RuntimeGraphs
{
    public class RuntimeGraph<T>
    {
        public List<RuntimeGraphNode<T>> Nodes = new List<RuntimeGraphNode<T>>();

        public void RemoveNode(RuntimeGraphNode<T> node)
        {
            if (node.Graph == this)
            {
                node.BreakAllLinks();
                Nodes.Remove(node);
            }
            else
            {
                Debug.LogWarning("Remove node from an invalid graph");
            }
        }
    }

    public class RuntimeGraphNode<T>
    {
        public T Payload = default(T);
        public RuntimeGraph<T> Graph;
        public Vector2 Position = Vector2.zero;

        public List<RuntimeGraphNode<T>> Outgoing = new List<RuntimeGraphNode<T>>();
        public List<RuntimeGraphNode<T>> Incoming = new List<RuntimeGraphNode<T>>();

        public RuntimeGraphNode(RuntimeGraph<T> graph)
        {
            this.Graph = graph;
        }


        public void MakeLinkTo(RuntimeGraphNode<T> destNode)
        {
            Outgoing.Add(destNode);
            destNode.Incoming.Add(this);
        }

        public void BreakLinkTo(RuntimeGraphNode<T> destNode)
        {
            Outgoing.Remove(destNode);
            destNode.Incoming.Remove(this);
        }

        public void BreakAllOutgoingLinks()
        {
            var outgoingNodes = new List<RuntimeGraphNode<T>>(Outgoing);
            foreach (var outgoingNode in outgoingNodes)
            {
                BreakLinkTo(outgoingNode);
            }
        }

        public void BreakAllIncomingLinks()
        {
            var incomingNodes = new List<RuntimeGraphNode<T>>(Incoming);
            foreach (var incomingNode in incomingNodes)
            {
                incomingNode.BreakLinkTo(this);
            }
        }

        public void BreakAllLinks()
        {
            BreakAllOutgoingLinks();
            BreakAllIncomingLinks();
        }

        public override string ToString()
        {
            if (Payload != null)
            {
                return Payload.ToString();
            }
            return base.ToString();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\RuntimeGraph\RuntimeGraphBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using System.Collections.Generic;
using UnityEngine;


namespace DungeonArchitect.RuntimeGraphs
{
    public class RuntimeGraphBuilderHandlers<T>
    {
        public System.Func<GraphNode, bool> CanCreateNode;
        public System.Action<GraphNode, RuntimeGraphNode<T>> NodeCreated;
        public System.Func<GraphNode, T> GetPayload;
    }

    public class RuntimeGraphBuilder
    {
        public static RuntimeGraphNode<T> AddNode<T>(GraphNode graphNode, RuntimeGraph<T> runtimeGraph, RuntimeGraphBuilderHandlers<T> handlers)
        {
            if (handlers.CanCreateNode(graphNode))
            {
                var runtimeNode = new RuntimeGraphNode<T>(runtimeGraph);
                runtimeNode.Payload = handlers.GetPayload(graphNode);
                runtimeNode.Position = graphNode.Position;
                runtimeGraph.Nodes.Add(runtimeNode);
                handlers.NodeCreated(graphNode, runtimeNode);
                return runtimeNode;
            }
            return null;
        }

        public static RuntimeGraphNode<T> AddNode<T>(T payload, RuntimeGraph<T> runtimeGraph)
        {
            var runtimeNode = new RuntimeGraphNode<T>(runtimeGraph);
            runtimeNode.Payload = payload;
            runtimeNode.Position = Vector2.zero;
            runtimeGraph.Nodes.Add(runtimeNode);
            return runtimeNode;
        }

        public static void Build<T>(Graph graph, RuntimeGraph<T> runtimeGraph, RuntimeGraphBuilderHandlers<T> handlers)
        {
            runtimeGraph.Nodes.Clear();

            // Create the nodes
            var mapping = new Dictionary<GraphNode, RuntimeGraphNode<T>>();
            foreach (var graphNode in graph.Nodes)
            {
                var runtimeNode = AddNode(graphNode, runtimeGraph, handlers);
                mapping.Add(graphNode, runtimeNode);
            }

            // Connect the links
            foreach (var link in graph.Links)
            {
                if (link == null) continue;
                var snode = link.Output ? link.Output.Node : null;
                var dnode = link.Input ? link.Input.Node : null;
                if (snode == null || dnode == null) continue;
                if (!mapping.ContainsKey(snode) || !mapping.ContainsKey(dnode)) continue;

                var sourceNode = mapping[snode];
                var destNode = mapping[dnode];

                sourceNode.MakeLinkTo(destNode);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Meshing\Geometry\GeometryData.cs:
 using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Meshing.Common
{
    public struct GeometryVertex
    {
        public Vector3 position;
        public Vector3 normal;
        public Vector2 uv;
        public float ao;
    }

    public class GeometryData 
    {
        public GeometryVertex[] vertices = new GeometryVertex[0];
        public int[] indices = new int[0];
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\DungeonNavAgent.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Navigation {
	public abstract class DungeonNavAgent : MonoBehaviour {
		public abstract void Resume();
		public abstract void Stop();
		public abstract float GetRemainingDistance();
		public abstract Vector3 Destination { get; set; }
		public abstract Vector3 Velocity { get; set; }
		public abstract Vector3 Direction { get; }
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\DungeonNavAgent2D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using SharpNav.Crowds;

namespace DungeonArchitect.Navigation {
	public class DungeonNavAgent2D : DungeonNavAgent {
		public float radius = 0.5f;
		public float height = 1f;
		public float maxAcceleration = 8;
		public float maxSpeed = 3f;	
		public float collisionQueryRange = 4;	
		public float pathOptimizationRange = 15;	
		public float separationWeight = 3;
		public Vector2 navAgentCollisionOffset;

		// No. of updates per second
		public float updateFrequency = 2;

		int agentId;
		DungeonNavMesh navMesh;
		Rigidbody2D rigidBody2D;
		bool running = true;
		Vector3 previousDirection = Vector3.zero;

		public DungeonNavMesh NavMesh {
			get {
				return navMesh;
			}
		}

		Vector3 destination;
		SharpNav.Crowds.Agent agent;

		public override Vector3 Destination {
			get {
				return destination;
			}
			set { destination = value; }
		}

		public override Vector3 Velocity {
			get {
				if (agent == null) return Vector3.zero;
				return ToV3(agent.Vel);
			}
			set {
				agent.Vel = ToSV3(value);
			}
		}

		public override Vector3 Direction {
			get {
				return previousDirection;
			}
		}

		public float DesiredSpeed {
			get {
				if (agent == null) return 0;
				return agent.DesiredSpeed; 
			}
		}

		Vector3 _debugNavDest = Vector3.zero;
		void OnDrawGizmosSelected() {
			Gizmos.color = Color.yellow;
			Gizmos.DrawWireSphere(destination, 0.1f);
			Gizmos.color = Color.cyan;
			Gizmos.DrawWireSphere(FlipYZ(_debugNavDest), 0.1f);
			if (agent != null) {
				Gizmos.color = Color.red;
				Gizmos.DrawWireSphere(FlipYZ(ToV3(agent.Position)), radius);
			}
		}

		Vector3 FlipYZ(Vector3 v) {
			return new Vector3(v.x, v.z, v.y);
		}

		void Awake() {
			rigidBody2D = GetComponent<Rigidbody2D>();
			if (rigidBody2D == null) {
				Debug.LogWarning("Rigid Body 2D not assigned to nav agent game object");
			}
		}

		// Use this for initialization
		void Start () {
			//transform.position = FlipYZ(transform.position);
            navMesh = GameObject.FindObjectOfType<DungeonNavMesh>();
			if (navMesh == null || navMesh.NavMeshQuery == null)
            {
				Debug.LogWarning("Cannot build initialize dungeon navigation agent. No dungeon navigation object found in the scene. Drop in the DungeonNavigation prefab into the scene");
			} 
            else {
				// Place the player on the nearest valid nav mesh polygon
				PositionOnNearestNavMesh();

				var agentParams = new SharpNav.Crowds.AgentParams();
				agentParams.Radius = radius;
				agentParams.Height = height;
				agentParams.MaxAcceleration = maxAcceleration;
				agentParams.MaxSpeed = maxSpeed;
				agentParams.CollisionQueryRange = collisionQueryRange;
				agentParams.PathOptimizationRange = pathOptimizationRange;
				agentParams.SeparationWeight = separationWeight;
				agentParams.UpdateFlags = UpdateFlags.Separation | UpdateFlags.OptimizeTopo; 

				var position = ActorPosition3D + new Vector3(navAgentCollisionOffset.x, 0, navAgentCollisionOffset.y);
				var sposition = ToSV3(position);
				if (navMesh.Crowd == null) {
					Debug.Log ("Navmesh not initialized properly.  Crowd is null");
					return;
				}
				agentId = navMesh.Crowd.AddAgent(sposition, agentParams);

				if (agentId >= 0) {
					agent = navMesh.Crowd.GetAgent(agentId);
				} else {
					Debug.Log ("Cannot create crowd nav agent");
				}
			}
		}

		Vector3 ActorPosition3DX {
			get { return (transform.position); }
			set { 
				transform.position = value;
			}
		}

		Vector3 ActorPosition3D {
			get { return FlipYZ(transform.position); }
			set { 
				var flipped = FlipYZ (value);
				flipped.z = 0;
				transform.position = flipped;
			}
		}


		void PositionOnNearestNavMesh() {
			var navPoint = navMesh.NavMeshQuery.FindNearestPoly(ToSV3(ActorPosition3D), ToSV3(Vector3.one * 6));
			ActorPosition3D = ToV3 (navPoint.Position);
		}

		public static SharpNav.Geometry.Vector3 ToSV3(Vector3 v) {
			return new SharpNav.Geometry.Vector3(v.x, v.y, v.z);
		}

		public static Vector3 ToV3(SharpNav.Geometry.Vector3 v) {
			return new Vector3(v.X, v.Y, v.Z);
		}

		public override void Stop() {
			if (agent != null) {
				var navPoint = navMesh.NavMeshQuery.FindNearestPoly(agent.Position, ToSV3(Vector3.one * 4));
				agent.Reset (navPoint.Polygon, navPoint.Position);
			}
			rigidBody2D.velocity = Vector2.zero;
			running = false;
		}

		public override void Resume() {
			running = true;
		}

		void Update() {

		}

		public override float GetRemainingDistance() {
			if (agent == null) return 0;
			var direction = (ToV3(agent.TargetPosition) - ActorPosition3D);
			direction.y = 0;
			return direction.magnitude;
		}

		// Update is called once per frame
		void FixedUpdate() {
			// Move the player towards the destination
			if (running && agent != null) {
				// Move the character using unity's physics

				// Reset the position of the character to the nav agent's position if they are too far away
				{
					var resetDistanceThreshold = 4;
					var distanceToNavAgent = (ActorPosition3D - ToV3(agent.Position)).magnitude;
					if (distanceToNavAgent > resetDistanceThreshold) {
						ActorPosition3D = ToV3(agent.Position);
					}

				}

				{
					var svelocity = agent.Vel;
					var velocity = ToV3 (svelocity);

					rigidBody2D.velocity = FlipYZ(velocity);

					if (velocity.sqrMagnitude > 0.01f) {
						previousDirection = velocity.normalized;
					}
				}

				try {
					// Move the nav agent
					var navPoint = navMesh.NavMeshQuery.FindNearestPoly(ToSV3(ActorPosition3D), ToSV3(Vector3.one * 2));
					agent.Position = navPoint.Position;

					navPoint = navMesh.NavMeshQuery.FindNearestPoly(ToSV3(FlipYZ(destination)), ToSV3(Vector3.one * 2));
					agent.RequestMoveTarget(navPoint.Polygon, navPoint.Position);

					_debugNavDest = ToV3 (navPoint.Position);
				} catch(System.Exception) {
					//Debug.Log(e);
				}
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\DungeonNavAgent3D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using SharpNav.Crowds;


namespace DungeonArchitect.Navigation {
	public class DungeonNavAgent3D : DungeonNavAgent {
		public float radius = 0.5f;
		public float height = 1f;
		public float maxAcceleration = 8;
		public float maxSpeed = 3f;	
		public float collisionQueryRange = 4;	
		public float pathOptimizationRange = 15;	
		public float separationWeight = 3;
		public float gravity = -10;
		
		// No. of updates per second
		public float updateFrequency = 2;
        float timeSinceLastNavUpdate = 0;
		
		CharacterController character;
		
		int agentId;
		DungeonNavMesh navMesh;
		bool running = true;
		
		public DungeonNavMesh NavMesh {
			get {
				return navMesh;
			}
		}
		
		Vector3 destination;
		SharpNav.Crowds.Agent agent;
		
		public override Vector3 Destination {
			get {
				return destination;
			}
			set { destination = value; }
		}
		
		public override Vector3 Velocity {
			get {
				if (agent == null) return Vector3.zero;
				return ToV3(agent.Vel);
			}
			set {
				agent.Vel = ToSV3(value);
			}
		}
		
		public override Vector3 Direction {
			get {
				return Velocity.normalized;
			}
		}

		public float DesiredSpeed {
			get {
				if (agent == null) return 0;
				return agent.DesiredSpeed; 
			}
		}
		
		void OnDrawGizmosSelected() {
			if (agent != null) {
				Gizmos.DrawSphere(ToV3(agent.Position), 1);
			}
		}
		
		// Use this for initialization
		void Start () {
			character = GetComponent<CharacterController>();
			navMesh = GameObject.FindObjectOfType<DungeonNavMesh>();
			if (navMesh == null)
			{
				Debug.LogWarning("Cannot build initialize dungeon navigation agent. No dungeon navigation object found in the scene. Drop in the DungeonNavigation prefab into the scene");
			} 
			else {
				// Place the player on the nearest valid nav mesh polygon
				PositionOnNearestNavMesh();
				
				var agentParams = new SharpNav.Crowds.AgentParams();
				agentParams.Radius = radius;
				agentParams.Height = height;
				agentParams.MaxAcceleration = maxAcceleration;
				agentParams.MaxSpeed = maxSpeed;
				agentParams.CollisionQueryRange = collisionQueryRange;
				agentParams.PathOptimizationRange = pathOptimizationRange;
				agentParams.SeparationWeight = separationWeight;
				agentParams.UpdateFlags = UpdateFlags.Separation | UpdateFlags.OptimizeTopo; 
				
				var position = transform.position;
				var sposition = ToSV3(position);
				if (navMesh.Crowd == null) {
					Debug.Log ("Navmesh not initialized properly.  Crowd is null");
					return;
				}
				agentId = navMesh.Crowd.AddAgent(sposition, agentParams);
				
				if (agentId >= 0) {
					agent = navMesh.Crowd.GetAgent(agentId);
				} else {
					Debug.Log ("Cannot create crowd nav agent");
				}
			}
		}
		
		void PositionOnNearestNavMesh() {
			var navPoint = navMesh.NavMeshQuery.FindNearestPoly(ToSV3(transform.position), ToSV3(Vector3.one * 6));
			transform.position = ToV3 (navPoint.Position);
		}
		
		public static SharpNav.Geometry.Vector3 ToSV3(Vector3 v) {
			return new SharpNav.Geometry.Vector3(v.x, v.y, v.z);
		}
		
		public static Vector3 ToV3(SharpNav.Geometry.Vector3 v) {
			return new Vector3(v.X, v.Y, v.Z);
		}
		
		public override void Stop() {
			if (agent != null) {
				var navPoint = navMesh.NavMeshQuery.FindNearestPoly(agent.Position, ToSV3(Vector3.one * 4));
				agent.Reset (navPoint.Polygon, navPoint.Position);
			}
			running = false;
		}
		
		public override void Resume() {
			running = true;
		}
		
		void Update() {
			
		}
		
		public override float GetRemainingDistance() {
			if (agent == null) return 0;
			var direction = (ToV3(agent.TargetPosition) - transform.position);
			direction.y = 0;
			return direction.magnitude;
		}
		
		// Update is called once per frame
		void FixedUpdate() {
            timeSinceLastNavUpdate += Time.fixedDeltaTime;
            bool recalculatePath = false;
            if (updateFrequency == 0)
            {
                recalculatePath = true;
            }
            else
            {
                float frameTime = 1.0f / Mathf.Max(1, updateFrequency);
                if (timeSinceLastNavUpdate >= frameTime)
                {
                    recalculatePath = true;
                    timeSinceLastNavUpdate = 0;
                }
            }
            ProcessMove(recalculatePath);
        }

        void ProcessMove(bool recalculatePath) {
			// Move the player towards the destination
			if (running && agent != null && character.enabled) {
				// Move the character using unity's physics
				
				// Reset the position of the character to the nav agent's position if they are too far away
				{
					var resetDistanceThreshold = 4;
					var distanceToNavAgent = (transform.position - ToV3(agent.Position)).magnitude;
					if (distanceToNavAgent > resetDistanceThreshold) {
						transform.position = ToV3(agent.Position);
					}
					
				}
				
				{
					var svelocity = agent.Vel;
					var velocity = ToV3 (svelocity);
					
					if (!character.isGrounded) {
						velocity += new Vector3(0, gravity, 0);
					}

					bool moved = false; //character.SimpleMove(velocity);
					if (!moved) {
                        if (recalculatePath)
                        {
                            var delta = velocity * Time.fixedDeltaTime;
                            character.Move(delta);
                        }
                        else
                        {
                            character.SimpleMove(velocity);
                        }
					}
					
					// Set the rotation
					var direction = velocity;
					direction.y = 0;
					var speedSq = direction.sqrMagnitude;
					if (speedSq > 0.01f) {
						transform.rotation = Quaternion.LookRotation(direction.normalized);
					}
				}

                if (recalculatePath)
                {
                    try
                    {
                        // Move the nav agent
                        var navPoint = navMesh.NavMeshQuery.FindNearestPoly(ToSV3(transform.position), ToSV3(Vector3.one * 2));
                        agent.Position = navPoint.Position;

                        navPoint = navMesh.NavMeshQuery.FindNearestPoly(ToSV3(destination), ToSV3(Vector3.one * 2));
                        agent.RequestMoveTarget(navPoint.Polygon, navPoint.Position);
                    }
                    catch (System.Exception)
                    {
                        //Debug.Log(e);
                    }
                }
			}
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\DungeonNavMesh.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using STE = SharpNav.Geometry.TriangleEnumerable;
using SVector3 = SharpNav.Geometry.Vector3;
using Triangle3 = SharpNav.Geometry.Triangle3;
using Crowd = SharpNav.Crowds.Crowd;

namespace DungeonArchitect.Navigation {

    public class NavigationEvent
    {
        public DungeonNavMesh navMesh;
    }

    public delegate void OnNavmeshBuiltDelegate(NavigationEvent e);

	public class DungeonNavMesh : MonoBehaviour {
		public float agentHeight = 2;
		public float agentRadius = 0.5f;
		public float agentClimbHeight = 0.5f;
		public float cellSize = 0.2f;
		public int maxCrowdAgents = 50;
		public Mesh visualization;
		public Color visualizationColor = new Color(0, 0.5f, 1, 0.25f);
		public bool visualize2D = false;

        public event OnNavmeshBuiltDelegate OnNavmeshBuilt;
	    
	    SharpNav.NavMesh navMesh;
		public SharpNav.NavMesh NavMesh {
			get {
				return navMesh;
			}
		}


		SharpNav.NavMeshQuery navMeshQuery;
		public SharpNav.NavMeshQuery NavMeshQuery {
			get {
				return navMeshQuery;
			}
		}

		public Crowd crowd;
		public Crowd Crowd {
			get {
				return crowd;
			}
		}

		SharpNav.PolyMesh polyMesh = null;
		public SharpNav.PolyMesh PolyMesh {
			get {
				return polyMesh;
			}
		}
		
		SharpNav.PolyMeshDetail polyMeshDetail = null;
		public SharpNav.PolyMeshDetail PolyMeshDetail {
			get {
				return polyMeshDetail;
			}
		}

		void Awake() {
			SetNavMeshVisible(false);
		}

		void Update() {
			if (crowd != null) {
				crowd.Update(Time.deltaTime);
			}
		}

		public void SetNavMeshVisible(bool show) {
			var meshRenderer = GetComponent<MeshRenderer>();
			if (meshRenderer != null) {
				meshRenderer.enabled = show;
			}
		}

		// Use this for initialization
		public void Build() {
			List<Triangle3> triangles = new List<Triangle3>();
			// Get all the triangle provider components attached to this game object
			var triangleProviders = GetComponents<NavigationTriangleProvider>();
			foreach (var triangleProvider in triangleProviders) {
				triangleProvider.AddNavTriangles(triangles);
			}

			if (triangles.Count == 0) {
				// No geometry exists. Cannot create
				Debug.Log ("No geometry has been added to the nav mesh");
				return;
			}

			//use the default generation settings
			var settings = SharpNav.NavMeshGenerationSettings.Default;
			settings.AgentHeight = agentHeight;
			settings.AgentRadius = agentRadius;
			settings.MaxClimb = agentClimbHeight;
			settings.CellSize = cellSize;
			navMesh = SharpNav.NavMesh.Generate(triangles, settings, out polyMesh, out polyMeshDetail);

			SharpNav.TiledNavMesh tiledMesh = navMesh;
	        navMeshQuery = new SharpNav.NavMeshQuery(tiledMesh, 2048);
	        crowd = new Crowd(maxCrowdAgents, agentRadius, ref tiledMesh);

			BuildVisualization();

            if (OnNavmeshBuilt != null)
            {
                var e = new NavigationEvent();
                e.navMesh = this;
                OnNavmeshBuilt(e);
            }
		}

		public static Vector3 ToV3(SVector3 v) {
			return new Vector3(v.X, v.Y, v.Z);
		}

		void BuildVisualization() {
			//if (visualization == null) 
			{
				var filter = GetComponent<MeshFilter>();
				visualization = new Mesh();
				filter.mesh = visualization;
			}
			if (polyMesh == null) return;

			visualization.Clear();


			var tile = navMesh.GetTileAt(0, 0, 0);
			var vertices = new List<Vector3>();
			var triangles = new List<int>();

			for (int i = 0; i < tile.Polys.Length; i++)
			{
				for (int j = 1; j + 1 < tile.Polys[i].VertCount; j++)
				{
					int vertIndex0 = tile.Polys[i].Verts[0];
					int vertIndex1 = tile.Polys[i].Verts[j];
					int vertIndex2 = tile.Polys[i].Verts[j + 1];
					
					var v = tile.Verts[vertIndex0];
					var v0 = ToV3(v);
					
					v = tile.Verts[vertIndex1];
					var v1 = ToV3(v);
					
					v = tile.Verts[vertIndex2];
					var v2 = ToV3(v);

					var offset = vertices.Count;
					vertices.Add(v0);
					vertices.Add(v1);
					vertices.Add(v2);
					
					triangles.Add (offset);
					triangles.Add (offset + 1);
					triangles.Add (offset + 2);
				}
			}

			if (visualize2D) {
				// Flip YZ
				float t;
				for (int i = 0; i < vertices.Count; i++) {
					var v = vertices[i];
					t = v.y;
					v.y = v.z;
					v.z = t;
					vertices[i] = v;
				}
			}

			visualization.vertices = vertices.ToArray();
			visualization.SetIndices(triangles.ToArray(), MeshTopology.Triangles, 0);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\NavigationBuildInvoker.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Navigation {
	/// <summary>
	/// Drop this script into your dungeon object and assign the nav mesh prefab to
	/// automatically rebuild the nav mesh whenever the dungeon is rebuild (works both with runtime and design time)
	/// </summary>
	public class NavigationBuildInvoker : DungeonEventListener {
		public DungeonNavMesh navMesh;

		/// <summary>
		/// Called after the dungeon is completely built
		/// </summary>
		/// <param name="model">The dungeon model</param>
		public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model) {
			if (navMesh != null) {
				navMesh.Build();
			}
			else {
				Debug.LogWarning("Cannot automatically rebuild nav mesh as it is not assigned to the dungeon event listener");
			}
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\NavigationTriangleProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using SharpNav.Geometry;

namespace DungeonArchitect.Navigation {
	public class NavigationTriangleProvider : MonoBehaviour {

		public virtual void AddNavTriangles(List<Triangle3> triangles) {
			// Implementations should override and implement this function
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Actors\SxMeshActor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.SxEngine
{
    public class SxMeshActor : SxActor
    {
        public SxMeshComponent MeshComponent;
        
        public SxMeshActor()
        {
            MeshComponent = AddComponent<SxMeshComponent>();
        }

        public void SetMesh(SxMesh mesh)
        {
            MeshComponent.Mesh = mesh;
        }
        
        public void SetMaterial(SxMaterial material)
        {
            MeshComponent.Material = material;
        }
        
        public void SetMesh<T>() where T : SxMesh, new()
        {
            MeshComponent.Mesh = SxMeshRegistry.Get<T>();
        }

        public void SetMaterial<T>() where T : SxMaterial, new()
        {
            MeshComponent.Material = SxMaterialRegistry.Get<T>();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Actors\SxTextActor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.SxEngine
{
    public class SxTextActor : SxActor
    {
        public SxTextComponent TextComponent;

        public SxTextActor()
        {
            TextComponent = AddComponent<SxTextComponent>();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Components\SxMeshComponent.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.SxEngine
{
    public class SxMeshComponent : SxActorComponent
    {
        public SxMesh Mesh;
        public SxMaterial Material
        {
            get => _material;
            set => _material = value;
        }
        
        private SxMaterial _material;
        
        protected override void DrawImpl(SxRenderContext context, Matrix4x4 accumWorldTransform, SxRenderCommandList renderCommandList)
        {
            if (Material == null)
            {
                Material = SxMaterialRegistry.Get<SxDefaultMaterial>();
            }
            
            if (Mesh != null)
            {
                renderCommandList.Add(new SxRenderCommand(accumWorldTransform, Mesh, Material));
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Components\SxTextComponent.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace DungeonArchitect.SxEngine
{
    public enum SxTextHAlign
    {
        Left,
        Center,
        Right
    }

    public enum SxTextVAlign
    {
        Top,
        Center,
        Bottom
    }

    public struct SxTextComponentSettings
    {
        public Font Font;
        public Color Color;
        public float Scale;
        public SxTextHAlign HAlign;
        public SxTextVAlign VAlign;
        public float DepthBias;
        public SxMaterial CustomMaterial;
        public bool WordWrap;
        public float WordWrapWidth;
        public float WordWrapHeight;
    }

    public struct SxTextLineInfo
    {
        public string Text;
        public float Scale;
        public float PaddingTop;
        public float PaddingBottom;
    }

    public class SxTextLineList
    {
        private List<SxTextLineInfo> lines = new List<SxTextLineInfo>();
        public SxTextLineInfo[] Lines => lines.ToArray();
        public int LineSpacing = 10;

        public int Length => lines.Count;
        
        public SxTextLineList()
        {
        }

        public SxTextLineList(string message)
        {
            AddLine(message);
        }

        public void Clear()
        {
            lines.Clear();
        }

        public void AddLine(string message, float scale = 1, float paddingTop = 0, float paddingBottom = 0)
        {   
            lines.Add(new SxTextLineInfo()
            {
                Text = message, 
                Scale = scale,
                PaddingTop = paddingTop,
                PaddingBottom = paddingBottom
            });
        }
    }
    
    public class SxTextComponent : SxActorComponent
    {
        private SxMesh mesh;
        private SxMaterial material;
        private SxTextLineList lines = new SxTextLineList();
        public SxTextComponentSettings Settings = new SxTextComponentSettings();

        public void SetText(string message)
        {
            lines = new SxTextLineList(message);
            RebuildMesh();
        }

        public void SetLines(SxTextLineList newLines)
        {
            lines = newLines;
            RebuildMesh();
        }

        private const string ValidCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_`~!@#$%^&*()-+=[]{}\\|;:'\"<>,./? ";

        public void Initialize(SxTextComponentSettings textSettings)
        {
            this.Settings = textSettings;
            Font.textureRebuilt += OnTextureRebuilt;

            if (Settings.Font != null)
            {
                Settings.Font.RequestCharactersInTexture(ValidCharacters);
                UpdateMaterial(Settings.Font);
                RebuildMesh();
            }
        }

        void UpdateMaterial(Font font)
        {
            if (font != null && font.material != null)
            {
                if (Settings.CustomMaterial != null)
                {
                    material = Settings.CustomMaterial;
                    material.UnityMaterial.mainTexture = font.material.mainTexture;
                }
                else
                {
                    material = new SxUnityMaterial(font.material);
                    material.DepthBias = Settings.DepthBias;
                }
            }
        }

        public override void Destroy()
        {
            base.Destroy();
            Font.textureRebuilt -= OnTextureRebuilt;
        }

        private void OnTextureRebuilt(Font font)
        {
            if (font == Settings.Font)
            {
                UpdateMaterial(font);
                RebuildMesh();
            }
        }

        protected override void DrawImpl(SxRenderContext context, Matrix4x4 accumWorldTransform, SxRenderCommandList renderCommandList)
        {
            if (mesh != null && material != null)
            {
                renderCommandList.Add(new SxRenderCommand(accumWorldTransform, mesh, material));
            }
        }

        private static void CalcTextSize(string message, float scale, Font font, out float width, out float minY, out float maxY)
        {
            width = 0;
            minY = maxY = 0;
            
            var localScale = scale / font.fontSize;
            for (var i = 0; i < message.Length; i++)
            {
                CharacterInfo ch;
                font.GetCharacterInfo(message[i], out ch);
                width += ch.advance * localScale;
                minY = Mathf.Min(minY, ch.minY * localScale);
                maxY = Mathf.Max(maxY, ch.maxY * localScale);
            }
        }

        private float CalculateTextHeight(SxTextLineList lines, float scale)
        {
            float height = 0;
            for (var i = 0; i < lines.Lines.Length; i++)
            {
                var line = lines.Lines[i];
                var lineScale = scale * line.Scale;
                CalcTextSize(line.Text, lineScale, Settings.Font, out var _, out var minY, out var maxY);
                height += maxY - minY;
                
                var localScale = scale * line.Scale / Settings.Font.fontSize;
                if (i > 0)
                {
                    height += lines.LineSpacing * localScale;
                }

                height += (line.PaddingTop + line.PaddingBottom) * localScale;
            }

            return height;
        }

        private static SxTextLineList PerformWordWrap(SxTextLineList lineList, float maxWidth, float scale, Font font)
        {
            var result = new SxTextLineList();
            foreach (var lineInfo in lineList.Lines)
            {
                var baseScale = scale * lineInfo.Scale;
                string[] wrappedLines = PerformWordWrap(lineInfo.Text, maxWidth, baseScale, font);
                for (int i = 0; i < wrappedLines.Length; i++)
                {
                    result.AddLine(wrappedLines[i], lineInfo.Scale, 
                        (i == 0) ? lineInfo.PaddingTop : 0,
                        (i == wrappedLines.Length - 1 ? lineInfo.PaddingBottom : 0));
                }
            }

            return result;
        }
        
        class TokenInfo
        {
            public string Message;
            public float Width = 0;
            public float MinY = 0;
            public float MaxY = 0;
        }
        
        private static string[] PerformWordWrap(string message, float maxWidth, float scale, Font font)
        {
            var textTokens = message.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            var tokens = new TokenInfo[textTokens.Length];
            for (int i = 0; i < tokens.Length; i++)
            {
                tokens[i] = new TokenInfo
                {
                    Message = textTokens[i]
                };
                CalcTextSize(textTokens[i], scale, font, out tokens[i].Width, out tokens[i].MinY, out tokens[i].MaxY);
            }

            CalcTextSize(" ", scale, font, out var spaceWidth, out var _, out var _);

            var lines = new List<string>();
            var line = new StringBuilder();
            var lineWidth = 0.0f;
            for (int i = 0; i < tokens.Length; i++)
            {
                var token = tokens[i];
                var tokenWidth = tokens[i].Width;
                if (line.Length > 0 && lineWidth + spaceWidth + tokenWidth > maxWidth)
                {
                    lines.Add(line.ToString());
                    line.Clear();
                    lineWidth = 0;
                }

                if (line.Length > 0)
                {
                    line.Append(" ");
                    lineWidth += spaceWidth;
                }

                line.Append(token.Message);
                lineWidth += tokenWidth;
            }

            if (line.Length > 0)
            {
                lines.Add(line.ToString());
            }

            return lines.ToArray();
        }

        private void RebuildMesh()
        {
            mesh = null;
            if (material == null || lines.Length == 0 || Settings.Font == null)
            {
                return;
            }

            UpdateMaterial(Settings.Font);

            var textWidth = 0.0f;
            var textHeight = 0.0f;
            var pos = Vector3.zero;
            var vertices = new List<SxMeshVertex>();

            var activeScale = Settings.Scale;
            var wrappedLines = lines;
            if (Settings.WordWrap)
            {
                wrappedLines = PerformWordWrap(lines, Settings.WordWrapWidth, activeScale, Settings.Font);
                if (Settings.WordWrapHeight > 1e-4f)
                {
                    var worldHeight = CalculateTextHeight(wrappedLines, activeScale);
                    if (worldHeight > Settings.WordWrapHeight)
                    {
                        var scaleLow = 0.0f;
                        var scaleHigh = 1.0f;
                        const int maxTries = 10;
                        int numTries = 0;
                        float bestScale = activeScale;
                        float bestHeight = worldHeight;
                        
                        while (numTries < maxTries)
                        {
                            var mid = (scaleLow + scaleHigh) * 0.5f;
                            var midScale = activeScale * mid;
                            wrappedLines = PerformWordWrap(lines, Settings.WordWrapWidth, midScale, Settings.Font);
                            worldHeight = CalculateTextHeight(wrappedLines, midScale);
                            if (worldHeight < Settings.WordWrapHeight)
                            {
                                scaleLow = mid;
                            }
                            else
                            {
                                scaleHigh = mid;
                            }

                            if (bestHeight > Settings.WordWrapHeight)
                            {
                                if (bestHeight > worldHeight)
                                {
                                    bestHeight = worldHeight;
                                    bestScale = midScale;
                                }
                            }
                            else
                            {
                                if (bestHeight < worldHeight)
                                {
                                    bestHeight = worldHeight;
                                    bestScale = midScale;
                                }
                            }
                            numTries++;
                        }

                        activeScale = bestScale;
                    }
                }
            }
            
            foreach (var lineInfo in wrappedLines.Lines.Reverse())
            {
                var baseScale = activeScale * lineInfo.Scale;
                var scale = baseScale / Settings.Font.fontSize;
                pos.y += lineInfo.PaddingBottom * scale;
                
                var line = lineInfo.Text;

                var lineHeight = 0.0f;
                var lineWidth = 0.0f;
                for (var i = 0; i < line.Length; i++)
                {
                    CharacterInfo ch;
                    Settings.Font.GetCharacterInfo(line[i], out ch);
                    var p0 = pos + new Vector3(ch.minX, ch.maxY, 0) * scale;
                    var p1 = pos + new Vector3(ch.maxX, ch.maxY, 0) * scale;
                    var p2 = pos + new Vector3(ch.maxX, ch.minY, 0) * scale;
                    var p3 = pos + new Vector3(ch.minX, ch.minY, 0) * scale;

                    var t0 = ch.uvTopLeft;
                    var t1 = ch.uvTopRight;
                    var t2 = ch.uvBottomRight;
                    var t3 = ch.uvBottomLeft;

                    vertices.Add(new SxMeshVertex(p0, Settings.Color, t0));
                    vertices.Add(new SxMeshVertex(p1, Settings.Color, t1));
                    vertices.Add(new SxMeshVertex(p2, Settings.Color, t2));
                    vertices.Add(new SxMeshVertex(p3, Settings.Color, t3));

                    pos += new Vector3(ch.advance * scale, 0, 0);

                    lineHeight = Mathf.Max(lineHeight, ch.maxY * scale);
                    lineWidth += ch.advance * scale;
                }

                textWidth = Mathf.Max(textWidth, lineWidth);
                var paddedHeight = lineHeight + lines.LineSpacing * scale;
                textHeight += paddedHeight;

                pos.x = 0;
                pos.y += paddedHeight;
                
                pos.y += lineInfo.PaddingTop * scale;
            }
            
            var offset = Vector3.zero;
            if (Settings.VAlign == SxTextVAlign.Center)
            {
                offset.y -= textHeight * 0.5f;
            }
            else if (Settings.VAlign == SxTextVAlign.Top)
            {
                offset.y -= textHeight;
            }

            if (Settings.HAlign == SxTextHAlign.Center)
            {
                offset.x -= textWidth * 0.5f;
            }
            else if (Settings.HAlign == SxTextHAlign.Right)
            {
                offset.x -= textWidth;
            }

            foreach (var vertex in vertices)
            {
                vertex.Position += offset;
            }

            mesh = new SxMesh();
            mesh.CreateSection(0, GL.QUADS, vertices.ToArray());
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Meshing\SxImportedMeshBase.cs:
 
using UnityEngine;

namespace DungeonArchitect.SxEngine.Utils
{
    public class SxCubeBaseMesh : SxMesh
    {   
        public SxCubeBaseMesh()
        {
            var mesh = Resources.Load<Mesh>("MarkerGen/meshes/cube_base");
            SxMeshImporter.Import(mesh, this);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Meshing\SxMesh.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.SxEngine
{
    public class SxMeshVertex
    {
        public Vector3 Position { get; set; } = Vector3.zero;
        public Color Color { get; set; } = Color.white;
        public Vector2 UV0 { get; set; } = Vector2.zero;

        public SxMeshVertex()
        {
        }

        public SxMeshVertex(Vector3 position)
        {
            this.Position = position;
        }
        
        public SxMeshVertex(Vector3 position, Color color)
        {
            this.Position = position;
            this.Color = color;
        }
        
        public SxMeshVertex(Vector3 position, Color color, Vector2 uv0)
        {
            this.Position = position;
            this.Color = color;
            this.UV0 = uv0;
        }
    }

    public class SxMeshSection
    {
        public int DrawMode { get; set; } = GL.LINES;
        public SxMeshVertex[] Vertices { get; set; } = new SxMeshVertex[0];
    }

    public class SxMesh
    {
        public Dictionary<int, SxMeshSection> Sections = new Dictionary<int, SxMeshSection>();
        
        public void CreateSection(int sectionIndex, int drawMode, SxMeshVertex[] vertices)
        {
            ClearSection(sectionIndex);

            var section = new SxMeshSection();
            section.DrawMode = drawMode;
            section.Vertices = vertices;
            Sections.Add(sectionIndex, section);
        }

        public void ClearSection(int sectionIndex)
        {
            Sections.Remove(sectionIndex);
        }

        public void ClearAllSections()
        {
            Sections.Clear();
        }
    }
    
    public class SxMeshRegistry
    {
        private static Dictionary<System.Type, SxMesh> cache = new Dictionary<System.Type, SxMesh>();

        public static SxMesh Get<T>() where T : SxMesh, new()
        {
            if (cache.ContainsKey(typeof(T)))
            {
                return cache[typeof(T)];
            }

            var mesh = new T();
            cache.Add(typeof(T), mesh);
            return mesh;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Meshing\SxMeshPrimitives.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.SxEngine
{
    public class SxQuadMesh : SxMesh
    {
        public SxQuadMesh()
        {
            Build(Color.white);
        }

        public SxQuadMesh(Color color)
        {
            Build(color);
        }
        
        void Build(Color color)
        {
         
            var vertices = new SxMeshVertex[]
            {
                new SxMeshVertex(new Vector3(-1, -1, 0), color, new Vector2(0, 0)),
                new SxMeshVertex(new Vector3(1, -1, 0), color, new Vector2(1, 0)),
                new SxMeshVertex(new Vector3(1, 1, 0), color, new Vector2(1, 1)),
                new SxMeshVertex(new Vector3(-1, 1, 0), color, new Vector2(0, 1))
            };

            CreateSection(0, GL.QUADS, vertices);   
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Rendering\SxCamera.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.SxEngine
{
    public class SxCamera
    {
        public Vector3 Location
        {
            get => location;
            set
            {
                if (location != value)
                {
                    location = value;
                    viewMatrixDirty = true;
                }
            } 
        }
        public Quaternion Rotation
        {
            get => rotation;
            set
            {
                if (rotation != value)
                {
                    rotation = value;
                    viewMatrixDirty = true;
                }
            } 
        }

        public float FOV
        {
            get => fov;
            set
            {
                fov = value;
                projMatrixDirty = true;
            }
        }

        public float AspectRatio { get; private set; } = 1.0f;
        public Vector2 ScreenSize { get; private set; } = Vector2.one;

        public void SetAspectRatio(float width, float height)
        {
            AspectRatio = width / height;
            ScreenSize = new Vector2(width, height);
            projMatrixDirty = true;
        }
        
        public Vector3 GetRightVector()
        {
            var axisZ = Rotation * Vector3.forward;
            return Vector3.Cross(Vector3.up, axisZ);
        }

        public Matrix4x4 ViewMatrix
        {
            get
            {
                if (viewMatrixDirty)
                {
                    BuildViewMatrix();
                }

                return viewMatrix;
            }
        }

        public Matrix4x4 ViewMatrixInverse => viewMatrixInverse;

        public Matrix4x4 ProjectionMatrix
        {
            get
            {
                if (projMatrixDirty)
                {
                    BuildProjectionMatrix();
                }

                return projMatrix;
            }
        }

        public Matrix4x4 ProjectionMatrixInverse => projMatrixInverse;

        private Vector3 location = Vector3.zero;
        private Quaternion rotation = Quaternion.identity;
        private Matrix4x4 viewMatrix = Matrix4x4.identity;
        private Matrix4x4 viewMatrixInverse = Matrix4x4.identity;
        private Matrix4x4 projMatrix = Matrix4x4.identity;
        private Matrix4x4 projMatrixInverse = Matrix4x4.identity;
        
        private float fov = 75;
        private bool viewMatrixDirty = true;
        private bool projMatrixDirty = true;

        public void LookAt(Vector3 target)
        {
            Rotation = Quaternion.LookRotation((location - target).normalized);
        }

        void BuildViewMatrix()
        {
            var baseTransform = new Matrix4x4(
                new Vector4(-1, 0, 0, 0),
                new Vector4(0, 1, 0, 0),
                new Vector4(0, 0, 1, 0),
                new Vector4(0, 0, 0, 1));
            var camTransform = Matrix4x4.TRS(location, rotation, Vector3.one) * baseTransform;
            viewMatrix = camTransform.inverse;
            viewMatrixInverse = viewMatrix.inverse;
            viewMatrixDirty = false;
        }

        public Ray ScreenToRay(Vector2 screenPosition)
        {
            // https://antongerdelan.net/opengl/raycasting.html
            screenPosition.y = ScreenSize.y - screenPosition.y;
            var rayNdc = screenPosition / ScreenSize * 2 - Vector2.one;
            var rayClip = new Vector4(rayNdc.x, rayNdc.y, -1, 1);
            var rayEye = projMatrixInverse * rayClip;
            rayEye.z = -1;
            rayEye.w = 0;

            Vector3 rayWorldDir = viewMatrixInverse * rayEye;
            rayWorldDir.Normalize();

            return new Ray(location, rayWorldDir);
        }
        
        void BuildProjectionMatrix()
        {
            projMatrix = Matrix4x4.Perspective(FOV, AspectRatio, 0.1f, 100.0f);
            projMatrixInverse = projMatrix.inverse;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Rendering\SxMaterial.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace DungeonArchitect.SxEngine
{
    public abstract class SxMaterial
    {
        protected Material unityMaterial;
        
        public virtual Material UnityMaterial { get => unityMaterial; }

        public float DepthBias = 0.0f;
        public int RenderQueue
        {
            get
            {
                if (unityMaterial != null)
                {
                    return unityMaterial.renderQueue;
                }
                return 0;
            }
        }

        public virtual SxMaterial Clone()
        {
            Material clonedMat = null;
            if (unityMaterial != null)
            {
                clonedMat = Object.Instantiate(unityMaterial);
            }

            return new SxUnityMaterial(clonedMat);
        }

        public void SetFloat(string name, float value)
        {
            unityMaterial.SetFloat(name, value);
        }

        public void SetInt(string name, int value)
        {
            unityMaterial.SetInt(name, value);
        }

        public void SetColor(string name, Color value)
        {
            unityMaterial.SetColor(name, value);
        }
    }

    public class SxUnityMaterial : SxMaterial
    {
        public SxUnityMaterial(Material material)
        {
            this.unityMaterial = material;
        }
    }
    
    public abstract class SxUnityResourceMaterial : SxMaterial
    {
        private string materialPath;
        private bool materialValid = false;

        public override Material UnityMaterial
        {
            get
            {
                if (materialValid && unityMaterial == null)
                {
                    LoadMaterial(); 
                }

                return unityMaterial;
            }
        }

        public SxUnityResourceMaterial(string resourceName)
        {
            materialPath = resourceName;
            LoadMaterial();
            materialValid = (unityMaterial != null);
        }

        void LoadMaterial()
        {
            unityMaterial = Resources.Load<Material>(materialPath);
        }
        
    }
    
    
    public abstract class SxUnityResourceCopyMaterial : SxMaterial {
        private string materialPath;
        private bool materialValid = false;
        
        public override Material UnityMaterial
        {
            get
            {
                if (materialValid && unityMaterial == null)
                {
                    LoadMaterial(); 
                }

                return unityMaterial;
            }
        }

        public SxUnityResourceCopyMaterial(string resourceName)
        {
            materialPath = resourceName;
            LoadMaterial();
            materialValid = (unityMaterial != null);
        }
        
        void LoadMaterial()
        {
            var template = Resources.Load<Material>(materialPath);
            if (template != null)
            {
                unityMaterial = new Material(template);
            }
        }
    }
    
    public class SxMaterialRegistry
    {
        private static Dictionary<System.Type, SxMaterial> cache = new Dictionary<Type, SxMaterial>();

        public static SxMaterial Get<T>() where T : SxMaterial, new()
        {
            if (cache.ContainsKey(typeof(T)))
            {
                return cache[typeof(T)];
            }

            var material = new T();
            cache.Add(typeof(T), material);
            return material;
        }
    }
    
    public class SxDefaultMaterial : SxMaterial
    {
        public SxDefaultMaterial()
        {
            Shader shader = Shader.Find("Hidden/Internal-Colored");
            unityMaterial = new Material(shader);
            unityMaterial.hideFlags = HideFlags.HideAndDontSave;
            unityMaterial.SetInt("_SrcBlend", (int) UnityEngine.Rendering.BlendMode.SrcAlpha);
            unityMaterial.SetInt("_DstBlend", (int) UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
            //unityMaterial.SetInt("_Cull", (int) UnityEngine.Rendering.CullMode.Off);
            //lineMaterial.SetInt("_ZWrite", 0);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Rendering\SxRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Utils;
using UnityEngine;
using UnityEngine.Rendering;
using Object = UnityEngine.Object;

namespace DungeonArchitect.SxEngine
{
    public struct SxRenderContext
    {
        public Vector3 CameraPosition;
    }

    public class SxRenderCommand : IComparable<SxRenderCommand>
    {
        public Matrix4x4 AccumWorldTransform; 
        public SxMesh Mesh;
        public SxMaterial Material;
        private float distanceSqToCam = 0;

        public SxRenderCommand(Matrix4x4 accumWorldTransform, SxMesh mesh, SxMaterial material)
        {
            AccumWorldTransform = accumWorldTransform;
            Mesh = mesh;
            Material = material;
        }

        public int CompareTo(SxRenderCommand b)
        {
            var a = this;
            var queueA = a.Material != null ? a.Material.RenderQueue : 0;
            var queueB = b.Material != null ? b.Material.RenderQueue : 0;
            if (queueA == queueB)
            {
                var depthBiasA = a.Material != null ? a.Material.DepthBias : 0;
                var depthBiasB = b.Material != null ? b.Material.DepthBias : 0;
                var da = a.distanceSqToCam + depthBiasA;
                var db = b.distanceSqToCam + depthBiasB;
                if (da == db) return 0;
                return da > db ? -1 : 1;
            }
            else
            {
                return queueA < queueB ? -1 : 1;
            }
        }

        public void UpdateDistanceToCam(Vector3 camLocation)
        {
            distanceSqToCam = (Matrix.GetTranslationDivW(ref AccumWorldTransform) - camLocation).sqrMagnitude;
        }
    }

    public class SxRenderCommandList
    {   
        private List<SxRenderCommand> renderCommands = new List<SxRenderCommand>();
        public SxRenderCommand[] Commands
        {
            get => renderCommands.ToArray();
        }
        
        public void Add(SxRenderCommand command)
        {
            renderCommands.Add(command);
        }

        public void Sort(Vector3 camLocation)
        {
            UpdateDistanceFromCam(camLocation);
            renderCommands.Sort();
        }

        private void UpdateDistanceFromCam(Vector3 camLocation)
        {
            foreach (var command in renderCommands)
            {
                command.UpdateDistanceToCam(camLocation);
            }
        }
    }
    
    public class SxRenderer 
    {
        class ClearState
        {
            public bool ClearDepth = false;
            public bool ClearColor = false;
            public Color Color = Color.black;
        }
        
        public RenderTexture Texture { get; private set; }
        public SxCamera Camera { get; } = new SxCamera();

        public Matrix4x4 ViewMatrix => Camera.ViewMatrix;
        
        private ClearState clearState = new ClearState();

        public bool SortRenderCommands { get; set; } = true;

        public int BatchCount { get; private set; } = 0;
        
        public delegate void DrawDelegate(SxRenderContext context);

        public event DrawDelegate Draw;

        public void SetClearState(bool clearDepth, bool clearColor, Color color)
        {
            clearState.ClearDepth = clearDepth;
            clearState.ClearColor = clearColor;
            clearState.Color = color;
        }

        public SxRenderContext CreateRenderContext()
        {
            return new SxRenderContext
            {
                CameraPosition = Camera.Location
            };
        }
        
        public void Render(Vector2 size, SxWorld world)
        {
            AcquireTexture(size);
            
            var oldRTT = RenderTexture.active; 
            RenderTexture.active = Texture;
            
            GL.PushMatrix();
            GL.LoadProjectionMatrix(Camera.ProjectionMatrix);

            if (clearState.ClearColor || clearState.ClearDepth)
            {
                GL.Clear(clearState.ClearDepth, clearState.ClearColor, clearState.Color);
            }
            
            var context = CreateRenderContext();
            
            var renderCommandList = new SxRenderCommandList();
            world.Draw(context, renderCommandList);

            if (SortRenderCommands)
            {
                renderCommandList.Sort(context.CameraPosition);
            }
            
            Render(renderCommandList, Camera.ViewMatrix);
            
            if (Draw != null)
            {                
                Draw.Invoke(context);
            }
            
            GL.PopMatrix();
            
            RenderTexture.active = oldRTT;
        }
        
        public void Release()
        {
            ReleaseTexture();
        }
        
        private void AcquireTexture(Vector2 size)
        {
            var width = Mathf.RoundToInt(size.x);
            var height = Mathf.RoundToInt(size.y);
            if (Texture != null && (Texture.width != width || Texture.height != height))
            {
                ReleaseTexture();
            }
            
            if (Texture == null)
            {
                Texture = new RenderTexture(Mathf.RoundToInt(size.x), Mathf.RoundToInt(size.y), 16, RenderTextureFormat.ARGB32);
                var textureCreated = Texture.Create();
                if (textureCreated)
                {
                    Camera.SetAspectRatio(Texture.width, Texture.height);
                }
                    
            }
        }

        private void ReleaseTexture()
        {
            Texture.Release();
            Object.DestroyImmediate(Texture);
            Texture = null;
        }
        
        public void Render(SxRenderCommandList renderCommandList, Matrix4x4 viewMatrix)
        {
            var renderQueueCommands = new Dictionary<int, List<SxRenderCommand>>();
            foreach (var command in renderCommandList.Commands)
            {
                if (command == null) continue;

                int renderQueue;
                if (command.Material != null && command.Material.UnityMaterial != null)
                {
                    renderQueue = command.Material.UnityMaterial.renderQueue;
                }
                else
                {
                    renderQueue = (int)RenderQueue.Geometry;
                }

                if (!renderQueueCommands.ContainsKey(renderQueue))
                {
                    renderQueueCommands.Add(renderQueue, new List<SxRenderCommand>());
                }
                renderQueueCommands[renderQueue].Add(command);
            }

            BatchCount = 0;
            var renderQueues = renderQueueCommands.Keys.ToList();
            renderQueues.Sort();
            foreach (var renderQueue in renderQueues)
            {
                var commands = renderQueueCommands[renderQueue];
                Material activeMaterial = null;
                int activePass = -1;
                foreach (var command in commands)
                {
                    var mat = command.Material.UnityMaterial;
                    if (mat == null) continue;
                    var passCount = mat.passCount;
                    for (int passIdx = 0; passIdx < passCount; passIdx++)
                    {
                        if (activeMaterial != mat || activePass != passIdx)
                        {
                            mat.SetPass(passIdx);
                            BatchCount++;
                            
                            activeMaterial = mat;
                            activePass = passIdx;
                        }
                        
                        GL.modelview = viewMatrix * command.AccumWorldTransform; 

                        foreach (var entry in command.Mesh.Sections)
                        {
                            var section = entry.Value;
                            GL.Begin(section.DrawMode);
                    
                            foreach (var vertex in section.Vertices)
                            {
                                GL.Color(vertex.Color);
                                GL.TexCoord(vertex.UV0);

                                var p = vertex.Position;
                                GL.Vertex3(p.x, p.y, p.z);
                            }
                    
                            GL.End();
                        }
                    }
                }
            }
        }
    }
}


 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Rendering\SxSceneGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.SxEngine.Utils;
using UnityEngine;

namespace DungeonArchitect.SxEngine
{
    public class SxSceneGraph
    {
        public SxRootSceneNode RootNode { get; } = new SxRootSceneNode();

        public void IterateNodes(System.Action<ISxSceneNode> visit)
        {
            var stack = new Stack<ISxSceneNode>();
            stack.Push(RootNode);

            while (stack.Count > 0)
            {
                var top = stack.Pop();
                if (top == null) continue;
                
                visit(top);
                
                foreach (var childNode in top.Children)
                {
                    stack.Push(childNode);
                }
            }
        }

        public void Remove(ISxSceneNode nodeToRemove)
        {
            var stack = new Stack<ISxSceneNode>();
            stack.Push(RootNode);
            
            while (stack.Count > 0)
            {
                var top = stack.Pop();
                if (top == null) continue;

                if (top.Children.Contains(nodeToRemove))
                {
                    top.RemoveChild(nodeToRemove);
                    break;
                }
            }
        }
    }

    public interface ISxSceneNode
    {
        SxTransform WorldTransform { get; set; }
        void Draw(SxRenderContext context, Matrix4x4 accumWorldTransform, SxRenderCommandList renderCommandList);
        void Tick(SxRenderContext context, float deltaTime);
        void Destroy();

        ISxSceneNode[] Children { get; }
        void AddChild(ISxSceneNode child);
        void RemoveChild(ISxSceneNode child);
        ISxSceneNode Parent { get; set; }
    }

    public abstract class SxSceneNodeBase : ISxSceneNode
    {
        public SxTransform WorldTransform { get; set; } = SxTransform.identity;
        public ISxSceneNode[] Children
        {
            get => children.ToArray();
        }
        private List<ISxSceneNode> children = new List<ISxSceneNode>();

        public abstract void Draw(SxRenderContext context, Matrix4x4 accumWorldTransform, SxRenderCommandList renderCommandList);
        public abstract void Tick(SxRenderContext context, float deltaTime);
        public abstract void Destroy();
        public void AddChild(ISxSceneNode child)
        {
            children.Add(child);
        }

        public void RemoveChild(ISxSceneNode child)
        {
            children.Remove(child);
        }

        public ISxSceneNode Parent { get; set; }

        public void RemoveAllChildren()
        {
            children.Clear();
        }
    }
    
    public class SxSceneGraphUtils
    {
        public static Matrix4x4 AccumulateTransforms(ISxSceneNode node)
        {
            if (node == null) return Matrix4x4.identity;
            return AccumulateTransforms(node.Parent) * node.WorldTransform.Matrix;
        }
        public static Matrix4x4 FindAbsoluteTransform(ISxSceneNode node)
        {
            if (node == null) return Matrix4x4.identity;
            return FindAbsoluteTransform(node.Parent) * node.WorldTransform.Matrix;
        }
    }

    public class SxRootSceneNode : SxSceneNodeBase
    {
        public override void Draw(SxRenderContext context, Matrix4x4 accumWorldTransform, SxRenderCommandList renderCommandList)
        {
        }

        public override void Tick(SxRenderContext context, float deltaTime)
        {
        }

        public override void Destroy()
        {
        }
    }
    
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Utils\SxMaterialUtils.cs:
 namespace DungeonArchitect.SxEngine.Utils
{
    public class SxGridMaterial : SxUnityResourceMaterial
    {
        public SxGridMaterial() : base("GridMaterial") {}
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Utils\SxMeshUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.SxEngine.Utils
{
    public class SxMeshUtils
    {
        public static SxMesh CreateGridMesh(int numCells, float cellSize)
        {
            var gridMesh = new SxMesh();

            var vertices = new List<SxMeshVertex>();
        
            float start = -(numCells / 2) * cellSize;
            float end = start + numCells * cellSize;
            var gridColor = new Color(0, 0, 0, 0.05f);
            for (int i = 0; i <= numCells; i++)
            {
                var a = (i - numCells / 2) * cellSize;

                var colorX = gridColor;
                var colorZ = gridColor;
                vertices.Add(new SxMeshVertex(new Vector3(start, 0, a), colorX));
                vertices.Add(new SxMeshVertex(new Vector3(end, 0, a), colorX));

                vertices.Add(new SxMeshVertex(new Vector3(a, 0, start), colorZ));
                vertices.Add(new SxMeshVertex(new Vector3(a, 0, end), colorZ));
                
                if (i == numCells / 2)
                {
                    colorX = new Color(1, 0.5f, 0.5f, 1);
                    colorZ = new Color(0.5f, 0.5f, 1, 1);
                    
                    vertices.Add(new SxMeshVertex(new Vector3(0, 0, a), colorX));
                    vertices.Add(new SxMeshVertex(new Vector3(1, 0, a), colorX));

                    vertices.Add(new SxMeshVertex(new Vector3(a, 0, 0), colorZ));
                    vertices.Add(new SxMeshVertex(new Vector3(a, 0, 1), colorZ));
                }
            }
        
            vertices.Add(new SxMeshVertex(new Vector3(0, 0, 0), Color.green));
            vertices.Add(new SxMeshVertex(new Vector3(0, 1, 0), Color.green));
            
            gridMesh.CreateSection(0, GL.LINES, vertices.ToArray());
            return gridMesh;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Utils\SxTransform.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.SxEngine.Utils
{
    public struct SxTransform
    {
        private Vector3 _position;
        private Quaternion _rotation;
        private Vector3 _scale;
        private Matrix4x4 _matrix;
        private bool dirty;

        public static readonly SxTransform identity = new SxTransform()
        {
            _position = Vector3.zero,
            _rotation = Quaternion.identity,
            _scale = Vector3.one,
            _matrix = Matrix4x4.identity,
            dirty = false
        };

        public SxTransform(Vector3 position)
        {
            _position = position;
            _rotation = Quaternion.identity;
            _scale = Vector3.one;
            _matrix = Matrix4x4.identity;
            dirty = true;
        }
        
        public SxTransform(Quaternion rotation)
        {
            _position = Vector3.zero;
            _rotation = rotation;
            _scale = Vector3.one;
            _matrix = Matrix4x4.identity;
            dirty = true;
        }
        
        public SxTransform(Vector3 position, Quaternion rotation)
        {
            _position = position;
            _rotation = rotation;
            _scale = Vector3.one;
            _matrix = Matrix4x4.identity;
            dirty = true;
        }

        public SxTransform(Vector3 position, Quaternion rotation, Vector3 scale)
        {
            _position = position;
            _rotation = rotation;
            _scale = scale;
            _matrix = Matrix4x4.identity;
            dirty = true;
        }
        
        public Vector3 Positon
        {
            get => _position;
            set
            {
                if (_position != value)
                {
                    _position = value;
                    dirty = true;
                }
            }
        }
        
        public Quaternion Rotation
        {
            get => _rotation;
            set
            {
                if (_rotation != value)
                {
                    _rotation = value;
                    dirty = true;
                }
            }
        }
        
        public Vector3 Scale
        {
            get => _scale;
            set
            {
                if (_scale != value)
                {
                    _scale = value;
                    dirty = true;
                }
            }
        }

        public Matrix4x4 Matrix
        {
            get
            {
                if (dirty)
                {
                    _matrix = Matrix4x4.TRS(_position, _rotation, _scale);
                    dirty = false;
                }

                return _matrix;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Common\UIEvents.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class WidgetClickEvent
    {
        public Event e;
        public UISystem uiSystem;
        public object userdata;
    }
    public delegate void OnWidgetClicked(WidgetClickEvent clickEvent);

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Utils\DeferredUICommands.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.UI
{
    public interface IDeferredUICommand
    {
        void Execute(UISystem uiSystem);
    }

    public abstract class DeferredUICommandBase : IDeferredUICommand
    {
        public abstract void Execute(UISystem uiSystem);
    }

    public class EditorCommand_InitializeGraphCameras : DeferredUICommandBase
    {
        IWidget host;
        public EditorCommand_InitializeGraphCameras(IWidget host)
        {
            this.host = host;
        }

        public override void Execute(UISystem uiSystem)
        {
            var graphEditors = WidgetUtils.GetWidgetsOfType<GraphEditor>(host);
            foreach (var graphEditor in graphEditors)
            {
                var bounds = new Rect(Vector2.zero, graphEditor.WidgetBounds.size);
                graphEditor.FocusCameraOnBestFit(bounds);
            }
        }
    }

    public class EditorCommand_FocusOnGraphNode : DeferredUICommandBase
    {
        GraphEditor graphEditor;
        GraphNode graphNode;
        public EditorCommand_FocusOnGraphNode(GraphEditor graphEditor, GraphNode graphNode)
        {
            this.graphEditor = graphEditor;
            this.graphNode = graphNode;
        }

        public override void Execute(UISystem uiSystem)
        {
            graphEditor.FocusCameraOnNode(graphNode);
            graphEditor.SelectNode(graphNode, uiSystem);
            uiSystem.Platform.ShowObjectProperty(graphNode);
        }
    }

    public class EditorCommand_SetBorderContent : DeferredUICommandBase
    {
        BorderWidget border;
        IWidget content;
        public EditorCommand_SetBorderContent(BorderWidget border, IWidget content)
        {
            this.border = border;
            this.content = content;
        }

        public override void Execute(UISystem uiSystem)
        {
            border.SetContent(content);
        }
    }

    public class EditorCommand_UpdateWidget : DeferredUICommandBase
    {
        IWidget content;
        Rect bounds;
        public EditorCommand_UpdateWidget(IWidget content, Rect bounds)
        {
            this.content = content;
            this.bounds = bounds;
        }

        public override void Execute(UISystem uiSystem)
        {
            content.UpdateWidget(uiSystem, bounds);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Utils\GUIState.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI
{
    public class GUIState
    {
        Color color;
        Color backgroundColor;
        UIRenderer renderer;
        public GUIState(UIRenderer renderer)
        {
            this.renderer = renderer;
            Save();
        }

        public void Save()
        {
            if (renderer != null)
            {
                color = renderer.color;
                backgroundColor = renderer.backgroundColor;
            }
        }

        public void Restore()
        {
            if (renderer != null)
            {
                renderer.color = color;
                renderer.backgroundColor = backgroundColor;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Utils\MouseDeltaTracker.cs:
 using UnityEngine;

namespace DungeonArchitect.UI
{
    public class MouseDeltaTracker
    {
        private bool mouseButtonDown = false;
        private bool dragging = false;
        private Vector2 trackingStart = Vector2.zero;
        private Vector2 trackingEnd = Vector2.zero;


        public delegate void MouseClickEvent(Event e, UISystem uiSystem);

        public event MouseClickEvent OnLeftClick;
        public event MouseClickEvent OnRightClick;
        public event MouseClickEvent OnDragStart;
        public event MouseClickEvent OnDragEnd;
        public event MouseClickEvent OnDrag;
            
        // Max number of pixels the mouse can move before invoking a click 
        public float ClickMoveDeltaTolerance { get; set; } = 4;

        public void HandleInput(Event e, UISystem uiSystem)
        {
            if (e == null)
            {
                return;
            }

            if (e.type == EventType.MouseDown)
            {
                StartTracking(e);
            }
            else if (e.type == EventType.MouseUp)
            {
                EndTracking(e, uiSystem);
            }
            else if (e.type == EventType.MouseDrag)
            {
                HandleDrag(e, uiSystem);
            }
        }

        private void HandleDrag(Event e, UISystem uiSystem)
        {
            if (!mouseButtonDown || e.button != 0) return;
            if (!dragging)
            {
                var moveDistance = (e.mousePosition - trackingStart).magnitude;
                if (moveDistance > ClickMoveDeltaTolerance)
                {
                    dragging = true;
                    OnDragStart?.Invoke(e, uiSystem);
                }
            }
            else
            {
                OnDrag?.Invoke(e, uiSystem);
            }
        }
        
        private void StartTracking(Event e)
        {
            mouseButtonDown = true;
            trackingStart = e.mousePosition;
        }

        private void EndTracking(Event e, UISystem uiSystem)
        {
            if (!mouseButtonDown)
            {
                // called end tracking without calling start first
                return;
            }
            
            mouseButtonDown = false;
            trackingEnd = e.mousePosition;
            var moveDistance = (trackingEnd - trackingStart).magnitude;
            if (moveDistance <= ClickMoveDeltaTolerance)
            {
                if (e.button == 0)
                {
                    // Invoke left click
                    OnLeftClick?.Invoke(e, uiSystem);
                }
                else if (e.button == 1)
                {
                    // Invoke right click
                    OnRightClick?.Invoke(e, uiSystem);
                }
            }

            if (dragging)
            {
                if (e.button == 0)
                {
                    dragging = false;
                    OnDragEnd?.Invoke(e, uiSystem);
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Utils\UIResourceLookup.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.UI
{
    /// <summary>
    /// The resource filename constants used by dungeon architect editor
    /// </summary>
    public class UIResourceLookup
    {
		public static readonly string TEXTURE_GO_NODE_SELECTION = "graph_node_go_selection";
		public static readonly string TEXTURE_GO_NODE_FRAME = "graph_node_go_frame";
        public static readonly string TEXTURE_GO_NODE_BG = "graph_node_go_bg";
        public static readonly string TEXTURE_PIN_GLOW = "graph_pin_glow";
		public static readonly string TEXTURE_MULTI_GO_NODE_FRAME = "graph_node_multi_go_frame";

        public static readonly string TEXTURE_MARKER_NODE_SELECTION = "graph_node_marker_selection";
        public static readonly string TEXTURE_MARKER_NODE_FRAME = "graph_node_marker_frame";
        public static readonly string TEXTURE_MARKER_EMITTER_NODE_FRAME = "graph_node_marker_emitter_frame";
        public static readonly string TEXTURE_MARKER_NODE_BG = "graph_node_marker_bg";

        public static readonly string TEXTURE_CURSOR_RING = "sc_cursor_circle";
        public static readonly string TEXTURE_CURSOR_RING_SOLID = "sc_cursor_circle_solid";

        public static readonly string TEXTURE_REFRESH_16 = "refresh_16";

        public static readonly string GUI_STYLE_BANNER = "DABannerStyle";

        public static readonly string ICON_CLOSE_16x = "icon_close_16x";
        public static readonly string ICON_PLUS_16x = "icon_plus_16x";
        public static readonly string ICON_MOVEUP_16x = "icon_up_16x";
        public static readonly string ICON_MOVEDOWN_16x = "icon_down_16x";
        public static readonly string ICON_ZOOMFIT_16x = "icon_fit_16x";

        public static readonly string ICON_ERROR_16x = "icon_error_16x";
        public static readonly string ICON_WARNING_16x = "icon_warning_16x";
        public static readonly string ICON_INFO_16x = "icon_info_16x";
        public static readonly string ICON_SUCCESS_16x = "icon_success_16x";
        public static readonly string ICON_WHITE_16x = "icon_white_16";
        public static readonly string ICON_PLAY_16x = "icon_play_16x";
        public static readonly string ICON_PLAY_16xb = "icon_play_16xb";
        public static readonly string ICON_SETTINGS_16x = "icon_settings_16x";
        public static readonly string ICON_DISCORD_16x = "icon_discord_16x";
        public static readonly string ICON_DOCS_16x = "icon_docs_16x";
        

        public static readonly string SKIN_TOOLBAR_BUTTONS = "ToolbarButtons";
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Widget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public delegate void WidgetDragEvent(Event e, UISystem uiSystem);

    public enum WidgetMessage
    {
        DrawHighlight
    }

    public interface IWidget
    {
        void UpdateWidget(UISystem uiSystem, Rect bounds);
        void Draw(UISystem uiSystem, UIRenderer renderer);
        void HandleInput(Event e, UISystem uiSystem);
        void HandleMessage(UISystem uiSystem, WidgetMessage message);

        void OnFocus();
        void LostFocus();
        
        bool IsCompositeWidget();
        bool CanAcquireFocus();
        bool RequiresInputEveryFrame();
        IWidget[] GetChildWidgets();
        Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem);
        Rect WidgetBounds { get; set; }
        bool ShowFocusHighlight { get; set; }
        Vector2 ScrollPosition { get; set; }

    }

    public abstract class WidgetBase : IWidget
    {
        private bool showFocusHighlight = false;
        private Rect widgetBounds = Rect.zero;
        private Vector2 scrollPosition = Vector2.zero;

        public bool ShowFocusHighlight
        {
            get { return showFocusHighlight; }
            set { showFocusHighlight = value; }
        }

        public Rect WidgetBounds
        {
            get { return widgetBounds; }
            set { widgetBounds = value; }
        }

        public virtual Vector2 ScrollPosition
        {
            get { return scrollPosition; }
            set { scrollPosition = value; }
        }

        public bool DragDropEnabled = false;
        public virtual bool CanAcquireFocus() { return false; }
        public virtual bool RequiresInputEveryFrame() { return false; }
        public virtual Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem) { return size; }

        public void Draw(UISystem uiSystem, UIRenderer renderer)
        {
            DrawImpl(uiSystem, renderer);
        }

        protected virtual void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
        }

        public virtual void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            WidgetBounds = bounds;
        }

        public virtual void OnFocus()
        {
            
        }

        public virtual void LostFocus()
        {
            
        }
        
        protected bool IsPaintEvent(UISystem uiSystem)
        {
            return uiSystem.Platform.CurrentEvent.type == EventType.Repaint;
        }

        public virtual void HandleMessage(UISystem uiSystem, WidgetMessage message) {
            if (message == WidgetMessage.DrawHighlight)
            {
                //DrawFocusHighlight(uiSystem);
            }
        }

        protected virtual void DrawFocusHighlight(UISystem uiSystem, UIRenderer renderer)
        {
            var hilightBounds = new Rect(new Vector2(0.5f, 0.5f), WidgetBounds.size - Vector2.one);
            WidgetUtils.DrawWidgetFocusHighlight(renderer, hilightBounds, WidgetUtils.FOCUS_HIGHLITE_COLOR);
        }

        public virtual void HandleInput(Event e, UISystem uiSystem)
        {
            switch (e.type)
            {
                case EventType.MouseDrag:
                    if (uiSystem.SupportsDragDrop && DragDropEnabled)
                    {
                        HandleDragStart(e, uiSystem);
                    }
                    break;

                case EventType.DragUpdated:
                    if (uiSystem.SupportsDragDrop && DragDropEnabled && IsDragDataSupported(e, uiSystem))
                    {
                        HandleDragUpdate(e, uiSystem);
                    }
                    break;

                case EventType.DragPerform:
                    if (uiSystem.SupportsDragDrop && DragDropEnabled && IsDragDataSupported(e, uiSystem))
                    {
                        HandleDragPerform(e, uiSystem);
                    }
                    break;
            }
        }

        public virtual bool IsCompositeWidget() { return false; }
        public virtual IWidget[] GetChildWidgets() { return null; }

        protected virtual bool IsDragDataSupported(Event e, UISystem uiSystem) { return false; }

        public event WidgetDragEvent DragStart;
        public event WidgetDragEvent DragUpdate;
        public event WidgetDragEvent DragPerform;

        protected virtual void HandleDragStart(Event e, UISystem uiSystem)
        {
            uiSystem.Platform.DragDrop.PrepareStartDrag();
            uiSystem.Platform.DragDrop.StartDrag("Widget Drag");

            // Make sure no one uses the event after us
            Event.current.Use();

            if (DragStart != null)
            {
                DragStart.Invoke(e, uiSystem);
            }
        }

        void HandleDragUpdate(Event e, UISystem uiSystem)
        {
            uiSystem.Platform.DragDrop.SetVisualMode(UIDragDropVisualMode.Copy);

            if (DragUpdate != null)
            {
                DragUpdate.Invoke(e, uiSystem);
            }
        }

        void HandleDragPerform(Event e, UISystem uiSystem)
        {
            uiSystem.Platform.DragDrop.AcceptDrag();

            if (DragPerform != null)
            {
                DragPerform.Invoke(e, uiSystem);
            }
        }


    }

    public class NullWidget : WidgetBase
    {
        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
        }
    }
    
    public class SpacerWidget : WidgetBase
    {
        private Vector2 desiredSize;

        public SpacerWidget(Vector2 size)
        {
            this.desiredSize = size;
        }
        
        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            return this.desiredSize;
        }

        public void SetSize(Vector2 size)
        {
            this.desiredSize = size;
        }
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\WidgetUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class WidgetUtils
    {
        public static void GetWidgets(IWidget widget, ref List<IWidget> result)
        {
            if (widget == null)
            {
                return;
            }
            result.Add(widget);

            var children = widget.GetChildWidgets();
            if (children != null)
            {
                foreach (var child in children)
                {
                    GetWidgets(child, ref result);
                }
            }
        }

        public static List<T> GetWidgetsOfType<T>(IWidget root) where T : IWidget
        {
            var widgets = new List<IWidget>();
            GetWidgets(root, ref widgets);

            var result = new List<T>();
            foreach (var widget in widgets)
            {
                if (widget != null && widget is T)
                {
                    result.Add((T)widget);
                }
            }
            return result;
        }

        public static void HandleWidgetInput(UISystem uiSystem, Event e, Vector2 mousePosition, IWidget widget)
        {
            if (widget != null)
            {
                var bounds = new Rect(Vector2.zero, widget.WidgetBounds.size);
                if (bounds.Contains(mousePosition))
                {
                    mousePosition += widget.ScrollPosition;

                    bool propagateInput = false;
                    if (widget == uiSystem.FocusedWidget)
                    {
                        propagateInput = true;
                    }

                    if (widget.RequiresInputEveryFrame())
                    {
                        propagateInput = true;
                    }

                    if (propagateInput)
                    {
                        var widgetEvent = new Event(e);
                        widgetEvent.mousePosition = mousePosition;
                        widget.HandleInput(widgetEvent, uiSystem);
                    }

                    // Check if the children can be found first
                    var children = widget.GetChildWidgets();
                    if (children != null)
                    {
                        foreach (var child in children)
                        {
                            if (child == null) continue;
                            var childMousePosition = mousePosition - child.WidgetBounds.position;
                            HandleWidgetInput(uiSystem, e, childMousePosition, child);
                        }
                    }
                }
            }
        }

        public static bool BuildWidgetEvent(Vector2 mousePosition, IWidget root, IWidget widgetToFind, ref Vector2 widgetMousePosition)
        {
            mousePosition += root.ScrollPosition;
            if (root == widgetToFind)
            {
                widgetMousePosition = mousePosition;
                return true;
            }

            var children = root.GetChildWidgets();
            if (children != null)
            {
                foreach (var child in children)
                {
                    if (child == null) continue;

                    var childMousePosition = mousePosition - child.WidgetBounds.position;
                    if (BuildWidgetEvent(childMousePosition, child, widgetToFind, ref widgetMousePosition))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public static bool FindWidgetOnCursor(Event e, IWidget widget, out Event outEvent, out IWidget outWidget)
        {
            if (widget != null)
            {
                var mousePosition = e.mousePosition;
                var bounds = new Rect(Vector2.zero, widget.WidgetBounds.size);
                if (bounds.Contains(mousePosition))
                {
                    mousePosition += widget.ScrollPosition;
                    // Check if the children can be found first
                    var children = widget.GetChildWidgets();
                    if (children != null)
                    {
                        foreach (var child in children)
                        {
                            var childEvent = new Event(e);
                            childEvent.mousePosition = mousePosition - child.WidgetBounds.position;
                            if (FindWidgetOnCursor(childEvent, child, out outEvent, out outWidget))
                            {
                                return true;
                            }
                        }
                    }

                    outEvent = new Event(e);
                    outWidget = widget;
                    return true;
                }
            }

            outEvent = null;
            outWidget = null;
            return false;
        }

        public static void ProcessDragOperation(Event e, IWidget widget, UISystem uiSystem)
        {
            if (e.type == EventType.DragUpdated || e.type == EventType.DragPerform)
            {
                Event widgetEvent;
                IWidget widgetOnCursor;
                if (FindWidgetOnCursor(e, widget, out widgetEvent, out widgetOnCursor))
                {
                    if (widgetOnCursor != null)
                    {
                        if (e.type == EventType.DragUpdated)
                        {
                            widgetOnCursor.HandleInput(e, uiSystem);
                        }
                        else if (e.type == EventType.DragPerform)
                        {
                            // Request the focus so our focus input handling code will handle this
                            if (uiSystem != null)
                            {
                                uiSystem.RequestFocus(widgetOnCursor);
                            }
                        }
                    }
                }
            }
        }

        public static bool ProcessInputFocus(Vector2 mousePosition, UISystem uiSystem, IWidget widget)
        {
            if (uiSystem == null || widget == null)
            {
                return false;
            }

            var bounds = new Rect(Vector2.zero, widget.WidgetBounds.size);
            if (!bounds.Contains(mousePosition))
            {
                return false;
            }

            mousePosition += widget.ScrollPosition;


            if (widget.CanAcquireFocus())
            {
                uiSystem.RequestFocus(widget);
                return true;
            }

            var children = widget.GetChildWidgets();
            if (children != null)
            {
                foreach (var child in children)
                {
                    if (child == null) continue;
                    var childMousePosition = mousePosition - child.WidgetBounds.position;
                    if (ProcessInputFocus(childMousePosition, uiSystem, child))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public static void DrawWidgetFocusHighlight(UIRenderer renderer, Rect bounds, Color color)
        {
            DrawWidgetFocusHighlight(renderer, bounds, color, 1);
        }


        public static void DrawWidgetFocusHighlight(UIRenderer renderer, Rect bounds, Color color, float thickness)
        {
            DrawWidgetFocusHighlight(renderer, bounds, color, thickness, null);
        }

        public static void DrawWidgetFocusHighlight(UIRenderer renderer, Rect bounds, Color color, float thickness, Texture2D texture)
        {
            const float padding = 1;
            float x0 = (bounds.xMin + padding);
            float y0 = (bounds.yMin + padding);
            float x1 = (bounds.xMax - padding);
            float y1 = (bounds.yMax - padding);

            Vector2 P00 = new Vector2(x0, y0);
            Vector2 P10 = new Vector2(x1, y0);
            Vector2 P11 = new Vector2(x1, y1);
            Vector2 P01 = new Vector2(x0, y1);
            if (thickness == 1)
            {
                renderer.DrawPolyLine(color, P00, P10, P11, P01, P00);
            }
            else
            {
                if (texture != null)
                {
                    renderer.DrawAAPolyLine(texture, thickness, color, P00, P10, P11, P01, P00);
                }
                else
                {
                    renderer.DrawAAPolyLine(thickness, color, P00, P10, P11, P01, P00);
                }
            }
        }

        public readonly static Color FOCUS_HIGHLITE_COLOR = new Color(1, 0.5f, 0, 1);
        public static void DrawWidgetGroup(UISystem uiSystem, UIRenderer renderer, IWidget widget)
        {
            renderer.BeginGroup(widget.WidgetBounds);
            widget.Draw(uiSystem, renderer);
            renderer.EndGroup();
        }

        public static bool IsDragEvent(Event e)
        {
            return e.type == EventType.DragPerform
                || e.type == EventType.DragUpdated
                || e.type == EventType.DragExited
                || e.type == EventType.MouseDrag;
        }
    }


}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\VisibilityGraph\Impl\GameObjectVisibilityGraphNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Visibility.Impl
{
    public class GameObjectVisibilityGraphNode : VisibilityGraphNode
    {
        private GameObject[] gameObjects;
        
        public GameObjectVisibilityGraphNode(GameObject gameObject)
        {
            gameObjects = new GameObject[] { gameObject };
        }

        public GameObjectVisibilityGraphNode(GameObject[] gameObjects)
        {
            this.gameObjects = gameObjects.Clone() as GameObject[];
        }
        
        public override void SetVisibleImpl(bool visible)
        {   
            if (gameObjects != null)
            {
                foreach (var gameObject in gameObjects)
                {
                    gameObject.SetActive(visible);
                }
            }
        }
        
        public override Bounds CalculateBounds()
        {
            var bounds = new Bounds();
            bool foundBounds = false;
            foreach (var gameObject in gameObjects)
            {
                Bounds itemBounds;
                if (CalculateBounds(gameObject, out itemBounds))
                {
                    if (!foundBounds)
                    {
                        bounds = itemBounds;
                        foundBounds = true;
                    }
                    else
                    {
                        bounds.Encapsulate(itemBounds);
                    }
                }
            }
            
            return bounds;
        }
        
        private bool CalculateBounds(GameObject target, out Bounds bounds)
        {
            if (target == null)
            {
                bounds = new Bounds();
                return false;
            }
            
            if (target.transform.childCount == 0)
            {
                var renderer = target.GetComponent<Renderer>();
                if (renderer == null)
                {
                    bounds = new Bounds();
                    return false;
                }
                else
                {
                    bounds = renderer.bounds;
                    return true;
                }
            }

            bounds = new Bounds();
            bool foundBounds = false;
            var stack = new Stack<GameObject>();
            stack.Push(target);
            while (stack.Count > 0)
            {
                var top = stack.Pop();
                if (top == null) continue;
                
                var renderer = top.GetComponent<Renderer>();
                if (renderer != null)
                {
                    if (!foundBounds)
                    {
                        bounds = renderer.bounds;
                        foundBounds = true;
                    }
                    else
                    {
                        bounds.Encapsulate(renderer.bounds);
                    }
                }

                // Add the children
                for (int i = 0; i < top.transform.childCount; i++)
                {
                    var child = top.transform.GetChild(i);
                    if (child == null) continue;
                    stack.Push(child.gameObject);
                }
            }

            return foundBounds;
        }
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Collections\Generic\BufferedQueue.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace SharpNav.Collections.Generic
{
	/// <summary>
	/// Typical LIFO generic queue container that stores data inside of
	/// a fixed-size internal buffer (array).
	/// </summary>
	/// <typeparam name="T">Type of element that given BufferedQueue object stores. </typeparam>
	public class BufferedQueue<T> : ICollection<T>
	{
        private const int SIZE = 100;   // Fixed internal size of the data array
		private T[] data;               // Internal data array
	    private int first;              // Index of first element in queue
        private int last;               // Index of last element in queue

		/// <summary>
		/// Initializes a new instance of the <see cref="BufferedQueue{T}"/> class.
		/// </summary>
		/// <param name="size">The maximum number of items that will be stored.</param>
		public BufferedQueue(int size)
		{
			this.data = new T[SIZE];
            this.first = this.last = -1;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="BufferedQueue{T}"/> class as a copy of an
		/// <see cref="ICollection{T}"/> of the same type.
		/// </summary>
		/// <param name="items">The collection to copy from.</param>
		public BufferedQueue(ICollection<T> items)
		{
			if (items.Count <= SIZE)
			{
                this.data = new T[SIZE];
				items.CopyTo(data, 0);
				this.first = 0;
			}
			else
			{
                this.data = items.Skip(items.Count - SIZE).ToArray();
				this.first = 0;
			}
		}

		/// <summary>
		/// Gets the number of elements in the queue.
		/// </summary>
		public int Count
		{
			get
			{
                return (last >= 0 && first >= 0) ? last - first : 0;
			}
		}

		/// <summary>
		/// Gets a value indicating whether the queue is read-only (False for now)
		/// </summary>
		bool ICollection<T>.IsReadOnly
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		/// Gets the value at specified index (valid ranges are from 0 to size-1)
		/// </summary>
		/// <param name="index">Index value</param>
		/// <returns>The value at the index</returns>
		public T this[int index]
		{
			get
			{
				return data[index];
			}
		}

		/// <summary>
		/// Adds a new element to the front of the queue.
		/// </summary>
		/// <param name="item">The element to be added to the queue</param>
		/// <returns>True if element was added to queue, False otherwise</returns>
		public bool Enqueue(T item)
		{
			if (last == data.Length)
				return false;
            if (first < 0)
                first = 0; 
			data[++last] = item;
			return true;
		}

		/// <summary>
		/// Removes bottom element from queue and returns it (and updates "first" index)
		/// </summary>
		/// <returns>Bottom element</returns>
		public T Dequeue()
		{
			if (first < 0)
				throw new InvalidOperationException("The queue is empty.");
			return data[first++];
		}

		/// <summary>
		/// Returns last element in the queue
		/// </summary>
		/// <returns>size element</returns>
		public T Peek()
		{
			if (last == 0)
				throw new InvalidOperationException("The queue is empty.");
            return data[last]; 
		}

		/// <summary>
		/// Resets queue pointer back to default, essentially clearing the queue. 
		/// </summary>
		public void Clear()
		{
			first = last = -1;
		}

		/// <summary>
		/// Returns whether the queue contains a given item.
		/// </summary>
		/// <param name="item">Item to search for</param>
		/// <returns>True if item exists in queue, False if not</returns>
		public bool Contains(T item)
		{
			for (int i = 0; i <= last; i++)
				if (item.Equals(data[i]))
					return true;

			return false;
		}

		/// <summary>
		/// Copies the contents of the <see cref="BufferedQueue{T}"/> to an array.
		/// </summary>
		/// <param name="array">The array to copy to.</param>
		/// <param name="arrayIndex">The index within the array to start copying to.</param>
		public void CopyTo(T[] array, int arrayIndex)
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Gets the <see cref="BufferedQueue"/>'s enumerator.
		/// </summary>
		/// <returns>The enumerator.</returns>
		public IEnumerator<T> GetEnumerator()
		{
			if (last < 0 || first < 0)
				yield break;

			//TODO handle wrap-arounds.
			for (int i = 0; i <= last; i++)
				yield return data[i];
		}

		/// <summary>
		/// Calls <see cref="Enqueue"/>.
		/// </summary>
		/// <param name="item">The item to add.</param>
		void ICollection<T>.Add(T item)
		{
			Enqueue(item);
		}

		/// <summary>
		/// Unsupported, but necessary to implement <see cref="ICollection{T}"/>.
		/// </summary>
		/// <param name="item">An item.</param>
		/// <returns>Nothing. This method will always throw <see cref="InvalidOperationException"/>.</returns>
		/// <exception cref="InvalidOperationException">Will always be thrown. This is not a valid operation.</exception>
		bool ICollection<T>.Remove(T item)
		{
			throw new InvalidOperationException("Cannot remove from an arbitrary index in a queue");
		}

		/// <summary>
		/// The non-generic version of <see cref="GetEnumerator"/>.
		/// </summary>
		/// <returns>A non-generic enumerator.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
} 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Collections\Generic\BufferedStack.cs:
 // Copyright (c) 2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace SharpNav.Collections.Generic
{
	/// <summary>
	/// Typical FIFO generic stack container that stores data inside of
	/// a fixed-size internal buffer (array). 
	/// </summary>
	/// <typeparam name="T">Type of element that given BufferedStack object stores. </typeparam>
	public class BufferedStack<T> : ICollection<T>
	{
		private T[] data;       // Internal data array
		private int top;        // Index of the position "above" the top of the stack

		/// <summary>
		/// Initializes a new instance of the <see cref="BufferedStack{T}"/> class.
		/// </summary>
		/// <param name="size">The maximum number of items that will be stored.</param>
		public BufferedStack(int size)
		{
			data = new T[size];
			top = 0; 
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="BufferedStack{T}"/> class as a copy of an
		/// <see cref="ICollection{T}"/> of the same type.
		/// </summary>
		/// <param name="size">The number of elements to copy from the collection.</param>
		/// <param name="items">The collection to copy from.</param>
		public BufferedStack(int size, ICollection<T> items)
		{
			if (items.Count <= size)
			{
				data = new T[size];
				items.CopyTo(data, 0);
				top = items.Count;
			}
			else
			{
				data = items.Skip(items.Count - size).ToArray();
				top = size; 
			}
		}

		/// <summary>
		/// Gets the number of elements in the stack.
		/// </summary>
		public int Count
		{
			get
			{
				return top; 
			}
		}

		/// <summary>
		/// Gets a value indicating whether the stack is read-only (False for now)
		/// </summary>
		bool ICollection<T>.IsReadOnly
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		/// Gets the value at specified index (valid ranges are from 0 to size-1)
		/// </summary>
		/// <param name="index">Index value</param>
		/// <returns>The value at the index</returns>
		public T this[int index]
		{
			get
			{
				return data[index];
			}
		}

		/// <summary>
		/// Pushes a new element to the top of the stack.
		/// </summary>
		/// <param name="item">The element to be added to the stack</param>
		/// <returns>True if element was added to stack, False otherwise</returns>
		public bool Push(T item)
		{
			if (top == data.Length)
				return false;
			data[top++] = item;
			return true; 
		}

		/// <summary>
		/// Removes most recent (top) element from stack and returns it.
		/// </summary>
		/// <returns>Top element</returns>
		public T Pop()
		{
			if (top == 0)
				throw new InvalidOperationException("The stack is empty.");

			return data[--top]; 
		}

		/// <summary>
		/// Returns copy of the top element of the stack.
		/// </summary>
		/// <returns>Top element</returns>
		public T Peek()
		{
			if (top == 0)
				throw new InvalidOperationException("The stack is empty.");

			return data[top - 1];
		}

		/// <summary>
		/// Resets stack pointer back to default, essentially clearing the stack. 
		/// </summary>
		public void Clear()
		{
			top = 0;
		}

		/// <summary>
		/// Returns whether the stack contains a given item.
		/// </summary>
		/// <param name="item">Item to search for</param>
		/// <returns>True if item exists in stack, False if not</returns>
		public bool Contains(T item)
		{
			for (int i = 0; i < top; i++)
				if (item.Equals(data[i]))
					return true;

			return false;
		}

		/// <summary>
		/// Copies the contents of the <see cref="BufferedStack{T}"/> to an array.
		/// </summary>
		/// <param name="array">The array to copy to.</param>
		/// <param name="arrayIndex">The index within the array to start copying to.</param>
		public void CopyTo(T[] array, int arrayIndex)
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Gets the <see cref="BufferedStack"/>'s enumerator.
		/// </summary>
		/// <returns>The enumerator.</returns>
		public IEnumerator<T> GetEnumerator()
		{
			if (top == 0)
				yield break;

			//TODO handle wrap-arounds.
			for (int i = 0; i < top; i++)
				yield return data[i];
		}

		/// <summary>
		/// Calls <see cref="Push"/>.
		/// </summary>
		/// <param name="item">The item to add.</param>
		void ICollection<T>.Add(T item)
		{
			Push(item);
		}

		/// <summary>
		/// Unsupported, but necessary to implement <see cref="ICollection{T}"/>.
		/// </summary>
		/// <param name="item">An item.</param>
		/// <returns>Nothing. This method will always throw <see cref="InvalidOperationException"/>.</returns>
		/// <exception cref="InvalidOperationException">Will always be thrown. This is not a valid operation.</exception>
		bool ICollection<T>.Remove(T item)
		{
			throw new InvalidOperationException("Cannot remove from an arbitrary index in a stack");
		}

		/// <summary>
		/// The non-generic version of <see cref="GetEnumerator"/>.
		/// </summary>
		/// <returns>A non-generic enumerator.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Collections\Generic\IValueWithCost.cs:
 // Copyright (c) 2013-2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

namespace SharpNav.Collections.Generic
{
	/// <summary>
	/// An interface that defines a class containing a cost associated with the instance.
	/// Used in <see cref="PriorityQueue{T}"/>
	/// </summary>
	public interface IValueWithCost
	{
		/// <summary>
		/// Gets the cost of this instance.
		/// </summary>
		float Cost { get; }
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Collections\Generic\PriorityQueue.cs:
 // Copyright (c) 2013-2014 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using System.Collections.Generic;

namespace SharpNav.Collections.Generic
{
	/// <summary>
	/// Use a priority queue (heap) to determine which node is more important.
	/// </summary>
	/// <typeparam name="T">
	/// A type that has a cost for each instance via the <see cref="IValueWithCost"/> interface.
	/// </typeparam>
	public class PriorityQueue<T> : ICollection<T>
		where T : class, IValueWithCost
	{
		private T[] heap;
		private int capacity;
		private int size;

		/// <summary>
		/// Initializes a new instance of the <see cref="PriorityQueue{T}"/> class with a given capacity of size n.
		/// </summary>
		/// <param name="n">The maximum number of nodes that can be stored.</param>
		public PriorityQueue(int n)
		{
			capacity = n;
			size = 0;
			heap = new T[capacity + 1];
		}

		/// <summary>
		/// Gets the number of elements in the priority queue.
		/// </summary>
		public int Count
		{
			get
			{
				return size;
			}
		}

		/// <summary>
		/// Gets a value indicating whether the collection is read-only. For <see cref="PriorityQueue{T}"/>, this is
		/// always <c>true</c>.
		/// </summary>
		bool ICollection<T>.IsReadOnly
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		/// Remove all the elements from the priority queue.
		/// </summary>
		public void Clear()
		{
			size = 0;
		}

		/// <summary>
		/// Determines whether the priority queue is empty
		/// </summary>
		/// <returns>True if empty, false if not</returns>
		public bool Empty()
		{
			return size == 0;
		}

		/// <summary>
		/// Return the node at the top of the heap.
		/// </summary>
		/// <returns>Top node in heap</returns>
		public T Top()
		{
			return (size > 0) ? heap[0] : null;
		}

		/// <summary>
		/// Remove the node at the top of the heap. Then, move the bottommost node to the top and trickle down
		/// until the nodes are in order.
		/// </summary>
		/// <returns>Node with lowest value in heap</returns>
		public T Pop()
		{
			if (size == 0)
				return null;

			T result = heap[0];
			size--;
			TrickleDown(0, heap[size]);
			return result;
		}

		/// <summary>
		/// Add the node at the bottom of the heap and move it up until the nodes ae in order.
		/// </summary>
		/// <param name="node">The node to add</param>
		public void Push(T node)
		{
			size++;
			BubbleUp(size - 1, node);
		}

		/// <summary>
		/// Returns whether the given item exists in the heap. 
		/// </summary>
		/// <param name="item">Item to look for</param>
		/// <returns>True or False</returns>
		public bool Contains(T item)
		{
			for (int c = 0; c < size; c++)
				if (heap[c] == item)
					return true;

			return false;
		}

		/// <summary>
		/// Change the value of the node, which may involve some swapping of elements to maintain heap order.
		/// </summary>
		/// <param name="node">The node to modify</param>
		public void Modify(T node)
		{
			for (int i = 0; i < size; i++)
			{
				if (heap[i] == node)
				{
					BubbleUp(i, node);
					return;
				}
			}
		}

		/// <summary>
		/// Copies the contents of the <see cref="PriorityQueue{T}"/> to an array.
		/// </summary>
		/// <param name="array">The array to copy to.</param>
		/// <param name="arrayIndex">The index within the array to start copying to.</param>
		public void CopyTo(T[] array, int arrayIndex)
		{
			if (arrayIndex + heap.Length > array.Length)
				throw new ArgumentException("Array not large enough to hold priority queue", "array");

			Array.Copy(heap, 0, array, arrayIndex, heap.Length);
		}

		/// <summary>
		/// Gets the <see cref="PriorityQueue"/>'s enumerator.
		/// </summary>
		/// <returns>The enumerator.</returns>
		public IEnumerator<T> GetEnumerator()
		{
			return ((IEnumerable<T>)heap).GetEnumerator();
		}

		/// <summary>
		/// Calls <see cref="Push"/>.
		/// </summary>
		/// <param name="item">The item to add.</param>
		void ICollection<T>.Add(T item)
		{
			Push(item);
		}

		/// <summary>
		/// Unsupported, but necessary to implement <see cref="ICollection{T}"/>.
		/// </summary>
		/// <param name="item">An item.</param>
		/// <returns>Nothing. This method will always throw <see cref="InvalidOperationException"/>.</returns>
		/// <exception cref="InvalidOperationException">Will always be thrown. This is not a valid operation.</exception>
		bool ICollection<T>.Remove(T item)
		{
			throw new InvalidOperationException("This priority queue implementation only allows elements to be popped off the top, not removed.");
		}

		/// <summary>
		/// The non-generic version of <see cref="GetEnumerator"/>.
		/// </summary>
		/// <returns>A non-generic enumerator.</returns>
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		/// <summary>
		/// While going up a priority queue, keep swapping elements until the element reaches the top.
		/// </summary>
		/// <param name="i">Index of current node</param>
		/// <param name="node">The node itself</param>
		private void BubbleUp(int i, T node)
		{
			int parent = (i - 1) / 2;

			while ((i > 0) && (heap[parent].Cost > node.Cost))
			{
				heap[i] = heap[parent];
				i = parent;
				parent = (i - 1) / 2;
			}

			heap[i] = node;
		}

		/// <summary>
		/// While moving down the priority queue, keep swapping elements.
		/// </summary>
		/// <param name="i">Index of current node</param>
		/// <param name="node">The node itself</param>
		private void TrickleDown(int i, T node)
		{
			int child = (i * 2) + 1;

			while (child < size)
			{
				//determine which child element has a smaller cost 
				if (((child + 1) < size) && (heap[child].Cost > heap[child + 1].Cost))
					child++;

				heap[i] = heap[child];
				i = child;
				child = (i * 2) + 1;
			}

			BubbleUp(i, node);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\ThirdParty\SharpNav\Collections\Generic\ProximityGrid.cs:
 // Copyright (c) 2014-2015 Robert Rouhani <robert.rouhani@gmail.com> and other contributors (see CONTRIBUTORS file).
// Licensed under the MIT License - https://raw.github.com/Robmaister/SharpNav/master/LICENSE

using System;
using SharpNav.Geometry;

#if MONOGAME
using Vector3 = Microsoft.Xna.Framework.Vector3;
#elif OPENTK
using Vector3 = OpenTK.Vector3;
#elif SHARPDX
using Vector3 = SharpDX.Vector3;
#endif

namespace SharpNav.Collections.Generic
{
	/// <summary>
	/// A <see cref="ProximityGrid{T}"/> is a uniform 2d grid that can efficiently retrieve items near a specified grid cell.
	/// </summary>
	/// <typeparam name="T">An equatable type.</typeparam>
	public class ProximityGrid<T>
		where T : IEquatable<T>
	{
		#region Fields

		private const int Invalid = -1;

		//private float cellSize;
		private float invCellSize;

		private Item[] pool;
		private int poolHead;

		private int[] buckets;

		private BBox2i bounds;

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <see cref="ProximityGrid{T}"/> class.
		/// </summary>
		/// <param name="poolSize">The size of the item array</param>
		/// <param name="cellSize">The size of each cell</param>
		public ProximityGrid(int poolSize, float cellSize)
		{
			//this.cellSize = cellSize;
			this.invCellSize = 1.0f / cellSize;

			//allocate hash buckets
			this.buckets = new int[MathHelper.NextPowerOfTwo(poolSize)];

			//allocate pool of items
			this.poolHead = 0;
			this.pool = new Item[poolSize];
			for (int i = 0; i < this.pool.Length; i++)
				this.pool[i] = new Item();

			this.bounds = new BBox2i(Vector2i.Max, Vector2i.Min);

			Clear();
		}

		#endregion

		#region Methods

		/// <summary>
		/// Reset all the data
		/// </summary>
		public void Clear()
		{
			for (int i = 0; i < buckets.Length; i++)
				buckets[i] = Invalid;

			poolHead = 0;

			this.bounds = new BBox2i(Vector2i.Max, Vector2i.Min);
		}

		/// <summary>
		/// Take all the coordinates within a certain range and add them all to an array
		/// </summary>
		/// <param name="value">The value.</param>
		/// <param name="minX">Minimum x-coordinate</param>
		/// <param name="minY">Minimum y-coordinate</param>
		/// <param name="maxX">Maximum x-coordinate</param>
		/// <param name="maxY">Maximum y-coordinate</param>
		public void AddItem(T value, float minX, float minY, float maxX, float maxY)
		{
			int invMinX = (int)Math.Floor(minX * invCellSize);
			int invMinY = (int)Math.Floor(minY * invCellSize);
			int invMaxX = (int)Math.Floor(maxX * invCellSize);
			int invMaxY = (int)Math.Floor(maxY * invCellSize);

			bounds.Min.X = Math.Min(bounds.Min.X, invMinX);
			bounds.Min.Y = Math.Min(bounds.Min.Y, invMinY);
			bounds.Max.X = Math.Max(bounds.Max.X, invMaxX);
			bounds.Max.Y = Math.Max(bounds.Max.Y, invMaxY);

			for (int y = invMinY; y <= invMaxY; y++)
			{
				for (int x = invMinX; x <= invMaxX; x++)
				{
					if (poolHead < pool.Length)
					{
						int h = HashPos2(x, y, buckets.Length);
						int idx = poolHead;
						poolHead++;
						pool[idx].X = x;
						pool[idx].Y = y;
						pool[idx].Value = value;
						pool[idx].Next = buckets[h]; 
						buckets[h] = idx;
					}
				}
			}
		}

		/// <summary>
		/// Take all the items within a certain range and add their ids to an array.
		/// </summary>
		/// <param name="minX">The minimum x-coordinate</param>
		/// <param name="minY">The minimum y-coordinate</param>
		/// <param name="maxX">The maximum x-coordinate</param>
		/// <param name="maxY">The maximum y-coordinate</param>
		/// <param name="values">The array of values</param>
		/// <param name="maxVals">The maximum number of values that can be stored</param>
		/// <returns>The number of unique values</returns>
		public int QueryItems(float minX, float minY, float maxX, float maxY, T[] values, int maxVals)
		{
			int invMinX = (int)Math.Floor(minX * invCellSize);
			int invMinY = (int)Math.Floor(minY * invCellSize);
			int invMaxX = (int)Math.Floor(maxX * invCellSize);
			int invMaxY = (int)Math.Floor(maxY * invCellSize);

			int n = 0;

			for (int y = invMinY; y <= invMaxY; y++)
			{
				for (int x = invMinX; x <= invMaxX; x++)
				{
					int h = HashPos2(x, y, buckets.Length);
					int idx = buckets[h];
					
					while (idx != Invalid) 
					{
						if (pool[idx].X == x && pool[idx].Y == y)
						{
							//check if the id exists already
							int i = 0;
							while (i != n && !values[i].Equals(pool[idx].Value))
								i++;

							//item not found, add it
							if (i == n)
							{
								if (n >= maxVals)
									return n;
								values[n++] = pool[idx].Value;
							}
						}

						idx = pool[idx].Next;
					}
				}
			}

			return n;
		}

		/// <summary>
		/// Gets the number of items at a specific location.
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		/// <returns>The number of items at the specified coordinates.</returns>
		public int GetItemCountAtLocation(int x, int y)
		{
			int n = 0;
			int h = HashPos2(x, y, buckets.Length);
			int idx = buckets[h];

			while (idx != Invalid)
			{
				Item item = pool[idx];
				if (item.X == x && item.Y == y)
					n++;
				idx = item.Next;
			}

			return n;
		}

		/// <summary>
		/// Hash function
		/// </summary>
		/// <param name="x">The x-coordinate</param>
		/// <param name="y">The y-coordinate</param>
		/// <param name="n">Total size of hash table</param>
		/// <returns>A hash value</returns>
		public static int HashPos2(int x, int y, int n)
		{
			return ((x * 73856093) ^ (y * 19349663)) & (n - 1);
		}

		#endregion

		/// <summary>
		/// An "item" is simply a coordinate on the proximity grid
		/// </summary>
		private class Item
		{
			public T Value { get; set; }

			public int X { get; set; }

			public int Y { get; set; }

			public int Next { get; set; }
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\LaunchPadAction.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Editors.LaunchPad.Actions.Impl;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions
{
    public enum LaunchPadActionType
    {
        None,
        OpenFolder,
        OpenScene,
        OpenTheme,
        OpenSnapFlow,
        OpenGridFlow,
        OpenSnapGridFlow,
        CloneScene,
        CloneSceneAndBuild,
        CloneInfinityScene,
        CloneInfinitySceneAndBuild,
        CloneTheme,
        CloneSnapFlow,
        CloneSnapGridFlow,
        CloneGridFlow,
        Documentation,
        Video,
    }

    [System.Serializable]
    public class LaunchPadActionData
    {
        public string path = "";
        public bool resource_path = false;
        public bool readOnly = false;
        public string icon = "";
        public string title = "";
    }

    public interface ILaunchPadAction 
    {
        Texture2D GetIcon();
        string GetText();
        void Execute();
        bool IsValid();
    }

    public abstract class LaunchPadActionBase : ILaunchPadAction
    {
        public abstract Texture2D GetIcon();
        public abstract string GetText();
        public abstract void Execute();
        public virtual bool IsValid() { return true; }

        protected string ConvertResourceToAssetPath(string resourcePath)
        {
            var obj = Resources.Load<Object>(resourcePath);
            var assetPath = AssetDatabase.GetAssetPath(obj);
            return GetRelativePath(assetPath);
        }

        protected bool CloneAsset(string sourceTemplatePath, bool resourcePath, out string targetPath, string title)
        {
            string sourcePath;
            if (resourcePath)
            {
                var sourceResourcePath = "LaunchPad/templates/" + sourceTemplatePath;
                sourcePath = ConvertResourceToAssetPath(sourceResourcePath);
            }
            else
            {
                sourcePath = sourceTemplatePath;
            }
            var fileInfo = new System.IO.FileInfo(sourcePath);
            var extension = fileInfo.Extension.Length > 0 ? fileInfo.Extension.Substring(1) : "";
            targetPath = EditorUtility.SaveFilePanelInProject(title, fileInfo.Name, extension, "Please choose a path to saved the cloned asset(s)");
            if (targetPath.Length == 0) return false;
            return AssetDatabase.CopyAsset(sourcePath, targetPath);
        }

        protected string GetRelativePath(string path)
        {
            if (path.StartsWith(Application.dataPath))
            {
                path = "Asset" + path.Substring(Application.dataPath.Length);
            }
            return path;
        }

        protected string ExtractFilename(string path)
        {
            var fileInfo = new System.IO.FileInfo(path);
            return fileInfo.Name;
        }

        protected bool CloneTemplateReferencedAsset(Object templateObj, string destFolder, out string clonedObjPath)
        {
            var templateObjPath = AssetDatabase.GetAssetPath(templateObj);
            var templateObjFilename = ExtractFilename(templateObjPath);
            clonedObjPath = destFolder + templateObjFilename;
            clonedObjPath = AssetDatabase.GenerateUniqueAssetPath(clonedObjPath);
            return AssetDatabase.CopyAsset(templateObjPath, clonedObjPath);
        }

        protected void PingAsset(string path)
        {
            Object obj = AssetDatabase.LoadAssetAtPath<Object>(path);
            Selection.activeObject = obj;
            EditorGUIUtility.PingObject(obj);
        }

        protected void OpenLink(string path)
        {
            if (path.StartsWith("http"))
            {
                Application.OpenURL(path);
            }
        }

    }

    public class LaunchPadActionFactory
    {
        public static ILaunchPadAction Create(LaunchPadActionType actionType, LaunchPadActionData data)
        {
            switch(actionType)
            {
                case LaunchPadActionType.OpenFolder: return new LaunchPadActionOpenFolder(data.path);
                case LaunchPadActionType.OpenScene: return new LaunchPadActionOpenScene(data.path);
                case LaunchPadActionType.OpenTheme: return new LaunchPadActionOpenTheme(data.path);
                case LaunchPadActionType.OpenSnapFlow: return new LaunchPadActionOpenSnapFlow(data.path);
                case LaunchPadActionType.OpenGridFlow: return new LaunchPadActionOpenGridFlow(data.path, data.readOnly);
                case LaunchPadActionType.OpenSnapGridFlow: return new LaunchPadActionOpenSnapGridFlow(data.path, data.readOnly);
                case LaunchPadActionType.CloneScene: return new LaunchPadActionCloneScene(data.path, data.resource_path);
                case LaunchPadActionType.CloneSceneAndBuild: return new LaunchPadActionCloneSceneAndBuild(data.path, data.resource_path);
                case LaunchPadActionType.CloneInfinityScene: return new LaunchPadActionCloneInfinityScene(data.path, data.resource_path);
                case LaunchPadActionType.CloneInfinitySceneAndBuild: return new LaunchPadActionCloneInfinitySceneAndBuild(data.path, data.resource_path);
                case LaunchPadActionType.CloneTheme: return new LaunchPadActionCloneTheme(data.path, data.resource_path);
                case LaunchPadActionType.CloneSnapFlow: return new LaunchPadActionCloneSnapFlow(data.path, data.resource_path);
                case LaunchPadActionType.CloneSnapGridFlow: return new LaunchPadActionCloneSnapGridFlow(data.path, data.resource_path);
                case LaunchPadActionType.CloneGridFlow: return new LaunchPadActionCloneGridFlow(data.path, data.resource_path);
                case LaunchPadActionType.Documentation: return new LaunchPadActionDocumentation(data.path);
                case LaunchPadActionType.Video: return new LaunchPadActionVideo(data.path);
                default: return null;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Screens\ScreenPage.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.UI.Widgets;

namespace DungeonArchitect.Editors.LaunchPad
{
    public class ScreenPageJsonDataBase
    {
        public string title;
        public string layout;
    }
    public delegate void OnScreenPageLinkClicked(string path);

    public enum ScreenPageType
    {
        CardGrid,
        Details,
        News,
        Empty
    }

    public abstract class ScreenPage
    {
        public string Id { get; set; }
        public string Title { get; set; }
        public IWidget Widget { get; protected set; }
        public abstract void Load(string json);
        public event OnScreenPageLinkClicked LinkClicked;

        protected void NotifyLinkClicked(string path)
        {
            if (LinkClicked != null)
            {
                LinkClicked.Invoke(path);
            }
        }

    }

    public class ScreenPageFactory
    {
        public static ScreenPage Create(ScreenPageType pageType)
        {
            if (pageType == ScreenPageType.CardGrid)
            {
                return new ScreenPageCardGrid();
            }
            else if (pageType == ScreenPageType.Details)
            {
                return new ScreenPageDetails();
            }
            else if (pageType == ScreenPageType.News)
            {
                return new ScreenPageNews();
            }
            return null;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Screens\ScreenPageLoader.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad
{
    public class ScreenPageLoader
    {
        static T LoadAsset<T>(string basePath, string path) where T : Object
        {
            var fullPath = "LaunchPad/" + basePath + path;
            return Resources.Load<T>(fullPath);
        }

        static TextAsset LoadPageAsset(string path)
        {
            return LoadAsset<TextAsset>("pages/", path);
        }

        public static Texture2D LoadImageAsset(string path)
        {
            return LoadAsset<Texture2D>("images/", path);
        }


        public static ScreenPage LoadPage(string path)
        {
            var textAsset = LoadPageAsset(path);
            if (textAsset == null)
            {
                return null;
            }

            var json = textAsset.text;
            var layoutType = GetPageType(json);
            var page = ScreenPageFactory.Create(layoutType);
            if (page != null)
            {
                page.Load(json);
            }

            return page;
        }

        static ScreenPageType GetPageType(string json)
        {
            var data = JsonUtility.FromJson<ScreenPageJsonDataBase>(json);
            if (data == null)
            {
                return ScreenPageType.Empty;
            }

            try
            {
                ScreenPageType result = (ScreenPageType)System.Enum.Parse(typeof(ScreenPageType), data.layout);
                return result;
            }
            catch { }

            return ScreenPageType.Empty;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Widgets\LaunchPadActionWidget.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Editors.LaunchPad.Actions;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad
{

    public class LaunchPadActionWidget : WidgetBase
    {
        protected IWidget Content;
        public LaunchPadActionType actionType = LaunchPadActionType.None;
        ILaunchPadAction action;


        public LaunchPadActionWidget(LaunchPadActionType actionType, ILaunchPadAction action, LaunchPadActionData data)
        {
            this.action = action;
            this.actionType = actionType;

            var title = action.GetText();
            if (data.title != null && data.title.Length > 0)
            {
                title = data.title;
            }

            if (action != null)
            {
                var host =
                    new BorderWidget(
                        new StackPanelWidget(StackPanelOrientation.Vertical)
                        .AddWidget(
                            new ImageWidget(action.GetIcon())
                            .SetDrawMode(ImageWidgetDrawMode.Fixed)
                        , 30, true)
                        .AddWidget(
                            new BorderWidget(
                                new LabelWidget(title)
                                .SetTextAlign(TextAnchor.MiddleCenter)
                                .SetColor(new Color(0.8f, 0.8f, 0.8f)))
                            .SetPadding(5, 5, 5, 5)
                            .SetTransparent()
                        , 0, true))
                    .SetPadding(2, 8, 2, 0)
                    .SetColor(new Color(0.1f, 0.1f, 0.1f));

                var link = new LinkWidget(host);
                link.LinkClicked += OnLinkClicked; ;

                Content = link;
            }
            else
            {
                this.Content = new NullWidget();
            }
        }

        private void OnLinkClicked(WidgetClickEvent clickEvent)
        {
            if (action != null)
            {
                action.Execute();
            }
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (Content != null)
            {
                var contentBounds = new Rect(Vector2.zero, WidgetBounds.size);
                Content.UpdateWidget(uiSystem, contentBounds);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            // Draw the content
            if (Content != null)
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, Content);
            }
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { Content };
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            if (Content != null)
            {
                return Content.GetDesiredSize(size, uiSystem);
            }
            else
            {
                return base.GetDesiredSize(size, uiSystem);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Widgets\LaunchPadCardWidget.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad
{
    public class LaunchPadCardWidgetData
    {
        public string title;
        public string description;
        public Texture2D thumbnail;
        public string link = "";
        public string url;
    }

    public class LaunchPadCardWidget : WidgetBase
    {
        LaunchPadCardWidgetData data;
        IWidget layout;
        ImageWidget thumbnailWidget;
        LabelWidget titleWidget;
        LabelWidget descriptionWidget;
        float thumbnailHeight = 100;
        bool showDescription;
        public event OnScreenPageLinkClicked LinkClicked;


        public LaunchPadCardWidget(LaunchPadCardWidgetData data, bool showDescription)
        {
            this.data = data;
            this.showDescription = showDescription;
        }

        void BuildLayout(UISystem uiSystem)
        {
            thumbnailWidget =
                new ImageWidget(data.thumbnail)
                .SetDrawMode(ImageWidgetDrawMode.Fill);

            titleWidget =
                new LabelWidget(data.title)
                    .SetFontSize(18)
                    .SetTextAlign(TextAnchor.MiddleCenter)
                    .SetColor(new Color(0.85f, 0.85f, 0.85f));

            if (showDescription)
            {
                descriptionWidget =
                    new LabelWidget(data.description)
                        .SetFontSize(14)
                        .SetTextAlign(TextAnchor.UpperCenter)
                        .SetColor(new Color(0.65f, 0.65f, 0.65f))
                        .SetWordWrap(true);
            }

            float titlePadding = 5;
            float descPadding = 8;
            StackPanelWidget host =
                new StackPanelWidget(StackPanelOrientation.Vertical)
                .AddWidget(thumbnailWidget, thumbnailHeight)
                .AddWidget(new BorderWidget(titleWidget)
                    .SetPadding(titlePadding, titlePadding, titlePadding, 0)
                    .SetBorderColor(new Color(0, 0, 0, 0))
                    .SetColor(new Color(0, 0, 0, 0))
                    , 0, true);

            if (showDescription)
            {
                host.AddWidget(new BorderWidget(descriptionWidget)
                    .SetPadding(descPadding, 0, descPadding, descPadding)
                    .SetBorderColor(new Color(0, 0, 0, 0))
                    .SetColor(new Color(0, 0, 0, 0)));
            }

            var hostLink = new LinkWidget(host);
            hostLink.LinkClicked += OnCardClicked;

            layout = new BorderWidget(hostLink)
                        .SetColor(new Color(0.1f, 0.1f, 0.1f))
                        .SetBorderColor(new Color(0, 0, 0, 1))
                        .SetPadding(0, 0, 0, 0);
        }

        public LaunchPadCardWidget SetThumbnailHeight(float height)
        {
            this.thumbnailHeight = height;
            return this;
        }

        private void OnCardClicked(WidgetClickEvent clickEvent)
        {
            if (data != null)
            {
                if (data.url != null && data.url.Length > 0)
                {
                    Application.OpenURL(data.url);
                }

                if (data.link != null && data.link.Length > 0)
                {
                    if (LinkClicked != null)
                    {
                        LinkClicked.Invoke(data.link);
                    }
                }
            }
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (layout == null)
            {
                BuildLayout(uiSystem);
            }
            var contentBounds = new Rect(Vector2.zero, WidgetBounds.size);
            layout.UpdateWidget(uiSystem, contentBounds);
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (layout != null)
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, layout);
            }
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { layout };
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            if (layout == null) return Vector2.zero;
            return layout.GetDesiredSize(size, uiSystem);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Widgets\LaunchPadCategoryWidget.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad
{
    public struct LaunchPadCategoryData
    {
        public LaunchPadCategoryData(string path, string displayText)
        {
            this.path = path;
            this.displayText = displayText;
        }

        public string path;
        public string displayText;
    }

    public class LaunchPadCategoryDataSource : ListViewSource<LaunchPadCategoryData>
    {
        LaunchPadCategoryData[] items;
        
        public int Count
        {
            get => (items != null) ? items.Length : 0;
        }
        
        public void SetItems(LaunchPadCategoryData[] items)
        {
            this.items = items;
        }

        public override LaunchPadCategoryData[] GetItems()
        {
            return items;
        }

        public override IWidget CreateWidget(LaunchPadCategoryData item)
        {
            var itemWidget = new LaunchPadCategoryItem(item);
            itemWidget.TextStyle.fontSize = 16;

            itemWidget.SelectedTextStyle = new GUIStyle(itemWidget.TextStyle);
            itemWidget.SelectedTextStyle.normal.textColor = Color.white;
            itemWidget.SelectedColor = new Color(0.2f, 0.2f, 0.2f);

            return itemWidget;
        }
    }

    public class LaunchPadCategoryItem : ListViewTextItemWidget
    {
        public LaunchPadCategoryItem(LaunchPadCategoryData category)
            : base(category, () => category.displayText)
        {
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\DemoGame\Door\LockedDoor.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Flow.Items;
using UnityEngine;

namespace DungeonArchitect.Samples.GridFlow
{
    public class LockedDoor : MonoBehaviour
    {
        public Transform doorLeft;
        public Transform doorRight;

        private Animator animator;

        private string lockId;
        private string[] validKeys = new string[0];
 

        private void Start()
        {
            // find the door id (grab it from the item metadata component that DA creates)
            var lockItemMetadata = FindItemMetadata();
            if (lockItemMetadata != null)
            {
                lockId = lockItemMetadata.itemId;
                validKeys = lockItemMetadata.referencedItemIds;
            }

            animator = GetComponent<Animator>();
        }

        /// <summary>
        /// Search the current game object and works its way up the hierarchy to find the item metadata object 
        /// </summary>
        /// <returns></returns>
        FlowItemMetadataComponent FindItemMetadata()
        {
            var obj = gameObject;
            while (obj != null)
            {
                var itemMetadata = obj.GetComponent<FlowItemMetadataComponent>();
                if (itemMetadata != null)
                {
                    return itemMetadata;
                }

                var parentTransform = obj.transform.parent; 
                obj = (parentTransform != null) ? parentTransform.gameObject : null;
            }

            return null;
        }

        void OnTriggerEnter(Collider other)
        {
            if (CanOpenDoor(other))
            {
                OpenDoor();
            }
        }

        void OnTriggerExit(Collider other)
        {
            CloseDoor();
        }

        bool CanOpenDoor(Collider other)
        {
            var inventory = other.gameObject.GetComponentInChildren<Inventory>();
            if (inventory != null)
            {
                // Check if any of the valid keys are present in the inventory of the collided object
                foreach (var validKey in validKeys)
                {
                    if (inventory.ContainsItem(validKey))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        void OpenDoor()
        {
            animator.SetBool("doorOpen", true);
        }

        void CloseDoor()
        {
            animator.SetBool("doorOpen", false);
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\DemoGame\Inventory\Inventory.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.GridFlow
{
    public enum InventoryItemType
    {
        None,
        Key,
    }

    [System.Serializable]
    public class InventoryItem
    {
        public InventoryItemType itemType = InventoryItemType.None;
        public string itemId;
        public Sprite icon = null;
    }

    public class Inventory : MonoBehaviour
    {
        public InventorySlot[] slots;
        InventoryUI inventoryUI;

        private void Awake()
        {
            inventoryUI = GameObject.FindObjectOfType<InventoryUI>();
        }

        /// <summary>
        /// Adds an item to a free slot
        /// </summary>
        /// <param name=""></param>
        /// <returns></returns>
        public bool Add(InventoryItem item)
        {
            foreach (var slot in slots)
            {
                if (slot.item.itemType == InventoryItemType.None)
                {
                    // Found a free slot
                    slot.item = item;

                    // Update the UI
                    if (inventoryUI != null)
                    {
                        inventoryUI.UpdateUI(this);
                    }
                    return true;
                }
            }
            return false;
        }

        public bool ContainsItem(string itemId)
        {
            foreach (var slot in slots)
            {
                if (slot.item.itemType != InventoryItemType.None)
                {
                    if (slot.item.itemId == itemId)
                    {
                        return true;
                    }
                }
            }
            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\DemoGame\Inventory\InventorySlot.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Samples.GridFlow
{
    public class InventorySlot : MonoBehaviour
    {
        public InventoryItem item = new InventoryItem();
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\DemoGame\Inventory\PickableItem.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Flow.Items;
using UnityEngine;

namespace DungeonArchitect.Samples.GridFlow
{
    public class PickableItem : MonoBehaviour
    {
        public InventoryItemType itemType = InventoryItemType.None;
        public Sprite icon = null;

        private void OnTriggerEnter(Collider other)
        {
            var go = other.gameObject;
            var inventory = go.GetComponentInChildren<Inventory>();
            if (inventory != null)
            {
                var item = new InventoryItem();
                item.itemType = itemType;
                item.itemId = GetItemId();
                item.icon = icon;

                if (inventory.Add(item))
                {
                    // We successfully added this item to the inventory. destroy this game object
                    Destroy(gameObject);
                    return;
                }
            }
        }

        string GetItemId()
        {
            var itemMetadata = GetComponent<FlowItemMetadataComponent>();
            return (itemMetadata != null) ? itemMetadata.itemId : "";
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_GridFlow\Scripts\DemoGame\UI\InventoryUI.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;
using UnityEngine.UI;

namespace DungeonArchitect.Samples.GridFlow
{
    public class InventoryUI : MonoBehaviour
    {
        public Image[] slotImages;

        public void UpdateUI(Inventory inventory)
        {
            for (int i = 0; i < inventory.slots.Length && i < slotImages.Length; i++)
            {
                var slot = inventory.slots[i];
                if (slot.item.itemType != InventoryItemType.None)
                {
                    var image = slotImages[i];
                    image.sprite = slot.item.icon;
                    image.color = Color.white;
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_Samples\DemoBuilder_Snap_Extras\Snap_Marker_Support\Scripts\_Internal\SnapThemeEngineMarkerInserter.cs:
 using System.Collections;
using System.Collections.Generic;
using DungeonArchitect;
using DungeonArchitect.Samples.Snap;
using UnityEngine;

/// <summary>
/// This will be run in the second dummy dungeon (Dungeon 2) whose sole purpose is to spawn the snap markers
/// Dungeon 1 - Runs the snap dungeon.   When completes,  invokes Dungeon2.Build()
/// Dungeon 2 - Builds an empty dungeon.   Before running the theme engine, it finds all the SnapCustomMarkers in the scene (spawned by the first dungeon)
///             and inserts it into the theme engine so they can be spawned 
/// </summary>
public class SnapThemeEngineMarkerInserter : DungeonEventListener
{
    public bool hideMarkerGizmos;
    /// <summary>
    /// Called after all the markers have been emitted for the level (but before the theming engine is run on those markers)
    /// This gives you an opportunity to modify the markers 
    /// </summary>
    /// <param name="dungeon"></param>
    /// <param name="model"></param>
    /// <param name="markers"></param>
    public override void OnDungeonMarkersEmitted(Dungeon dungeon, DungeonModel model, LevelMarkerList markers)
    {
        // Find all the spawn markers in the scene (they would have been spawned
        var snapMarkersInScene = FindObjectsOfType<SnapCustomMarker>();
        
        // insert the snap markers into the theme engine's marker list so our dungeon can pick it up and spawn it
        foreach (var snapMarker in snapMarkersInScene)
        {
            var marker = new PropSocket();
            marker.Id = 0;
            marker.SocketType = snapMarker.markerName;
            marker.Transform = snapMarker.transform.localToWorldMatrix;
            marker.gridPosition = IntVector.Zero;
            marker.cellId = 0;

            markers.Add(marker);

            if (hideMarkerGizmos)
            {
                snapMarker.hideGizmoVisuals = hideMarkerGizmos;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\DomainEditors\Layout\Layout2DGraphDomainEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Layout;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.UI.Widgets.GraphEditors;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.DomainEditors.Layout2D
{
    public class Layout2DGraphDomainEditor : FlowDomainEditor
    {
        FlowLayoutGraph layoutGraph;
        
        [SerializeField]
        FlowLayoutToolGraph2D layoutGraphTool;
        
        [SerializeField]
        GraphPanel<FlowPreviewLayoutGraphEditor> layoutGraphPanel;

        public FlowItem SelectedItem { get; set; }  = null;
        public FlowLayoutGraphNode SelectedLayoutNode { get; set; } = null;

        public delegate void GraphNodeDelegate(object sender, GraphNodeEventArgs e);
        public delegate void ItemStateDelegate(FlowItem item);

        public event GraphNodeDelegate NodeSelectionChanged;
        public event GraphNodeDelegate NodeDoubleClicked;
        public event ItemStateDelegate ItemSelectionChanged;
        
        
        public override IWidget Content { get; protected set; }
        public override bool StateValid
        {
            get => (layoutGraph != null);
        }
        
        public override void Init(IFlowDomain domain, FlowEditorConfig editorConfig, UISystem uiSystem)
        {
            base.Init(domain, editorConfig, uiSystem);
            layoutGraphTool = ScriptableObject.CreateInstance<FlowLayoutToolGraph2D>();
            layoutGraphPanel = new GraphPanel<FlowPreviewLayoutGraphEditor>(layoutGraphTool, null, uiSystem);
            layoutGraphPanel.Border.SetTitle("Result: Layout Graph");
            layoutGraphPanel.Border.SetColor(new Color(0.2f, 0.3f, 0.2f));
            layoutGraphPanel.GraphEditor.EditorStyle.branding = "Layout";
            layoutGraphPanel.GraphEditor.EditorStyle.displayAssetFilename = false;
            layoutGraphPanel.GraphEditor.ItemSelectionChanged += OnItemSelectionChanged;
            layoutGraphPanel.GraphEditor.Events.OnNodeSelectionChanged.Event += OnNodeSelectionChanged;
            layoutGraphPanel.GraphEditor.Events.OnNodeDoubleClicked.Event += OnNodeDoubleClicked;
            Content = layoutGraphPanel;
        }
        
        private void OnNodeSelectionChanged(object sender, GraphNodeEventArgs e)
        {
            var previewNode = (e.Nodes.Length == 1) ? e.Nodes[0] as FlowLayoutToolGraph2DNode : null;
            var previewLayoutNode = (previewNode != null) ? previewNode.LayoutNode : null;

            if (previewLayoutNode != SelectedLayoutNode)
            {
                SelectedLayoutNode = previewLayoutNode;
            }

            if (NodeSelectionChanged != null)
            {
                NodeSelectionChanged.Invoke(sender, e);
            }
        }

        private void OnNodeDoubleClicked(object sender, GraphNodeEventArgs e)
        {
            if (NodeDoubleClicked != null)
            {
                NodeDoubleClicked.Invoke(sender, e);
            }
        }

        private void OnItemSelectionChanged(FlowItem item)
        {
            if (item != SelectedItem)
            {
                SelectedItem = item;
            }

            if (ItemSelectionChanged != null)
            {
                ItemSelectionChanged.Invoke(item);
            }
        }
        
        public override void Destroy()
        {
            if (layoutGraphTool != null)
            {
                Object.DestroyImmediate(layoutGraphTool);
                layoutGraphTool = null;
            }
        }
        
        public override void UpdateNodePreview(FlowExecTaskState taskState)
        {
            if (taskState != null)
            {
                layoutGraph = taskState.GetState<FlowLayoutGraph>();
                FlowLayoutToolGraph2DBuilder.Build(layoutGraph, new NonEditorGraphBuilder(layoutGraphTool));
            }
        }

        public override void SetReadOnly(bool readOnly)
        {
            if (layoutGraphPanel != null && layoutGraphPanel.GraphEditor != null)
            {
                layoutGraphPanel.GraphEditor.SetReadOnly(readOnly);
            }
        }

        public FlowLayoutGraph FlowGraph
        {
            get => layoutGraph;
            set => layoutGraph = value;
        }
        
        public FlowPreviewLayoutGraphEditor GraphEditor
        {
            get => (layoutGraphPanel != null) ? layoutGraphPanel.GraphEditor : null;
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\DomainEditors\Layout\Layout3DGraphDomainEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.DomainEditors.Layout3D
{
    public interface ILayout3DGraphDomainSettings
    {
        bool AutoFocusViewport { get; }
    }
    
    public class Layout3DGraphDomainEditor : FlowDomainEditor
    {
        private FlowLayoutGraph layoutGraph;
        private FlowLayoutToolGraph3D viewport;
        private ToolbarWidget toolbar;
        static readonly string BTN_RECENTER_VIEW = "RecenterView";

        public override void Init(IFlowDomain domain, FlowEditorConfig editorConfig, UISystem uiSystem)
        {
            base.Init(domain, editorConfig, uiSystem);

            // Setup the viewport
            {
                viewport = new FlowLayoutToolGraph3D();
                viewport.SetClearState(true, true, new Color(0.90f, 0.95f, 1.0f));
                viewport.MoveSpeed = 6;
            }
            
            // Setup the floating toolbar
            {
                toolbar = new ToolbarWidget();
                toolbar.ButtonSize = 24;
                toolbar.Padding = 0;
                toolbar.Background = new Color(0, 0, 0, 0);
                toolbar.AddButton(BTN_RECENTER_VIEW, UIResourceLookup.ICON_ZOOMFIT_16x);

                toolbar.ButtonPressed += ToolbarOnButtonPressed;
            }

            Content = new OverlayPanelWidget()
                .AddWidget(viewport)
                .AddWidget(toolbar, OverlayPanelHAlign.Right, OverlayPanelVAlign.Top, new Vector2(24, 24), new Vector2(10, 10));
            
            // Build the scene
            viewport.Build(null);
            
            viewport.RecenterView();
        }

        private void ToolbarOnButtonPressed(UISystem uisystem, string id)
        {
            viewport.RecenterView();
        }

        public override IWidget Content { get; protected set; }
        public override bool StateValid { get; }
        public override void UpdateNodePreview(FlowExecTaskState taskState)
        {
            if (taskState != null)
            {
                layoutGraph = taskState.GetState<FlowLayoutGraph>();
                viewport.Build(layoutGraph);
                
                // Recenter the view
                if (EditorConfig is ILayout3DGraphDomainSettings)
                {
                    var viewportSettings = EditorConfig as ILayout3DGraphDomainSettings;
                    if (viewportSettings.AutoFocusViewport)
                    {
                        viewport.ResetFrameTimer();
                        viewport.RecenterView();
                    }
                }
            }
        }

        public override bool RequiresRepaint()
        {
            return viewport != null && viewport.IsCameraMoving(); 
        }
        
        public override void HandleInput(UISystem uiSystem)
        {
            var e = uiSystem.Platform.CurrentEvent;
            if (e == null) return;
            if (e.type == EventType.KeyDown)
            {
                // Handle Key pressed
                if (e.keyCode == KeyCode.F)
                {
                    if (viewport != null)
                    {
                        viewport.RecenterView();
                    }
                }
            }
        }
        
        public FlowLayoutGraph FlowGraph
        {
            get => layoutGraph;
            set => layoutGraph = value;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\DomainEditors\Tilemap\TilemapFlowDomainEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.DomainEditors.Layout2D;
using DungeonArchitect.Editors.Flow.Tilemap;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Domains.Tilemap.Tooling;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.UI.Widgets.GraphEditors;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.DomainEditors.Tilemap
{
    public class TilemapFlowDomainEditor : FlowDomainEditor
    {
        FlowTilemap tilemap = null;
        
        [SerializeField]
        FlowTilemapToolGraph tilemapTool;
        
        [SerializeField]
        GraphPanel<FlowPreviewTilemapGraphEditor> tilemapPanel;
        
        Layout2DGraphDomainEditor layoutDomainEditor;
        IntVector2 lastTilemapCellClicked = IntVector2.Zero;
        bool tilemapDirty = false;
        
        public delegate void TileEventDelegate(FlowTilemap tilemap, int tileX, int tileY);
        public event TileEventDelegate TileClicked;
        public event TileEventDelegate TileDoubleClicked;
        
        FlowTilemapToolBuildContext BuildContext { get; } = new FlowTilemapToolBuildContext();

        public override IWidget Content { get; protected set; }

        public override bool StateValid
        {
            get => tilemap != null;
        }
        
        public FlowTilemap Tilemap
        {
            get => tilemap;
            set => tilemap = value;
        }

        public void SetLayoutDomainEditor(Layout2DGraphDomainEditor layoutDomainEditor)
        {
            this.layoutDomainEditor = layoutDomainEditor;
        }

        public override void Init(IFlowDomain domain, FlowEditorConfig editorConfig, UISystem uiSystem)
        {
            base.Init(domain, editorConfig, uiSystem);
            tilemapTool = ScriptableObject.CreateInstance<FlowTilemapToolGraph>();
            tilemapPanel = new GraphPanel<FlowPreviewTilemapGraphEditor>(tilemapTool, null, uiSystem);
            tilemapPanel.Border.SetTitle("Result: Tilemap");
            tilemapPanel.Border.SetColor(new Color(0.3f, 0.2f, 0.2f));
            tilemapPanel.GraphEditor.EditorStyle.branding = "Tilemap";
            tilemapPanel.GraphEditor.EditorStyle.displayAssetFilename = false;
            tilemapPanel.GraphEditor.TileClicked += TilemapGraphEditor_TileClicked;
            tilemapPanel.GraphEditor.Events.OnNodeDoubleClicked.Event += TilemapGraphEditor_OnNodeDoubleClicked;
            Content = tilemapPanel;
        }
        
        private void TilemapGraphEditor_TileClicked(FlowTilemap tilemap, int tileX, int tileY)
        {
            lastTilemapCellClicked.Set(tileX, tileY);
            
            if (TileClicked != null)
            {
                TileClicked.Invoke(tilemap, tileX, tileY);
            }
        }

        private void TilemapGraphEditor_OnNodeDoubleClicked(object sender, GraphNodeEventArgs e)
        {
            if (TileDoubleClicked != null)
            {
                TileDoubleClicked.Invoke(tilemap, lastTilemapCellClicked.x, lastTilemapCellClicked.y);
            }
        }
        
        public override void UpdateNodePreview(FlowExecTaskState taskState)
        {
            if (taskState != null)
            {
                tilemap = taskState.GetState<FlowTilemap>();
                RebuildTilemap();
            }
        }
        
        public override void Update()
        {   
            if (tilemapDirty)
            {
                RebuildTilemap();
                tilemapDirty = false;
            }
        }

        public override void Invalidate()
        {
            tilemapDirty = true;
        }
        
        public override void SetReadOnly(bool readOnly)
        {
            if (tilemapPanel != null && tilemapPanel.GraphEditor != null)
            {
                tilemapPanel.GraphEditor.SetReadOnly(readOnly);
            }
        }

        void RebuildTilemap()
        {
            if (tilemap != null)
            {
                BuildContext.tilemap = tilemap;
                BuildContext.graphBuilder = new NonEditorGraphBuilder(tilemapTool);
                BuildContext.LayoutGraph = layoutDomainEditor.FlowGraph;
                BuildContext.selectedNode = layoutDomainEditor.SelectedLayoutNode;
                BuildContext.selectedItem = layoutDomainEditor.SelectedItem;
                FlowTilemapToolGraphBuilder.Build(BuildContext);

                if (tilemapPanel != null)
                {
                    tilemapPanel.GraphEditor.UpdateGridSpacing();
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Implementations\GridFlow\GridFlowEditorWindow.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Editors.Flow.DomainEditors.Layout2D;
using DungeonArchitect.Editors.Flow.DomainEditors.Tilemap;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.UI.Widgets.GraphEditors;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.Impl
{
    public class GridFlowEditorWindow : FlowEditorWindow
    {
        private Layout2DGraphDomainEditor layoutDomainEditor;
        private TilemapFlowDomainEditor tilemapDomainEditor;
        
        IWidget widgetSetupLayoutOnly;
        IWidget widgetSetupLayoutAndTilemap;

        protected override IWidget DomainLayoutWidget { get; set; }
        protected override string WindowTitle { get => "Grid Flow Editor"; }
        
        public static void ShowWindow()
        {
            var window = EditorWindow.GetWindow<GridFlowEditorWindow>();
            window.Init(null);
        }

        protected override FlowEditorConfig CreateEditorConfig()
        {
            return CreateInstance<GridFlowEditorConfig>();
        }

        protected override FlowExecNodeOutputRegistry GetLinkedDungeonNodeOutputRegistry()
        {
            var config = editorConfig as GridFlowEditorConfig;
            return config != null ? config.dungeonBuilder.ExecNodeOutputRegistry : null;
        }

        protected override void InitDomains()
        {
            layoutDomainEditor = CreateInstance<Layout2DGraphDomainEditor>();
            layoutDomainEditor.Init(new GridFlowLayoutGraphDomain(), editorConfig, uiSystem);
            layoutDomainEditor.NodeSelectionChanged += LayoutDomainEditor_OnNodeSelectionChanged; 
            layoutDomainEditor.ItemSelectionChanged += LayoutDomainEditor_OnItemSelectionChanged;
            RegisterDomainEditor(layoutDomainEditor);

            tilemapDomainEditor = CreateInstance<TilemapFlowDomainEditor>();
            tilemapDomainEditor.SetLayoutDomainEditor(layoutDomainEditor);
            tilemapDomainEditor.Init(new GridFlowTilemapDomain(), editorConfig, uiSystem);
            tilemapDomainEditor.TileClicked += TilemapDomainEditor_OnTileClicked;
            tilemapDomainEditor.TileDoubleClicked += TilemapDomainEditor_OnTileDoubleClicked;
            RegisterDomainEditor(tilemapDomainEditor);
            
            widgetSetupLayoutOnly = layoutDomainEditor.Content; 
            widgetSetupLayoutAndTilemap =
                new Splitter(SplitterDirection.Horizontal)
                    .AddWidget(layoutDomainEditor.Content, 1)
                    .AddWidget(tilemapDomainEditor.Content, 1);
        }

        private void LayoutDomainEditor_OnItemSelectionChanged(FlowItem item)
        {
            tilemapDomainEditor.Invalidate();
        }

        private void LayoutDomainEditor_OnNodeSelectionChanged(object sender, GraphNodeEventArgs e)
        {
            tilemapDomainEditor.Invalidate();
        }

        protected override void UpdateDomainPreview(FlowExecTaskState taskState)
        {
            base.UpdateDomainPreview(taskState);
            
            DomainLayoutWidget = null; 

            if (layoutDomainEditor.StateValid && tilemapDomainEditor.StateValid)
            {
                // Show the result layout for tilemap
                DomainLayoutWidget = widgetSetupLayoutAndTilemap;
            }
            else if (layoutDomainEditor.StateValid)
            {
                // Show the result layout graphs
                DomainLayoutWidget = widgetSetupLayoutOnly;
            }
        }
        
        protected override bool IsDomainStateInvalid()
        {
            return (layoutDomainEditor == null || tilemapDomainEditor == null || !layoutDomainEditor.IsInitialized() || !tilemapDomainEditor.IsInitialized());
        }


        private void TilemapDomainEditor_OnTileDoubleClicked(FlowTilemap tilemap, int tileX, int tileY)
        {
            if (tilemap != null)
            {
                bool valid = false;
                var bounds = new Bounds();
                var cellId = tileY * tilemap.Width + tileX;
                var items = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
                GameObject selectedObject = null;
                foreach (var item in items)
                {
                    if (item.userData == cellId)
                    {
                        var renderer = item.gameObject.GetComponent<Renderer>();
                        if (renderer != null)
                        {
                            if (!valid)
                            {
                                valid = true;
                                bounds = renderer.bounds;
                            }
                            else
                            {
                                bounds.Encapsulate(renderer.bounds);
                            }
                        }

                        selectedObject = item.gameObject;
                    }
                }

                if (valid && SceneView.lastActiveSceneView != null)
                {
                    bounds.center += new Vector3(0, bounds.extents.y, 0);
                    bounds.extents = new Vector3(bounds.extents.x, 1, bounds.extents.z);

                    SceneView.lastActiveSceneView.Frame(bounds, false);
                }

                if (selectedObject != null)
                {
                    Selection.activeGameObject = selectedObject;
                    EditorApplication.RepaintHierarchyWindow();
                }
            }
        }

        private void TilemapDomainEditor_OnTileClicked(FlowTilemap tilemap, int tileX, int tileY)
        {
            var cell = tilemap.Cells[tileX, tileY];
            if (cell.CellType == FlowTilemapCellType.Floor)
            {
                var nodeCoord = cell.NodeCoord;
                layoutDomainEditor.GraphEditor.SelectNodeAtCoord(nodeCoord, uiSystem);
            }

            layoutDomainEditor.GraphEditor.SelectNodeItem(cell.Item);
        }
        
        public override void SetReadOnly(bool readOnly)
        {
            base.SetReadOnly(readOnly);
            
            layoutDomainEditor.SetReadOnly(readOnly);
            tilemapDomainEditor.SetReadOnly(readOnly);
        }
    }

    public class GridFlowEditorConfig : FlowEditorConfig
    {
        public override DungeonBuilder FlowBuilder
        {
            get => dungeonBuilder;
        }
        
        public GridFlowDungeonBuilder dungeonBuilder;
    } 

    [CustomEditor(typeof(GridFlowEditorConfig), true)]
    public class GridFlowExecGraphEditorConfigInspector : FlowExecGraphEditorConfigInspector
    {
        SerializedProperty dungeonObject;

        protected override void OnEnable()
        {
            base.OnEnable();
            dungeonObject = sobject.FindProperty("dungeonBuilder");
        }

        protected override void DrawDungeonProperty()
        {
            EditorGUILayout.PropertyField(dungeonObject);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Implementations\SnapGridFlow\SnapGridFlowEditorConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.DomainEditors.Layout3D;
using DungeonArchitect.Flow.Impl.SnapGridFlow;

namespace DungeonArchitect.Editors.Flow.Impl
{
    public enum SnapGridFlowEditorLayoutMode
    {
        Vertical,
        Horizontal
    }
    
    public class SnapGridFlowEditorConfig : FlowEditorConfig, ILayout3DGraphDomainSettings
    {
        public SnapGridFlowModuleDatabase moduleDatabase;
        public bool autoFocusViewport = true;
        public SnapGridFlowEditorLayoutMode layoutMode = SnapGridFlowEditorLayoutMode.Vertical;
        
        public override DungeonBuilder FlowBuilder
        {
            get => null;
        }

        public bool AutoFocusViewport { get => autoFocusViewport; }
    } 
    
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Implementations\SnapGridFlow\SnapGridFlowEditorConfigEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;
using UnityEngine.UI;

namespace DungeonArchitect.Editors.Flow.Impl
{
    [CustomEditor(typeof(SnapGridFlowEditorConfig), true)]
    public class SnapGridFlowEditorConfigEditor : Editor
    {
        private SerializedObject sobject;
        SerializedProperty randomizeSeed;
        SerializedProperty seed;
        SerializedProperty moduleDatabase;
        SerializedProperty autoFocusViewport;
        SerializedProperty layoutMode;
        
        private void OnEnable()
        {
            sobject = new SerializedObject(target);
            randomizeSeed = sobject.FindProperty("randomizeSeed");
            seed = sobject.FindProperty("seed");
            moduleDatabase = sobject.FindProperty("moduleDatabase");
            autoFocusViewport = sobject.FindProperty("autoFocusViewport");
            layoutMode = sobject.FindProperty("layoutMode");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();
            
            GUILayout.Label("SGF Editor Config", EditorStyles.boldLabel);
            
            EditorGUILayout.PropertyField(randomizeSeed);
            EditorGUILayout.PropertyField(seed);
            EditorGUILayout.PropertyField(moduleDatabase);
            EditorGUILayout.PropertyField(autoFocusViewport);

            /*
            using (var changeScope = new EditorGUI.ChangeCheckScope())
            {
                EditorGUILayout.PropertyField(layoutMode);
                if (changeScope.changed)
                {
                    RebuildEditorLayout();
                }
            }
            */

            sobject.ApplyModifiedProperties();
        }

        void RebuildEditorLayout()
        {
            var window = EditorWindow.GetWindow<SnapGridFlowEditorWindow>();
            if (window != null)
            {
                window.RequestRebuildLayout();
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Implementations\SnapGridFlow\SnapGridFlowEditorUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{
    public class SnapGridFlowEditorUtils
    {
        public static void InitAsset(SnapGridFlowModuleBounds moduleBounds)
        {
            
        }
        
        public static void InitAsset(SnapGridFlowModuleDatabase moduleDB)
        {
            
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Implementations\SnapGridFlow\SnapGridFlowEditorWindow.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.DomainEditors.Layout3D;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using DungeonArchitect.UI.Widgets;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Impl
{
    public class SnapGridFlowEditorWindow : FlowEditorWindow
    {
        private Layout3DGraphDomainEditor layoutDomainEditor;

        protected override string WindowTitle { get; } = "Snap Grid Flow Editor";
        protected override IWidget DomainLayoutWidget { get; set; }
        protected override void InitDomains()
        {
            layoutDomainEditor = CreateInstance<Layout3DGraphDomainEditor>();
            layoutDomainEditor.Init(new SnapGridFlowLayoutGraph3DDomain(), editorConfig, uiSystem);
            RegisterDomainEditor(layoutDomainEditor);

            DomainLayoutWidget = layoutDomainEditor.Content;
        }
        
        protected override FlowEditorConfig CreateEditorConfig()
        {
            return CreateInstance<SnapGridFlowEditorConfig>();
        }

        protected override FlowExecNodeOutputRegistry GetLinkedDungeonNodeOutputRegistry()
        {
            return null;
        }

        protected override bool IsDomainStateInvalid()
        {
            return layoutDomainEditor == null || !layoutDomainEditor.IsInitialized();
        }
        
        protected override void AddDomainExtenders(FlowDomainExtensions domainExtensions)
        {
            var config = editorConfig as SnapGridFlowEditorConfig;
            
            var extension = domainExtensions.GetExtension<SnapGridFlowDomainExtension>();
            extension.ModuleDatabase = (config != null) ? config.moduleDatabase : null;
        }

        public void SetModuleDatabase(SnapGridFlowModuleDatabase moduleDatabase)
        {
            var config = editorConfig as SnapGridFlowEditorConfig;
            if (config != null)
            {
                config.moduleDatabase = moduleDatabase;
            }
        }
        
        protected override IWidget CreateMainLayout(IWidget execGraphWidget, IWidget domainsWidget)
        {
            var config = editorConfig as SnapGridFlowEditorConfig;
            
            return new Splitter(config != null && config.layoutMode == SnapGridFlowEditorLayoutMode.Vertical 
                    ? SplitterDirection.Vertical : SplitterDirection.Horizontal)
                .AddWidget(execGraphWidget, 1)
                .AddWidget(domainsWidget, 2);
        }

        public static void ShowWindow()
        {
            var window = EditorWindow.GetWindow<SnapGridFlowEditorWindow>();
            window.Init(null);
        }

        public void RequestRebuildLayout()
        {
            BuildLayout();

            uiSystem.SetLayout(null);
            RequestRepaint();
            
            if (execGraphPanel != null)
            {
                execGraphPanel.ResetCamera();
            }

            if (layoutDomainEditor != null)
            {
                layoutDomainEditor.RequiresRepaint();
            }

        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Implementations\SnapGridFlow\SnapGridFlowModuleDBCompiler.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using DungeonArchitect.Frameworks.Snap;
using DungeonArchitect.Utils;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.Impl
{
    public class SnapGridFlowModuleDBCompiler
    {
        public enum CompileErrorType
        {
            Success,
            Warning,
            Error
        }
        
        public struct CompileResultEntry
        {
            public CompileErrorType errorType;
            public string message;
            public int moduleIndex;

            public CompileResultEntry(CompileErrorType errorType, string message) : this(errorType, -1, message) {}
            public CompileResultEntry(CompileErrorType errorType, int moduleIndex, string message)
            {
                this.errorType = errorType;
                this.message = message;
                this.moduleIndex = moduleIndex;
            }
        }

        private static SgfModuleDatabaseConnectionInfo[] GenerateConnectionInfo(GameObject module)
        {
            var baseModuleInverse = module.transform.localToWorldMatrix.inverse;
            baseModuleInverse = Matrix4x4.TRS(Matrix.GetTranslation(ref baseModuleInverse), Matrix.GetRotation(ref baseModuleInverse), Vector3.one);
            
            var result = new List<SgfModuleDatabaseConnectionInfo>();
            var connectionComponents = module.GetComponentsInChildren<SnapConnection>();
            for (var i = 0; i < connectionComponents.Length; i++)
            {
                var connectionComp = connectionComponents[i];
                var transform = connectionComp.transform;
                var worldTransform = baseModuleInverse * transform.localToWorldMatrix; // Matrix4x4.TRS(transform.localPosition, transform.localRotation, transform.localScale);

                var info = new SgfModuleDatabaseConnectionInfo();
                info.ConnectionIndex = i;
                info.Transform = worldTransform;
                info.Category = connectionComp.category;
                result.Add(info);
            }

            return result.ToArray();
        }
        
        public static bool Build(SnapGridFlowModuleDatabase moduleDatabase, out CompileResultEntry[] errors)
        {
            if (moduleDatabase == null)
            {
                errors = new CompileResultEntry[] { new CompileResultEntry(CompileErrorType.Error, "Missing module database reference") };
                return false;
            }

            if (moduleDatabase.ModuleBoundsAsset == null)
            {
                errors = new CompileResultEntry[] { new CompileResultEntry(CompileErrorType.Error, "Missing module bounds reference") };
                return false;
            }

            var bounds = moduleDatabase.ModuleBoundsAsset;
            var errorList = new List<CompileResultEntry>();
            for (var m = 0; m < moduleDatabase.Modules.Length; m++)
            {
                var item = moduleDatabase.Modules[m];
                if (item.ModulePrefab == null)
                {
                    errorList.Add(new CompileResultEntry(CompileErrorType.Error, m, "Missing module prefab reference"));
                    continue;
                }

                if (item.ModulePrefab.moduleBounds != bounds)
                {
                    errorList.Add(new CompileResultEntry(CompileErrorType.Error, m, "Different bounds asset specified in module prefab"));
                    continue;
                }

                // Build this entry
                var moduleSize = Vector3.Scale(bounds.chunkSize, DungeonArchitect.Utils.MathUtils.ToVector3(item.ModulePrefab.numChunks));
                var moduleBounds = new Bounds(moduleSize * 0.5f, moduleSize);
                item.ModuleBounds = moduleBounds;
                item.NumChunks = item.ModulePrefab.numChunks;
                item.Connections = GenerateConnectionInfo(item.ModulePrefab.gameObject);

                // Build the assemblies
                if (item.allowRotation)
                {
                    item.RotatedAssemblies = new SgfModuleAssembly[4];
                    SGFModuleAssemblyBuilder.Build(bounds, item, out item.RotatedAssemblies[0]);
                    for (int r = 1; r < 4; r++)
                    {
                        SGFModuleAssemblyBuilder.Rotate90Cw(item.RotatedAssemblies[r - 1], out item.RotatedAssemblies[r]);
                    }
                }
                else
                {
                    item.RotatedAssemblies = new SgfModuleAssembly[1];
                    SGFModuleAssemblyBuilder.Build(bounds, item, out item.RotatedAssemblies[0]);
                }
                
                // build the placeable item list
                {
                    var placeableItems = new Dictionary<PlaceableMarker, int>();
                    var placeableMarkers = item.ModulePrefab.gameObject.GetComponentsInChildren<PlaceableMarker>();
                    foreach (var placeableMarker in placeableMarkers)
                    {
                        var prefabTemplate = PrefabUtility.GetCorrespondingObjectFromOriginalSource(placeableMarker);
                        if (prefabTemplate == null) continue;
                        
                        if (!placeableItems.ContainsKey(prefabTemplate))
                        {
                            placeableItems.Add(prefabTemplate, 0);
                        }

                        placeableItems[prefabTemplate]++;
                    }

                    var result = new List<SgfModuleDatabasePlaceableMarkerInfo>();
                    foreach (var entry in placeableItems)
                    {
                        var info = new SgfModuleDatabasePlaceableMarkerInfo();
                        info.placeableMarkerTemplate = entry.Key;
                        info.count = entry.Value;
                        result.Add(info);
                    }

                    item.AvailableMarkers = result.ToArray();
                }
            }

            EditorUtility.SetDirty(moduleDatabase);

            errors = errorList.ToArray();
            var success = (errors.Length == 0);
            return success;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Editors\Grid\GridMarkerGenEditor.cs:
 using System;
using System.Linq;
using DungeonArchitect.Editors.MarkerGenerator.Editors.Grid.Actors;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Grid;
using DungeonArchitect.MarkerGenerator.Rule;
using DungeonArchitect.MarkerGenerator.Rule.Grid;
using DungeonArchitect.SxEngine;
using DungeonArchitect.SxEngine.Utils;
using DungeonArchitect.UI;
using DungeonArchitect.Utils;
using UnityEditor;
using UnityEngine;
using MathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Editors.MarkerGenerator.Editors.Grid
{
    public class GridMarkerGenEditor : MarkerGenEditor
    {
        public override Type PatternType => typeof(GridMarkerGenPattern);
        public override Type RuleType => typeof(GridMarkerGenRule);
        
        private GridMarkerGenPattern gridPattern = null;

        private SxGridMarkerGenGroundActor groundActor;
        private SxCursorActor cursorActor;
        private readonly MouseDeltaTracker deltaTracker;
        private SxGridPatternRuleActor hoveredActor = null;
        private SxGridPatternRuleActor selectedActor = null;
        private SxGridPatternRuleActor draggedActor = null;
        
        
        public GridMarkerGenEditor()
        {
            deltaTracker = new MouseDeltaTracker();
            deltaTracker.OnLeftClick += OnLeftClick;
            deltaTracker.OnRightClick += OnRightClick;
            deltaTracker.OnDrag += OnDrag;
            deltaTracker.OnDragStart += OnDragStart;
            deltaTracker.OnDragEnd += OnDragEnd;
        }

        public override void Update(double frameTime)
        {
            if (draggedActor != null)
            {
                cursorActor.SetSmoothPosition(draggedActor.Position, true);
            }
            if (FrameRequiresRepaint())
            {
                RequestRepaint = true;
            }
        }

        private bool FrameRequiresRepaint()
        {
            if (cursorActor != null && cursorActor.Animating)
            {
                return true;
            }
            
            if (PatternViewport != null && PatternViewport.World != null)
            {
                foreach (var ruleActor in PatternViewport.World.GetActorsOfType<SxGridPatternRuleActor>())
                {
                    if (ruleActor.Animating)
                    {
                        return true;
                    }
                }
            }
            
            return false;
        }

        public override void OnRuleGraphChanged(MarkerGenRule rule)
        {
            // Find the rule actor and update the text
            if (PatternViewport != null && PatternViewport.World != null)
            {
                var ruleActors = PatternViewport.World.GetActorsOfType<SxGridPatternRuleActor>();
                foreach (var ruleActor in ruleActors)
                {
                    if (ruleActor.Rule == rule)
                    {
                        ruleActor.UpdateRuleText();
                        PatternViewport.Invalidate();
                        break;
                    }
                }
            }
        }
        
        public override void HandleInput(Event widgetEvent, UISystem uiSystem)
        {
            if (PatternViewport == null)
            {
                return;
            }
            
            SxCamera camera = PatternViewport.Camera;
            deltaTracker.HandleInput(widgetEvent, uiSystem);
            
            // Update the cursor
            if (cursorActor != null)
            {
                if (widgetEvent.type == EventType.MouseMove || (widgetEvent.type == EventType.MouseDrag && draggedActor == null))
                {
                    SxGridPatternRuleActor newHoveredRuleActor = null;
                    if (GetActorUnderMouse(widgetEvent.mousePosition, out var actor, out var intersectionPoint))
                    {
                        if (actor is SxGridMarkerGenGroundActor ground)
                        {
                            Debug.Assert(ground == groundActor);
                            var cursorPosition = MathUtils.ClampToRect(intersectionPoint, groundActor.WorldBounds);
                            
                            // Check if we have a rule actor in this cell
                            SxGridPatternRuleActor cellRuleActor = null;
                            if (groundActor.Deproject(cursorPosition, out var item, out var itemType))
                            {
                                if (PatternViewport != null && PatternViewport.World != null)
                                {
                                    foreach (var ruleActorToTest in PatternViewport.World.GetActorsOfType<SxGridPatternRuleActor>())
                                    {
                                        if (ruleActorToTest.Rule != null)
                                        {
                                            if (ruleActorToTest.Rule.coord == item.Coord && ruleActorToTest.Rule.ruleType == itemType)
                                            {
                                                cellRuleActor = ruleActorToTest;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                if (cellRuleActor == null)
                                {
                                    // Hovered over the grid actor.
                                    cursorActor.SetSmoothPosition(cursorPosition); 
                                    groundActor.OnMouseHover(cursorPosition);
                                }
                                else
                                {
                                    // Make it hover over the rule actor
                                    actor = cellRuleActor;
                                    intersectionPoint = cellRuleActor.Position;
                                }
                            }
                            
                        }
                        
                        if (actor is SxGridPatternRuleActor ruleActor)
                        {
                            if (draggedActor == null || draggedActor == ruleActor)
                            {
                                var cursorPosition = MathUtils.ClampToRect(intersectionPoint, groundActor.WorldBounds);
                                cursorActor.SetSmoothPosition(cursorPosition);
                                groundActor.OnMouseHover(cursorPosition);
                                HandleHoverRuleActor(ruleActor);
                                newHoveredRuleActor = ruleActor;
                            }
                        }
                    }

                    HandleHoverRuleActor(newHoveredRuleActor);

                    RequestRepaint = true;
                }
            }
        }

        private bool GetActorUnderMouse(Vector2 mousePosition, out SxActor actor, out Vector3 intersectionPoint)
        {
            return GetActorUnderMouse(mousePosition, Array.Empty<SxActor>(), out actor, out intersectionPoint);
        }

        public override void HandleRulePropertyChange(MarkerGenRule rule)
        {
            // Update the material and transform of the rule actor
            SxGridPatternRuleActor ruleActor = null;
            if (PatternViewport != null && PatternViewport.World != null)
            {
                foreach (var actor in PatternViewport.World.GetActorsOfType<SxGridPatternRuleActor>())
                {
                    if (actor != null && actor.Rule == rule)
                    {
                        ruleActor = actor;
                        break;
                    }
                }
            }

            if (ruleActor != null)
            {
                ruleActor.UpdateTransform(true);
                ruleActor.UpdateMaterial();
                PatternViewport?.Invalidate();
            }
        }

        private bool GetActorUnderMouse(Vector2 mousePosition, SxActor[] actorsToIgnore, out SxActor actor, out Vector3 intersectionPoint)
        {
            if (PatternViewport != null && PatternViewport.Camera != null && PatternViewport.World != null)
            {
                var camera = PatternViewport.Camera;
                var world = PatternViewport.World;
                var ray = camera.ScreenToRay(mousePosition);
                
                // Check if we hit an object actor
                {
                    SxActor bestActor = null;
                    float bestDistance = float.MaxValue;
                    var bestIntersectionPoint = Vector3.zero;
                    
                    var ruleActors = world.GetActorsOfType<SxGridPatternRuleActor>();
                    foreach (var ruleActor in ruleActors)
                    {
                        if (ruleActor == null || actorsToIgnore.Contains(ruleActor))
                        {
                            continue;
                        }
                        
                        var bounds = ruleActor.GetBounds();
                        if (bounds.IntersectRay(ray, out var intersectionDistance))
                        {
                            if (intersectionDistance < bestDistance)
                            {
                                bestActor = ruleActor;
                                bestIntersectionPoint = ruleActor.WorldTransform.Positon;
                                bestDistance = intersectionDistance;
                            }
                        }
                    }

                    if (bestActor != null)
                    {
                        actor = bestActor;
                        intersectionPoint = bestIntersectionPoint;
                        return true;
                    }
                }

                // Check if we hit a ground actor
                {
                    var plane = new Plane(Vector3.up, Vector3.zero);
                    if (MathUtils.RayPlaneIntersection(ray, plane, out var intersectionDistance))
                    {
                        actor = groundActor;
                        intersectionPoint = ray.GetPoint(intersectionDistance);
                        return true;
                    }
                }
            }
            
            actor = null;
            intersectionPoint = Vector3.zero;
            return false;
        }
        
        public override void LoadScene(MarkerGenPattern pattern, UIPlatform platform)
        {
            if (PatternViewport == null)
            {
                return;
            }
            
            var world = PatternViewport.World;
            cursorActor = world.SpawnActor<SxCursorActor>(true);
            
            gridPattern = pattern as GridMarkerGenPattern;
            if (gridPattern == null)
            {
                return;
            }

            // Build the ground actor
            {
                groundActor = world.SpawnActor<SxGridMarkerGenGroundActor>(true);
                
                var buildSettings = new GridMarkerGenGroundActorSettings();
                const int gridHalfSize = 5;
                buildSettings.Start = new Vector2Int(-gridHalfSize, -gridHalfSize);
                buildSettings.End = new Vector2Int(gridHalfSize, gridHalfSize);
                groundActor.Build(buildSettings);

            }
            
            // Create the rule actors
            {
                foreach (var rule in pattern.rules)
                {
                    if (rule is GridMarkerGenRule gridRule)
                    {
                        CreateRuleActor(world, gridRule);
                    }
                }
            }
            
            // build a grid
            {
                var gridMesh = world.SpawnActor<SxMeshActor>(true);
                gridMesh.SetMesh(SxMeshUtils.CreateGridMesh(10, 1.0f));
                gridMesh.SetMaterial<SxGridMaterial>();
            }
        }

        private void HandleSelectRuleActor(SxGridPatternRuleActor newSelectedActor)
        {
            Selection.activeObject = newSelectedActor?.Rule;
            
            if (selectedActor == newSelectedActor)
            {
                return;
            }

            var oldSelectedActor = selectedActor;
            if (oldSelectedActor != null)
            {
                oldSelectedActor.SetSelected(false);
            }

            if (newSelectedActor != null)
            {
                newSelectedActor.SetSelected(true);
            }
            selectedActor = newSelectedActor;
            
            var selectedRule = selectedActor?.Rule;
            NotifyRuleSelected(selectedRule);
        }
        
        private void HandleHoverRuleActor(SxGridPatternRuleActor newHoveredActor)
        {
            if (hoveredActor == newHoveredActor)
            {
                return;
            }

            var oldHoveredActor = hoveredActor;
            if (oldHoveredActor != null)
            {
                oldHoveredActor.SetHovered(false);
            }

            if (newHoveredActor != null)
            {
                newHoveredActor.SetHovered(true);
            }

            hoveredActor = newHoveredActor;
        }

        private void OnDragStart(Event e, UISystem uiSystem)
        {
            draggedActor = null;
            if (GetActorUnderMouse(e.mousePosition, out var actor, out var intersectionPoint))
            {
                if (actor is SxGridPatternRuleActor ruleActor)
                {
                    draggedActor = ruleActor;
                    HandleSelectRuleActor(draggedActor);
                }
            }
            
        }
        
        private void OnDragEnd(Event e, UISystem uiSystem)
        {
            if (draggedActor != null)
            {
                //draggedActor.UpdateTransform(false);
            }

            draggedActor = null;
        }
        
        private void OnDrag(Event e, UISystem uiSystem)
        {
            if (draggedActor == null || cursorActor == null) return;

            var actorsToIgnore = new SxActor[] { draggedActor };
            if (GetActorUnderMouse(e.mousePosition, actorsToIgnore, out var actor, out var intersection))
            {
                if (actor == groundActor)
                {
                    if (groundActor.Deproject(intersection, out var item, out var itemType))
                    {
                        var existingRule = GetRuleAt(item.Coord, itemType);
                        if (existingRule == null)
                        {
                            // No rule exists at this location. Move the actor here 
                            draggedActor.Rule.coord = item.Coord;
                            draggedActor.Rule.ruleType = itemType;
                            draggedActor.UpdateTransform(true);
                        }
                    }
                }
            }
        }
        
        private void OnLeftClick(Event e, UISystem uiSystem)
        {
            SxGridPatternRuleActor clickedRuleActor = null;
            if (GetActorUnderMouse(e.mousePosition, out var actor, out var intersection))
            {
                if (actor is SxGridPatternRuleActor ruleActor)
                {
                    clickedRuleActor = ruleActor;
                }
            }
            
            HandleSelectRuleActor(clickedRuleActor);
            PatternViewport.Invalidate();
        }

        private void OnRightClick(Event e, UISystem uiSystem)
        {
            if (GetActorUnderMouse(e.mousePosition, out var actor, out var intersection))
            {
                if (actor is SxGridMarkerGenGroundActor ground)
                {
                    if (ground.Deproject(intersection, out var item, out var itemType))
                    {
                        var menu = uiSystem.Platform.CreateContextMenu();
                        menu.AddItem("Add Rule", () =>
                        {
                            AddNewRule(item.Coord, itemType, uiSystem.Platform);
                        });
                        menu.Show();
                    }
                }
                else if (actor is SxGridPatternRuleActor ruleActor)
                {   
                    var menu = uiSystem.Platform.CreateContextMenu();
                    menu.AddItem("Delete Rule", () =>
                    {
                        string message = string.Format("Are you sure you want to delete the selected rule block?");
                        bool removeItem = EditorUtility.DisplayDialog("Delete Rule Block?", message, "Delete", "Cancel");
                        if (removeItem)
                        {
                            DeleteRule(ruleActor, uiSystem.Platform);
                        }
                    });
                    menu.Show();
                }
            }
        }

        void DeleteRule(SxGridPatternRuleActor ruleActor, UIPlatform platform)
        {
            if (ruleActor != null)
            {
                MarkerGenEditorUtils.RemoveRule(Asset, gridPattern, ruleActor.Rule);
                NotifyRuleSelected(ruleActor.Rule);
                ruleActor.Destroy();
            }
        }

        GridMarkerGenRule GetRuleAt(Vector2Int coord, GridMarkerGenRuleType ruleType)
        {
            foreach (var rule in gridPattern.rules)
            {
                if (rule is GridMarkerGenRule gridRule)
                {
                    if (gridRule.coord == coord && gridRule.ruleType == ruleType)
                    {
                        return gridRule;
                    }
                }
            }

            return null;
        }
        
        SxGridPatternRuleActor AddNewRule(Vector2Int coord, GridMarkerGenRuleType ruleType, UIPlatform platform)
        {
            // Make sure a rule with the same coords do not exist
            {
                var existingRule = GetRuleAt(coord, ruleType);
                if (existingRule != null)
                {
                    return null;
                }
            }

            var rule = MarkerGenEditorUtils.AddNewRule<GridMarkerGenRule>(Asset, gridPattern, platform);
            if (rule == null)
            {
                return null;
            }
            
            // Assign a random color to the rule
            rule.color = MarkerGenEditorUtils.CreateRandomColor();

            if (PatternViewport == null || PatternViewport.World == null)
            {
                return null;
            }
            
            rule.coord = coord;
            rule.ruleType = ruleType;

            var ruleActor = CreateRuleActor(PatternViewport.World, rule);
            HandleSelectRuleActor(ruleActor);
            return ruleActor;
        }

        SxGridPatternRuleActor CreateRuleActor(SxWorld world, GridMarkerGenRule rule)
        {
            var ruleActor = world.SpawnActor<SxGridPatternRuleActor>(true);
            ruleActor.Initialize(rule, groundActor.Settings.TileSize, groundActor.Settings.EdgeSize);
            return ruleActor;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Editors\Grid\GridMarkerGenEditorUtils.cs:
 using DungeonArchitect.MarkerGenerator.Rule.Grid;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.Editors.Grid
{
    public class GridMarkerGenEditorUtils
    {
        public static void DeprojectGround(Vector3 InWorldIntersection, float InTileSize, float InEdgeSize, out Vector2Int OutCoord, out GridMarkerGenRuleType OutItemType)
        {
            float offset = InTileSize + InEdgeSize;
            var loc = new Vector2(InWorldIntersection.x, InWorldIntersection.z);
            {
                var locOffset = InTileSize * 0.5f + InEdgeSize;
                loc += new Vector2(locOffset, locOffset);
            }

            var key = new Vector2Int();
            key.x = Mathf.FloorToInt(loc.x / offset);
            key.y = Mathf.FloorToInt(loc.y / offset);

            float fx = loc.x - key.x * offset;
            float fz = loc.y - key.y * offset;
            if (fx < InEdgeSize && fz < InEdgeSize) {
                OutItemType = GridMarkerGenRuleType.Corner;
            }
            else if (fx < InEdgeSize) {
                OutItemType = GridMarkerGenRuleType.EdgeZ;
            }
            else if (fz < InEdgeSize) {
                OutItemType = GridMarkerGenRuleType.EdgeX;
            }
            else {
                OutItemType = GridMarkerGenRuleType.Ground;
            }
            OutCoord = key;
        }

        public static void GetItemLocationScale(Vector2Int coord, float tileSize, float edgeSize, GridMarkerGenRuleType itemType, bool bVisuallyDominant,
            out Vector3 outLocation, out Vector3 outScale)
        {
            float offset = tileSize + edgeSize;
            float wallHeight = tileSize;
            if (!bVisuallyDominant) {
                wallHeight *= 0.25f;
            }
	
            if (itemType == GridMarkerGenRuleType.Corner) {
                outLocation = new Vector3(coord.x - 0.5f, 0, coord.y - 0.5f) * offset;
                outScale = new Vector3(edgeSize, edgeSize, wallHeight);
            }
            else if (itemType == GridMarkerGenRuleType.EdgeX) {
                outLocation = new Vector3(coord.x, 0, coord.y - 0.5f) * offset;
                outScale = new Vector3(tileSize, edgeSize, wallHeight);
            }
            else if (itemType == GridMarkerGenRuleType.EdgeZ) {
                outLocation = new Vector3(coord.x - 0.5f, 0, coord.y) * offset;
                outScale = new Vector3(edgeSize, tileSize, wallHeight);
            }
            else {	// Ground
                outLocation = new Vector3(coord.x, 0, coord.y) * offset;
                outScale = new Vector3(tileSize, tileSize, tileSize * 0.1f);
            }
        }


        public static Color CreateHoverColor(Color color)
        {
            Color.RGBToHSV(color, out var h, out var s, out var v);
            s *= 0.75f;
            return Color.HSVToRGB(h, s, v);

        }

        public static Color CreatePaleColor(Color color)
        {
            Color.RGBToHSV(color, out var h, out var s, out var v);
            s *= 0.5f;
            return Color.HSVToRGB(h, s, v);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\UI\GraphEditor\MarkerGenRuleGraphEditor.cs:
 using DungeonArchitect.Editors.MarkerGenerator.UI.NodeRenderers;
using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Nodes.Actions;
using DungeonArchitect.MarkerGenerator.Nodes.Condition;
using DungeonArchitect.MarkerGenerator.Pins;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.UI
{
    public class MarkerGenRuleGraphEditor : GraphEditor
    {
        public bool drawInvalidGraphMessage = false;
        
        public override void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            base.Init(graph, editorBounds, assetObject, uiSystem);
            EditorStyle.branding = "Rule Graph";
        }

        protected override GraphContextMenu CreateContextMenu()
        {
            return new MarkerGenRuleGraphContextMenu(this);
        }
        
        public override GraphSchema GetGraphSchema()
        {
            return new MarkerGenRuleGraphSchema();
        }
        
        protected override void InitializeNodeRenderers(GraphNodeRendererFactory renderers)
        {
            renderers.RegisterNodeRenderer(typeof(CommentNode), new CommentNodeRenderer(EditorStyle.commentTextColor));
            renderers.RegisterNodeRenderer(typeof(MarkerGenRuleGraphNode), new MarkerGenRuleNodeRenderer());
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            return new SplineGraphLinkRenderer();
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {
            var action = userdata as MarkerGenRuleGraphContextMenuUserData;
            var mouseScreen = lastMousePosition;
            GraphNode node = null;
            if (action != null)
            {
                if (action.Action == MarkerGenRuleGraphEditorAction.CreateCommentNode)
                {
                    node = CreateNode<CommentNode>(mouseScreen, e.uiSystem);
                }
                else if (action.Action == MarkerGenRuleGraphEditorAction.CreateRuleNode)
                {
                    node = CreateNode(mouseScreen, action.NodeType, e.uiSystem);
                }

                if (node != null)
                {
                    SelectNode(node, e.uiSystem);
                }
            }

            if (node != null)
            {
                // Check if the menu was created by dragging out a link
                if (e.sourcePin != null)
                {
                    GraphPin targetPin = (e.sourcePin.PinType == GraphPinType.Input) 
                            ? node.OutputPin 
                            : node.InputPin;

                    if (targetPin != null)
                    {

                        // Align the target pin with the mouse position where the link was dragged and released
                        node.Position = e.mouseWorldPosition - targetPin.Position;

                        GraphPin inputPin, outputPin;
                        if (e.sourcePin.PinType == GraphPinType.Input)
                        {
                            inputPin = e.sourcePin;
                            outputPin = targetPin;
                        }
                        else
                        {
                            inputPin = targetPin;
                            outputPin = e.sourcePin;
                        }

                        CreateLinkBetweenPins(outputPin, inputPin, e.uiSystem);
                    }
                    
                }
            }
        }

        protected override string GetGraphNotInitializedMessage()
        {
            return "Select a rule block to edit";
        }


        protected override void DrawHUD(UISystem uiSystem, UIRenderer renderer, Rect bounds)
        {
            base.DrawHUD(uiSystem, renderer, bounds);

            if (drawInvalidGraphMessage)
            {
                var offset = new Vector2(10, 30);
                string errorMessage = "Warning: Compilation failed. Invalid graph";
                var style = new GUIStyle(GUI.skin.GetStyle("label"));
                style.normal.textColor = Color.red;
                
                var textSize = style.CalcSize(new GUIContent(errorMessage));
                
                var x = bounds.x + offset.x;
                var y = bounds.yMax - textSize.y - offset.y;
                var textBounds = new Rect(new Vector2(x, y), textSize);
                renderer.DrawRect(MathUtils.ExpandRect(textBounds, 4), new Color(0, 0, 0, 0.5f));
                renderer.Label(textBounds, errorMessage, style);
            }
        }
    }
    
    public class MarkerGenRuleGraphSchema : GraphSchema
    {
        public override bool CanCreateLink(GraphPin output, GraphPin input, out string errorMessage)
        {
            errorMessage = "";
            if (input == output)
            {
                return false;
            }
            
            if (output == null || input == null)
            {
                errorMessage = "Invalid connection";
                return false;
            }

            if (input.PinType == output.PinType)
            {
                errorMessage = "Not Allowed";
                return false;
            }

            if (input.GetType() != output.GetType())
            {
                errorMessage = "Not Allowed";
                return false;
            }

            var graph = output.Node.Graph;
            foreach (var link in graph.Links)
            {
                if (link.Input == input && link.Output == output)
                {
                    errorMessage = "Not Allowed: Already connected";
                    return false;
                }
            }

            return true;
        }

        public override T TryCreateLink<T>(Graph graph, GraphPin output, GraphPin input)
        {
            bool isConditionalNode = output is MarkerGenRuleGraphPinBool;
            bool isExecNode = output is MarkerGenRuleGraphPinExec;
            
            if (isConditionalNode)
            {
                // Only one input, multiple outputs
                GraphOperations.DestroyPinLinks(graph, input, null);
            }
            else if (isExecNode)
            {
                // multiple inputs, one output
                GraphOperations.DestroyPinLinks(graph, output, null);
            }
            
            return base.TryCreateLink<T>(graph, output, input);
        }
    }

    public enum MarkerGenRuleGraphEditorAction
    {
        CreateCommentNode,
        CreateRuleNode
    }
    
    class MarkerGenRuleGraphContextMenuUserData
    {
        public MarkerGenRuleGraphContextMenuUserData(UISystem uiSystem, MarkerGenRuleGraphEditorAction action)
            : this(uiSystem, action, null)
        {
        }

        public MarkerGenRuleGraphContextMenuUserData(UISystem uiSystem, MarkerGenRuleGraphEditorAction action, System.Type nodeType)
        {
            this.uiSystem = uiSystem;
            this.Action = action;
            this.NodeType = nodeType;
        }

        public MarkerGenRuleGraphEditorAction Action { get; set; }
        public System.Type NodeType { get; set; }
        public UISystem uiSystem { get; set; }
    }

    
    class MarkerGenRuleGraphContextMenu : GraphContextMenu
    {
        private MarkerGenRuleGraphEditor host;
        
        struct MenuItemInfo
        {
            public MenuItemInfo(string title, float weight, System.Type handlerType)
            {
                this.title = title;
                this.weight = weight;
                this.handlerType = handlerType;
            }

            public string title;
            public float weight;
            public System.Type handlerType;
        }

        public MarkerGenRuleGraphContextMenu(MarkerGenRuleGraphEditor host)
        {
            this.host = host;
        }

        void AddMenuItem<T>(string name, string subMenu, IContextMenu menu, UISystem uiSystem)
        {
            menu.AddItem(subMenu + name, HandleContextMenu, new MarkerGenRuleGraphContextMenuUserData(uiSystem, MarkerGenRuleGraphEditorAction.CreateRuleNode, typeof(T)));
        }

        void PopulateConditionItems(IContextMenu menu, UISystem uiSystem, string subMenu = "")
        {
            AddMenuItem<MarkerGenRuleNodeMarkerExists>("Marker Exists", subMenu, menu, uiSystem);
            AddMenuItem<MarkerGenRuleNodeConditionScript>("Script Node", subMenu, menu, uiSystem);
            AddMenuItem<MarkerGenRuleNodeAnd>("And", subMenu, menu, uiSystem);
            AddMenuItem<MarkerGenRuleNodeOr>("Or", subMenu, menu, uiSystem);
            AddMenuItem<MarkerGenRuleNodeNot>("Not", subMenu, menu, uiSystem);
        }
        
        void PopulateActionItems(IContextMenu menu, UISystem uiSystem, string subMenu = "")
        {
            AddMenuItem<MarkerGenRuleNodeAddMarker>("Add Marker", subMenu, menu, uiSystem);
            AddMenuItem<MarkerGenRuleNodeRemoveMarker>("Remove Marker", subMenu, menu, uiSystem);
        }

        void PopulateDebugItems(IContextMenu menu, UISystem uiSystem)
        {
            menu.AddItem("Debug/Result Node", HandleContextMenu, new MarkerGenRuleGraphContextMenuUserData(uiSystem, MarkerGenRuleGraphEditorAction.CreateRuleNode, typeof(MarkerGenRuleNodeResult)));
            menu.AddItem("Debug/OnSelected Node", HandleContextMenu, new MarkerGenRuleGraphContextMenuUserData(uiSystem, MarkerGenRuleGraphEditorAction.CreateRuleNode, typeof(MarkerGenRuleNodeOnPass)));
        }

        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
            this.sourcePin = sourcePin;
            this.mouseWorldPosition = mouseWorld;
            
            var menu = uiSystem.Platform.CreateContextMenu();

            if (sourcePin != null && sourcePin is MarkerGenRuleGraphPinBool)
            {
                PopulateConditionItems(menu, uiSystem);
            }
            else if (sourcePin != null && sourcePin is MarkerGenRuleGraphPinExec)
            {
                PopulateActionItems(menu, uiSystem);
            }
            else 
            {
                PopulateConditionItems(menu, uiSystem, "Condition/");
                PopulateActionItems(menu, uiSystem, "Actions/");
                menu.AddSeparator("");
                menu.AddItem("Add Comment Node", HandleContextMenu, new MarkerGenRuleGraphContextMenuUserData(uiSystem, MarkerGenRuleGraphEditorAction.CreateCommentNode));
            }

            menu.Show();
        }

        void HandleContextMenu(object action)
        {
            var item = action as MarkerGenRuleGraphContextMenuUserData;
            if (item != null)
            {
                DispatchMenuItemEvent(action, BuildEvent(null, item.uiSystem));
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\UI\LayerList\MarkerGenPatternListPanel.cs:
 using System.Collections.Generic;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.UI
{
    class MarkerGenPatternListViewConstants
    {
        public static readonly string DragDropID = "RuleDragOp";
        public static readonly Color ThemeColor = new Color(0.3f, 0.3f, 0.2f);
    }

    public class MarkerGenPatternListViewItem : ListViewTextItemWidget
    {
        public MarkerGenPatternListViewItem(MarkerGenPattern pattern)
            : base(pattern, () => pattern.patternName)
        {
        }
        
    }
    
    public class MarkerGenPatternListViewSource : ListViewSource<MarkerGenPattern>
    {
        MarkerGeneratorAsset asset;
        public MarkerGenPatternListViewSource(MarkerGeneratorAsset asset)
        {
            this.asset = asset;
        }
        public override MarkerGenPattern[] GetItems()
        {
            return asset != null ? asset.patterns : null;
        }

        public override IWidget CreateWidget(MarkerGenPattern item)
        {
            var itemWidget = new MarkerGenPatternListViewItem(item);
            itemWidget.TextStyle.fontSize = 16;

            itemWidget.SelectedTextStyle = new GUIStyle(itemWidget.TextStyle);
            itemWidget.SelectedTextStyle.normal.textColor = Color.black;
            itemWidget.SelectedColor = MarkerGenPatternListViewConstants.ThemeColor * 2;

            return itemWidget;
        }
    }

    
    public delegate void MarkerGenPatternEvent();
    public delegate void MarkerGenPatternObjEvent(MarkerGenPattern pattern);

    public class MarkerGenPatternListPanel : WidgetBase
    {
        MarkerGeneratorAsset asset;

        IWidget host;

        public ListViewWidget<MarkerGenPattern> ListView;
        ToolbarWidget toolbar;

        public event MarkerGenPatternEvent OnAddItem;
        public event MarkerGenPatternObjEvent OnRemoveItem;

        readonly static string BTN_ADD_ITEM = "AddItem";
        readonly static string BTN_REMOVE_ITEM = "RemoveItem";
        readonly static string BTN_MOVE_UP = "MoveUp";
        readonly static string BTN_MOVE_DOWN = "MoveDown";

        public MarkerGenPatternListPanel(MarkerGeneratorAsset asset)
        {
            this.asset = asset;

            toolbar = new ToolbarWidget();
            toolbar.ButtonSize = 24;
            toolbar.Padding = 4;
            toolbar.Background = new Color(0, 0, 0, 0);
            toolbar.AddButton(BTN_ADD_ITEM, UIResourceLookup.ICON_PLUS_16x);
            toolbar.AddButton(BTN_REMOVE_ITEM, UIResourceLookup.ICON_CLOSE_16x);
            toolbar.AddButton(BTN_MOVE_UP, UIResourceLookup.ICON_MOVEUP_16x);
            toolbar.AddButton(BTN_MOVE_DOWN, UIResourceLookup.ICON_MOVEDOWN_16x);
            toolbar.ButtonPressed += Toolbar_ButtonPressed;
            var toolbarSize = new Vector2(toolbar.Padding * 2 + toolbar.ButtonSize * 4, toolbar.Padding * 2 + toolbar.ButtonSize);

            ListView = new ListViewWidget<MarkerGenPattern>();
            ListView.ItemHeight = 45;
            ListView.Bind(new MarkerGenPatternListViewSource(asset));

            IWidget toolWidget = new StackPanelWidget(StackPanelOrientation.Horizontal)
                                .AddWidget(new NullWidget())
                                .AddWidget(toolbar, toolbarSize.x);

            toolWidget = new BorderWidget(toolWidget)
                .SetPadding(0, 0, 0, 0)
                .SetDrawOutline(false)
                .SetColor(new Color(0, 0, 0, 0.25f));

            host = new BorderWidget()
                   .SetTitle("Patterns")
                   .SetColor(MarkerGenPatternListViewConstants.ThemeColor)
                   .SetContent(
                        new StackPanelWidget(StackPanelOrientation.Vertical)
                        .AddWidget(toolWidget, toolbarSize.y)
                        .AddWidget(ListView)
                    );
        }


        private void Toolbar_ButtonPressed(UISystem uiSystem, string id)
        {
            if (asset == null)
            {
                return;
            }

            if (id == BTN_ADD_ITEM)
            {
                if (OnAddItem != null)
                {
                    OnAddItem.Invoke();
                }
            }
            else if (id == BTN_REMOVE_ITEM)
            {
                var pattern = ListView.GetSelectedItem();
                if (pattern != null) 
                {
                    if (OnRemoveItem != null)
                    {
                        OnRemoveItem.Invoke(pattern);
                    }
                }
                
            }
            else if (id == BTN_MOVE_UP)
            {
                var nodeType = ListView.GetSelectedItem();
                var list = new List<MarkerGenPattern>(asset.patterns);
                int index = list.IndexOf(nodeType);
                if (index > 0)
                {
                    list.RemoveAt(index);
                    index--;
                    list.Insert(index, nodeType);
                    asset.patterns = list.ToArray();

                    ListView.NotifyDataChanged();
                    ListView.SetSelectedIndex(index);
                }
            }
            else if (id == BTN_MOVE_DOWN)
            {
                var rule = ListView.GetSelectedItem();
                var list = new List<MarkerGenPattern>(asset.patterns);
                int index = list.IndexOf(rule);
                if (index + 1 < list.Count)
                {
                    list.RemoveAt(index);
                    index++;
                    list.Insert(index, rule);
                    asset.patterns = list.ToArray();

                    ListView.NotifyDataChanged();
                    ListView.SetSelectedIndex(index);
                }
            }
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (host != null)
            {
                var childBounds = new Rect(Vector2.zero, bounds.size);
                host.UpdateWidget(uiSystem, childBounds);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            host.Draw(uiSystem, renderer);
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            host.HandleInput(e, uiSystem);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { host };
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\UI\PatternViewport\PatternViewportWidget.cs:
 using DungeonArchitect.MarkerGenerator.Rule;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.UI.Viewport
{
    public class PatternViewportWidget : SxViewportWidget
    {
        public PatternViewportWidget()
        {
            Renderer.SortRenderCommands = false;
        }

        public void RecenterView()
        {
            // TODO: Implement me
            FocusCameraOnPoints(new Vector3[] { Vector3.zero }, 3);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\SnapEdExecutionGraphContextMenu.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class SnapEdExecutionGraphContextMenu : GraphContextMenu
    {
        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
            this.sourcePin = sourcePin;
            var execEditor = graphEditor as SnapEdExecutionGraphEditor;
            var flowAsset = (execEditor != null) ? execEditor.FlowAsset : null;

            var menu = uiSystem.Platform.CreateContextMenu();
            if (flowAsset != null && flowAsset.productionRules.Length > 0)
            {
                foreach (var rule in flowAsset.productionRules)
                {
                    string text = "Add Rule: " + rule.ruleName;
                    menu.AddItem(text, HandleContextMenu, new SnapEdExecutionGraphEditorMenuData(uiSystem, SnapEdExecutionGraphEditorAction.CreateRuleNode, rule));
                }
                menu.AddSeparator("");
            }
            menu.AddItem("Add Comment Node", HandleContextMenu, new SnapEdExecutionGraphEditorMenuData(uiSystem, SnapEdExecutionGraphEditorAction.CreateCommentNode));
            menu.Show();
        }

        void HandleContextMenu(object action)
        {
            var item = action as SnapEdExecutionGraphEditorMenuData;
            DispatchMenuItemEvent(action, BuildEvent(null, item.uiSystem));
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\SnapEdExecutionGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI;
using DungeonArchitect.Grammar;
using DungeonArchitect.Graphs;
using UnityEditor;
using UnityEngine;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.SnapFlow
{
    public enum SnapEdExecutionGraphEditorAction
    {
        CreateRuleNode,
        CreateCommentNode
    }

    class SnapEdExecutionGraphEditorMenuData
    {
        public SnapEdExecutionGraphEditorMenuData(UISystem uiSystem, SnapEdExecutionGraphEditorAction action)
            : this(uiSystem, action, null)
        {
        }
        public SnapEdExecutionGraphEditorMenuData(UISystem uiSystem, SnapEdExecutionGraphEditorAction action, GrammarProductionRule rule)
        {
            this.Action = action;
            this.uiSystem = uiSystem;
            this.Rule = rule;
        }

        public SnapEdExecutionGraphEditorAction Action;
        public UISystem uiSystem;
        public GrammarProductionRule Rule;
    }

    public class SnapEdExecutionGraphSchema : GraphSchema
    {
        public override bool CanCreateLink(GraphPin output, GraphPin input, out string errorMessage)
        {
            errorMessage = "";
            if (output == null || input == null)
            {
                errorMessage = "Invalid connection";
                return false;
            }

            if (input.Node != null)
            {
                input = input.Node.InputPin;
            }

            var sourceNode = output.Node;
            var destNode = input.Node;

            if (destNode is GrammarExecEntryNode)
            {
                errorMessage = "Not Allowed: Cannot connect to entry node";
                return false;
            }

            // Make sure we don't already have this connection
            foreach (var link in output.GetConntectedLinks())
            {
                if (link.Input == input)
                {
                    errorMessage = "Not Allowed: Already connected";
                    return false;
                }
            }

            return true;
        }
    }

    public class SnapEdExecutionGraphEditor : GraphEditor
    {
        public SnapFlowAsset FlowAsset { get; private set; }
        public override void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            FlowAsset = assetObject as SnapFlowAsset;

            base.Init(graph, editorBounds, assetObject, uiSystem);
        }

        GrammarProductionRule GetDragData()
        {
            var dragDropData = DragAndDrop.GetGenericData(RuleListViewConstants.DragDropID);
            if (dragDropData != null && dragDropData is GrammarProductionRule)
            {
                return dragDropData as GrammarProductionRule;
            }
            return null;
        }

        public override GraphSchema GetGraphSchema()
        {
            return new SnapEdExecutionGraphSchema();
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            return new StraightLineGraphLinkRenderer();
        }

        public override T CreateLink<T>(Graph graph, GraphPin output, GraphPin input, UISystem uiSystem)
        {
            if (input != null && input.Node != null)
            {
                input = input.Node.InputPin;
            }

            // If we have a link in the opposite direction, then break that link
            var sourceNode = output.Node;
            var destNode = input.Node;
            if (sourceNode != null && destNode != null)
            {
                var links = destNode.OutputPin.GetConntectedLinks();
                foreach (var link in links)
                {
                    if (link.Output.Node == input.Node && link.Input.Node == output.Node)
                    {
                        GraphOperations.DestroyLink(link, uiSystem.Undo);
                    }
                }

                if (sourceNode is GrammarExecEntryNode)
                {
                    // Destroy all outgoing links first
                    var outgoingLinks = output.GetConntectedLinks();
                    foreach (var link in outgoingLinks)
                    {
                        GraphOperations.DestroyLink(link, uiSystem.Undo);
                    }
                }
            }

            if (input.Node != null)
            {
                input = input.Node.InputPin;
                if (input != null)
                {
                    return base.CreateLink<T>(graph, output, input, uiSystem);
                }
            }
            return null;
        }

        bool IsDragDataSupported()
        {
            return GetDragData() != null;
        }

        public override void Draw(UISystem uiSystem, UIRenderer renderer)
        {
            base.Draw(uiSystem, renderer);

            if (IsPaintEvent(uiSystem))
            {
                bool isDragging = (uiSystem != null && uiSystem.IsDragDrop);
                if (isDragging && IsDragDataSupported())
                {
                    // Show the drag drop overlay
                    var bounds = new Rect(Vector2.zero, WidgetBounds.size);
                    var dragOverlayColor = new Color(1, 0, 0, 0.25f);
                    renderer.DrawRect(bounds, dragOverlayColor);
                }
            }
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);

            switch (e.type)
            {
                case EventType.DragUpdated:
                    if (IsDragDataSupported())
                    {
                        HandleDragUpdate(e, uiSystem);
                    }
                    break;

                case EventType.DragPerform:
                    if (IsDragDataSupported())
                    {
                        HandleDragPerform(e, uiSystem);
                    }
                    break;
            }
        }

        private void HandleDragUpdate(Event e, UISystem uiSystem)
        {
            DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
        }

        private void HandleDragPerform(Event e, UISystem uiSystem)
        {
            // TODO: Create a node here
            var rule = GetDragData();
            if (rule != null)
            {
                if (uiSystem != null)
                {
                    uiSystem.RequestFocus(this);
                }

                var ruleNode = CreateNewExecRuleNode(rule, e.mousePosition, uiSystem);
                SelectNode(ruleNode, uiSystem);
            }

            DragAndDrop.AcceptDrag();
        }

        GrammarExecRuleNode CreateNewExecRuleNode(GrammarProductionRule rule, Vector2 mousePosition, UISystem uiSystem)
        {
            var node = CreateNode<GrammarExecRuleNode>(mousePosition, uiSystem);
            node.rule = rule;

            // Adjust the initial position of the placed node
            {
                var nodeRenderer = nodeRenderers.GetRenderer(node.GetType());
                if (nodeRenderer is GrammarNodeRendererBase)
                {
                    var grammarNodeRenderer = nodeRenderer as GrammarNodeRendererBase;
                    grammarNodeRenderer.UpdateNodeBounds(node, 1.0f);
                }

                var mouseWorld = camera.ScreenToWorld(mousePosition);
                var bounds = node.Bounds;
                bounds.position = mouseWorld - bounds.size / 2.0f;
                node.Bounds = bounds;
            }

            return node;

        }

        protected override GraphContextMenu CreateContextMenu()
        {
            return new SnapEdExecutionGraphContextMenu();
        }

        protected override void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers)
        {
            nodeRenderers.RegisterNodeRenderer(typeof(CommentNode), new CommentNodeRenderer(EditorStyle.commentTextColor));
            nodeRenderers.RegisterNodeRenderer(typeof(GrammarExecRuleNode), new GrammarExecRuleNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(GrammarExecEntryNode), new GrammarExecEntryNodeRenderer());
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {
            var data = userdata as SnapEdExecutionGraphEditorMenuData;

            var mouseScreen = lastMousePosition;
            if (data.Action == SnapEdExecutionGraphEditorAction.CreateRuleNode)
            {
                var ruleNode = CreateNewExecRuleNode(data.Rule, LastMousePosition, e.uiSystem);
                if (ruleNode != null)
                {
                    CreateLinkBetweenPins(e.sourcePin, ruleNode.InputPin, e.uiSystem);
                    SelectNode(ruleNode, e.uiSystem);
                }
            }
            else if (data.Action == SnapEdExecutionGraphEditorAction.CreateCommentNode)
            {
                CreateCommentNode(mouseScreen, e.uiSystem);
            }

        }

        protected override void DrawHUD(UISystem uiSystem, UIRenderer renderer, Rect bounds) { }

        void CreateCommentNode(Vector2 screenPos, UISystem uiSystem)
        {
            var worldPos = camera.ScreenToWorld(screenPos);
            var commentNode = CreateNode<CommentNode>(worldPos, uiSystem);
            commentNode.Position = worldPos;
            commentNode.background = new Color(0.224f, 1.0f, 0.161f, 0.7f);
            BringToFront(commentNode);
            SelectNode(commentNode, uiSystem);
        }

        protected override string GetGraphNotInitializedMessage()
        {
            return "Graph not initialize";
        }

        protected override GraphEditorStyle CreateEditorStyle()
        {
            var editorStyle = base.CreateEditorStyle();
            editorStyle.branding = "Execution Graph";
            editorStyle.backgroundColor = new Color(0.15f, 0.15f, 0.2f);
            return editorStyle;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\SnapEdGrammarGraphContextMenu.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class SnapEdGrammarGraphContextMenu : GraphContextMenu
    {
        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
            this.sourcePin = sourcePin;
            var menu = new GenericMenu();
            menu.AddItem(new GUIContent("Add Wildcard Node"), false, HandleContextMenu, new SnapEdGrammarGraphEditorContextMenuData(uiSystem, SnapEdGrammarGraphEditorAction.CreateWildcard));
            menu.AddSeparator("");

            var grammarGraphEditor = graphEditor as SnapEdGrammarGraphEditor;
            var flowAsset = (grammarGraphEditor != null) ? grammarGraphEditor.FlowAsset : null;
            if (flowAsset != null && flowAsset.nodeTypes != null && flowAsset.nodeTypes.Length > 0)
            {
                foreach (var nodeType in flowAsset.nodeTypes)
                {
                    var data = new SnapEdGrammarGraphEditorContextMenuData(uiSystem, SnapEdGrammarGraphEditorAction.CreateTaskNode, nodeType);
                    menu.AddItem(new GUIContent("Add Node: " + nodeType.nodeName), false, HandleContextMenu, data);
                }
                menu.AddSeparator("");
            }

            menu.AddItem(new GUIContent("Add Comment Node"), false, HandleContextMenu, new SnapEdGrammarGraphEditorContextMenuData(uiSystem, SnapEdGrammarGraphEditorAction.CreateCommentNode));
            menu.ShowAsContext();
        }

        void HandleContextMenu(object userdata)
        {
            var item = userdata as SnapEdGrammarGraphEditorContextMenuData;
            DispatchMenuItemEvent(userdata, BuildEvent(null, item.uiSystem));
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\SnapEdGrammarGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using DungeonArchitect.Grammar;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using UnityEditor;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.SnapFlow
{
    public enum SnapEdGrammarGraphEditorAction
    {
        CreateTaskNode,
        CreateWildcard,
        CreateCommentNode
    }

    public class SnapEdGrammarGraphEditorContextMenuData
    {
        public SnapEdGrammarGraphEditorContextMenuData(UISystem uiSystem, SnapEdGrammarGraphEditorAction action)
            : this(uiSystem, action, null)
        {
        }

        public SnapEdGrammarGraphEditorContextMenuData(UISystem uiSystem, SnapEdGrammarGraphEditorAction action, object userData)
        {
            this.uiSystem = uiSystem;
            this.Action = action;
            this.UserData = userData;
        }

        public UISystem uiSystem;
        public SnapEdGrammarGraphEditorAction Action;
        public object UserData;
    }

    public class SnapEdGrammarGraphSchema : GraphSchema
    {

        public override bool CanCreateLink(GraphPin output, GraphPin input, out string errorMessage)
        {
            errorMessage = "";
            if (output == null || input == null)
            {
                errorMessage = "Invalid connection";
                return false;
            }

            if (input.Node != null)
            {
                input = input.Node.InputPin;
            }

            var sourceNode = output.Node;
            var destNode = input.Node;

            // Make sure we don't already have this connection
            foreach (var link in output.GetConntectedLinks())
            {
                if (link.Input == input)
                {
                    errorMessage = "Not Allowed: Already connected";
                    return false;
                }
            }

            return true;
        }
    }

    public class SnapEdGrammarGraphEditor : GraphEditor
    {
        public SnapFlowAsset FlowAsset { get; private set; }

        public void SetBranding(string branding)
        {
            if (EditorStyle != null)
            {
                EditorStyle.branding = branding;
            }
        }

        public override void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            FlowAsset = assetObject as SnapFlowAsset;

            base.Init(graph, editorBounds, assetObject, uiSystem);
        }

        T GetDragData<T>() where T : Object
        {
            var dragDropData = DragAndDrop.GetGenericData(NodeListViewConstants.DragDropID);
            if (dragDropData != null && dragDropData is T)
            {
                return dragDropData as T;
            }
            return null;
        }

        public override GraphSchema GetGraphSchema()
        {
            return new SnapEdGrammarGraphSchema();
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            return new StraightLineGraphLinkRenderer();
        }

        public override void OnNodeSelectionChanged(UISystem uiSystem)
        {
            base.OnNodeSelectionChanged(uiSystem);

            // Fetch all selected nodes
            var selectedNodes = from node in graph.Nodes
                                where node.Selected
                                select node;

            if (selectedNodes.Count() == 0)
            {
                uiSystem.Platform.ShowObjectProperty(graph);
            }
        }

        public override T CreateLink<T>(Graph graph, GraphPin output, GraphPin input, UISystem uiSystem)
        {
            if (input != null && input.Node != null)
            {
                input = input.Node.InputPin;
            }

            // If we have a link in the opposite direction, then break that link
            var sourceNode = output.Node;
            var destNode = input.Node;
            if (sourceNode != null && destNode != null)
            {
                var links = destNode.OutputPin.GetConntectedLinks();
                foreach (var link in links)
                {
                    if (link.Output.Node == input.Node && link.Input.Node == output.Node)
                    {
                        GraphOperations.DestroyLink(link, uiSystem.Undo);
                    }
                }
            }

            if (input.Node != null)
            {
                input = input.Node.InputPin;
                if (input != null)
                {
                    return base.CreateLink<T>(graph, output, input, uiSystem);
                }
            }
            return null;
        }

        bool IsDragDataSupported()
        {
            // We are dragging. Check if we support this data type
            return GetDragData<GrammarNodeType>() != null;
        }
        
        public override void Draw(UISystem uiSystem, UIRenderer renderer)
        {
            base.Draw(uiSystem, renderer);
            if (IsPaintEvent(uiSystem))
            {
                var bounds = new Rect(Vector2.zero, WidgetBounds.size);

                bool isDragging = (uiSystem != null && uiSystem.IsDragDrop);
                if (isDragging && IsDragDataSupported())
                {
                    // Show the drag drop overlay
                    var dragOverlayColor = new Color(1, 0, 0, 0.25f);
                    renderer.DrawRect(bounds, dragOverlayColor);
                }
            }
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);

            switch (e.type)
            {
                case EventType.DragUpdated:
                    if (IsDragDataSupported())
                    {
                        HandleDragUpdate(e, uiSystem);
                    }
                    break;

                case EventType.DragPerform:
                    if (IsDragDataSupported())
                    {
                        HandleDragPerform(e, uiSystem);
                    }
                    break;
            }
        }

        private void HandleDragUpdate(Event e, UISystem uiSystem)
        {
            DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
        }

        private void HandleDragPerform(Event e, UISystem uiSystem)
        {
            // TODO: Create a node here
            var nodeType = GetDragData<GrammarNodeType>();
            if (nodeType != null)
            {
                if (uiSystem != null)
                {
                    uiSystem.RequestFocus(this);
                }

                CreateNewTaskNode(nodeType, e.mousePosition, true, uiSystem);
            }

            DragAndDrop.AcceptDrag();
        }

        int FindNextAvailableIndex()
        {
            if (graph.Nodes.Count == 0)
            {
                return 0;
            }

            // Find an appropriate execution index for this node
            var usedIndices = new HashSet<int>();
            foreach (var graphNode in graph.Nodes)
            {
                if (graphNode is GrammarTaskNode)
                {
                    var taskNode = graphNode as GrammarTaskNode;
                    usedIndices.Add(taskNode.executionIndex);
                }
            }

            for (int i = 0; i < usedIndices.Count + 1; i++)
            {
                if (!usedIndices.Contains(i))
                {
                    return i;
                }
            }
            return 0;
        }

        void CreateCommentNode(Vector2 screenPos, UISystem uiSystem)
        {
            var worldPos = camera.ScreenToWorld(screenPos);
            var commentNode = CreateNode<CommentNode>(worldPos, uiSystem);
            commentNode.Position = worldPos;
            commentNode.background = new Color(0.224f, 1.0f, 0.161f, 0.7f);
            BringToFront(commentNode);
            SelectNode(commentNode, uiSystem);
        }

        GrammarTaskNode CreateNewTaskNode(GrammarNodeType nodeType, Vector2 mousePosition, bool selectAfterCreate, UISystem uiSystem)
        {
            int index = FindNextAvailableIndex();
            var node = CreateNode<GrammarTaskNode>(mousePosition, uiSystem);
            node.NodeType = nodeType;
            node.executionIndex = index;
            node.DisplayExecutionIndex = true;

            // Adjust the initial position of the placed node
            {
                var nodeRenderer = nodeRenderers.GetRenderer(node.GetType());
                if (nodeRenderer is GrammarNodeRendererBase)
                {
                    var grammarNodeRenderer = nodeRenderer as GrammarNodeRendererBase;
                    grammarNodeRenderer.UpdateNodeBounds(node, 1.0f);
                }

                var mouseWorld = camera.ScreenToWorld(mousePosition);
                var bounds = node.Bounds;
                bounds.position = mouseWorld - bounds.size / 2.0f;
                node.Bounds = bounds;
            }

            if (selectAfterCreate)
            {
                BringToFront(node);
                SelectNode(node, uiSystem);
            }

            return node;
        }

        protected override GraphContextMenu CreateContextMenu()
        {
            return new SnapEdGrammarGraphContextMenu();
        }

        protected override void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers)
        {
            nodeRenderers.RegisterNodeRenderer(typeof(GrammarTaskNode), new GrammarTaskNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(CommentNode), new CommentNodeRenderer(EditorStyle.commentTextColor));
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {
            var data = userdata as SnapEdGrammarGraphEditorContextMenuData;
            if (data == null) return;

            var mouseScreen = lastMousePosition;
            if (data.Action == SnapEdGrammarGraphEditorAction.CreateTaskNode)
            {
                if (data.UserData != null && data.UserData is GrammarNodeType)
                {
                    var nodeType = data.UserData as GrammarNodeType;
                    var node = CreateNewTaskNode(nodeType, lastMousePosition, true, e.uiSystem);
                    CreateLinkBetweenPins(e.sourcePin, node.InputPin, e.uiSystem);
                }
            }
            else if (data.Action == SnapEdGrammarGraphEditorAction.CreateWildcard)
            {
                var nodeType = FlowAsset.wildcardNodeType;
                if (nodeType != null)
                {
                    var node = CreateNewTaskNode(nodeType, lastMousePosition, true, e.uiSystem);
                    CreateLinkBetweenPins(e.sourcePin, node.InputPin, e.uiSystem);
                }
            }
            else if (data.Action == SnapEdGrammarGraphEditorAction.CreateCommentNode)
            {
                CreateCommentNode(mouseScreen, e.uiSystem);
            }
        }

        protected override void DrawHUD(UISystem uiSystem, UIRenderer renderer, Rect bounds) { }

        protected override string GetGraphNotInitializedMessage()
        {
            return "Graph not initialize";
        }

        protected override GraphEditorStyle CreateEditorStyle()
        {
            var editorStyle = base.CreateEditorStyle();
            editorStyle.backgroundColor = new Color(0.2f, 0.2f, 0.2f);
            return editorStyle;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\SnapEdResultGraphContextMenu.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class SnapEdResultGraphContextMenu : GraphContextMenu
    {
        class ItemInfo
        {
            public ItemInfo(UISystem uiSystem, SnapEdResultGraphEditorAction action)
            {
                this.uiSystem = uiSystem;
                this.action = action;
            }

            public UISystem uiSystem;
            public SnapEdResultGraphEditorAction action;
        }
        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
            var menu = new GenericMenu();
            menu.AddItem(new GUIContent("Add Comment Node"), false, HandleContextMenu, new ItemInfo(uiSystem, SnapEdResultGraphEditorAction.CreateCommentNode));
            menu.ShowAsContext();
        }

        void HandleContextMenu(object userdata)
        {
            var item = userdata as ItemInfo;
            DispatchMenuItemEvent(item.action, BuildEvent(null, item.uiSystem));
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\SnapEdResultGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.Grammar;
using DungeonArchitect.RuntimeGraphs;
using DungeonArchitect.Graphs.Layouts;
using DungeonArchitect.Graphs.Layouts.Layered;
using DungeonArchitect.Graphs.Layouts.Spring;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors.SnapFlow
{
    public enum SnapEdResultGraphEditorAction
    {
        CreateTaskNode,
        CreateCommentNode
    }

    public class SnapEdResultGraphEditor : GraphEditor
    {
        [SerializeField]
        public SnapEdResultGraphEditorConfig ResultGraphPanelConfig { get; private set; }

        public override void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            base.Init(graph, editorBounds, assetObject, uiSystem);
            if (ResultGraphPanelConfig == null)
            {
                ResultGraphPanelConfig = CreateInstance<SnapEdResultGraphEditorConfig>();
            }
        }

        public override void OnEnable()
        {
            base.OnEnable();

            if (ResultGraphPanelConfig == null)
            {
                ResultGraphPanelConfig = CreateInstance<SnapEdResultGraphEditorConfig>();
            }
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            return new StraightLineGraphLinkRenderer();
        }

        protected override GraphContextMenu CreateContextMenu()
        {
            return new SnapEdResultGraphContextMenu();
        }

        protected override void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers)
        {
            nodeRenderers.RegisterNodeRenderer(typeof(GrammarTaskNode), new GrammarTaskNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(CommentNode), new CommentNodeRenderer(EditorStyle.commentTextColor));
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {
            var action = (SnapEdResultGraphEditorAction)userdata;

            var mouseScreen = lastMousePosition;
            if (action == SnapEdResultGraphEditorAction.CreateTaskNode)
            {
                //CreateSpatialNodeAtMouse<SCRuleNode>(mouseScreen);
            }
            else if (action == SnapEdResultGraphEditorAction.CreateCommentNode)
            {
                CreateCommentNode(mouseScreen, e.uiSystem);
            }
        }

        public override void OnNodeSelectionChanged(UISystem uiSystem)
        {
            base.OnNodeSelectionChanged(uiSystem);

            // Fetch all selected nodes
            var selectedNodes = from node in graph.Nodes
                                where node.Selected
                                select node;

            if (selectedNodes.Count() == 0)
            {
                uiSystem.Platform.ShowObjectProperty(ResultGraphPanelConfig);
            }
        }

        public class RuntimeGraphLayoutNodeActions : IGraphLayoutNodeActions<RuntimeGraphNode<GrammarRuntimeGraphNodeData>>
        {
            public void SetNodePosition(RuntimeGraphNode<GrammarRuntimeGraphNodeData> node, Vector2 position)
            {
                node.Position = position;
            }

            public Vector2 GetNodePosition(RuntimeGraphNode<GrammarRuntimeGraphNodeData> node)
            {
                return node.Position;
            }

            public RuntimeGraphNode<GrammarRuntimeGraphNodeData>[] GetOutgoingNodes(RuntimeGraphNode<GrammarRuntimeGraphNodeData> node)
            {
                return node.Outgoing.ToArray();
            }
        }

        private void PerformLayout(GrammarRuntimeGraph runtimeGraph)
        {
            var layout = CreateGraphLayoutInstance();
            if (layout != null)
            {
                layout.Layout(runtimeGraph.Nodes.ToArray(), new RuntimeGraphLayoutNodeActions());
            }
        }

        private IGraphLayout<RuntimeGraphNode<GrammarRuntimeGraphNodeData>> CreateGraphLayoutInstance()
        {
            IGraphLayout<RuntimeGraphNode<GrammarRuntimeGraphNodeData>> layout = null;
            if (ResultGraphPanelConfig != null)
            {
                if (ResultGraphPanelConfig.layoutType == GraphLayoutType.Layered)
                {
                    var config = ResultGraphPanelConfig.configLayered;
                    if (config == null)
                    {
                        config = new GraphLayoutLayeredConfig();
                    }

                    layout = new GraphLayoutLayered<RuntimeGraphNode<GrammarRuntimeGraphNodeData>>(config);
                }
                else if (ResultGraphPanelConfig.layoutType == GraphLayoutType.Spring)
                {
                    var config = ResultGraphPanelConfig.configSpring;
                    if (config == null)
                    {
                        config = new GraphLayoutSpringConfig();
                    }
                    layout = new GraphLayoutSpring<RuntimeGraphNode<GrammarRuntimeGraphNodeData>>(config);
                }
            }

            return layout;
        }

        public override T CreateLink<T>(Graph graph, GraphPin output, GraphPin input, UISystem uiSystem)
        {
            if (input != null && input.Node != null)
            {
                input = input.Node.InputPin;
            }

            // If we have a link in the opposite direction, then break that link
            var sourceNode = output.Node;
            var destNode = input.Node;
            if (sourceNode != null && destNode != null)
            {
                var links = destNode.OutputPin.GetConntectedLinks();
                foreach (var link in links)
                {
                    if (link.Output.Node == input.Node && link.Input.Node == output.Node)
                    {
                        GraphOperations.DestroyLink(link, uiSystem.Undo);
                    }
                }
            }

            if (input.Node != null)
            {
                input = input.Node.InputPin;
                if (input != null)
                {
                    return base.CreateLink<T>(graph, output, input, uiSystem);
                }
            }
            return null;
        }

        public override GraphSchema GetGraphSchema()
        {
            return new SnapEdGrammarGraphSchema();
        }

        void CreateCommentNode(Vector2 screenPos, UISystem uiSystem)
        {
            var worldPos = camera.ScreenToWorld(screenPos);
            var commentNode = CreateNode<CommentNode>(worldPos, uiSystem);
            commentNode.Position = worldPos;
            commentNode.background = new Color(0.224f, 1.0f, 0.161f, 0.7f);
            BringToFront(commentNode);
            SelectNode(commentNode, uiSystem);
        }

        protected override string GetGraphNotInitializedMessage()
        {
            return "Graph not initialize";
        }

        protected override GraphEditorStyle CreateEditorStyle()
        {
            var editorStyle = base.CreateEditorStyle();
            editorStyle.branding = "Result Graph";
            editorStyle.backgroundColor = new Color(0.15f, 0.2f, 0.15f);
            return editorStyle;
        }

        void ClearActiveGraph(UISystem uiSystem)
        {
            // Clear the existing graphs
            DeleteNodes(graph.Nodes.ToArray(), uiSystem);
            graph.Nodes.Clear();
            graph.Links.Clear();

        }
        public void RefreshGraph(Graph graph, GrammarRuntimeGraph runtimeGraph, UISystem uiSystem)
        {
            SetGraph(graph);

            PerformLayout(runtimeGraph);

            ClearActiveGraph(uiSystem);

            var map = new Dictionary<RuntimeGraphNode<GrammarRuntimeGraphNodeData>, GraphNode>();
            // Add nodes
            foreach (var runtimeNode in runtimeGraph.Nodes)
            {
                var screenCoord = camera.WorldToScreen(runtimeNode.Position);
                var graphNode = CreateNode<GrammarTaskNode>(screenCoord, uiSystem);
                graphNode.NodeType = runtimeNode.Payload.nodeType;
                graphNode.DisplayExecutionIndex = false;

                map.Add(runtimeNode, graphNode);
            }

            // Add links
            {
                foreach (var runtimeNode in runtimeGraph.Nodes)
                {
                    foreach (var outgoingRuntimeNode in runtimeNode.Outgoing)
                    {
                        GraphNode srcGraphNode = map.ContainsKey(runtimeNode) ? map[runtimeNode] : null;
                        GraphNode dstGraphNode = map.ContainsKey(outgoingRuntimeNode) ? map[outgoingRuntimeNode] : null;
                        if (srcGraphNode == null || dstGraphNode == null || srcGraphNode.OutputPin == null || dstGraphNode.InputPin == null)
                        {
                            Debug.LogWarning("Cannot create link in result graph due to invalid node state");
                            continue;
                        }
                        CreateLinkBetweenPins(srcGraphNode.OutputPin, dstGraphNode.InputPin, uiSystem);
                    }
                }
            }

            FocusCameraOnBestFit();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\SnapEdResultGraphEditorConfig.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs.Layouts;
using DungeonArchitect.Graphs.Layouts.Layered;
using DungeonArchitect.Graphs.Layouts.Spring;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class SnapEdResultGraphEditorConfig : ScriptableObject
    {
        public GraphLayoutType layoutType;
        public GraphLayoutLayeredConfig configLayered;
        public GraphLayoutSpringConfig configSpring;

        private void OnEnable()
        {
            if (configLayered == null)
            {
                configLayered = new GraphLayoutLayeredConfig();
            }
            if (configSpring == null)
            {
                configSpring = new GraphLayoutSpringConfig();
            }
        }

        public void SaveState(KeyValueData editorData)
        {
            editorData.Set("layoutType", (int)layoutType);

            if (configLayered != null)
            {
                editorData.Set("layered.separation", configLayered.separation);
            }

            if (configSpring != null)
            {
                editorData.Set("spring.interNodeDistance", configSpring.interNodeDistance);
                editorData.Set("spring.interNodeTension", configSpring.interNodeTension);
                editorData.Set("spring.springDistance", configSpring.springDistance);
                editorData.Set("spring.springTension", configSpring.springTension);
                editorData.Set("spring.iterations", configSpring.iterations);
                editorData.Set("spring.timeStep", configSpring.timeStep);
            }
        }

        public void LoadState(KeyValueData editorData)
        {
            int layoutTypeValue = 0;
            if (editorData.GetInt("layoutType", ref layoutTypeValue))
            {
                layoutType = (GraphLayoutType)layoutTypeValue;
            }

            if (configLayered == null)
            {
                configLayered = new GraphLayoutLayeredConfig();
            }

            editorData.GetVector2("layered.separation", ref configLayered.separation);

            if (configSpring == null)
            {
                configSpring = new GraphLayoutSpringConfig();
            }

            editorData.GetFloat("spring.interNodeDistance", ref configSpring.interNodeDistance);
            editorData.GetFloat("spring.interNodeTension", ref configSpring.interNodeTension);
            editorData.GetFloat("spring.springDistance", ref configSpring.springDistance);
            editorData.GetFloat("spring.springTension", ref configSpring.springTension);
            editorData.GetInt("spring.iterations", ref configSpring.iterations);
            editorData.GetFloat("spring.timeStep", ref configSpring.timeStep);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\Panels\ErrorListPanel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    public enum DungeonFlowErrorType
    {
        Error,
        Warning,
        Info,
        Success
    }


    public class DungeonFlowErrorEntry
    {
        public string Message = "";
        public DungeonFlowErrorType ErrorType = DungeonFlowErrorType.Info;
        public ISnapEdValidatorAction Action;

        public DungeonFlowErrorEntry() { }
        public DungeonFlowErrorEntry(string message)
        {
            this.Message = message;
        }

        public DungeonFlowErrorEntry(string message, DungeonFlowErrorType errorType)
        {
            this.Message = message;
            this.ErrorType = errorType;
        }

        public DungeonFlowErrorEntry(string message, DungeonFlowErrorType errorType, ISnapEdValidatorAction action)
        {
            this.Message = message;
            this.ErrorType = errorType;
            this.Action = action;
        }
    }

    public class DungeonFlowErrorList
    {
        public List<DungeonFlowErrorEntry> Errors = new List<DungeonFlowErrorEntry>();
    }

    public class ErrorListViewSource : ListViewSource<DungeonFlowErrorEntry>
    {
        DungeonFlowErrorList errorList;
        public ErrorListViewSource(DungeonFlowErrorList errorList)
        {
            this.errorList = errorList;
        }

        public override DungeonFlowErrorEntry[] GetItems()
        {
            return (errorList != null && errorList.Errors != null) 
                ? errorList.Errors.ToArray() : null;
        }

        public override IWidget CreateWidget(DungeonFlowErrorEntry item)
        {
            var itemWidget = new ErrorListViewItem(item);

            return itemWidget;
        }
    }

    public class ErrorListViewItem : ListViewTextItemWidget
    {
        public ErrorListViewItem(DungeonFlowErrorEntry entry)
            : base(entry, () => entry.Message)
        {
            OffsetX = 2;

            int fontSize = 14;

            TextStyle.fontSize = fontSize;
            SelectedTextStyle.normal.textColor = Color.blue;

            SelectedTextStyle.fontSize = fontSize;
            SelectedTextStyle.normal.textColor = Color.black;

            SelectedColor = ErrorListPanel.ThemeColor * 2.0f;
        }

        Texture GetTexture(UIRenderer renderer)
        {
            var entry = ItemData as DungeonFlowErrorEntry;
            if (entry != null)
            {
                switch(entry.ErrorType)
                {
                    case DungeonFlowErrorType.Error:
                        return renderer.GetResource<Texture>(UIResourceLookup.ICON_ERROR_16x) as Texture;

                    case DungeonFlowErrorType.Warning:
                        return renderer.GetResource<Texture>(UIResourceLookup.ICON_WARNING_16x) as Texture;

                    case DungeonFlowErrorType.Info:
                        return renderer.GetResource<Texture>(UIResourceLookup.ICON_INFO_16x) as Texture;

                    case DungeonFlowErrorType.Success:
                        return renderer.GetResource<Texture>(UIResourceLookup.ICON_SUCCESS_16x) as Texture;
                }
            }
            return renderer.GetResource<Texture>(UIResourceLookup.ICON_INFO_16x) as Texture;
        }

        public override void DrawText(UIRenderer renderer, Rect bounds)
        {
            var iconOffset = new Vector2(1, 1) * (bounds.height - 16) * 0.5f;
            var iconBounds = new Rect(iconOffset, new Vector2(16, 16));
            renderer.DrawTexture(iconBounds, GetTexture(renderer));

            var style = Selected ? SelectedTextStyle : TextStyle;
            float x = OffsetX + bounds.height;
            float y = (bounds.height - style.lineHeight) / 2.0f - 1;
            string message = GetCaption();
            var content = new GUIContent(message, message);
            var textSize = style.CalcSize(content);
            var textBounds = new Rect(new Vector2(x, y), textSize);
            renderer.Label(textBounds, content, style);
        }
    }

    public class ErrorListPanel : WidgetBase
    {
        IWidget host;
        public DungeonFlowErrorList errorList { get; private set; }

        public static readonly Color ThemeColor = new Color(0.3f, 0.2f, 0.2f);
        public ListViewWidget<DungeonFlowErrorEntry> ListView;

        public ErrorListPanel(DungeonFlowErrorList errorList)
        {
            this.errorList = errorList;

            ListView = new ListViewWidget<DungeonFlowErrorEntry>();
            ListView.Bind(new ErrorListViewSource(errorList));
            ListView.ItemHeight = 20;

            host = new BorderWidget()
                   .SetTitle("Error List")
                   .SetColor(ThemeColor)
                   .SetContent(ListView)
                    ;

        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            host.Draw(uiSystem, renderer);
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (host != null)
            {
                var childBounds = new Rect(Vector2.zero, bounds.size);
                host.UpdateWidget(uiSystem, childBounds);
            }
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            host.HandleInput(e, uiSystem);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { host };
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\Panels\NodeListPanel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.Grammar;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors.SnapFlow
{
    class NodeListViewConstants
    {
        public static readonly string DragDropID = "NodeTypeDragOp";
        public static readonly Color ThemeColor = new Color(0.2f, 0.3f, 0.3f);
    }

    public class NodeListViewItem : ListViewTextItemWidget
    {
        HighlightWidget highlight;

        public NodeListViewItem(GrammarNodeType nodeType)
            : base(nodeType, () => nodeType.nodeName)
        {
            DragDropEnabled = true;
            DragStart += NodeListViewItem_DragStart;

            highlight = new HighlightWidget()
                .SetContent(new NullWidget())
                .SetObjectOfInterest(nodeType);
        }

        private void NodeListViewItem_DragStart(Event e, UISystem uiSystem)
        {
            DragAndDrop.SetGenericData(NodeListViewConstants.DragDropID, ItemData);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            var children = new List<IWidget>();
            {
                IWidget[] baseChildren = base.GetChildWidgets();
                if (baseChildren != null)
                {
                    children.AddRange(baseChildren);
                }
            }
            children.Add(highlight);
            return children.ToArray();
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            base.DrawImpl(uiSystem, renderer);

            highlight.Draw(uiSystem, renderer);
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            highlight.UpdateWidget(uiSystem, bounds);
        }
    }

    public class NodeListViewSource : ListViewSource<GrammarNodeType>
    {
        SnapFlowAsset flowAsset;
        public NodeListViewSource(SnapFlowAsset flowAsset)
        {
            this.flowAsset = flowAsset;
        }
        public override GrammarNodeType[] GetItems()
        {
            return flowAsset != null ? flowAsset.nodeTypes : null;
        }

        public override IWidget CreateWidget(GrammarNodeType item)
        {
            var itemWidget = new NodeListViewItem(item);
            itemWidget.TextStyle.fontSize = 16;

            itemWidget.SelectedTextStyle = new GUIStyle(itemWidget.TextStyle);
            itemWidget.SelectedTextStyle.normal.textColor = Color.black;
            itemWidget.SelectedColor = NodeListViewConstants.ThemeColor * 2.0f;

            return itemWidget;
        }
    }

    public class NodeListPanel : WidgetBase
    {
        SnapFlowAsset flowAsset;

        IWidget host;

        public ListViewWidget<GrammarNodeType> ListView;
        ToolbarWidget toolbar;


        readonly static string BTN_ADD_ITEM = "AddItem";
        readonly static string BTN_REMOVE_ITEM = "RemoveItem";
        readonly static string BTN_MOVE_UP = "MoveUp";
        readonly static string BTN_MOVE_DOWN= "MoveDown";

        public NodeListPanel(SnapFlowAsset flowAsset)
        {
            this.flowAsset = flowAsset;

            toolbar = new ToolbarWidget();
            toolbar.ButtonSize = 24;
            toolbar.Padding = 4;
            toolbar.Background = new Color(0, 0, 0, 0);
            toolbar.AddButton(BTN_ADD_ITEM, UIResourceLookup.ICON_PLUS_16x);
            toolbar.AddButton(BTN_REMOVE_ITEM, UIResourceLookup.ICON_CLOSE_16x);
            toolbar.AddButton(BTN_MOVE_UP, UIResourceLookup.ICON_MOVEUP_16x);
            toolbar.AddButton(BTN_MOVE_DOWN, UIResourceLookup.ICON_MOVEDOWN_16x);
            toolbar.ButtonPressed += Toolbar_ButtonPressed;
            var toolbarSize = new Vector2(toolbar.Padding * 2 + toolbar.ButtonSize * 4, toolbar.Padding * 2 + toolbar.ButtonSize);

            ListView = new ListViewWidget<GrammarNodeType>();
            ListView.ItemHeight = 45;
            ListView.Bind(new NodeListViewSource(flowAsset));

            IWidget toolWidget = new StackPanelWidget(StackPanelOrientation.Horizontal)
                                .AddWidget(new NullWidget())
                                .AddWidget(toolbar, toolbarSize.x);

            toolWidget = new BorderWidget(toolWidget)
                .SetPadding(0, 0, 0, 0)
                .SetDrawOutline(false)
                .SetColor(new Color(0, 0, 0, 0.25f));

            var border = new BorderWidget()
                   .SetTitle("Node List")
                   .SetColor(NodeListViewConstants.ThemeColor)
                   .SetContent(
                        new StackPanelWidget(StackPanelOrientation.Vertical)
                        .AddWidget(toolWidget, toolbarSize.y)
                        .AddWidget(new HighlightWidget()
                            .SetContent(ListView)
                            .SetObjectOfInterest(DungeonFlowEditorHighlightID.NodePanel)
                        )
                    );

            host = border;
        }

        private void Toolbar_ButtonPressed(UISystem uiSystem, string id)
        {
            if (flowAsset == null)
            {
                return;
            }

            if (id == BTN_ADD_ITEM)
            {
                var nodeType = SnapEditorUtils.AddNodeType(flowAsset, "Task");
                ListView.NotifyDataChanged();

                int index = System.Array.FindIndex(flowAsset.nodeTypes, t => t == nodeType);
                ListView.SetSelectedIndex(index);
            }
            else if (id == BTN_REMOVE_ITEM)
            {
                var nodeType = ListView.GetSelectedItem();
                if (nodeType != null)
                {
                    string message = string.Format("Are you sure you want to delete the node type \'{0}\'?", nodeType.nodeName);
                    bool removeItem = EditorUtility.DisplayDialog("Delete Node Type?", message, "Delete", "Cancel");
                    if (removeItem)
                    {
                        int index = System.Array.FindIndex(flowAsset.nodeTypes, t => t == nodeType);
                        SnapEditorUtils.RemoveNodeType(flowAsset, nodeType);
                        ListView.NotifyDataChanged();

                        if (index >= flowAsset.nodeTypes.Length)
                        {
                            index = flowAsset.nodeTypes.Length - 1;
                        }
                        ListView.SetSelectedIndex(index);
                    }
                }
            }
            else if (id == BTN_MOVE_UP)
            {
                var nodeType = ListView.GetSelectedItem();
                var list = new List<GrammarNodeType>(flowAsset.nodeTypes);
                int index = list.IndexOf(nodeType);
                if (index > 0)
                {
                    list.RemoveAt(index);
                    index--;
                    list.Insert(index, nodeType);
                    flowAsset.nodeTypes = list.ToArray();

                    ListView.NotifyDataChanged();
                    ListView.SetSelectedIndex(index);
                }
            }
            else if (id == BTN_MOVE_DOWN)
            {
                var nodeType = ListView.GetSelectedItem();
                var list = new List<GrammarNodeType>(flowAsset.nodeTypes);
                int index = list.IndexOf(nodeType);
                if (index + 1 < list.Count)
                {
                    list.RemoveAt(index);
                    index++;
                    list.Insert(index, nodeType);
                    flowAsset.nodeTypes = list.ToArray();

                    ListView.NotifyDataChanged();
                    ListView.SetSelectedIndex(index);
                }
            }

        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (host != null)
            {
                var childBounds = new Rect(Vector2.zero, bounds.size);
                host.UpdateWidget(uiSystem, childBounds);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            host.Draw(uiSystem, renderer);
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            host.HandleInput(e, uiSystem);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { host };
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\Panels\RuleListPanel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.Grammar;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;


namespace DungeonArchitect.Editors.SnapFlow
{
    class RuleListViewConstants
    {
        public static readonly string DragDropID = "RuleDragOp";
        public static readonly Color ThemeColor = new Color(0.3f, 0.3f, 0.2f);
    }

    public class RuleListViewItem : ListViewTextItemWidget
    {
        HighlightWidget highlight;

        public RuleListViewItem(GrammarProductionRule rule)
            : base(rule, () => rule.ruleName)
        {
            DragDropEnabled = true;
            DragStart += RuleListViewItem_DragStart;

            highlight = new HighlightWidget()
                .SetContent(new NullWidget())
                .SetObjectOfInterest(rule);
        }

        private void RuleListViewItem_DragStart(Event e, UISystem uiSystem)
        {
            DragAndDrop.SetGenericData(RuleListViewConstants.DragDropID, ItemData);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            var children = new List<IWidget>();
            {
                IWidget[] baseChildren = base.GetChildWidgets();
                if (baseChildren != null)
                {
                    children.AddRange(baseChildren);
                }
            }
            children.Add(highlight);
            return children.ToArray();
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            base.DrawImpl(uiSystem, renderer);

            if (IsPaintEvent(uiSystem))
            {
                highlight.Draw(uiSystem, renderer);
            }
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            highlight.UpdateWidget(uiSystem, bounds);
        }
    }

    public class RuleListViewSource : ListViewSource<GrammarProductionRule>
    {
        SnapFlowAsset flowAsset;
        public RuleListViewSource(SnapFlowAsset flowAsset)
        {
            this.flowAsset = flowAsset;
        }
        public override GrammarProductionRule[] GetItems()
        {
            return flowAsset != null ? flowAsset.productionRules : null;
        }

        public override IWidget CreateWidget(GrammarProductionRule item)
        {
            var itemWidget = new RuleListViewItem(item);
            itemWidget.TextStyle.fontSize = 16;

            itemWidget.SelectedTextStyle = new GUIStyle(itemWidget.TextStyle);
            itemWidget.SelectedTextStyle.normal.textColor = Color.black;
            itemWidget.SelectedColor = RuleListViewConstants.ThemeColor * 2;

            return itemWidget;
        }
    }

    public class RuleListPanel : WidgetBase
    {
        SnapFlowAsset flowAsset;

        IWidget host;

        public ListViewWidget<GrammarProductionRule> ListView;
        ToolbarWidget toolbar;


        readonly static string BTN_ADD_ITEM = "AddItem";
        readonly static string BTN_REMOVE_ITEM = "RemoveItem";
        readonly static string BTN_MOVE_UP = "MoveUp";
        readonly static string BTN_MOVE_DOWN = "MoveDown";

        public RuleListPanel(SnapFlowAsset flowAsset)
        {
            this.flowAsset = flowAsset;

            toolbar = new ToolbarWidget();
            toolbar.ButtonSize = 24;
            toolbar.Padding = 4;
            toolbar.Background = new Color(0, 0, 0, 0);
            toolbar.AddButton(BTN_ADD_ITEM, UIResourceLookup.ICON_PLUS_16x);
            toolbar.AddButton(BTN_REMOVE_ITEM, UIResourceLookup.ICON_CLOSE_16x);
            toolbar.AddButton(BTN_MOVE_UP, UIResourceLookup.ICON_MOVEUP_16x);
            toolbar.AddButton(BTN_MOVE_DOWN, UIResourceLookup.ICON_MOVEDOWN_16x);
            toolbar.ButtonPressed += Toolbar_ButtonPressed;
            var toolbarSize = new Vector2(toolbar.Padding * 2 + toolbar.ButtonSize * 4, toolbar.Padding * 2 + toolbar.ButtonSize);

            ListView = new ListViewWidget<GrammarProductionRule>();
            ListView.ItemHeight = 45;
            ListView.Bind(new RuleListViewSource(flowAsset));

            IWidget toolWidget = new StackPanelWidget(StackPanelOrientation.Horizontal)
                                .AddWidget(new NullWidget())
                                .AddWidget(toolbar, toolbarSize.x);

            toolWidget = new BorderWidget(toolWidget)
                .SetPadding(0, 0, 0, 0)
                .SetDrawOutline(false)
                .SetColor(new Color(0, 0, 0, 0.25f));

            host = new BorderWidget()
                   .SetTitle("Rule List")
                   .SetColor(RuleListViewConstants.ThemeColor)
                   .SetContent(
                        new StackPanelWidget(StackPanelOrientation.Vertical)
                        .AddWidget(toolWidget, toolbarSize.y)
                        .AddWidget(new HighlightWidget()
                            .SetContent(ListView)
                            .SetObjectOfInterest(DungeonFlowEditorHighlightID.RulePanel)
                        )
                    );
        }


        private void Toolbar_ButtonPressed(UISystem uiSystem, string id)
        {
            if (flowAsset == null)
            {
                return;
            }

            if (id == BTN_ADD_ITEM)
            {
                var rule = SnapEditorUtils.AddProductionRule(flowAsset, "Rule");
                int index = System.Array.FindIndex(flowAsset.productionRules, r => r == rule);
                ListView.NotifyDataChanged();
                ListView.SetSelectedIndex(index);
            }
            else if (id == BTN_REMOVE_ITEM)
            {
                var rule = ListView.GetSelectedItem();
                if (rule != null)
                {
                    string message = string.Format("Are you sure you want to delete the rule \'{0}\'?", rule.ruleName);
                    bool removeItem = EditorUtility.DisplayDialog("Delete Rule?", message, "Delete", "Cancel");
                    if (removeItem)
                    {
                        int index = System.Array.FindIndex(flowAsset.productionRules, r => r == rule);
                        SnapEditorUtils.RemoveProductionRule(flowAsset, rule);
                        ListView.NotifyDataChanged();

                        if (index >= flowAsset.productionRules.Length)
                        {
                            index = flowAsset.productionRules.Length - 1;
                        }
                        ListView.SetSelectedIndex(index);
                    }
                }
            }
            else if (id == BTN_MOVE_UP)
            {
                var nodeType = ListView.GetSelectedItem();
                var list = new List<GrammarProductionRule>(flowAsset.productionRules);
                int index = list.IndexOf(nodeType);
                if (index > 0)
                {
                    list.RemoveAt(index);
                    index--;
                    list.Insert(index, nodeType);
                    flowAsset.productionRules = list.ToArray();

                    ListView.NotifyDataChanged();
                    ListView.SetSelectedIndex(index);
                }
            }
            else if (id == BTN_MOVE_DOWN)
            {
                var rule = ListView.GetSelectedItem();
                var list = new List<GrammarProductionRule>(flowAsset.productionRules);
                int index = list.IndexOf(rule);
                if (index + 1 < list.Count)
                {
                    list.RemoveAt(index);
                    index++;
                    list.Insert(index, rule);
                    flowAsset.productionRules = list.ToArray();

                    ListView.NotifyDataChanged();
                    ListView.SetSelectedIndex(index);
                }
            }
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (host != null)
            {
                var childBounds = new Rect(Vector2.zero, bounds.size);
                host.UpdateWidget(uiSystem, childBounds);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            host.Draw(uiSystem, renderer);
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            host.HandleInput(e, uiSystem);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { host };
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\ProductionRule\ProductionRuleGraphTitleWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class ProductionRuleRHSTitleWidget : WidgetBase
    {
        public delegate void OnDeletePressed(ProductionRuleWidgetRHSState state);
        public event OnDeletePressed DeletePressed;

        public ProductionRuleWidgetRHSState State;

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            Vector2 titleOffset = new Vector2(5, 4);

            var titleStyle = new GUIStyle(EditorStyles.whiteLabel);
            titleStyle.normal.textColor = new Color(0.75f, 0.75f, 0.75f);

            var titleBounds = WidgetBounds;
            titleBounds.position += titleOffset;
            titleBounds.size -= titleOffset * 2;

            renderer.BeginGroup(titleBounds);

            float PX_BUTTON_SIZE = 18;
            float PX_BUTTON_PADDING = 10;
            float PX_PADDING = 5;
            float PX_WEIGHT_INPUT = 40;
            float PX_HEIGHT = 16;

            float x = titleBounds.width;
            x -= PX_BUTTON_SIZE;

            var guiState = new GUIState(renderer);
            renderer.backgroundColor = new Color(0.8f, 0.1f, 0.1f, 1.0f);
            bool deletePressed = false;
            if (renderer.Button(new Rect(x, 0, PX_BUTTON_SIZE, PX_BUTTON_SIZE), "X"))
            {
                deletePressed = true;
            }
            guiState.Restore();

            var WeightGraph = State.WeightedGraph;

            x -= PX_BUTTON_PADDING;
            x -= PX_WEIGHT_INPUT;

            string Weight = (WeightGraph != null) ? WeightGraph.weight.ToString() : "";
            guiState.Save();
            renderer.backgroundColor = new Color(0.6f, 0.6f, 0.6f);
            if (renderer.Button(new Rect(x, 1, PX_WEIGHT_INPUT, PX_HEIGHT), Weight, EditorStyles.miniButton))
            {
                Selection.activeObject = WeightGraph;
            }
            guiState.Restore();

            x -= PX_PADDING;

            //if (IsPaintEvent(uiSystem))
            {
                var weightCaption = new GUIContent("Weight:");
                float PX_WEIGHT_LABEL = titleStyle.CalcSize(weightCaption).x;

                x -= PX_WEIGHT_LABEL;
                renderer.Label(new Rect(x, 1, PX_WEIGHT_LABEL, PX_HEIGHT), weightCaption, titleStyle);

                float remainingWidth = x;
                if (x > 0)
                {
                    renderer.Label(new Rect(0, 0, remainingWidth, PX_HEIGHT), "RHS Graph", titleStyle);
                }
            }

            renderer.EndGroup();

            if (deletePressed)
            {
                if (DeletePressed != null)
                {
                    DeletePressed.Invoke(State);
                }
            }
        }
    }

    public class ProductionRuleLHSTitleWidget : WidgetBase
    {
        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (IsPaintEvent(uiSystem))
            {
                Vector2 titleOffset = new Vector2(5, 5);

                var titleStyle = new GUIStyle(EditorStyles.whiteLabel);
                titleStyle.normal.textColor = new Color(0.75f, 0.75f, 0.75f);

                var titleBounds = WidgetBounds;
                titleBounds.position += titleOffset;

                renderer.Label(titleBounds, "LHS Graph", titleStyle);
            }
        }

    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\ProductionRule\ProductionRuleWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI.Widgets;
using DungeonArchitect.Grammar;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class ProductionRuleWidgetRHSState
    {
        public GraphPanel<SnapEdGrammarGraphEditor> GraphPanel;
        public WeightedGrammarGraph WeightedGraph;
        public ProductionRuleRHSTitleWidget WidgetTitle;
    }

    public class ProductionRuleWidget : WidgetBase
    {
        SnapFlowAsset flowAsset;
        GrammarProductionRule productionRule;
        GraphPanel<SnapEdGrammarGraphEditor> LHSGraphPanel;
        List<ProductionRuleWidgetRHSState> RHSEditorStates = new List<ProductionRuleWidgetRHSState>();
        Splitter splitter;
        IWidget layout;
        bool layoutDirty = false;

        public void Init(SnapFlowAsset flowAsset, GrammarProductionRule productionRule, UISystem uiSystem)
        {
            this.flowAsset = flowAsset;
            this.productionRule = productionRule;

            if (productionRule != null)
            {
                var LHSGraph = productionRule ? productionRule.LHSGraph : null;
                LHSGraphPanel = new GraphPanel<SnapEdGrammarGraphEditor>(LHSGraph, flowAsset, uiSystem);
                LHSGraphPanel.GraphEditor.SetBranding("LHS");
                LHSGraphPanel.Border.SetTitleWidget(new ProductionRuleLHSTitleWidget());
                LHSGraphPanel.Border.SetColor(new Color(0.3f, 0.3f, 0.3f));

                RHSEditorStates = new List<ProductionRuleWidgetRHSState>();
                foreach (var RHSGraph in productionRule.RHSGraphs)
                {
                    AddRHSState(RHSGraph, uiSystem);
                }
            }

            BuildLayout();
        }

        public GraphEditor[] GetGraphEditors()
        {
            var graphEditors = new List<GraphEditor>();
            graphEditors.Add(LHSGraphPanel.GraphEditor);
            foreach (var rhsState in RHSEditorStates)
            {
                graphEditors.Add(rhsState.GraphPanel.GraphEditor);
            }
            return graphEditors.ToArray();
        }

        void BuildLayout()
        {
            float GRAPH_HEIGHT = 300;

            splitter = new Splitter(SplitterDirection.Vertical);
            splitter.SetFreeSize(true);
            splitter.SplitBarDragged += Splitter_SplitBarDragged;

            float panelHeight = GRAPH_HEIGHT;
            GetGraphPanelEditorSize(LHSGraphPanel, ref panelHeight);

            splitter.AddWidget(
                    new BorderWidget(LHSGraphPanel)
                    .SetPadding(0, 0, 0, 0)
                    .SetBorderColor(new Color(0, 0, 0, 0))
                    .SetColor(new Color(0, 0, 0, 0)),
                panelHeight);

            foreach (var rhsEditorState in RHSEditorStates)
            {
                panelHeight = GRAPH_HEIGHT;
                GetGraphPanelEditorSize(rhsEditorState.GraphPanel, ref panelHeight);
                splitter.AddWidget(
                    new BorderWidget(rhsEditorState.GraphPanel)
                    .SetPadding(0, 0, 0, 0)
                    .SetBorderColor(new Color(0, 0, 0, 0))
                    .SetColor(new Color(0, 0, 0, 0)),
                panelHeight);
            }

            var addRhsButton = new ButtonWidget(new GUIContent("Add RHS"))
                    .SetColor(new Color(0.8f, 0.8f, 0.8f));
            addRhsButton.ButtonPressed += AddRhsButton_ButtonPressed;

            splitter.AddWidget(new HighlightWidget()
                .SetContent(addRhsButton)
                .SetObjectOfInterest(DungeonFlowEditorHighlightID.ProductionAddRHSButton)
            , 30);

            var splitterHost = new ScrollPanelWidget(splitter, false);

            var layoutContent = new BorderWidget(splitterHost)
                .SetPadding(0, 0, 0, 0)
                .SetDrawOutline(false)
                .SetColor(new Color(0.2f, 0.2f, 0.2f));

            layout = new BorderWidget(layoutContent)
                .SetTitleGetter(GetProductionTitle)
                .SetColor(new Color(0.2f, 0.1f, 0.3f, 1))
                .SetDrawOutline(true)
                ;

        }

        GrammarGraph GetWidgetGraph(IWidget widget)
        {
            var graphPanels = WidgetUtils.GetWidgetsOfType<GraphPanel<SnapEdGrammarGraphEditor>>(widget);
            if (graphPanels.Count > 0)
            {
                var graphPanel = graphPanels[0];
                if (graphPanel != null && graphPanel.GraphEditor != null)
                {
                    var graph = graphPanel.GraphEditor.Graph as GrammarGraph;
                    return graph;
                }
            }
            return null;
        }

        void SetGraphPanelEditorSize(IWidget widget, float size)
        {
            var graph = GetWidgetGraph(widget);
            if (graph != null && graph.editorData != null)
            {
                graph.editorData.Set("panelSize", size);
                EditorUtility.SetDirty(graph);
            }
        }

        bool GetGraphPanelEditorSize(IWidget widget, ref float size)
        {
            var graph = GetWidgetGraph(widget);
            if (graph != null && graph.editorData != null)
            {
                return graph.editorData.GetFloat("panelSize", ref size);
            }
            return false;
        }

        private void Splitter_SplitBarDragged(SplitterNode prev, SplitterNode next)
        {
            if (prev != null)
            {
                SetGraphPanelEditorSize(prev.Content, prev.Weight);
            }
            if (next != null)
            {
                SetGraphPanelEditorSize(next.Content, next.Weight);
            }

        }

        string GetProductionTitle()
        {
            if (productionRule != null)
            {
                return "Production Rule: " + productionRule.ruleName;
            }
            else
            {
                return "Production Rule";
            }
        }

        private void AddRhsButton_ButtonPressed(UISystem uiSystem)
        {
            AddNewRHSState(uiSystem);
            layoutDirty = true;
        }

        ProductionRuleWidgetRHSState AddNewRHSState(UISystem uiSystem)
        {
            WeightedGrammarGraph RHSGraph = SnapEditorUtils.AddProductionRuleRHS(flowAsset, productionRule);
            return AddRHSState(RHSGraph, uiSystem);
        }

        ProductionRuleWidgetRHSState AddRHSState(WeightedGrammarGraph RHSGraph, UISystem uiSystem)
        {
            if (RHSGraph == null)
            {
                return null;
            }
            var state = new ProductionRuleWidgetRHSState();

            var rhsTitle = new ProductionRuleRHSTitleWidget();
            rhsTitle.State = state;
            rhsTitle.DeletePressed += RhsTitle_DeletePressed;

            var RHSGraphPanel = new GraphPanel<SnapEdGrammarGraphEditor>(RHSGraph.graph, flowAsset, uiSystem);
            RHSGraphPanel.GraphEditor.SetBranding("RHS");
            RHSGraphPanel.Border.SetTitleWidget(rhsTitle);
            RHSGraphPanel.Border.SetColor(new Color(0.3f, 0.3f, 0.3f));

            state.GraphPanel = RHSGraphPanel;
            state.WeightedGraph = RHSGraph;
            state.WidgetTitle = rhsTitle;

            RHSEditorStates.Add(state);

            return state;
        }

        private void RhsTitle_DeletePressed(ProductionRuleWidgetRHSState state)
        {
            string message = "Are you sure you want to delete this RHS graph?";
            bool removeItem = EditorUtility.DisplayDialog("Delete RHS Graph?", message, "Delete", "Cancel");
            if (removeItem)
            {
                RemoveRHSState(state);
                layoutDirty = true;
            }
        }

        void RemoveRHSState(ProductionRuleWidgetRHSState state)
        {
            RHSEditorStates.Remove(state);
            state.GraphPanel.GraphEditor.OnDestroy();

            SnapEditorUtils.RemoveProductionRuleRHS(productionRule, state.WeightedGraph);
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (productionRule == null)
            {
                return;
            }

            if (RHSEditorStates == null)
            {
                RHSEditorStates = new List<ProductionRuleWidgetRHSState>();
            }

            if (layoutDirty)
            {
                BuildLayout();
                layoutDirty = false;
            }

            layout.UpdateWidget(uiSystem, bounds);
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (flowAsset == null || productionRule == null)
            {
                return;
            }

            layout.Draw(uiSystem, renderer);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { layout };
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\IThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.BSP;
using DungeonArchitect.Builders.FloorPlan;
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Builders.Isaac;
using DungeonArchitect.Builders.Mario;
using DungeonArchitect.Builders.Maze;
using DungeonArchitect.Builders.SimpleCity;
using DungeonArchitect.Editors.Visualization.Implementation;
using DungeonArchitect.Themeing;
using UnityEngine;

namespace DungeonArchitect.Editors.Visualization
{
    public interface IThemeMarkerVisualizationBuilder
    {
        bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material);
    }

    public class ThemeMarkerVisualizationBuilderBase
    {
        protected void CreateGroundGeometry(float width, float length, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
        {
            localGeometry = ThemeMarkerVisualizationBuilderUtils.CreateGroundQuad(width, length);
            material = ThemeMarkerVisualizationBuilderUtils.GetGroundMaterial();
        }

        protected void CreateWallGeometry(float width, float height, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
        {
            localGeometry = ThemeMarkerVisualizationBuilderUtils.CreateWallQuad(width, height);
            material = ThemeMarkerVisualizationBuilderUtils.GetWallMaterial();
        }
        
        protected void CreatePillarGeometry(float radius, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
        {
            localGeometry = ThemeMarkerVisualizationBuilderUtils.CreateGroundQuad(radius * 2, radius * 2);
            material = ThemeMarkerVisualizationBuilderUtils.GetPillarMaterial();
        }

        protected void ApplyOffset(Vector3 offset, ThemeEditorVisMarkerGeometry localGeometry)
        {
            for (var i = 0; i < localGeometry.Vertices.Length; i++)
            {
                localGeometry.Vertices[i] = localGeometry.Vertices[i] + offset;
            }
        }
    }
    
    public static class ThemeMarkerVisualizationBuilderFactory
    {
        public static IThemeMarkerVisualizationBuilder Create(System.Type builderType)
        {
            if (builderType == typeof(GridDungeonBuilder))
            {
                return new GridThemeMarkerVisualizationBuilder();
            }
            if (builderType == typeof(GridFlowDungeonBuilder))
            {
                return new GridFlowThemeMarkerVisualizationBuilder();
            }
            if (builderType == typeof(SimpleCityDungeonBuilder))
            {
                return new SimpleCityThemeMarkerVisualizationBuilder();
            }
            if (builderType == typeof(FloorPlanBuilder))
            {
                return new FloorPlanThemeMarkerVisualizationBuilder();
            }
            if (builderType == typeof(BSPDungeonBuilder))
            {
                return new BSPThemeMarkerVisualizationBuilder();
            }
            if (builderType == typeof(MazeDungeonBuilder))
            {
                return new MazeThemeMarkerVisualizationBuilder();
            }
            if (builderType == typeof(MarioDungeonBuilder))
            {
                return new MarioThemeMarkerVisualizationBuilder();
            }
            if (builderType == typeof(IsaacDungeonBuilder))
            {
                return new IsaacThemeMarkerVisualizationBuilder();
            }
            
            return null;
        }
    }

    public static class ThemeMarkerVisualizationBuilderUtils
    {
        public static ThemeEditorVisMarkerGeometry CreateGroundQuad(float width, float length)
        {
            var geometry = CreateGroundQuad();
            var scale = new Vector3(width, 0, length) * 0.5f;
            for (var i = 0; i < geometry.Vertices.Length; i++)
            {
                geometry.Vertices[i] = Vector3.Scale(geometry.Vertices[i], scale);
            }

            return geometry;
        }

        public static ThemeEditorVisMarkerGeometry CreateWallQuad(float width, float height)
        {
            var geometry = CreateWallQuad();
            var scale = new Vector3(width * 0.5f, height, 0);
            for (var i = 0; i < geometry.Vertices.Length; i++)
            {
                geometry.Vertices[i] = Vector3.Scale(geometry.Vertices[i], scale);
            }

            return geometry;
        }
        
        public static Material GetGroundMaterial()
        {
            return Resources.Load<Material>("MarkerVisualizer/Materials/MatMarkerVisualizerBox");
        }
        
        public static Material GetWallMaterial()
        {
            return Resources.Load<Material>("MarkerVisualizer/Materials/MatMarkerVisualizerBox");
        }
        
        public static Material GetPillarMaterial()
        {
            return Resources.Load<Material>("MarkerVisualizer/Materials/MatMarkerVisualizerCircle");
        }

        static ThemeEditorVisMarkerGeometry CreateGroundQuad()
        {
            var geometry = new ThemeEditorVisMarkerGeometry();
            geometry.Vertices = new []
            {
                new Vector3(-1, 0, -1),
                new Vector3(1, 0, -1),
                new Vector3(1, 0, 1),
                new Vector3(-1, 0, 1)
            };

            geometry.UV = new[]
            {
                new Vector2(0, 0),
                new Vector2(1, 0),
                new Vector2(1, 1),
                new Vector2(0, 1)
            };

            geometry.Indices = new[]
            {
                0, 2, 1,
                0, 3, 2
            };
            return geometry;
        }
        
        static ThemeEditorVisMarkerGeometry CreateWallQuad()
        {
            var geometry = new ThemeEditorVisMarkerGeometry();
            geometry.Vertices = new []
            {
                new Vector3(-1, 0, 0),
                new Vector3(1, 0, 0),
                new Vector3(1, 1, 0),
                new Vector3(-1, 1, 0)
            };

            geometry.UV = new[]
            {
                new Vector2(0, 0),
                new Vector2(1, 0),
                new Vector2(1, 1),
                new Vector2(0, 1)
            };

            geometry.Indices = new[]
            {
                0, 2, 1,
                0, 3, 2
            };
            return geometry;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Layout\BaseFlowExecNodeHandler_CreateKeyLockInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_CreateKeyLockInspector : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Branch Info");
            {
                EditorGUI.indentLevel++;
                DrawProperties("keyBranch", "lockBranch");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Marker Names");
            {
                EditorGUI.indentLevel++;
                DrawProperties("keyMarkerName", "lockMarkerName");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Layout\BaseFlowExecNodeHandler_CreateMainPathInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_CreateMainPathInspector : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Path Info");
            {
                EditorGUI.indentLevel++;
                DrawProperties("pathSize", "pathName", "nodeColor");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Marker Names");
            {
                EditorGUI.indentLevel++;
                DrawProperties("startMarkerName", "goalMarkerName");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Start / Goal Nodes");
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.HelpBox(
                    "You can give a different path name to the start / goal nodes. This way when other branches connect to this main path, they don't connect to the start / goal nodes. Leave it blank to make it part of the main branch",
                    MessageType.Info);

                DrawProperties("startNodePathName", "goalNodePathName");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Layout\BaseFlowExecNodeHandler_CreatePathInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_CreatePathInspector : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Path Info");
            {
                EditorGUI.indentLevel++;
                DrawProperties("minPathSize", "maxPathSize", "pathName", "nodeColor");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Branching Info");
            {
                EditorGUI.indentLevel++;
                DrawProperties("startFromPath", "endOnPath");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Layout\BaseFlowExecNodeHandler_FinalizeGraphInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_FinalizeGraphInspector : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();
            
            DrawHeader("One-way Doors");
            {
                EditorGUI.indentLevel++;
                DrawProperties("oneWayDoorPromotionWeight");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Layout\BaseFlowExecNodeHandler_MirrorGraphInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_MirrorGraphInspector : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();
            
            
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Layout\BaseFlowExecNodeHandler_SpawnItemsInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Items;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_SpawnItemsInspector : FlowExecNodeHandlerInspectorBase
    {
        public enum InspectorFlowGraphItemType
        {
            Enemy = 2,
            Bonus = 3,
            Custom = 6,
        }
        
        void DrawItemTypeDropdown()
        {
            var itemTypeProperty = GetProperty("itemType");
            var currentValue = (InspectorFlowGraphItemType) itemTypeProperty.intValue;
            var edValue = (InspectorFlowGraphItemType) EditorGUILayout.EnumPopup("Item Type", currentValue);
            itemTypeProperty.intValue = (int)edValue;
        }
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            var handler = target as LayoutBaseFlowTaskSpawnItems;

            DrawHeader("Spawn Info");
            {
                EditorGUI.indentLevel++;
                DrawProperty("paths", true);
                DrawItemTypeDropdown();
                DrawProperties("markerName");

                if (handler.itemType == FlowGraphItemType.Custom)
                {
                    DrawProperty("customItemInfo", true);
                }

                DrawProperties("minCount", "maxCount");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Spawn Method");
            {
                EditorGUI.indentLevel++;
                DrawProperty("spawnMethod");
                if (handler.spawnMethod == LayoutFlowNodeHandler_SpawnItemMethod.CurveDifficulty)
                {
                    DrawProperty("spawnDistributionCurve");
                }

                if (handler.spawnMethod != LayoutFlowNodeHandler_SpawnItemMethod.RandomRange)
                {
                    DrawProperty("spawnDistributionVariance");
                }

                DrawProperties("minSpawnDifficulty", "spawnProbability");
                EditorGUI.indentLevel--;
            }

        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Tilemap\BaseFlowExecNodeHandlerInspector_CreateTilemapOverlay.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandlerInspector_CreateTilemapOverlay : FlowExecNodeHandlerInspectorBase
    {
        DAInspectorMonoScriptProperty<ITilemapFlowOverlayGenerator> generatorProperty;
        protected override void OnEnable()
        {
            base.OnEnable();

            var handler = target as GridFlowTilemapTaskCreateOverlay;
            generatorProperty = CreateScriptProperty<ITilemapFlowOverlayGenerator>(handler.generatorScriptClass);
        }

        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            var handler = target as GridFlowTilemapTaskCreateOverlay;

            DrawHeader("Visuals");
            {
                EditorGUI.indentLevel++;
                DrawProperties("markerName", "color");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Generation Settings");
            {
                EditorGUI.indentLevel++;
                DrawProperty("generationMethod");
                if (handler.generationMethod == TilemapFlowNodeHandler_CreateTilemapOverlayGenMethod.Noise)
                {
                    // Show noise settings
                    DrawProperty("noiseSettings", true);
                }
                else if (handler.generationMethod == TilemapFlowNodeHandler_CreateTilemapOverlayGenMethod.Script)
                {
                    // Show script settings
                    generatorProperty.Draw(className => handler.generatorScriptClass = className);
                }
                DrawProperty("overlayBlocksTile");
                
                EditorGUI.indentLevel--;
            }

            DrawHeader("Merge Settings");
            {
                EditorGUI.indentLevel++;
                DrawProperty("mergeConfig", true);
                EditorGUI.indentLevel++;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Tilemap\BaseFlowExecNodeHandlerInspector_InitializeTilemap.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandlerInspector_InitializeTilemap : FlowExecNodeHandlerInspectorBase
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Tilemap\BaseFlowExecNodeHandlerInspector_OptimizeTilemap.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandlerInspector_OptimizeTilemap : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Optimize");
            {
                EditorGUI.indentLevel++;
                DrawProperties("discardDistanceFromLayout");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Tilemap\BaseFlowExecNodeHandler_CreateTilemapElevationsInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_CreateTilemapElevationsInspector : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Marker");
            {
                EditorGUI.indentLevel++;
                DrawProperties("markerName");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Noise Settings");
            {
                EditorGUI.indentLevel++;
                DrawProperties("noiseOctaves", "noiseFrequency", "noiseValuePower", "numSteps");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Height data");
            {
                EditorGUI.indentLevel++;
                DrawProperties("minHeight", "maxHeight", "seaLevel");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Colors");
            {
                EditorGUI.indentLevel++;
                DrawProperties("landColor", "seaColor", "minColorMultiplier");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Tilemap\BaseFlowExecNodeHandler_FinalizeTilemapInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_FinalizeTilemapInspector : FlowExecNodeHandlerInspectorBase
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Tilemap\BaseFlowExecNodeHandler_MergeTilemapsInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Editors.Flow.Common
{
    public class BaseFlowExecNodeHandler_MergeTilemapsInspector : FlowExecNodeHandlerInspectorBase
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\Common\Tilemap\FlowPreviewTilemapGraphNodeInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Tilemap.Tooling;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.Common
{
    [CustomEditor(typeof(FlowTilemapToolGraphNode), false)]
    public class FlowPreviewTilemapGraphNodeInspector : Editor
    {
        SerializedObject sobject;
        SerializedProperty tileRenderSize;

        protected virtual void OnEnable()
        {
            sobject = new SerializedObject(target);
            tileRenderSize = sobject.FindProperty("tileRenderSize");
        }

        public override void OnInspectorGUI()
        {
            sobject.Update();

            EditorGUILayout.Space();
            GUILayout.Label("Tilemap Preview", InspectorStyles.HeaderStyle);
            {
                EditorGUI.indentLevel++;
                EditorGUI.BeginChangeCheck();
                EditorGUILayout.PropertyField(tileRenderSize);
                if (EditorGUI.EndChangeCheck())
                {
                    var node = target as FlowTilemapToolGraphNode;
                    node.RequestRecreatePreview = true;
                }
                EditorGUI.indentLevel--;
            }
            sobject.ApplyModifiedProperties();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Layout\GridFlowExecNodeHandler_CreateGridInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowLayoutTaskCreateGrid), false)]
    public class GridFlowExecNodeHandler_CreateGridInspector : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Grid Info");
            {
                EditorGUI.indentLevel++;
                DrawProperties("resolution");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Layout\GridFlowExecNodeHandler_CreateKeyLockInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowLayoutTaskCreateKeyLock), false)]
    public class GridFlowExecNodeHandler_CreateKeyLockInspector : BaseFlowExecNodeHandler_CreateKeyLockInspector
    {
        GridFlowExecNodePlacementSettingInspector placementInspector;
        protected override void OnEnable()
        {
            base.OnEnable();

            var handler = target as GridFlowLayoutTaskCreateKeyLock;
            placementInspector = new GridFlowExecNodePlacementSettingInspector(this, "placementSettings", "Key Placement", handler.placementSettings);
        }

        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            placementInspector.Draw(this);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Layout\GridFlowExecNodeHandler_CreateMainPathInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowLayoutTaskCreateMainPath), false)]
    public class GridFlowExecNodeHandler_CreateMainPathInspector : BaseFlowExecNodeHandler_CreateMainPathInspector
    {
        GridFlowExecNodePlacementSettingInspector startPlacementInspector;
        GridFlowExecNodePlacementSettingInspector goalPlacementInspector;
        
        private DAInspectorMonoScriptProperty<IGridFlowLayoutNodePositionConstraint> positionConstraintScriptProperty;

        protected override void OnEnable()
        {
            base.OnEnable();
            
            var handler = target as GridFlowLayoutTaskCreateMainPath;
            startPlacementInspector = new GridFlowExecNodePlacementSettingInspector(this, "startPlacementSettings", "Start Item Placement", handler.startPlacementSettings);
            goalPlacementInspector = new GridFlowExecNodePlacementSettingInspector(this, "goalPlacementSettings", "Goal Item Placement", handler.goalPlacementSettings);
            
            
            // Create the position constraint script property
            {
                var className = (handler != null) ? handler.nodePositionConstraintScriptClassName : "";
                positionConstraintScriptProperty = new DAInspectorMonoScriptProperty<IGridFlowLayoutNodePositionConstraint>(className);
            }
        }

        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();
            var handler = target as GridFlowLayoutTaskCreateMainPath;
            
            startPlacementInspector.Draw(this);
            goalPlacementInspector.Draw(this);
            
            DrawHeader("Position Constraints");
            {
                EditorGUI.indentLevel++;
                DrawProperty("positionConstraintMode");

                if (handler.positionConstraintMode == GridFlowLayoutTaskCreateMainPath.NodeConstraintType.StartEndNode)
                {
                    EditorGUILayout.HelpBox(
                        "Provide a list of coords where the start / end nodes can be placed. Leave the array blank to ignore the constraints",
                        MessageType.Info);
                    DrawProperty("startNodePositionConstraints", true);
                    DrawProperty("endNodePositionConstraints", true);
                }
                else if (handler.positionConstraintMode == GridFlowLayoutTaskCreateMainPath.NodeConstraintType.Script)
                {
                    EditorGUILayout.HelpBox("Specify a script that inherits from ScriptableObject and implements IGridFlowLayoutNodePositionConstraint",
                        MessageType.Info);
                    positionConstraintScriptProperty.Draw(className => handler.nodePositionConstraintScriptClassName = className);
                }
                EditorGUI.indentLevel--;
            }
            
            DrawHeader("Size Constraints");
            {
                EditorGUI.indentLevel++;
                DrawProperties("fixedStartRoomSize", "fixedEndRoomSize");
                EditorGUI.indentLevel--;
            }
            
            DrawHeader("Advanced: Performance");
            {
                EditorGUI.indentLevel++;
                DrawProperties("numParallelSearches", "maxFramesToProcess");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Layout\GridFlowExecNodeHandler_CreatePathInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowLayoutTaskCreatePath), false)]
    public class GridFlowExecNodeHandler_CreatePathInspector : BaseFlowExecNodeHandler_CreatePathInspector
    {
        private DAInspectorMonoScriptProperty<IGridFlowLayoutNodePositionConstraint> positionConstraintScriptProperty;
        
        protected override void OnEnable()
        {
            base.OnEnable();
            
            var handler = target as GridFlowLayoutTaskCreatePath;
            
            // Create the position constraint script property
            {
                var className = (handler != null) ? handler.nodePositionConstraintScriptClassName : "";
                positionConstraintScriptProperty = new DAInspectorMonoScriptProperty<IGridFlowLayoutNodePositionConstraint>(className);
            }
        }
        
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();
            var handler = target as GridFlowLayoutTaskCreatePath;
            
            DrawHeader("Position Constraints");
            {
                EditorGUI.indentLevel++;
                DrawProperty("positionConstraintMode");

                if (handler.positionConstraintMode == GridFlowLayoutTaskCreatePath.NodeConstraintType.Script)
                {
                    EditorGUILayout.HelpBox("Specify a script that inherits from ScriptableObject and implements IGridFlowLayoutNodePositionConstraint",
                        MessageType.Info);
                    positionConstraintScriptProperty.Draw(className => handler.nodePositionConstraintScriptClassName = className);
                }
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Layout\GridFlowExecNodeHandler_FinalizeGraphInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowLayoutTaskFinalizeGraph), false)]
    public class GridFlowExecNodeHandler_FinalizeGraphInspector : BaseFlowExecNodeHandler_FinalizeGraphInspector
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Layout");
            {
                EditorGUI.indentLevel++;
                DrawProperties("generateCaves", "generateCorridors", "maxEnemiesPerCaveNode");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Layout\GridFlowExecNodeHandler_MirrorGraphInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    
    [CustomEditor(typeof(GridFlowLayoutTaskMirrorGraph), false)]
    public class GridFlowExecNodeHandler_MirrorGraphInspector : BaseFlowExecNodeHandler_MirrorGraphInspector
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Direction");
            {
                EditorGUI.indentLevel++;
                DrawProperties("mirrorX", "mirrorY");
                EditorGUI.indentLevel--;
            }
            
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Layout\GridFlowExecNodeHandler_SpawnItemsInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowLayoutTaskSpawnItems), false)]
    public class GridFlowExecNodeHandler_SpawnItemsInspector : BaseFlowExecNodeHandler_SpawnItemsInspector
    {
        GridFlowExecNodePlacementSettingInspector placementInspector;
        protected override void OnEnable()
        {
            base.OnEnable();

            var handler = target as GridFlowLayoutTaskSpawnItems;
            placementInspector = new GridFlowExecNodePlacementSettingInspector(this, "placementSettings", "Placement Method", handler.placementSettings);
        }
        
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();
            
            placementInspector.Draw(this);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Tilemap\GridFlowExecNodeHandlerInspector_CreateTilemapOverlay.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowTilemapTaskCreateOverlay), false)]
    public class GridFlowExecNodeHandlerInspector_CreateTilemapOverlay : BaseFlowExecNodeHandlerInspector_CreateTilemapOverlay
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Tilemap\GridFlowExecNodeHandlerInspector_InitializeTilemap.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{

    [CustomEditor(typeof(GridFlowTilemapTaskInitialize), false)]
    public class GridFlowExecNodeHandlerInspector_InitializeTilemap : BaseFlowExecNodeHandlerInspector_InitializeTilemap
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Layout Settings");
            {
                EditorGUI.indentLevel++;
                DrawProperties("tilemapSizePerNode", "perturbAmount", "corridorLaneWidth", "layoutPadding", "cropTilemap", "wallGenerationMethod");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Cave Settings");
            {
                EditorGUI.indentLevel++;
                DrawProperties("caveThickness", "caveAutomataNeighbors", "caveAutomataIterations");
                EditorGUI.indentLevel--;
            }

            DrawHeader("Color Settings");
            {
                EditorGUI.indentLevel++;
                DrawProperties("roomColorSaturation", "roomColorBrightness");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Tilemap\GridFlowExecNodeHandlerInspector_OptimizeTilemap.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowTilemapTaskOptimize), false)]
    public class GridFlowExecNodeHandlerInspector_OptimizeTilemap : BaseFlowExecNodeHandlerInspector_OptimizeTilemap
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Tilemap\GridFlowExecNodeHandler_CreateTilemapElevationsInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowTilemapTaskCreateElevations), false)]
    public class GridFlowExecNodeHandler_CreateTilemapElevationsInspector : BaseFlowExecNodeHandler_CreateTilemapElevationsInspector
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Tilemap\GridFlowExecNodeHandler_FinalizeTilemapInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowTilemapTaskFinalize), false)]
    public class GridFlowExecNodeHandler_FinalizeTilemapInspector : BaseFlowExecNodeHandler_FinalizeTilemapInspector
    {
        protected override void DrawMiscProperties()
        {
            base.DrawMiscProperties();
            
            DrawProperties("debugUnwalkableCells");
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\GridFlow\Tilemap\GridFlowExecNodeHandler_MergeTilemapsInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.GridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.GridFlow
{
    [CustomEditor(typeof(GridFlowTilemapTaskMerge), false)]
    public class GridFlowExecNodeHandler_MergeTilemapsInspector : BaseFlowExecNodeHandler_MergeTilemapsInspector
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\SnapGridFlow\Layout\SnapGridFlowExecNodeHandler_CreateGridInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.SnapGridFlow
{
    [CustomEditor(typeof(SGFLayoutTaskCreateGrid), false)]
    public class SnapGridFlowExecNodeHandler_CreateGridInspector : FlowExecNodeHandlerInspectorBase
    {
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();

            DrawHeader("Grid Info");
            {
                EditorGUI.indentLevel++;
                DrawProperties("resolution");
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\SnapGridFlow\Layout\SnapGridFlowExecNodeHandler_CreateKeyLockInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.SnapGridFlow
{
    [CustomEditor(typeof(SGFLayoutTaskCreateKeyLock), false)]
    public class SnapGridFlowExecNodeHandler_CreateKeyLockInspector : BaseFlowExecNodeHandler_CreateKeyLockInspector
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\SnapGridFlow\Layout\SnapGridFlowExecNodeHandler_CreateMainPathInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.SnapGridFlow
{
    [CustomEditor(typeof(SGFLayoutTaskCreateMainPath), false)]
    public class SnapGridFlowExecNodeHandler_CreateMainPathInspector : BaseFlowExecNodeHandler_CreateMainPathInspector
    {
        private DAInspectorMonoScriptProperty<ISGFLayoutNodePositionConstraint> positionConstraintScriptProperty;
        private DAInspectorMonoScriptProperty<ISGFLayoutNodeCategoryConstraint> categoryConstraintScriptProperty;

        protected override void OnEnable()
        {
            base.OnEnable();

            var task = target as SGFLayoutTaskCreateMainPath;
            
            // Create the position constraint script property
            {
                var className = (task != null) ? task.nodePositionConstraintScriptClassName : "";
                positionConstraintScriptProperty = new DAInspectorMonoScriptProperty<ISGFLayoutNodePositionConstraint>(className);
            }
            
            // Create the module constraint script property
            {
                var className = (task != null) ? task.categoryConstraintScriptClassName : "";
                categoryConstraintScriptProperty = new DAInspectorMonoScriptProperty<ISGFLayoutNodeCategoryConstraint>(className);
            }
        }

        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();
            var task = target as SGFLayoutTaskCreateMainPath;

            DrawHeader("Snap Info");
            {
                EditorGUI.indentLevel++;
                DrawProperty("snapModuleCategories", true);
                EditorGUI.indentLevel--;
            }

            DrawHeader("Position Constraints");
            {
                EditorGUI.indentLevel++;
                DrawProperty("positionConstraintMode");

                if (task.positionConstraintMode == SGFLayoutTaskCreateMainPath.NodeConstraintType.StartEndNode)
                {
                    EditorGUILayout.HelpBox(
                        "Provide a list of coords where the start / end nodes can be placed. Leave the array blank to ignore the constraints",
                        MessageType.Info);
                    DrawProperty("startNodePositionConstraints", true);
                    DrawProperty("endNodePositionConstraints", true);
                }
                else if (task.positionConstraintMode == SGFLayoutTaskCreateMainPath.NodeConstraintType.Script)
                {
                    EditorGUILayout.HelpBox("Specify a script that inherits from ScriptableObject and implements ISGFLayoutNodePositionConstraint",
                        MessageType.Info);
                    positionConstraintScriptProperty.Draw(className => task.nodePositionConstraintScriptClassName = className);
                }
                EditorGUI.indentLevel--;
            }

            DrawHeader("Snap Module Constraints");
            {
                EditorGUI.indentLevel++;
                DrawProperty("categoryConstraintMode");
                if (task.categoryConstraintMode == SGFLayoutTaskCreateMainPath.NodeConstraintType.StartEndNode)
                {
                    EditorGUILayout.HelpBox("Provide a list of module categories for the start / end nodes. Leave the array blank to ignore the constraints",
                        MessageType.Info);
                    DrawProperty("startNodeCategoryConstraints", true);
                    DrawProperty("endNodeCategoryConstraints", true);
                }
                else if (task.categoryConstraintMode == SGFLayoutTaskCreateMainPath.NodeConstraintType.Script)
                {
                    EditorGUILayout.HelpBox("Specify a script that inherits from ScriptableObject and implements ISGFLayoutNodeCategoryConstraint",
                        MessageType.Info);
                    categoryConstraintScriptProperty.Draw(className => task.categoryConstraintScriptClassName = className);
                }
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\SnapGridFlow\Layout\SnapGridFlowExecNodeHandler_CreatePathInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.SnapGridFlow
{
    [CustomEditor(typeof(SGFLayoutTaskCreatePath), false)]
    public class SnapGridFlowExecNodeHandler_CreatePathInspector : BaseFlowExecNodeHandler_CreatePathInspector
    {
        private DAInspectorMonoScriptProperty<ISGFLayoutNodePositionConstraint> positionConstraintScriptProperty;
        private DAInspectorMonoScriptProperty<ISGFLayoutNodeCategoryConstraint> categoryConstraintScriptProperty;
        
        protected override void OnEnable()
        {
            base.OnEnable();

            var task = target as SGFLayoutTaskCreatePath;
            
            // Create the position constraint script property
            {
                var className = (task != null) ? task.nodePositionConstraintScriptClassName : "";
                positionConstraintScriptProperty = new DAInspectorMonoScriptProperty<ISGFLayoutNodePositionConstraint>(className);
            }
            
            // Create the module constraint script property
            {
                var className = (task != null) ? task.categoryConstraintScriptClassName : "";
                categoryConstraintScriptProperty = new DAInspectorMonoScriptProperty<ISGFLayoutNodeCategoryConstraint>(className);
            }
        }
        
        public override void HandleInspectorGUI()
        {
            base.HandleInspectorGUI();
            var task = target as SGFLayoutTaskCreatePath;

            DrawHeader("Snap Info");
            {
                EditorGUI.indentLevel++;
                DrawProperty("snapModuleCategories", true);
                EditorGUI.indentLevel--;
            }

            DrawHeader("Position Constraints");
            {
                EditorGUI.indentLevel++;
                DrawProperty("positionConstraintMode");

                if (task.positionConstraintMode == SGFLayoutTaskCreatePath.NodeConstraintType.Script)
                {
                    EditorGUILayout.HelpBox("Specify a script that inherits from ScriptableObject and implements ISGFLayoutNodePositionConstraint",
                        MessageType.Info);
                    positionConstraintScriptProperty.Draw(className => task.nodePositionConstraintScriptClassName = className);
                }
                EditorGUI.indentLevel--;
            }

            DrawHeader("Snap Module Constraints");
            {
                EditorGUI.indentLevel++;
                DrawProperty("categoryConstraintMode");
                if (task.categoryConstraintMode == SGFLayoutTaskCreatePath.NodeConstraintType.Script)
                {
                    EditorGUILayout.HelpBox("Specify a script that inherits from ScriptableObject and implements ISGFLayoutNodeCategoryConstraint",
                        MessageType.Info);
                    categoryConstraintScriptProperty.Draw(className => task.categoryConstraintScriptClassName = className);
                }
                EditorGUI.indentLevel--;
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\SnapGridFlow\Layout\SnapGridFlowExecNodeHandler_FinalizeGraphInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.SnapGridFlow
{
    [CustomEditor(typeof(SGFLayoutTaskFinalizeGraph), false)]
    public class SnapGridFlowExecNodeHandler_FinalizeGraphInspector : BaseFlowExecNodeHandler_FinalizeGraphInspector
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\PropertyEditors\Flow\SnapGridFlow\Layout\SnapGridFlowExecNodeHandler_SpawnItemsInspector.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Editors.Flow.Common;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks;
using UnityEditor;

namespace DungeonArchitect.Editors.Flow.SnapGridFlow
{
    [CustomEditor(typeof(SGFLayoutTaskSpawnItems), false)]
    public class SnapGridFlowExecNodeHandler_SpawnItemsInspector : BaseFlowExecNodeHandler_SpawnItemsInspector
    {
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Builders\Grid\SpatialConstraints\Rules\ConstraintRuleIsHigherThan.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Builders.Grid.SpatialConstraints
{
    /*
    [RuleMeta(name = "Grid Builder/Is Higher Than")]
    public class ConstraintRuleIsHigherThan : ConstraintRule
    {
        [SerializeField]
        public string markerName;

        [SerializeField]
        public float searchRadius = 0.1f;

        public override bool Process(ConstraintRuleContext context)
        {
            return false;
        }
    }
    */
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Terrain\Filter\BlurFilter.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;


namespace DungeonArchitect {
	/// <summary>
	/// A fast Gaussian blurring filter applied over a 2D data array
	/// </summary>
	public class BlurFilter : Filter {
		int radius;
		int w, h;

		public BlurFilter(int radius) {
			this.radius = radius;
		}

		public float[,] ApplyFilter (float[,] data)
		{
			var blurredData = new float[data.GetLength(0), data.GetLength(1)];
			gaussBlur_4(data, blurredData, radius);
			return blurredData;
		}

		// Algorithm from: http://blog.ivank.net/fastest-gaussian-blur.html
		void gaussBlur_4 (float[,] scl, float[,] tcl, int r) {
			h = scl.GetLength(0);
			w = scl.GetLength(1);
			var bxs = boxesForGauss(r, 3);
			boxBlur_4 (scl, tcl, (bxs[0]-1)/2);
			boxBlur_4 (tcl, scl, (bxs[1]-1)/2);
			boxBlur_4 (scl, tcl, (bxs[2]-1)/2);
		}
		void boxBlur_4 (float[,] scl, float[,] tcl, int r) {
			for(var y = 0; y < scl.GetLength(0); y++) {
				for(var x = 0; x < scl.GetLength(1); x++) {
					tcl[y, x] = scl[y, x];
				}
			}
			boxBlurH_4(tcl, scl, r);
			boxBlurT_4(scl, tcl, r);
		}

		float Get(float[,] data, int index) {
			var y = index / w;
			var x = index % w;
			return data[y, x];
		}

		void Set(float[,] data, int index, float value) {
			var y = index / w;
			var x = index % w;
			data[y, x] = value;
		}

		void boxBlurH_4 (float[,] scl, float[,] tcl, int r) {
			var iarr = 1.0f / (r+r+1);
			for(var i=0; i<h; i++) {
				int ti = i*w, li = ti, ri = ti+r;
				float fv = Get(scl, ti), lv = Get(scl, ti+w-1), val = (r+1)*fv;
				for(var j=0; j<r; j++) val += Get(scl, ti+j);
				for(var j=0  ; j<=r ; j++) { val += Get(scl, ri++) - fv       ;   Set(tcl, ti++, Round(val*iarr)); }
				for(var j=r+1; j<w-r; j++) { val += Get(scl, ri++) - Get(scl, li++);   Set(tcl, ti++, Round(val*iarr)); }
				for(var j=w-r; j<w  ; j++) { val += lv        - Get(scl, li++);   Set(tcl, ti++, Round(val*iarr)); }

				/*
				var ti = i*w, li = ti, ri = ti+r;
				var fv = scl[ti], lv = scl[ti+w-1], val = (r+1)*fv;
				for(var j=0; j<r; j++) val += scl[ti+j];
				for(var j=0  ; j<=r ; j++) { val += scl[ri++] - fv       ;   tcl[ti++] = Round(val*iarr); }
				for(var j=r+1; j<w-r; j++) { val += scl[ri++] - scl[li++];   tcl[ti++] = Round(val*iarr); }
				for(var j=w-r; j<w  ; j++) { val += lv        - scl[li++];   tcl[ti++] = Round(val*iarr); }
				*/
			}
		}
		void boxBlurT_4 (float[,] scl, float[,] tcl, int r) {
			var iarr = 1.0f / (r+r+1);
			for(var i=0; i<w; i++) {
				int ti = i, li = ti, ri = ti+r*w;
				float fv = Get(scl, ti), lv = Get(scl, ti+w*(h-1)), val = (r+1)*fv;
				for(var j=0; j<r; j++) val += Get(scl, ti+j*w);
				for(var j=0  ; j<=r ; j++) { val += Get(scl, ri) - fv     ;  Set(tcl, ti, Round(val*iarr));  ri+=w; ti+=w; }
				for(var j=r+1; j<h-r; j++) { val += Get(scl, ri) - Get(scl, li);  Set(tcl, ti, Round(val*iarr));  li+=w; ri+=w; ti+=w; }
				for(var j=h-r; j<h  ; j++) { val += lv      - Get(scl, li);  Set(tcl, ti, Round(val*iarr));  li+=w; ti+=w; }

				/*
				var ti = i, li = ti, ri = ti+r*w;
				var fv = scl[ti], lv = scl[ti+w*(h-1)], val = (r+1)*fv;
				for(var j=0; j<r; j++) val += scl[ti+j*w];
				for(var j=0  ; j<=r ; j++) { val += scl[ri] - fv     ;  tcl[ti] = Round(val*iarr);  ri+=w; ti+=w; }
				for(var j=r+1; j<h-r; j++) { val += scl[ri] - scl[li];  tcl[ti] = Round(val*iarr);  li+=w; ri+=w; ti+=w; }
				for(var j=h-r; j<h  ; j++) { val += lv      - scl[li];  tcl[ti] = Round(val*iarr);  li+=w; ti+=w; }
				*/
			}
		}
		
		int[] boxesForGauss(float sigma, int n)  // standard deviation, number of boxes
		{
			var wIdeal = Mathf.Sqrt((12*sigma*sigma/n)+1);  // Ideal averaging filter width 
			var wl = Mathf.FloorToInt(wIdeal);  if(wl%2==0) wl--;
			var wu = wl+2;
			
			var mIdeal = (12*sigma*sigma - n*wl*wl - 4*n*wl - 3*n)/(-4*wl - 4);
			var m = Mathf.Round(mIdeal);
			// var sigmaActual = Math.sqrt( (m*wl*wl + (n-m)*wu*wu - n)/12 );
			
			var sizes = new List<int>();  for(var i=0; i<n; i++) sizes.Add(i<m?wl:wu);
			return sizes.ToArray();
		}

		float Round(float a) {
			return a;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Dungeon\Terrain\Filter\Filter.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect {

    /// <summary>
    /// A data filter applied over a 2D data array
    /// </summary>
	public interface Filter {
		float[,] ApplyFilter(float[,] data);
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\MarkerGenRuleGraph.cs:
 using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator.Nodes.Actions;
using DungeonArchitect.MarkerGenerator.Nodes.Condition;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator
{
    public class MarkerGenRuleGraph : Graph
    {
        [SerializeField]
        public MarkerGenRuleNodeResult resultNode;
        
        [SerializeField]
        public MarkerGenRuleNodeOnPass passNode;
        
        public override void OnEnable()
        {
            base.OnEnable();

            hideFlags = HideFlags.HideInHierarchy;
            
            
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\MarkerGenRuleGraphNode.cs:
 using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator
{
    public abstract class MarkerGenRuleGraphNode : GraphNode
    {
        public virtual Color BodyColor => new Color(0.15f, 0.15f, 0.15f);
        public virtual Color TitleColor => new Color(0.3f, 0.3f, 0.3f);
        
        public abstract string Title { get; }
        
        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            CreateDefaultPins();
        }
        
        protected virtual void CreateDefaultPins()
        {
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Rule\MarkerGenRule.cs:
 using System;
using DungeonArchitect.MarkerGenerator.VM;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Rule
{
    public class MarkerGenRule : ScriptableObject
    {
        [HideInInspector]
        public MarkerGenRuleGraph ruleGraph;
        
        /// <summary>
        /// The condition graph compiled down to bytecode. This will run in a virtual machine
        /// </summary>
        [HideInInspector]
        public MarkerGenRuleProgram program;

        /// <summary>
        /// The actions to execute if the condition program passes
        /// </summary>
        [HideInInspector]
        public MarkerGenRuleActionList actions;

#if	UNITY_EDITOR
        /// <summary>
        /// Textual representation of the rule's condition graph, for preview purpose in the editor
        /// </summary>
        public string previewTextCondition = "";
        
        /// <summary>
        /// Textual representation of the rule's action graph, for preview purpose in the editor
        /// </summary>
        public string[] previewTextActions = Array.Empty<string>();

        /// <summary>
        /// The color of the rule object.  This is for visuals only
        /// </summary>
        public Color color = Color.white;


        [Tooltip(@"Make the rule block pop out in the scene.   This is purely visual, disable it for blocks whose visuals get in the way and don't really contribute to the pattern you're looking for")]
        public bool visuallyDominant = true;
#endif // UNITY_EDITOR

        public virtual bool IsAssetInsertedHere()
        {
            return (actions != null && actions.hints != null) ? actions.hints.emitsMarker : false;
        }
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Rule\MarkerGenRuleActionList.cs:
 using System;
using DungeonArchitect.MarkerGenerator.Nodes.Actions.Info;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Rule
{
    public class MarkerGenRuleActionList : ScriptableObject
    {
        public MarkerGenRuleActionInfo[] actionList = Array.Empty<MarkerGenRuleActionInfo>();
        public MarkerGenRuleActionListHints hints = new MarkerGenRuleActionListHints();
        public void Clear()
        {
            actionList = Array.Empty<MarkerGenRuleActionInfo>();
            hints = new MarkerGenRuleActionListHints();
        }
    }

    [System.Serializable]
    public class MarkerGenRuleActionListHints
    {
        public bool emitsMarker = false;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Rule\MarkerGenRuleProgram.cs:
 using System;
using DungeonArchitect.MarkerGenerator.VM;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Rule
{
    public class MarkerGenRuleProgram : ScriptableObject
    {
        public Instruction[] instructions = Array.Empty<Instruction>();
        public string[] stringTable = Array.Empty<string>();
        public bool compiled = false;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\VM\Compiler.cs:
 using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator.Nodes.Condition;
using DungeonArchitect.MarkerGenerator.Pins;
using DungeonArchitect.MarkerGenerator.Rule;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.VM
{
    public class ConditionGraphCompiler
    {
        public static void Compile(MarkerGenRuleGraph graph, MarkerGenRuleProgram program)
        {
            new ConditionGraphCompiler().CompileImpl(graph, program);
        }
        
        private readonly List<Instruction> instructions = new List<Instruction>();
        private readonly List<string> stringTable = new List<string>();
        private Dictionary<GraphPin, GraphPin> incomingPinMap;
        private readonly HashSet<MarkerGenRuleGraphNode> visited = new HashSet<MarkerGenRuleGraphNode>();
        private void CompileImpl(MarkerGenRuleGraph graph, MarkerGenRuleProgram program)
        {   
            instructions.Clear();
            stringTable.Clear();
            visited.Clear();
            
            if (graph == null || graph.resultNode == null)
            {
                // invalid graph state. emit a program that returns false
                CreateDefaultFalseProgram();
                AssembleProgram(program);
                program.compiled = false;
                return;
            }
            
            incomingPinMap = BuildPinLookup(graph);
            bool success = GenerateNodeInstructions(graph.resultNode);
            if (!success)
            {
                program.compiled = false;
                return;
            }

            AssembleProgram(program);
            program.compiled = true;
        }

        private bool GenerateNodeInstructions(MarkerGenRuleGraphNode node)
        {
            if (visited.Contains(node))
            {
                return false;
            }
            visited.Add(node);
            
            // Process all the input nodes first
            foreach (var inputPin in node.InputPins)
            {
                var linkedPin = incomingPinMap.ContainsKey(inputPin) ? incomingPinMap[inputPin] : null;
                if (linkedPin != null)
                {
                    // Traverse the incoming node
                    if (linkedPin.Node != null && linkedPin.Node is MarkerGenRuleGraphNode incomingNode)
                    {
                        var success = GenerateNodeInstructions(incomingNode);
                        if (!success)
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    // Push the default value of the pin (the checkbox on an unconnected pin widget in the graph editor)
                    var defaultValue = false;
                    if (inputPin is MarkerGenRuleGraphPinBool boolPin)
                    {
                        defaultValue = boolPin.defaultValue;
                    }
                    
                    AddInstruction(OpCodes.Push, VmUtils.ToInt(defaultValue));
                }
            }
            
            // Emit out the node opcode (the required function params should be available in the stack)
            if (node is MarkerGenRuleNodeMarkerExists markerExistNode)
            {
                int stringIdx = RegisterString(markerExistNode.markerName);
                AddInstruction(OpCodes.Push, stringIdx);
                AddInstruction(OpCodes.MarkerExists);
            }
            else if (node is MarkerGenRuleNodeConditionScript scriptNode)
            {
                int stringIdx = RegisterString(scriptNode.scriptClassName);
                AddInstruction(OpCodes.Push, stringIdx);
                AddInstruction(OpCodes.ConditionScript);
            }
            else if (node is MarkerGenRuleNodeAnd)
            {
                AddInstruction(OpCodes.And);
            }
            else if (node is MarkerGenRuleNodeOr)
            {
                AddInstruction(OpCodes.Or);
            }
            else if (node is MarkerGenRuleNodeNot)
            {
                AddInstruction(OpCodes.Not);
            }
            else if (node is MarkerGenRuleNodeResult)
            {
                AddInstruction(OpCodes.Halt);
            }
            else
            {
                Debug.Log("Unsupported code gen node: " + node.GetType());
                AddInstruction(OpCodes.NoOp);
            }
            
            visited.Remove(node);
            return true;
        }

        void AssembleProgram(MarkerGenRuleProgram program)
        {
            program.instructions = instructions.ToArray();
            program.stringTable = stringTable.ToArray();
        }
        
        void CreateDefaultFalseProgram()
        {
            // Push false and halt
            instructions.Clear();
            AddInstruction(OpCodes.Push, VmUtils.ToInt(false));
            AddInstruction(OpCodes.Halt);
        }
        

        void AddInstruction(int opcode, int arg0 = 0, int arg1 = 0)
        {
            instructions.Add(new Instruction(opcode, arg0, arg1));
        }
        
        int RegisterString(string value)
        {
            stringTable.Add(value);
            return stringTable.Count - 1;
        }
        
        Dictionary<GraphPin, GraphPin> BuildPinLookup(Graph graph)
        {
            var linkedTo = new Dictionary<GraphPin, GraphPin>();
            foreach (var link in graph.Links)
            {
                var pinInput = link.Input as MarkerGenRuleGraphPin;
                var pinOutput = link.Output as MarkerGenRuleGraphPin;
                if (pinInput == null || pinOutput == null) continue;
                
                linkedTo[pinInput] = pinOutput;
            }

            return linkedTo;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\VM\Instruction.cs:
 namespace DungeonArchitect.MarkerGenerator.VM
{
    [System.Serializable]
    public struct Instruction
    {
        public int opcode;
        public int arg0;
        public int arg1;

        public Instruction(int opcode, int arg0 = 0, int arg1 = 0)
        {
            this.opcode = opcode;
            this.arg0 = arg0;
            this.arg1 = arg1;
        }

        public static readonly Instruction NoOp = new Instruction(OpCodes.NoOp);
        public static readonly Instruction Halt = new Instruction(OpCodes.Halt);
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\VM\OpCodes.cs:
 namespace DungeonArchitect.MarkerGenerator.VM
{
    public struct OpCodes
    {
        public static readonly int NoOp = 0;

        // Stack Ops
        public static readonly int Push = 10;
        
        // Logical Ops
        public static readonly int And = 100;
        public static readonly int Or = 101;
        public static readonly int Not = 102;
        
        // Internal Functions
        public static readonly int MarkerExists = 200;
        public static readonly int ConditionScript = 201;
        
        // System Ops
        public static readonly int Halt = 1000;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\VM\VirtualMarchine.cs:
 using System.Collections;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using DungeonArchitect.MarkerGenerator.Rule;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.VM
{
    public interface IMarkerGenVmAPI
    {
        bool MarkerExists(string markerName);
        bool ConditionScript(string scriptPath);
    }

    public class MarkerGenVM
    {
        private IMarkerGenVmAPI api;
        
        private MarkerGenRuleProgram program;
        private int instructionIndex = 0;
        private Stack<int> stack = new Stack<int>();
        private bool running = false;
        
        public string ErrorMessage { get; private set; } = "";

        public MarkerGenVM(IMarkerGenVmAPI api)
        {
            this.api = api;
        }
        
        /// <summary>
        /// Executes the bytecode program.  the result of the program is saved in the out varaible
        /// </summary>
        /// <param name="programToLoad"></param>
        /// <param name="result"></param>
        /// <returns>True if the program ran successfully</returns>
        public bool Run(MarkerGenRuleProgram programToLoad, out bool result)
        {
            
            this.program = programToLoad;
            stack = new Stack<int>();
            instructionIndex = 0;
            ErrorMessage = "";
            
            if (program != null && program.instructions != null && program.instructions.Length > 0)
            {
                running = true;
            }
            else
            {
                this.program = null;
                running = false;
            }

            
            while (running && GetInstruction(out var instruction))
            {
                if (instruction.opcode == OpCodes.Push)
                {
                    PushStack(instruction.arg0);
                }
                else if (instruction.opcode == OpCodes.MarkerExists)
                {
                    ExecMarkerExists();
                }
                else if (instruction.opcode == OpCodes.ConditionScript)
                {
                    ExecConditionScript();
                }
                else if (instruction.opcode == OpCodes.And)
                {
                    ExecLogicalAnd();
                }
                else if (instruction.opcode == OpCodes.Or)
                {
                    ExecLogicalOr();
                }
                else if (instruction.opcode == OpCodes.Not)
                {
                    ExecLogicalNot();
                }

                // Move to the next instruction
                Step();
            }

            // The result of the execution should be in the stack
            bool success = PopStack(out var resultValue); 
            result = success && VmUtils.ToBool(resultValue);
            return success;
        }


        private void ExecConditionScript()
        {
            if (!PopStack(out var stringIdx))
            {
                running = false;
                return;
            }
            
            if (!GetString(stringIdx, out var scriptFullPath))
            {
                running = false;
                return;
            }

            var result = api.ConditionScript(scriptFullPath);
            PushStack(result);
        }

        private void ExecMarkerExists()
        {
            if (!PopStack(out var stringIdx))
            {
                running = false;
                return;
            }

            if (!GetString(stringIdx, out var markerName))
            {
                running = false;
                return;
            }

            var exists = api.MarkerExists(markerName);
            PushStack(exists);
        }

        private void ExecLogicalAnd()
        {
            int lhs = 0;
            int rhs = 0;
            if (!PopStack(out lhs) || !PopStack(out rhs))
            {
                running = false;
                return;
            }

            // Logical AND operation
            var result = VmUtils.ToBool(lhs) && VmUtils.ToBool(rhs);
            PushStack(result);
        }

        private void ExecLogicalOr()
        {
            int lhs = 0;
            int rhs = 0;
            if (!PopStack(out lhs) || !PopStack(out rhs))
            {
                running = false;
                return;
            }

            // Logical OR operation
            var result = VmUtils.ToBool(lhs) || VmUtils.ToBool(rhs);
            PushStack(result);
        }

        private void ExecLogicalNot()
        {
            int input = 0;
            if (!PopStack(out input))
            {
                running = false;
                return;
            }

            // Logical NOT operation
            var result = !VmUtils.ToBool(input);
            PushStack(result);
        }

        private void PushStack(bool value)
        {
            stack.Push(VmUtils.ToInt(value));
        }
        
        private void PushStack(int value)
        {
            stack.Push(value);
        }

        private bool PopStack(out int value)
        {
            if (stack.Count == 0)
            {
                value = 0;
                ErrorMessage = "Invalid Stack State";
                return false;
            }
            
            value = stack.Pop();
            return true;
        }

        private bool GetString(int stringIdx, out string value)
        {
            if (stringIdx >= 0 && stringIdx < program.stringTable.Length)
            {
                value = program.stringTable[stringIdx];
                return true;
            }
            else
            {
                ErrorMessage = "Invalid String Table index";
                value = "";
                return false;
            }

        }
        
        /// <summary>
        /// Gets the current instruction.  Returns true if the program is still running
        /// </summary>
        /// <param name="instruction"></param>
        /// <returns></returns>
        private bool GetInstruction(out Instruction instruction)
        {
            if (!running)
            {
                instruction = Instruction.Halt;
                return false;
            }

            instruction = program.instructions[instructionIndex];

            return instruction.opcode != OpCodes.Halt;
        }
        
        private Instruction Step()
        {
            if (!running)
            {
                return Instruction.Halt;
            }

            instructionIndex++;
            if (!GetInstruction(out var instruction))
            {
                running = false;
            } 

            return instruction;
        }
    }


    public class VmUtils
    {
        public static int ToInt(bool value)
        {
            return value ? 1 : 0;
        }
        
        public static bool ToBool(int value)
        {
            return value != 0;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\CommonRules\ConstraintRuleHeightDifference.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.SpatialConstraints;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.Grid.SpatialConstraints
{
    public enum ConstraintRuleHeightDifferenceType
    {
        IsSameHeight,
        IsAboveReferenceNode,
        IsBelowReferenceNode
    }

    [RuleMeta(name = "Common/Height Difference")]
    public class ConstraintRuleHeightDifference : ConstraintRule
    {
        [SerializeField]
        public string markerName;

        [SerializeField]
        public float markerSearchRadius = 0.1f;

        [SerializeField]
        public float heightCheckTollerance = 0.5f;

        [SerializeField]
        public ConstraintRuleHeightDifferenceType heightFunction;

        public override string ToString()
        {
            return string.Format("{0}: {1}", base.ToString(), markerName);
        }

        public override bool Process(ConstraintRuleContext context)
        {
            var searchResult = GetMarkerSearchResult(context);
            if (searchResult == null)
            {
                return false;
            }

            var source = Matrix.GetTranslation(ref context.processorContext.marker.Transform);
            var check = Matrix.GetTranslation(ref searchResult.Transform);

            var heightDiff = check.y - source.y;
            if (heightFunction == ConstraintRuleHeightDifferenceType.IsSameHeight)
            {
                return Mathf.Abs(heightDiff) < heightCheckTollerance;
            }
            else if (heightFunction == ConstraintRuleHeightDifferenceType.IsAboveReferenceNode)
            {
                return heightDiff > heightCheckTollerance;
            }
            else if (heightFunction == ConstraintRuleHeightDifferenceType.IsBelowReferenceNode)
            {
                return heightDiff < -heightCheckTollerance;
            }
            else
            {
                return false;
            }

        }

        PropSocket GetMarkerSearchResult(ConstraintRuleContext context)
        {
            var searchPosition = SpatialConstraintProcessorUtils.GetPosition2D(context.ruleNodeWorldPosition);

            float searchRadiusSq = markerSearchRadius * markerSearchRadius;
            // Check if we have a marker with the specified name here
            var markerSearchSpace = context.processorContext.levelMarkers.GetMarkersInSearchArea(searchPosition, markerSearchRadius);
            foreach (var marker in markerSearchSpace)
            {
                if (marker.markForDeletion)
                {
                    continue;
                }

                if (marker.SocketType == markerName)
                {
                    // Check if the distance is within the range
                    var candidateMarkerPosition = SpatialConstraintProcessorUtils.GetPosition2D(Matrix.GetTranslation(ref marker.Transform));

                    float distanceSq = (searchPosition - candidateMarkerPosition).sqrMagnitude;
                    if (distanceSq < searchRadiusSq)
                    {
                        return marker;
                    }
                }
            }

            return null;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\CommonRules\ConstraintRuleMarkerExists.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.SpatialConstraints;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Builders.Grid.SpatialConstraints
{
    [RuleMeta(name = "Common/Marker Exists")]
    public class ConstraintRuleMarkerExists : ConstraintRule
    {
        [SerializeField]
        public string markerName;

        [SerializeField]
        public float searchRadius = 0.1f;
        
        public override string ToString()
        {
            return string.Format("{0}: {1}", base.ToString(), markerName);
        }

        public override bool Process(ConstraintRuleContext context)
        {
            var searchPosition = SpatialConstraintProcessorUtils.GetPosition2D(context.ruleNodeWorldPosition);

            float searchRadiusSq = searchRadius * searchRadius;
            // Check if we have a marker with the specified name here
            var markerSearchSpace = context.processorContext.levelMarkers.GetMarkersInSearchArea(searchPosition, searchRadius);
            foreach (var marker in markerSearchSpace)
            {
                if (marker.markForDeletion)
                {
                    continue;
                }

                if (marker.SocketType == markerName)
                {
                    // Check if the distance is within the range
                    var candidateMarkerPosition = SpatialConstraintProcessorUtils.GetPosition2D(Matrix.GetTranslation(ref marker.Transform));

                    float distanceSq = (searchPosition - candidateMarkerPosition).sqrMagnitude;
                    if (distanceSq < searchRadiusSq)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\Graph\SpatialConstraintGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.SpatialConstraints
{
    [System.Serializable]
    public class SpatialConstraintGraph : Graph
    {
        [SerializeField]
        public SpatialConstraintAsset asset;

        public override void OnEnable()
        {
            base.OnEnable();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Splatmaps\Data\SplatData.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Splatmap
{
    public class SplatData
    {
        float[,] data;
        public float this[IntVector2 coords]
        {
            get
            {
                return data[coords.x, coords.y];
            }
            set
            {
                data[coords.x, coords.y] = value;
            }
        }

        public float[,] Data
        {
            get { return data; }
        }

        public SplatData(int textureSize)
        {
            data = new float[textureSize, textureSize];
        }

        public void Write(Texture2D texture)
        {
            int numPixels = texture.width * texture.height;
            var pixels = new Color32[numPixels];

            for (int y = 0; y < texture.height; y++)
            {
                for (int x = 0; x < texture.width; x++)
                {
                    //float weight = x / (float)roadmap.width;
                    float weight = data[x, y];

                    byte alpha = MathUtils.ToByte(weight);
                    int index = y * texture.width + x;
                    var color = new Color32(0, 0, 0, alpha);
                    pixels[index] = color;
                }
            }

            texture.SetPixels32(pixels);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Splatmaps\Data\SplatRasterizer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Splatmap
{
    public class SplatRasterizer
    {
        public SplatRasterizer(SplatData splatData)
        {
            this.splatData = splatData;
        }

        private SplatData splatData;

        struct FloodFillPixelInfo
        {
            public FloodFillPixelInfo(IntVector2 currentPixel, IntVector2 sourcePixel, float startValue) {
                this.currentPixel = currentPixel;
                this.sourcePixel = sourcePixel;
                this.startValue = startValue;
            }

            public IntVector2 currentPixel;
            public IntVector2 sourcePixel;
            public float startValue;
            
            public float DistanceToSource()
            {
                return (sourcePixel - currentPixel).Distance();
            }
        }

        /// <summary>
        /// flood fills from every pixel whose value is are greater than 0.
        /// This creates a nice blur like effect. Useful for making thick lines from the generated map
        /// </summary>
        /// <param name="splatData"></param>
        /// <param name="decay"></param>
        public void DecayFloodFill(float decayMultiplier)
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();

            int textureSize = splatData.Data.GetLength(0);
            var queue = new Queue<FloodFillPixelInfo>();
            for (int y = 0; y < textureSize; y++)
            {
                for (int x = 0; x < textureSize; x++)
                {
                    float value = splatData.Data[x, y];
                    if (value > 0.01f)
                    {
                        var info = new FloodFillPixelInfo();
                        info.currentPixel = new IntVector2(x, y);
                        info.sourcePixel = new IntVector2(x, y);
                        info.startValue = value;
                        queue.Enqueue(info);
                    }
                }
            }

            while (queue.Count > 0)
            {
                var front = queue.Dequeue();
                AddNeighbor(queue, ref front, textureSize, -1, 0, decayMultiplier);
                AddNeighbor(queue, ref front, textureSize, 1, 0, decayMultiplier);
                AddNeighbor(queue, ref front, textureSize, 0, 1, decayMultiplier);
                AddNeighbor(queue, ref front, textureSize, 0, -1, decayMultiplier);
            }

            sw.Stop();
            Debug.Log("Time elapsed: " + (sw.ElapsedMilliseconds / 1000.0f) + " s");
        }

        void AddNeighbor(Queue<FloodFillPixelInfo> queue, ref FloodFillPixelInfo info, int textureSize, int dx, int dy, float decayMultiplier)
        {
            FloodFillPixelInfo neighbor = info;
            neighbor.currentPixel.x += dx;
            neighbor.currentPixel.y += dy;
            if (neighbor.currentPixel.x < 0 || neighbor.currentPixel.x >= textureSize ||
                neighbor.currentPixel.y < 0 || neighbor.currentPixel.y >= textureSize)
            {
                // Out of bounds
                return;
            }

            var distance = neighbor.DistanceToSource();
            var weight = (neighbor.startValue - distance / textureSize * decayMultiplier);
            weight = Mathf.Clamp01(weight);
            if (weight <= 0)
            {
                return;
            }

            int nx = neighbor.currentPixel.x;
            int ny = neighbor.currentPixel.y;
            float existingWeight = splatData.Data[nx, ny];
            if (weight > existingWeight)
            {
                splatData.Data[nx, ny] = weight;
                queue.Enqueue(neighbor);
            }
        }


        int MapToTextureCoord(float value01, int lastIndex)
        {
            return Mathf.RoundToInt(lastIndex * value01);
        }

        void Swap(ref Vector2 a, ref Vector2 b)
        {
            Vector2 t = a;
            a = b;
            b = t;
        }

        public void ApplyCurve(AnimationCurve curve)
        {
            int textureSize = splatData.Data.GetLength(0);
            for (int y = 0; y < textureSize; y++)
            {
                for (int x = 0; x < textureSize; x++)
                {
                    float value = splatData.Data[x, y];
                    splatData.Data[x, y] = curve.Evaluate(value);
                }
            }
        }

        /// <summary>
        /// Draws a single pixel thick line. Values are normalized [0..1]
        /// </summary>
        /// <param name="start"></param>
        /// <param name="end"></param>
        public void DrawLine(Vector2 start, Vector2 end, float value)
        {
            // Bresenham's line algorithm
            // https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm

            int texLastIndex = splatData.Data.GetLength(0) - 1;

            if (start.x > end.x) Swap(ref start, ref end);
            
            int x0 = MapToTextureCoord(start.x, texLastIndex);
            int y0 = MapToTextureCoord(start.y, texLastIndex);

            int x1 = MapToTextureCoord(end.x, texLastIndex);
            int y1 = MapToTextureCoord(end.y, texLastIndex);


            x0 = Mathf.Clamp(x0, 0, texLastIndex);
            y0 = Mathf.Clamp(y0, 0, texLastIndex);
            x1 = Mathf.Clamp(x1, 0, texLastIndex);
            y1 = Mathf.Clamp(y1, 0, texLastIndex);

            float slope = (y1 - y0) / (float)(x1 - x0);

            if (Mathf.Abs(x1 - x0) > Mathf.Abs(y1 - y0))
            {
                for (int x = x0; x <= x1; x++)
                {
                    float yf = slope * (x - x0) + y0;
                    int y = Mathf.RoundToInt(yf);
                    splatData.Data[x, y] = value;
                }
            }
            else
            {
                int sy = Mathf.Min(y0, y1);
                int ey = Mathf.Max(y0, y1);
                for (int y = sy; y <= ey; y++)
                {
                    float xf = (y - y0) / slope + x0;
                    int x = Mathf.RoundToInt(xf);
                    splatData.Data[x, y] = value;
                }
            }
        }

        public void DrawCircle(Vector2 center, float radius01, float value)
        {
            // Bresenham's circle algorithm
            // http://www.geeksforgeeks.org/bresenhams-circle-drawing-algorithm/

            int texLastIndex = splatData.Data.GetLength(0) - 1;

            int r = Mathf.RoundToInt(texLastIndex * Mathf.Clamp01(radius01));
            int cx = MapToTextureCoord(center.x, texLastIndex);
            int cy = MapToTextureCoord(center.y, texLastIndex);
            
            int x = 0;
            int y = r;

            int d = 3 - (2 * r);

            while (x <= y)
            {
                _DrawCircleOctants(cx, cy, x, y, value);
                x++;
                if (d < 0)
                {
                    d = d + (4 * x) + 6;
                }
                else
                {
                    d = d + 4 * (x - y) + 10;
                    y--;
                }
            }

        }

        void SetPixel(int x, int y, float value)
        {
            int texLastIndex = splatData.Data.GetLength(0) - 1;
            if (x >= 0 && x < texLastIndex && y >= 0 && y < texLastIndex)
            {
                splatData.Data[x, y] = value;
            }
        }
        void _DrawCircleOctants(int xc, int yc, int x, int y, float value)
        {
            SetPixel(xc + x, yc + y, value);
            SetPixel(xc - x, yc + y, value);
            SetPixel(xc + x, yc - y, value);
            SetPixel(xc - x, yc - y, value);
            SetPixel(xc + y, yc + x, value);
            SetPixel(xc - y, yc + x, value);
            SetPixel(xc + y, yc - x, value);
            SetPixel(xc - y, yc - x, value);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Splatmaps\Debug\DungeonSplatmapVisualizer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Splatmap
{
    public class DungeonSplatmapVisualizer : DungeonEventListener
    {
        public Renderer debugRenderer;
        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model) {
            var splatmapComponent = GetComponent<DungeonSplatmap>();
            if (splatmapComponent != null)
            {
                var splatAsset = splatmapComponent.splatmap;
                if (splatAsset != null && splatAsset.splatTextures.Length > 0 && debugRenderer != null)
                {
                    var roadmap = splatAsset.splatTextures[0];
                    debugRenderer.material.mainTexture = roadmap;
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\GraphNodes\GameObjectArrayNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Graphs
{
	[System.Serializable]
	public class GameObjectArrayNode : VisualNode {
		public GameObject[] Templates;

		public override void Initialize(string id, Graph graph) {
			base.Initialize(id, graph);
			UpdateName("GameObjectArrayNode_");

			if (caption == null) {
				caption = "Game Object Array Node";
			}
		}

		public override void CopyFrom(GraphNode node)
		{
			base.CopyFrom(node);

			var goNode = node as GameObjectArrayNode;
			if (goNode == null) return;
			Templates = new GameObject[goNode.Templates.Length];
			System.Array.Copy (goNode.Templates, Templates, goNode.Templates.Length);
		}
	}

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\GraphNodes\GameObjectNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Graphs
{
	
	[System.Serializable]
	public class GameObjectNode : VisualNode {
		public GameObject Template;

		public override void Initialize(string id, Graph graph) {
			base.Initialize(id, graph);
			UpdateName("MeshNode_");

			if (caption == null) {
				caption = "Game Object Node";
			}
		}

        public override void CopyFrom(GraphNode node)
        {
            base.CopyFrom(node);

            var goNode = node as GameObjectNode;
            if (goNode == null) return;

            Template = goNode.Template;
        }
	}

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\GraphNodes\MarkerEmitterNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Graphs
{

	public class MarkerEmitterNode : PlaceableNode {
		[SerializeField]
		MarkerNode marker;

		public MarkerNode Marker {
			get {
				return marker;
			}
			set {
				marker = value;
			}
		}

		public override void Initialize(string id, Graph graph) {
			base.Initialize(id, graph);
			UpdateName("MarkerEmitterNode_");
			
			Size = new Vector2(120, 50);
			
			if (inputPins == null) {
				inputPins = new List<GraphPin>();
				
				CreatePin(GraphPinType.Input,
				          new Vector2(60, -2),
				          new Rect(-40, 0, 80, 15),
				          new Vector2(0, -1));
			}
			
			if (outputPins == null) {
				outputPins = new List<GraphPin>();
			}
			
			if (caption == null) {
				caption = "MarkerEmitter";
			}
		}
	}

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\GraphNodes\MarkerNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;

namespace DungeonArchitect.Graphs
{
	public class MarkerNode : GraphNode  {

		public string MarkerName
		{
			get => caption;
			set => caption = value;
		}
		
		public override void Initialize(string id, Graph graph) {
			base.Initialize(id, graph);
			UpdateName("MarkerNode_");
			
			Size = new Vector2(120, 50);
			
			if (inputPins == null) {
				inputPins = new List<GraphPin>();
			}
			
			if (outputPins == null) {
				outputPins = new List<GraphPin>();

				CreatePin(GraphPinType.Output,
				          new Vector2(60, 48),
				          new Rect(-40, -15, 80, 15),
				          new Vector2(0, 1));
			}
			
			if (caption == null) {
				caption = "Marker";
			}
		}


	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\GraphNodes\PlaceableNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Graphs
{
    public class PlaceableNode : GraphNode
    {
        public Matrix4x4 offset = Matrix4x4.identity;
        public bool consumeOnAttach = true;
        public float attachmentProbability = 1.0f;


        public override void CopyFrom(GraphNode node)
        {
            base.CopyFrom(node);

            var otherNode = node as PlaceableNode;
            if (otherNode == null) return;

            this.offset = otherNode.offset;
            this.consumeOnAttach = otherNode.consumeOnAttach;
            this.attachmentProbability = otherNode.attachmentProbability;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\GraphNodes\SpriteNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Graphs
{
	public enum DungeonSpriteCollisionType {
		None,
		Box,
		Circle,
		Polygon,
	}

	[System.Serializable]
	public class SpriteNode : VisualNode {
		public Sprite sprite;
		public Color color = new Color(1, 1, 1, 1);
		public Material materialOverride;
		public string sortingLayerName;
		public int orderInLayer;

		// Physics properties
		public DungeonSpriteCollisionType collisionType = DungeonSpriteCollisionType.None;
		public PhysicsMaterial2D physicsMaterial;
		public Vector2 physicsOffset = Vector2.zero;
		public Vector2 physicsSize = Vector2.one;
		public float physicsRadius = 0.5f;


		public override void Initialize(string id, Graph graph) {
			base.Initialize(id, graph);
			UpdateName("SpriteNode_");
			
			if (caption == null) {
				caption = "Sprite Node";
			}

		}
		
		public override void CopyFrom(GraphNode node)
		{
			base.CopyFrom(node);
			
			var spriteNode = node as SpriteNode;
			if (spriteNode == null) return;
			
			sprite = spriteNode.sprite;
			color = spriteNode.color;
			materialOverride = spriteNode.materialOverride;
			sortingLayerName = spriteNode.sortingLayerName;
			orderInLayer = spriteNode.orderInLayer;

		}
	}
	
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\GraphNodes\ThemeGraphSchema.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Linq;
using System.Text;
using System.Collections.Generic;
using MarkerChildMap = System.Collections.Generic.Dictionary<DungeonArchitect.Graphs.MarkerNode, System.Collections.Generic.List<DungeonArchitect.Graphs.MarkerNode>>;

namespace DungeonArchitect.Graphs
{
    public class ThemeGraphSchema : GraphSchema
    {
        public override bool CanCreateLink(GraphPin output, GraphPin input, out string errorMessage)
        {
            errorMessage = "";
            if (output == null || input == null)
            {
                errorMessage = "Invalid connection";
                return false;
            }
            if (output.PinType != GraphPinType.Output || input.PinType != GraphPinType.Input)
            {
                errorMessage = "Not Allowed";
                return false;
            }

            var sourceNode = output.Node;
            var destNode = input.Node;

            bool valid = (sourceNode is MarkerNode && destNode is VisualNode) ||
                         (sourceNode is VisualNode && destNode is MarkerEmitterNode);

            if (!valid)
            {
                errorMessage = "Not Allowed";
                return false;
            }

            // Check for loops. We dont allow loops in the graph as they do not make sense and would also cause an infinite loop in code
            var cyclePath = new List<MarkerNode>();
            if (ContainsLoops(output, input, ref cyclePath))
            {
                errorMessage = "Not Allowed. Contains Loop: " + CombineMarkerNames(cyclePath);
                return false;
            }

            
            return base.CanCreateLink(output, input, out errorMessage);
        }
        
        
        static string CombineMarkerNames(List<MarkerNode> markerNodes)
        {
            var builder = new StringBuilder();
            foreach (var markerNode in markerNodes)
            {
                if (builder.Length > 0)
                {
                    builder.Append(" > ");
                }
                builder.Append(markerNode.Caption);
            }
            return builder.ToString();
        }

        static bool ContainsLoops(GraphPin a, GraphPin b, ref List<MarkerNode> cyclePath)
        {
            cyclePath.Clear();
            if (a == null || b == null) return false;
            var graph = a.Node.Graph;
            var markerNodes = graph.GetNodes<MarkerNode>();

            var markerChildMap = new MarkerChildMap();
            foreach (var markerNode in markerNodes)
            {
                var emitters = GetEmitters(markerNode, a, b);
                var outMarkers = new List<MarkerNode>();
                foreach (var emitter in emitters)
                {
                    if (emitter.Marker != null)
                    {
                        outMarkers.Add(emitter.Marker);
                    }
                }
                markerChildMap.Add(markerNode, outMarkers);
            }

            if (FindCycles(ref markerChildMap, ref cyclePath))
            {
                return true;
            }

            // TODO: Implement me.  Important to avoid infinite loops later in the pipeline, if this graph has a loop
            return false;
        }

        static bool FindCycles(ref MarkerChildMap markerChildMap, ref List<MarkerNode> cyclePath)
        {
            var visited = new HashSet<MarkerNode>();
            foreach (var markerNode in markerChildMap.Keys)
            {
                if (visited.Contains(markerNode))
                {
                    // Already processed
                    // TODO: check if we need this as it would never happen
                    continue;
                }

                var traversePath = new List<MarkerNode>();
                traversePath.Add(markerNode);
                if (CheckCycleDFS(ref markerChildMap, ref traversePath))
                {
                    cyclePath = traversePath;
                    return true;
                }
            }
            return false;
        }

        static bool CheckCycleDFS(ref MarkerChildMap markerChildMap, ref List<MarkerNode> traversePath)
        {
            var topMarker = traversePath.Last();
            if (!markerChildMap.ContainsKey(topMarker)) return false;

            var childMarkers = markerChildMap[topMarker];
            foreach (var childMarker in childMarkers)
            {

                if (traversePath.Contains(childMarker))
                {
                    // Cycle detected
                    traversePath.Add(childMarker);
                    return true;
                }

                traversePath.Add(childMarker);
                var containsCycle = CheckCycleDFS(ref markerChildMap, ref traversePath);
                if (containsCycle)
                {
                    return true;
                }

                // Remove the last element since we are done processing it
                traversePath.RemoveAt(traversePath.Count - 1);
            }
            return false;
        }

        static GraphNode[] GetOutgoingNodes(GraphNode node, GraphPin a, GraphPin b)
        {
            var result = new List<GraphNode>();
            var outPin = node.OutputPin;
            if (outPin != null)
            {
                foreach (var link in outPin.GetConntectedLinks())
                {
                    var inPin = link.Input;
                    if (inPin != null)
                    {
                        var nextNode = inPin.Node;
                        if (nextNode != null)
                        {
                            result.Add(nextNode);
                        }
                    }
                }
            }

            if (a != null && b != null)
            {
                if (outPin == a && b.Node != null)
                {
                    result.Add(b.Node);
                }
                if (outPin == b && a.Node != null)
                {
                    result.Add(a.Node);
                }
            }

            return result.ToArray();
        }

        static MarkerEmitterNode[] GetEmitters(MarkerNode markerNode, GraphPin a, GraphPin b)
        {
            var emitters = new List<MarkerEmitterNode>();

            var meshNodes = GetOutgoingNodes(markerNode, a, b);
            foreach (var meshNode in meshNodes)
            {
                var emitterNodes = GetOutgoingNodes(meshNode, a, b);
                foreach (var emitterNode in emitterNodes)
                {
                    if (emitterNode is MarkerEmitterNode)
                    {
                        emitters.Add(emitterNode as MarkerEmitterNode);
                    }
                }
            }

            return emitters.ToArray();
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\GraphNodes\VisualNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Graphs
{
	
	[System.Serializable]
	public class VisualNode : PlaceableNode {
		/// <summary>
		/// Indicates if the game object created from this visual node is set to static
		/// If you are spawning NPCs or other dynamic objects, uncheck this
		/// </summary>
		public bool IsStatic = false;

		/// <summary>
		/// Indicates of the geometry in this node contributes to the navigation mesh
		/// You should enable this only if necessary to improve navmesh generation performance
		/// </summary>
		public bool affectsNavigation = true;

		/// <summary>
		/// Indicates if the selection rule is enabled.  The selection rule will not run if this is disabled
		/// </summary>
		public bool selectionRuleEnabled = false;

		/// <summary>
		/// The class name of the selection rule. 
		/// Selection rules let you specify behavior logic for selecting your nodes
		/// </summary>
		public string selectionRuleClassName;

		/// <summary>
		/// Indicates if the transform rule is enabled.  The transform rule will not run if this is disabled
		/// </summary>
		public bool transformRuleEnabled = false;

		/// <summary>
		/// The class name of the transformation rule.  
		/// Transform rules let you specify behavior logic to apply the offset on the nodes
		/// </summary>
		public string transformRuleClassName;

        /// <summary>
        /// Flag to indicate if spatial constraints are to be used
        /// </summary>
        public bool useSpatialConstraint = false;

        /// <summary>
        /// Spatial constraints lets you select a node based on nearby neighbor constraints
        /// </summary>
        [SerializeField]
        public SpatialConstraintAsset spatialConstraint;
        
		public override void Initialize(string id, Graph graph) {
			base.Initialize(id, graph);
			Size = new Vector2(120, 120);
			bool createInputPins = false;
			bool createOutputPins = false;
			
			if (inputPins == null) {
				inputPins = new List<GraphPin>();
				createInputPins = true;
			}
			if (outputPins == null) {
				outputPins = new List<GraphPin>();
				createOutputPins = true;
			}
			
			if (createInputPins) {
				// Create an input pin on the top
				CreatePin(GraphPinType.Input,
				          new Vector2(60, 0),
				          new Rect(-40, 0, 80, 15),
				          new Vector2(0, -1));
			}
			
			if (createOutputPins) {
				// Create an output pin at the bottom
				CreatePin(GraphPinType.Output,
				          new Vector2(60, 120),
				          new Rect(-40, -15, 80, 15),
				          new Vector2(0, 1));
			}
            

        }
		
		public override void CopyFrom(GraphNode node)
		{
			base.CopyFrom(node);
			
			var visualNode = node as VisualNode;
			if (visualNode == null) return;
			
			IsStatic = visualNode.IsStatic;
			affectsNavigation = visualNode.affectsNavigation;
			selectionRuleEnabled = visualNode.selectionRuleEnabled;
			selectionRuleClassName = visualNode.selectionRuleClassName;
			transformRuleEnabled = visualNode.transformRuleEnabled;
			transformRuleClassName = visualNode.transformRuleClassName;
		}
        
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\SceneProvider\DungeonSceneObjectInstantiator.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    public interface IDungeonSceneObjectInstantiator
    {
        GameObject Instantiate(GameObject template, Vector3 position, Quaternion rotation, Vector3 scale, Transform parent);
    }
    
    public class RuntimeDungeonSceneObjectInstantiator : IDungeonSceneObjectInstantiator
    {
        public GameObject Instantiate(GameObject template, Vector3 position, Quaternion rotation, Vector3 scale, Transform parent)
        {
            var gameObj = MonoBehaviour.Instantiate(template) as GameObject;
            gameObj.transform.SetParent(parent);
            gameObj.transform.position = position;
            gameObj.transform.rotation = rotation;
            gameObj.transform.localScale = scale;
            return gameObj;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\SceneProvider\DungeonSceneObjectSpawner.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Utils;
using DungeonArchitect.Themeing;

namespace DungeonArchitect
{
    public struct DungeonNodeSpawnData
    {
        public DungeonThemeItem nodeData;
        public Matrix4x4 transform;
        public PropSocket socket;
        public float _sortDistance;
    }

    /// <summary>
    /// Takes care of spawning the dungeon objects from the input list
    /// This allows us to use different strategies to spawn the objects (e.g. synchronous or async spawning over multiple frames)
    /// </summary>
    public abstract class DungeonSceneObjectSpawner
    {
        public abstract void Spawn(DungeonNodeSpawnData[] spawnDataList, DungeonSceneProvider sceneProvider, PMRandom random, IDungeonSceneObjectInstantiator objectInstantiator, DungeonItemSpawnListener[] spawnListeners);
        public virtual void Tick() { }
        public virtual void Destroy() { } 

        protected GameObject SpawnNodeItem(DungeonNodeSpawnData data, DungeonSceneProvider sceneProvider, PMRandom random, IDungeonSceneObjectInstantiator objectInstantiator)
        {
            if (data.socket.markForDeletion)
            {
                return null;
            }

            GameObject dungeonItem = null;
            var nodeData = data.nodeData;

            if (nodeData is GameObjectDungeonThemeItem)
            {
                var gameObjectProp = nodeData as GameObjectDungeonThemeItem;
                dungeonItem = sceneProvider.AddGameObject(gameObjectProp, data.transform, objectInstantiator);
            }
            else if (nodeData is GameObjectArrayDungeonThemeItem)
            {
                var gameObjectArrayProp = nodeData as GameObjectArrayDungeonThemeItem;
                int count = gameObjectArrayProp.Templates.Length;
                if (count > 0)
                {
                    int index = Mathf.FloorToInt(random.GetNextUniformFloat() * count) % count;
                    dungeonItem = sceneProvider.AddGameObjectFromArray(gameObjectArrayProp, index, data.transform, objectInstantiator);
                }
            }
            else if (nodeData is SpriteDungeonThemeItem)
            {
                var spriteProp = nodeData as SpriteDungeonThemeItem;
                dungeonItem = sceneProvider.AddSprite(spriteProp, data.transform, objectInstantiator);
            }

            TagDungeonItemUserData(dungeonItem, data.socket.cellId);

            return dungeonItem;
        }

        protected void TagDungeonItemUserData(GameObject dungeonItem, int cellID)
        {
            if (dungeonItem == null) return;

            var data = dungeonItem.GetComponent<DungeonSceneProviderData>();
            if (data != null)
            {
                data.userData = cellID;
            }
        }

        protected class SpawnInfo
        {
            public DungeonNodeSpawnData spawnData;
            public GameObject spawnedItem;
        }

        protected void NotifySpawnListeners(DungeonItemSpawnListener[] spawnListeners, List<SpawnInfo> spawnList)
        {
            foreach (var spawnListener in spawnListeners)
            {
                if (spawnListener == null) continue;
                
                foreach (var spawnInfo in spawnList)
                { 
                    if (spawnInfo != null && spawnInfo.spawnedItem != null)
                    {
                        spawnListener.SetMetadata(spawnInfo.spawnedItem, spawnInfo.spawnData);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Spawn all the objects from the list in the same frame
    /// </summary>
    public class SyncDungeonSceneObjectSpawner : DungeonSceneObjectSpawner
    {
        public override void Spawn(DungeonNodeSpawnData[] spawnDataList, DungeonSceneProvider sceneProvider, PMRandom random, IDungeonSceneObjectInstantiator objectInstantiator, DungeonItemSpawnListener[] spawnListeners)
        {
            var spawnList = new List<SpawnInfo>();

            sceneProvider.OnDungeonBuildStart();
            foreach (var spawnData in spawnDataList)
            {
                var spawnInfo = new SpawnInfo();
                spawnInfo.spawnData = spawnData;
                spawnInfo.spawnedItem = SpawnNodeItem(spawnData, sceneProvider, random, objectInstantiator);
                spawnList.Add(spawnInfo);
            }
            sceneProvider.OnDungeonBuildStop();

            NotifySpawnListeners(spawnListeners, spawnList);

        }
    }

    /// <summary>
    /// Async spawning of dungeon items spread across multiple frames
    /// </summary>
    public class AsyncDungeonSceneObjectSpawner : DungeonSceneObjectSpawner
    {
        private long maxMilliPerFrame;
        private Vector3 buildOrigin;
        private DungeonSceneProvider sceneProvider;
        private PMRandom random;
        private IDungeonSceneObjectInstantiator objectInstantiator;
        private DungeonItemSpawnListener[] spawnListeners;
        private Queue<DungeonNodeSpawnData> buildQueue;

        List<SpawnInfo> spawnList = new List<SpawnInfo>();

        public AsyncDungeonSceneObjectSpawner(long maxMilliPerFrame, Vector3 buildOrigin)
        {
            this.maxMilliPerFrame = maxMilliPerFrame;
            this.buildOrigin = buildOrigin;
        }

        public class SpawnListSorter : IComparer<DungeonNodeSpawnData>
        {
            // Call CaseInsensitiveComparer.Compare with the parameters reversed.
            public int Compare(DungeonNodeSpawnData a, DungeonNodeSpawnData b)
            {
                if (a._sortDistance == b._sortDistance) return 0;
                return a._sortDistance < b._sortDistance ? -1 : 1;
            }
        }

        public override void Spawn(DungeonNodeSpawnData[] spawnDataList, DungeonSceneProvider sceneProvider, PMRandom random, IDungeonSceneObjectInstantiator objectInstantiator, DungeonItemSpawnListener[] spawnListeners)
        {
            this.sceneProvider = sceneProvider;
            this.random = random;
            this.objectInstantiator = objectInstantiator;
            this.spawnListeners = spawnListeners;

            for (int i = 0; i < spawnDataList.Length; i++)
            {
                var position = Matrix.GetTranslation(ref spawnDataList[i].transform);
                spawnDataList[i]._sortDistance = (position - buildOrigin).sqrMagnitude;
            }
            System.Array.Sort(spawnDataList, new SpawnListSorter());

            spawnList.Clear();
            sceneProvider.OnDungeonBuildStart();

            buildQueue = new Queue<DungeonNodeSpawnData>(spawnDataList);

        }

        public override void Tick()
        {
            if (buildQueue == null || buildQueue.Count == 0)
            {
                return;
            }

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            while (buildQueue.Count > 0 && stopwatch.ElapsedMilliseconds < maxMilliPerFrame)
            {
                var spawnData = buildQueue.Dequeue();

                var spawnInfo = new SpawnInfo();
                spawnInfo.spawnData = spawnData;
                spawnInfo.spawnedItem = SpawnNodeItem(spawnData, sceneProvider, random, objectInstantiator);
                spawnList.Add(spawnInfo);
            }

            if (buildQueue.Count == 0)
            {
                sceneProvider.OnDungeonBuildStop();

                NotifySpawnListeners(spawnListeners, spawnList);
                spawnList.Clear();
            }
        }

        public override void Destroy()
        {
            buildQueue = null;

            if (sceneProvider != null)
            {
                sceneProvider.OnDungeonBuildStop();
                spawnList.Clear();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\SceneProvider\DungeonSceneProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Utils;
using DungeonArchitect.Graphs;
using DungeonArchitect.Themeing;

namespace DungeonArchitect
{
    /// <summary>
    /// A scene provider instantiates game objects into the scene.  
    /// Implementations can customize the instantiation process if needed (e.g. object pooling etc)
    /// </summary>
	public class DungeonSceneProvider : MonoBehaviour {
        /// <summary>
        /// Called when build is started
        /// </summary>
        public virtual void OnDungeonBuildStart()
        {
            Initialize();
        }

        /// <summary>
        /// Called after build has ended
        /// </summary>
		public virtual void OnDungeonBuildStop() {}

        /// <summary>
        /// Request the creation of a game object
        /// </summary>
        /// <param name="gameObjectProp">The template to use for instantiation</param>
        /// <param name="transform">The transform of the instantiated game object</param>
		public virtual GameObject AddGameObject(GameObjectDungeonThemeItem gameObjectProp, Matrix4x4 transform, IDungeonSceneObjectInstantiator objectInstantiator) { return null; }

		/// <summary>
		/// Requests the creation of a game object from the provided list
		/// </summary>
		/// <returns>The game object from array.</returns>
		/// <param name="gameObjectArrayProp">Game object array property.</param>
		/// <param name="index">Index.</param>
		/// <param name="transform">Transform.</param>
		public virtual GameObject AddGameObjectFromArray(GameObjectArrayDungeonThemeItem gameObjectArrayProp, int index, Matrix4x4 transform, IDungeonSceneObjectInstantiator objectInstantiator) { return null; }

        /// <summary>
        /// Request the creation of a sprite object
        /// </summary>
        /// <param name="spriteProp">The sprite game object template reference</param>
        /// <param name="transform">The transform of the prop</param>
		public virtual GameObject AddSprite(SpriteDungeonThemeItem spriteProp, Matrix4x4 transform, IDungeonSceneObjectInstantiator objectInstantiator) { return null; }
        //public virtual void AddLight(GameObject Template, Matrix4x4 transform, string NodeId) {}

        /// <summary>
        /// Dungeon config used by the builder
        /// </summary>
		protected DungeonConfig config;

        /// <summary>
        /// The owning dungeon actor reference
        /// </summary>
        protected Dungeon dungeon;

        /// <summary>
        /// The parent for all spawned game objects.  Assign this to create all spawned objects
        /// underneath it to avoid cluttering up the hierarchy
        /// </summary>
		public GameObject itemParent;

		void Awake() {
            Initialize();
		}

        protected void Initialize()
        {
            config = GetComponent<DungeonConfig>();
            dungeon = GetComponent<Dungeon>();
            itemParent = GameObject.Find("DungeonHolder");
            if (itemParent != null && !itemParent.isStatic)
            {
                // The parent should be static for performance reasons, or all child generated items would be considered as non-static (? TODO: confirm)
                Debug.LogWarning("Dungeon Scene Items parent is not marked static (" + itemParent.name + ").  Please mark as static to improve performance");
            }
        }

		protected GameObject BuildGameObject(GameObjectDungeonThemeItem gameObjectProp, Matrix4x4 transform, IDungeonSceneObjectInstantiator objectInstantiator) {
			return BuildGameObject (gameObjectProp.Template, gameObjectProp.NodeId, gameObjectProp.affectsNavigation, transform, gameObjectProp.externallyManaged, objectInstantiator);
		}

		protected GameObject BuildGameObjectFromArray(GameObjectArrayDungeonThemeItem gameObjectArrayProp, int index, Matrix4x4 transform, IDungeonSceneObjectInstantiator objectInstantiator) {
			if (index < 0 || index >= gameObjectArrayProp.Templates.Length) {
				// Invalid index
				return null;
			}
            GameObject template = gameObjectArrayProp.Templates[index];
            if (template == null)
            {
                return null;
            }

			return BuildGameObject(template, gameObjectArrayProp.NodeId, gameObjectArrayProp.affectsNavigation, transform, gameObjectArrayProp.externallyManaged, objectInstantiator);
		}

		protected GameObject BuildGameObject(GameObject template, string nodeId, bool affectsNavigation, Matrix4x4 transform, bool externallyManaged, IDungeonSceneObjectInstantiator objectInstantiator) {
			Matrix.DecomposeMatrix(ref transform, out _position, out _rotation, out _scale);
			
			var MeshTemplate = template;
			string NodeId = nodeId;

            var parentTransform = (itemParent != null) ? itemParent.transform : null;
            var gameObj = objectInstantiator.Instantiate(MeshTemplate, _position, _rotation, _scale, parentTransform);
            
			var data = gameObj.AddComponent<DungeonSceneProviderData> ();
			data.NodeId = NodeId;
			data.dungeon = dungeon;
			data.affectsNavigation = affectsNavigation;
			data.externallyManaged = externallyManaged;
			
			return gameObj;
		}

		protected void FlipSpriteTransform(ref Matrix4x4 transform, Sprite sprite) {
			Matrix.DecomposeMatrix(ref transform, out _position, out _rotation, out _scale);

			FlipSpritePosition(ref _position);

			//var basePixelScale = 1.0f / sprite.pixelsPerUnit;	// TODO: Verify this
			//var spriteScale = new Vector3(sprite.rect.width * basePixelScale, sprite.rect.height * basePixelScale, 1);
			//_scale = Vector3.Scale(_scale, spriteScale);

			// flip the rotation
			var angles = _rotation.eulerAngles;
			var t = angles.z;
			angles.z = -angles.y;
			angles.y = t;
			_rotation = Quaternion.Euler(angles);

			transform.SetTRS(_position, _rotation, _scale);
		}
		
		protected void FlipSpritePosition(ref Matrix4x4 transform) {
			var position = Matrix.GetTranslation(ref transform);
			
			FlipSpritePosition(ref _position);
			
			Matrix.SetTranslation(ref transform, position);
		}

		protected void FlipSpritePosition(ref Vector3 position) {
			var z = position.z;
			position.z = position.y;
			position.y = z;
		}

        public virtual void InvalidateNodeCache(string NodeId) {  }

		protected GameObject BuildSpriteObject(SpriteDungeonThemeItem spriteData, Matrix4x4 transform, string NodeId) {
			if (spriteData.sprite == null) return null;
			var gameObj = new GameObject(spriteData.sprite.name);
			
			// Setup the sprite
			var spriteRenderer = gameObj.AddComponent<SpriteRenderer>();
			spriteRenderer.sprite = spriteData.sprite;
			spriteRenderer.color = spriteData.color;
			spriteRenderer.sortingOrder = spriteData.orderInLayer;
			
			if (spriteData.materialOverride != null) {
				spriteRenderer.material = spriteData.materialOverride;
			}
			if (spriteData.sortingLayerName != null && spriteData.sortingLayerName.Length > 0) {
				spriteRenderer.sortingLayerName = spriteData.sortingLayerName;
			}

			// Setup the sprite collision
			var collisionType = spriteData.collisionType;
			if (collisionType != DungeonSpriteCollisionType.None) {
				Vector2 baseScaleMultiplier = Vector2.one;
				var sprite = spriteData.sprite;
				var pixelsPerUnit = sprite.pixelsPerUnit;
				baseScaleMultiplier.x = sprite.rect.width / pixelsPerUnit;
				baseScaleMultiplier.y = sprite.rect.height / pixelsPerUnit;

				Collider2D collider = null;
				if (collisionType == DungeonSpriteCollisionType.Box) {
					var boxCollider = gameObj.AddComponent<BoxCollider2D>();
					boxCollider.size = Vector3.Scale(spriteData.physicsSize, baseScaleMultiplier);
					collider = boxCollider;
				}
				else if (collisionType == DungeonSpriteCollisionType.Circle) {
					var circleCollider = gameObj.AddComponent<CircleCollider2D>();
					circleCollider.radius = spriteData.physicsRadius * baseScaleMultiplier.x;
					collider = circleCollider;
				}
				else if (collisionType == DungeonSpriteCollisionType.Polygon) {
					collider = gameObj.AddComponent<PolygonCollider2D>();
				}

				if (collider != null) {
					collider.sharedMaterial = spriteData.physicsMaterial;
					collider.offset = Vector3.Scale(spriteData.physicsOffset, baseScaleMultiplier);
				}
			}


			// Set the transform
			Matrix.DecomposeMatrix(ref transform, out _position, out _rotation, out _scale);
			gameObj.transform.position = _position;
			gameObj.transform.rotation = _rotation;
			gameObj.transform.localScale = _scale;
			
			// Setup dungeon related parameters
			if (itemParent != null) {
				gameObj.transform.SetParent(itemParent.transform, true);
			}
			
			var data = gameObj.AddComponent<DungeonSceneProviderData> ();
			data.NodeId = NodeId;
            data.dungeon = dungeon;
            data.affectsNavigation = spriteData.affectsNavigation;
			
			return gameObj;
		}
		
		protected Vector3 _position = new Vector3();
		protected Quaternion _rotation = new Quaternion();
		protected Vector3 _scale = new Vector3();
		protected void SetTransform(Transform transform, Matrix4x4 matrix) {
			Matrix.DecomposeMatrix(ref matrix, out _position, out _rotation, out _scale);
			transform.position = _position;
			transform.rotation = _rotation;
			transform.localScale = _scale;
		}
	}
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\SceneProvider\DungeonSceneProviderData.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Meta-data added to each spawned game object in the scene.  This is used to identify objects that belong to the dungeons, for later destruction and rebuilding
    /// </summary>
    public class DungeonSceneProviderData : MonoBehaviour
    {
		/// <summary>
		/// The graph node id this game object was spawned from in the theme graph
		/// </summary>
        public string NodeId;

		/// <summary>
		/// The dungeon this game object belongs to
		/// </summary>
        public Dungeon dungeon;

		/// <summary>
		/// Indicates if the geometry in this node contributes to navigation mesh generation
		/// This flag reflects the state set in the theme graph's visual node affectsNavigation flag
		/// </summary>
		public bool affectsNavigation = false;

        /// <summary>
        /// The custom user data for the builder to use
        /// </summary>
        public int userData = -1;

        /// <summary>
        /// If true, the theme engine will not destroy this object on rebuilds as the lifecycle is managed externally
        /// </summary>
        public bool externallyManaged = false;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\Visualization\DungeonMarkerVisualizerComponent.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Themeing
{   
    public class ThemeEditorVisMarkerGeometry
    {
        public Vector3[] Vertices;
        public Vector2[] UV;
        public int[] Indices;
    }
    
    public class ThemeEditorVisualizationState
    {
        public ThemeEditorVisMarkerGeometry LocalGeometry;
        public Matrix4x4[] MarkerTransforms;
        public Material Material;
    }

    public class DungeonMarkerVisualizerComponent : MonoBehaviour
    {
        void Awake()
        {
            if (Application.isPlaying)
            {
                Destroy(gameObject);
                return;
            }
        }

        public void Clear()
        {
            var meshFilter = gameObject.GetComponent<MeshFilter>();
            if (meshFilter == null)
            {
                meshFilter = gameObject.AddComponent<MeshFilter>();
            }

            meshFilter.mesh = new Mesh();
        }
        
        public void Build(ThemeEditorVisualizationState state)
        {
            var meshFilter = gameObject.GetComponent<MeshFilter>();
            if (meshFilter == null)
            {
                meshFilter = gameObject.AddComponent<MeshFilter>();
            }

            var meshRenderer = gameObject.GetComponent<MeshRenderer>();
            if (meshRenderer == null)
            {
                meshRenderer = gameObject.AddComponent<MeshRenderer>();            
            }

            var mesh = new Mesh();
            meshFilter.mesh = mesh;
            meshRenderer.material = state.Material;

            var vertices = new List<Vector3>();
            var uvs = new List<Vector2>();
            var indices = new List<int>();

            var localGeometry = state.LocalGeometry;
            
            foreach (var markerTransform in state.MarkerTransforms)
            {
                int baseIndex = vertices.Count;

                foreach (var localPosition in localGeometry.Vertices)
                {
                    var position = markerTransform.MultiplyPoint(localPosition);
                    vertices.Add(position);
                }
                
                uvs.AddRange(localGeometry.UV);
                
                foreach (var localIndex in localGeometry.Indices)
                {
                    indices.Add(baseIndex + localIndex);
                }
            }

            mesh.vertices = vertices.ToArray();
            mesh.uv = uvs.ToArray();
            mesh.triangles = indices.ToArray();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Triangulator\Geometry\Edge.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;

namespace DungeonArchitect.Triangulator.Geometry
{
	/// <summary>
	/// Edge made from two point indexes
	/// </summary>
	public class Edge : IEquatable<Edge>
	{
		/// <summary>
		/// Start of edge index
		/// </summary>
		public int p1;
		/// <summary>
		/// End of edge index
		/// </summary>
		public int p2;
		/// <summary>
		/// Initializes a new edge instance
		/// </summary>
		/// <param name="point1">Start edge vertex index</param>
		/// <param name="point2">End edge vertex index</param>
		public Edge(int point1, int point2)
		{
			p1 = point1; p2 = point2;
		}
		/// <summary>
		/// Initializes a new edge instance with start/end indexes of '0'
		/// </summary>
		public Edge()
			: this(0, 0)
		{
		}

		#region IEquatable<dEdge> Members

		/// <summary>
		/// Checks whether two edges are equal disregarding the direction of the edges
		/// </summary>
		/// <param name="other"></param>
		/// <returns></returns>
		public bool Equals(Edge other)
		{
			return
				((this.p1 == other.p2) && (this.p2 == other.p1)) ||
				((this.p1 == other.p1) && (this.p2 == other.p2));
		}

		#endregion
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Triangulator\Geometry\Point.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Triangulator.Geometry
{
	/// <summary>
	/// 2D Point with double precision
	/// </summary>
	public class Point
	{
		/// <summary>
		/// X component of point
		/// </summary>
		protected double _X;
		/// <summary>
		/// Y component of point
		/// </summary>
		protected double _Y;

		/// <summary>
		/// Initializes a new instance of a point
		/// </summary>
		/// <param name="x"></param>
		/// <param name="y"></param>
		public Point(double x, double y)
		{
			_X = x;
			_Y = y;
		}
	
		/// <summary>
		/// Gets or sets the X component of the point
		/// </summary>
		public double X
		{
			get { return _X; }
			set { _X = value; }
		}

		/// <summary>
		/// Gets or sets the Y component of the point
		/// </summary>
		public double Y
		{
			get { return _Y; }
			set { _Y = value; }
		}

		/// <summary>
		/// Makes a planar checks for if the points is spatially equal to another point.
		/// </summary>
		/// <param name="other">Point to check against</param>
		/// <returns>True if X and Y values are the same</returns>
		public bool Equals2D(Point other)
		{
			return (X == other.X && Y == other.Y);
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Triangulator\Geometry\PointN.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Triangulator.Geometry
{
	/// <summary>
	/// A point with an attribute value of type 'T'
	/// </summary>
	public class Point<T> : Point
	{
		private T _attr;
		/// <summary>
		/// Initializes a new instance of the point
		/// </summary>
		/// <param name="x">X component</param>
		/// <param name="y">Y component</param>
		/// <param name="attribute">Attribute</param>
		public Point(double x, double y, T attribute)
			: base(x, y)
		{
			_attr = attribute;
		}
		/// <summary>
		/// Initializes a new instance of the point and sets the attribute to its default value
		/// </summary>
		/// <param name="x">X component</param>
		/// <param name="y">Y component</param>
		public Point(double x, double y)
			: this(x, y, default(T))
		{
		}
		/// <summary>
		/// Gets or sets the attribute component of the point
		/// </summary>
		public T Attribute
		{
			get { return _attr; }
			set { _attr = value; }
		}

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\Triangulator\Geometry\Triangle.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Triangulator.Geometry
{
	/// <summary>
	/// Triangle made from three point indexes
	/// </summary>
	public struct Triangle
	{
		/// <summary>
		/// First vertex index in triangle
		/// </summary>
		public int p1;
		/// <summary>
		/// Second vertex index in triangle
		/// </summary>
		public int p2;
		/// <summary>
		/// Third vertex index in triangle
		/// </summary>
		public int p3;
		/// <summary>
		/// Initializes a new instance of a triangle
		/// </summary>
		/// <param name="point1">Vertex 1</param>
		/// <param name="point2">Vertex 2</param>
		/// <param name="point3">Vertex 3</param>
		public Triangle(int point1, int point2, int point3)
		{
			p1 = point1; p2 = point2; p3 = point3;
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\ExecGraph\FlowExecGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Flow.Exec
{
    public class FlowExecGraph : Graph
    {
        [SerializeField]
        public FlowExecResultGraphNode resultNode;

        public override void OnEnable()
        {
            base.OnEnable();

            hideFlags = HideFlags.HideInHierarchy;
        }
    }



    public class FlowExecGraphUtils
    {
        public static FlowExecRuleGraphNode[] GetIncomingNodes(FlowExecRuleGraphNode node)
        {
            var result = new List<FlowExecRuleGraphNode>();
            var incomingNodes = GraphUtils.GetIncomingNodes(node);
            foreach (var incomingNode in incomingNodes)
            {
                var incomingExecNode = incomingNode as FlowExecRuleGraphNode;
                if (incomingExecNode != null)
                {
                    result.Add(incomingExecNode);
                }
            }
            return result.ToArray();
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\Items\FlowItem.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Items
{
    [System.Serializable]
    public enum FlowGraphItemType
    {
        Key = 0,
        Lock = 1,
        Enemy = 2,
        Bonus = 3,
        Entrance = 4,
        Exit = 5,
        Custom = 6,
        Teleporter = 7,
    }

    [System.Serializable]
    public class FlowItem
    {
        public DungeonUID itemId;

        /// <summary>
        /// The item type
        /// </summary>
        public FlowGraphItemType type;

        public string markerName = "";

        /// <summary>
        /// Reference to other items (e.g. key locks from other nodes)
        /// </summary>
        public List<DungeonUID> referencedItemIds = new List<DungeonUID>();

        public bool editorSelected = false;

        public FlowGraphItemCustomInfo customInfo = FlowGraphItemCustomInfo.Default;

        [HideInInspector]
        public FlowDomainDataRegistry domainData = new FlowDomainDataRegistry();

        public FlowItem()
        {
            itemId = DungeonUID.NewUID();
        }
        
        public FlowItem Clone()
        {
            var newItem = new FlowItem();
            newItem.itemId = itemId;
            newItem.type = type;
            newItem.markerName = markerName;
            newItem.referencedItemIds = new List<DungeonUID>(referencedItemIds);
            newItem.customInfo = customInfo;
            newItem.domainData = domainData.Clone();
            return newItem;
        }

        public T GetDomainData<T>() where T : IFlowDomainData, new()
        {
            if (domainData == null)
            {
                return default;
            }

            return domainData.Get<T>();
        }
        
        public void SetDomainData<T>(T data) where T : IFlowDomainData, new()
        {
            if (domainData != null)
            {
                domainData.Set(data);
            }
        }
    }

    [System.Serializable]
    public struct FlowGraphItemCustomInfo
    {
        public string itemType;
        public string text;
        public Color textColor;
        public Color backgroundColor;

        public static readonly FlowGraphItemCustomInfo Default = new FlowGraphItemCustomInfo("custom", "", Color.white, Color.black);

        public FlowGraphItemCustomInfo(string itemType, string text, Color textColor, Color backgroundColor)
        {
            this.itemType = itemType;
            this.text = text;
            this.textColor = textColor;
            this.backgroundColor = backgroundColor;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\Items\FlowItemUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Flow.Items
{
    public class FlowItemUtils
    {
        public static string GetFlowItemText(FlowItem item)
        {
            switch (item.type)
            {
                case FlowGraphItemType.Entrance:
                    return "S";

                case FlowGraphItemType.Exit:
                    return "G";

                case FlowGraphItemType.Enemy:
                    return "E";

                case FlowGraphItemType.Key:
                    return "K";

                case FlowGraphItemType.Lock:
                    return "L";

                case FlowGraphItemType.Bonus:
                    return "B";

                case FlowGraphItemType.Custom:
                    return item.customInfo.text;

                default:
                    return "";
            }
        }

        public static void GetFlowItemColor(FlowItem item, out Color colorBackground, out Color colorText)
        {
            switch (item.type)
            {
                case FlowGraphItemType.Entrance:
                    colorBackground = new Color(0, 0.3f, 0);
                    colorText = Color.white;
                    break;

                case FlowGraphItemType.Exit:
                    colorBackground = new Color(0, 0, 0.3f);
                    colorText = Color.white;
                    break;

                case FlowGraphItemType.Enemy:
                    colorBackground = new Color(0.6f, 0, 0);
                    colorText = Color.white;
                    break;

                case FlowGraphItemType.Key:
                    colorBackground = Color.yellow;
                    colorText = Color.black;
                    break;

                case FlowGraphItemType.Lock:
                    colorBackground = Color.blue;
                    colorText = Color.white;
                    break;

                case FlowGraphItemType.Bonus:
                    colorBackground = new Color(0, 0.5f, 1);
                    colorText = Color.white;
                    break;

                case FlowGraphItemType.Custom:
                    colorBackground = item.customInfo.backgroundColor;
                    colorText = item.customInfo.textColor;
                    break;

                default:
                    colorBackground = Color.white;
                    colorText = Color.black;
                    break;
            }

        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\FlowLayoutGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout
{
    [System.Serializable]
    public class FlowLayoutGraph : ICloneable
    {
        [SerializeField]
        public List<FlowLayoutGraphNode> Nodes = new List<FlowLayoutGraphNode>();

        [SerializeField]
        public List<FlowLayoutGraphLink> Links = new List<FlowLayoutGraphLink>();

        public void RemoveNode(FlowLayoutGraphNode node)
        {
            BreakAllLinks(node);
            Nodes.Remove(node);
        }

        public void AddNode(FlowLayoutGraphNode node)
        {
            Nodes.Add(node);
        }

        public void RemoveLink(FlowLayoutGraphLink link)
        {
            Links.Remove(link);
        }

        public FlowLayoutGraphNode CreateNode()
        {
            var node = new FlowLayoutGraphNode();
            AddNode(node);
            return node;
        }

        public FlowLayoutGraphNode GetNode(DungeonUID nodeId)
        {
            foreach (var node in Nodes)
            {
                if (node.nodeId == nodeId)
                {
                    return node;
                }
            }

            return null;
        }

        public FlowLayoutGraphLink GetLink(FlowLayoutGraphNode sourceNode, FlowLayoutGraphNode destNode)
        {
            return GetLink(sourceNode, destNode, false);
        }

        public FlowLayoutGraphLink GetLink(FlowLayoutGraphNode sourceNode, FlowLayoutGraphNode destNode, bool ignoreDirection)
        {
            if (sourceNode == null || destNode == null)
            {
                return null;
            }

            return GetLink(sourceNode.nodeId, destNode.nodeId, ignoreDirection);
        }

        public FlowLayoutGraphLink GetLink(DungeonUID sourceNodeId, DungeonUID destNodeId, bool ignoreDirection)
        {
            foreach (var link in Links)
            {
                if (link.source == sourceNodeId && link.destination == destNodeId)
                {
                    return link;
                }
                if (ignoreDirection)
                {
                    if (link.source == destNodeId && link.destination == sourceNodeId)
                    {
                        return link;
                    }
                }
            }
            return null;
        }
        
        public FlowLayoutGraphLink[] GetLinks(DungeonUID sourceNodeId, DungeonUID destNodeId)
        {
            return GetLinks(sourceNodeId, destNodeId, false);
        }

        public FlowLayoutGraphLink[] GetLinks(DungeonUID sourceNodeId, DungeonUID destNodeId, bool ignoreDirection)
        {
            var result = new List<FlowLayoutGraphLink>();
            
            foreach (var link in Links)
            {
                if (link.source == sourceNodeId && link.destination == destNodeId) {
                    result.Add(link);
                }
                else if (ignoreDirection && link.source == destNodeId && link.destination == sourceNodeId) {
                    result.Add(link);
                }
            }

            return result.ToArray();
        }

        public FlowLayoutGraphLink MakeLink(FlowLayoutGraphNode sourceNode, FlowLayoutGraphNode destNode)
        {
            if (sourceNode == null || destNode == null)
            {
                return null;
            }

            // Make sure an existing link doesn't exist
            {
                FlowLayoutGraphLink existingLink = GetLink(sourceNode, destNode);
                if (existingLink != null)
                {
                    // Link already exists
                    return null;
                }
            }

            // Create a new link
            var link = new FlowLayoutGraphLink();
            link.source = sourceNode.nodeId;
            link.destination = destNode.nodeId;
            Links.Add(link);
            return link;
        }

        public FlowLayoutGraphLink MakeLinkFastUnsafe(FlowLayoutGraphNode sourceNode, FlowLayoutGraphNode destNode)
        {
            if (sourceNode == null || destNode == null)
            {
                return null;
            }

            // Create a new link
            var link = new FlowLayoutGraphLink();
            link.source = sourceNode.nodeId;
            link.destination = destNode.nodeId;
            Links.Add(link);
            return link;
        }

        public void BreakLink(FlowLayoutGraphNode sourceNode, FlowLayoutGraphNode destNode)
        {
            FlowLayoutGraphLink link = GetLink(sourceNode, destNode);
            if (link != null)
            {
                Links.Remove(link);
            }
        }

        public void BreakAllOutgoingLinks(FlowLayoutGraphNode node)
        {
            if (node != null)
            {
                var linkArray = Links.ToArray();
                foreach (var link in linkArray)
                {
                    if (link.source == node.nodeId)
                    {
                        Links.Remove(link);
                    }
                }
            }
        }

        public void BreakAllIncomingLinks(FlowLayoutGraphNode node)
        {
            if (node != null)
            {
                var linkArray = Links.ToArray();
                foreach (var link in linkArray)
                {
                    if (link.destination == node.nodeId)
                    {
                        Links.Remove(link);
                    }
                }
            }
        }

        public void BreakAllLinks(FlowLayoutGraphNode node)
        {
            if (node != null)
            {
                var linkArray = Links.ToArray();
                foreach (var link in linkArray)
                {
                    if (link.source == node.nodeId || link.destination == node.nodeId)
                    {
                        Links.Remove(link);
                    }
                }
            }
        }

        public void Clear()
        {
            var nodeList = Nodes.ToArray();
            foreach (var node in nodeList)
            {
                RemoveNode(node);
            }
        }

        public FlowLayoutGraphNode[] GetOutgoingNodes(FlowLayoutGraphNode node)
        {
            var result = new List<FlowLayoutGraphNode>();
            if (node != null)
            {
                foreach (var link in Links)
                {
                    if (link.source == node.nodeId)
                    {
                        result.Add(GetNode(link.destination));
                    }
                }
            }
            return result.ToArray();
        }

        public FlowLayoutGraphNode[] GetIncomingNodes(FlowLayoutGraphNode node)
        {
            var result = new List<FlowLayoutGraphNode>();
            if (node != null)
            {
                foreach (var link in Links)
                {
                    if (link.destination == node.nodeId)
                    {
                        result.Add(GetNode(link.source));
                    }
                }
            }
            return result.ToArray();
        }

        public FlowLayoutGraphLink[] GetOutgoingLinks(FlowLayoutGraphNode node)
        {
            var result = new List<FlowLayoutGraphLink>();
            if (node != null)
            {
                foreach (var link in Links)
                {
                    if (link.source == node.nodeId)
                    {
                        result.Add(link);
                    }
                }
            }
            return result.ToArray();
        }

        public FlowLayoutGraphLink[] GetIncomingLinks(FlowLayoutGraphNode node)
        {
            var result = new List<FlowLayoutGraphLink>();
            if (node != null)
            {
                foreach (var link in Links)
                {
                    if (link.destination == node.nodeId)
                    {
                        result.Add(link);
                    }
                }
            }
            return result.ToArray();
        }

        public FlowLayoutGraphNode[] GetConnectedNodes(FlowLayoutGraphNode node)
        {
            var result = new List<FlowLayoutGraphNode>();
            if (node != null)
            {
                foreach (var link in Links)
                {
                    if (link.destination == node.nodeId)
                    {
                        result.Add(GetNode(link.source));
                    }
                    else if (link.source == node.nodeId)
                    {
                        result.Add(GetNode(link.destination));
                    }
                }
            }
            return result.ToArray();
        }

        public DungeonUID[] GetConnectedNodes(DungeonUID nodeId)
        {
            var result = new List<DungeonUID>();
            foreach (var link in Links)
            {
                if (link.destination == nodeId)
                {
                    result.Add(link.source);
                }
                else if (link.source == nodeId)
                {
                    result.Add(link.destination);
                }
            }
            return result.ToArray();
        }
        
        public object Clone()
        {
            var newGraph = Activator.CreateInstance(GetType()) as FlowLayoutGraph;

            // Create nodes
            foreach (var oldNode in Nodes)
            {
                var newNode = oldNode.Clone();
                newGraph.Nodes.Add(newNode);
            }

            // Create the links
            foreach (var oldLink in Links)
            {
                var newLink = oldLink.Clone();
                newGraph.Links.Add(newLink);
            }

            return newGraph;
        }

        public FlowItem[] GetAllItems()
        {
            var items = new List<FlowItem>();

            foreach (var node in Nodes)
            {
                items.AddRange(node.items);
            }

            foreach (var link in Links)
            {
                items.AddRange(link.state.items);
            }

            return items.ToArray();
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\FlowLayoutGraphConstraints.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout.Pathing;

namespace DungeonArchitect.Flow.Domains.Layout
{
    public class FFAGConstraintsLink
    {
        public FFAGConstraintsLink(FlowLayoutGraphNode node, FlowLayoutGraphNode incomingNode, FlowLayoutGraphLink link)
        {
            this.Node = node;
            this.IncomingNode = incomingNode;
            this.Link = link;
        }

        public FlowLayoutGraphNode Node;
        public FlowLayoutGraphNode IncomingNode;
        public FlowLayoutGraphLink Link;
    }
    
    public interface IFlowLayoutGraphConstraints
    {
        bool IsValid(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode node, FlowLayoutGraphNode[] incomingNodes);
        bool IsValid(FlowLayoutGraphQuery graphQuery, FlowLayoutPathNodeGroup group, int pathIndex, int pathLength, FFAGConstraintsLink[] incomingNodes);
    }

    public class NullFlowLayoutGraphConstraints : IFlowLayoutGraphConstraints
    {
        public bool IsValid(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode node, FlowLayoutGraphNode[] incomingNodes)
        {
            return true;
        }

        public bool IsValid(FlowLayoutGraphQuery graphQuery, FlowLayoutPathNodeGroup group, int pathIndex, int pathLength, FFAGConstraintsLink[] incomingNodes)
        {
            return true;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\FlowLayoutGraphLink.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Flow.Domains.Layout
{
    [System.Serializable]
    public enum FlowLayoutGraphLinkType
    {
        Unconnected,
        Connected,
        OneWay
    }
    
    [System.Serializable]
    public class FlowLayoutGraphLinkState
    {
        //public bool Directional = false;
        //public bool OneWay = false;
        public FlowLayoutGraphLinkType type = FlowLayoutGraphLinkType.Unconnected;
        public List<FlowItem> items = new List<FlowItem>();

        public FlowLayoutGraphLinkState Clone()
        {
            var newState = new FlowLayoutGraphLinkState();
            newState.type = type;
            foreach (var item in items)
            {
                newState.AddItem(item.Clone());
            }
            return newState;
        }

        public void AddItem(FlowItem item)
        {
            items.Add(item);
        }

    }

    [System.Serializable]
    public class FlowLayoutGraphLink
    {
        public DungeonUID linkId;
        public DungeonUID source;
        public DungeonUID destination;
        public FlowLayoutGraphLinkState state = new FlowLayoutGraphLinkState();

        // If the source node was merged, the original unmerged node id would be here
        public DungeonUID sourceSubNode;
        
        // If the destination node was merged, the original unmerged node id would be here
        public DungeonUID destinationSubNode;
        
        public FlowLayoutGraphLink()
        {
            linkId = DungeonUID.NewUID();
        }

        public FlowLayoutGraphLink Clone()
        {
            var newLink = new FlowLayoutGraphLink();
            newLink.linkId = linkId;
            newLink.source = source;
            newLink.destination = destination;
            newLink.state = state.Clone();
            newLink.sourceSubNode = sourceSubNode;
            newLink.destinationSubNode = destinationSubNode;
            return newLink;
        }

        public void ReverseDirection()
        {
            MathUtils.Swap(ref source, ref destination);
            MathUtils.Swap(ref sourceSubNode, ref destinationSubNode);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\FlowLayoutGraphNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout
{
    [System.Serializable]
    public class FlowLayoutGraphNode
    {
        public DungeonUID nodeId;
        public Vector3 position = Vector3.zero;
        public bool active = false;
        public Color color = Color.green;
        public Vector3 coord = Vector3.zero;
        public string pathName = "";
        public List<FlowItem> items = new List<FlowItem>();
        public int pathIndex = -1;
        public int pathLength = 0;
        public bool mainPath = false;
        
        // This node may be a composite node which was created by merging these nodes
        [NonSerialized] // TODO: Fix serialization
        public List<FlowLayoutGraphNode> MergedCompositeNodes = new List<FlowLayoutGraphNode>();
        
        [HideInInspector]
        public FlowDomainDataRegistry domainData = new FlowDomainDataRegistry();
        
        public FlowLayoutGraphNode()
        {
            nodeId = DungeonUID.NewUID();
        }

        public FlowLayoutGraphNode Clone()
        {
            var newNode = new FlowLayoutGraphNode();
            newNode.nodeId = nodeId;
            newNode.position = position;
            newNode.active = active;
            newNode.color = color;
            newNode.coord = coord;
            newNode.pathName = pathName;
            newNode.pathIndex = pathIndex;
            newNode.pathLength = pathLength;
            newNode.mainPath = mainPath;
            newNode.domainData = domainData.Clone();

            foreach (var item in items)
            {
                newNode.AddItem(item.Clone());
            }
            
            foreach (var compositeNode in MergedCompositeNodes)
            {
                newNode.MergedCompositeNodes.Add(compositeNode.Clone());
            }
            
            return newNode;
        }

        public FlowItem CreateItem<T>() where T : FlowItem, new()
        {
            var item = new T();
            items.Add(item);
            return item;
        }
        
        public void AddItem(FlowItem item)
        {
            items.Add(item);
        }
        
        public T GetDomainData<T>() where T : IFlowDomainData, new()
        {
            if (domainData == null)
            {
                return default;
            }

            return domainData.Get<T>();
        }
        
        public void SetDomainData<T>(T data) where T : IFlowDomainData, new()
        {
            if (domainData != null)
            {
                domainData.Set(data);
            }
        }
    }

    public class FlowLayoutGraphNodeGroup
    {
        public DungeonUID GroupId = DungeonUID.Empty;
        public List<DungeonUID> GroupNodes = new List<DungeonUID>();

        public FlowLayoutGraphNodeGroup Clone()
        {
            var clone = new FlowLayoutGraphNodeGroup();
            clone.GroupId = GroupId;
            clone.GroupNodes = new List<DungeonUID>(GroupNodes);
            return clone;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\FlowLayoutGraphQuery.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout
{
    public class FlowLayoutGraphTraversal
    {
        private Dictionary<DungeonUID, FNodeInfo[]> outgoingNodes = new Dictionary<DungeonUID, FNodeInfo[]>();
        private Dictionary<DungeonUID, FNodeInfo[]> incomingNodes = new Dictionary<DungeonUID, FNodeInfo[]>();
        private Dictionary<DungeonUID, DungeonUID> teleporters = new Dictionary<DungeonUID, DungeonUID>();   // Node -> Node mapping of teleporters
        
        public void Build(FlowLayoutGraph graph)
        {
            outgoingNodes.Clear();
            incomingNodes.Clear();
            teleporters.Clear();

            if (graph == null)
            {
                return;
            }
            
            var outgoingList = new Dictionary<DungeonUID, List<FNodeInfo>>();
            var incomingList = new Dictionary<DungeonUID, List<FNodeInfo>>();
            
            foreach (var link in graph.Links)
            {
                if (link.state.type == FlowLayoutGraphLinkType.Unconnected)
                {
                    continue;
                }
                
                // Add outgoing nodes
                {
                    if (!outgoingList.ContainsKey(link.source))
                    {
                        outgoingList.Add(link.source, new List<FNodeInfo>());
                    }

                    var info = new FNodeInfo();
                    info.NodeId = link.destination;
                    info.LinkId = link.linkId;
                    info.Outgoing = true;
                    
                    outgoingList[link.source].Add(info);
                }
                
                // Add incoming nodes
                {
                    if (!incomingList.ContainsKey(link.destination))
                    {
                        incomingList.Add(link.destination, new List<FNodeInfo>());
                    }

                    var info = new FNodeInfo();
                    info.NodeId = link.source;
                    info.LinkId = link.linkId;
                    info.Outgoing = false;
                    
                    incomingList[link.destination].Add(info);
                }
            }

            // Finalize the incoming/outgoing list
            {
                foreach (var entry in outgoingList)
                {
                    outgoingNodes.Add(entry.Key, entry.Value.ToArray());
                }
                foreach (var entry in incomingList)
                {
                    incomingNodes.Add(entry.Key, entry.Value.ToArray());
                }
            }
            
            // Build the teleporter list
            {
                // Build a mapping of the teleporter item to their host node mapping
                var teleporterHostMap = new Dictionary<DungeonUID, FlowLayoutGraphNode>();     // Teleporter to owning node map
                foreach (var node in graph.Nodes)
                {
                    if (node == null || !node.active) continue;
                    foreach (var item in node.items)
                    {
                        if (item != null && item.type == FlowGraphItemType.Teleporter)
                        {
                            if (teleporterHostMap.ContainsKey(item.itemId))
                            {
                                teleporterHostMap.Remove(item.itemId);
                            }
                            teleporterHostMap.Add(item.itemId, node);
                        }
                    }
                }
                
                // Make another pass to build the teleporter list
                foreach (var node in graph.Nodes)
                {
                    if (node == null || !node.active) continue;
                    foreach (var item in node.items)
                    {
                        if (item != null && item.type == FlowGraphItemType.Teleporter)
                        {
                            if (item.referencedItemIds.Count > 0)
                            {
                                var otherTeleporterId = item.referencedItemIds[0];
                                if (teleporterHostMap.ContainsKey(otherTeleporterId))
                                {
                                    var teleNodeA = node;
                                    var teleNodeB = teleporterHostMap[otherTeleporterId];

                                    if (!teleporters.ContainsKey(teleNodeA.nodeId))
                                    {
                                        teleporters.Add(teleNodeA.nodeId, teleNodeB.nodeId);
                                    }
                                    if (!teleporters.ContainsKey(teleNodeB.nodeId))
                                    {
                                        teleporters.Add(teleNodeB.nodeId, teleNodeA.nodeId);
                                    }
                                } 
                            }
                        }
                    }
                }
            }
        }

        public FNodeInfo[] GetOutgoingNodes(DungeonUID nodeId)
        {
            if (outgoingNodes.ContainsKey(nodeId))
            {
                return outgoingNodes[nodeId];
            }

            return new FNodeInfo[0];
        }
        
        public FNodeInfo[] GetIncomingNodes(DungeonUID nodeId)
        {
            if (incomingNodes.ContainsKey(nodeId))
            {
                return incomingNodes[nodeId];
            }

            return new FNodeInfo[0];
        }
        
        public FNodeInfo[] GetConnectedNodes(DungeonUID nodeId)
        {
            var connectedNodes = new List<FNodeInfo>();
            connectedNodes.AddRange(GetOutgoingNodes(nodeId));
            connectedNodes.AddRange(GetIncomingNodes(nodeId));
            return connectedNodes.ToArray();
        }

        public bool GetTeleportNode(DungeonUID nodeId, out DungeonUID connectedNodeId)
        {
            if (!teleporters.ContainsKey(nodeId))
            {
                connectedNodeId = DungeonUID.Empty;
                return false;
            }

            connectedNodeId = teleporters[nodeId];
            return true;
        }
        
        public struct FNodeInfo
        {
            public DungeonUID NodeId;
            public DungeonUID LinkId;
            public bool Outgoing;
        }

    }

    public class FlowLayoutGraphQuery
    {
        public FlowLayoutGraphQuery(FlowLayoutGraph graph)
        {
            this.graph = graph;
            Build();
        }
        
        public FlowLayoutGraphTraversal Traversal
        {
            get => traversal;
        }

        public FlowLayoutGraph Graph
        {
            get => graph;
        }
        
        public FlowLayoutGraph GetGraph()
        {
            return graph;
        }
        
        public T GetGraphOfType<T>() where T : FlowLayoutGraph
        {
            return (T)graph;
        }

        public FlowLayoutGraphNode GetNode(DungeonUID nodeId)
        {
            return nodeMap.ContainsKey(nodeId) ? nodeMap[nodeId] : null;
        }

        public FlowLayoutGraphLink GetLink(DungeonUID linkId)
        {
            return linkMap.ContainsKey(linkId) ? linkMap[linkId] : null;
        }

        public FlowLayoutGraphNode GetSubNode(DungeonUID nodeId)
        {
            
            return subNodeMap.ContainsKey(nodeId) ? subNodeMap[nodeId] : null;
        }

        public bool GetParentNode(DungeonUID nodeId, out DungeonUID parentNodeId)
        {
            if (parentNodes.ContainsKey(nodeId))
            {
                parentNodeId = parentNodes[nodeId];
                return true;
            }

            parentNodeId = DungeonUID.Empty;
            return false;
        }
        
        public DungeonUID GetNodeAtCoord(Vector3 coord)
        {
            return coordToNodeMap.ContainsKey(coord) ? coordToNodeMap[coord] : DungeonUID.Empty;
        }

        public FlowLayoutGraphNode GetNodeObjAtCoord(Vector3Int nodeCoord)
        {
            if (nodeCoord.x >= 0 && nodeCoord.x < nodeArray3D.GetLength(0)
                && nodeCoord.y >= 0 && nodeCoord.y < nodeArray3D.GetLength(1)
                && nodeCoord.z >= 0 && nodeCoord.z < nodeArray3D.GetLength(2))
            {
                return nodeArray3D[nodeCoord.x, nodeCoord.y, nodeCoord.z];
            }

            return null;
        }

        public DungeonUID[] GetConnectedNodes(DungeonUID nodeId)
        {
            return connectedNodes.ContainsKey(nodeId) ? connectedNodes[nodeId] : new DungeonUID[0];
        }

        public DungeonUID[] GetIncomingNodes(DungeonUID nodeId)
        {
            return incomingNodes.ContainsKey(nodeId) ? incomingNodes[nodeId] : new DungeonUID[0];
        }
        
        public DungeonUID[] GetOutgoingNodes(DungeonUID nodeId)
        {
            return outgoingNodes.ContainsKey(nodeId) ? outgoingNodes[nodeId] : new DungeonUID[0];
        }

        public FlowLayoutGraphLink[] GetConnectedLinks(DungeonUID nodeId)
        {
            return connectedLinks.ContainsKey(nodeId) ? connectedLinks[nodeId] : new FlowLayoutGraphLink[0];
        }

        public FlowLayoutGraphLink GetConnectedLink(DungeonUID nodeA, DungeonUID nodeB)
        {
            var connectedLinks = GetConnectedLinks(nodeA);
            FlowLayoutGraphLink targetLink = null;
            foreach (var connectedLink in connectedLinks)
            {
                if (connectedLink == null) continue;
                if (connectedLink.source == nodeB
                    || connectedLink.sourceSubNode == nodeB
                    || connectedLink.destination == nodeB
                    || connectedLink.destinationSubNode == nodeB)
                {
                    targetLink = connectedLink;
                    break;
                }
            }

            return targetLink;
        }

        public FlowLayoutGraphLink GetConnectedLink(DungeonUID nodeA, DungeonUID nodeB, bool ignoreDirection)
        {
            var link = GetConnectedLink(nodeA, nodeB);
            if (link == null)
            {
                link = GetConnectedLink(nodeB, nodeA);
            }

            return link;
        }
        
        public void GetConnectedNodes(DungeonUID nodeId, out DungeonUID[] outConnectedNodeIds, out FlowLayoutGraphLink[] outConnectedLinks)
        {
            outConnectedNodeIds = GetConnectedNodes(nodeId);
            outConnectedLinks = GetConnectedLinks(nodeId);
        }

        public void Rebuild()
        {
            Build();
        }
        private void Build()
        {
            nodeMap.Clear();
            linkMap.Clear();
            connectedNodes.Clear();
            connectedLinks.Clear();
            outgoingNodes.Clear();
            incomingNodes.Clear();
            subNodeMap.Clear();
            coordToNodeMap.Clear();
            parentNodes.Clear();
            
            foreach (var node in graph.Nodes)
            {
                nodeMap.Add(node.nodeId, node);
                coordToNodeMap[node.coord] = node.nodeId;
                foreach (var subNode in node.MergedCompositeNodes)
                {
                    subNodeMap[subNode.nodeId] = subNode;
                    parentNodes[subNode.nodeId] = node.nodeId;
                }
            }

            {
                graphGridSize = IntVector.Zero;
                foreach (var node in graph.Nodes)
                {
                    var nodeCoord = MathUtils.RoundToVector3Int(node.coord);
                    graphGridSize.x = Mathf.Max(graphGridSize.x, nodeCoord.x + 1);
                    graphGridSize.y = Mathf.Max(graphGridSize.y, nodeCoord.y + 1);
                    graphGridSize.z = Mathf.Max(graphGridSize.z, nodeCoord.z + 1);
                }
                
                nodeArray3D = new FlowLayoutGraphNode[graphGridSize.x, graphGridSize.y, graphGridSize.z];
                foreach (var node in graph.Nodes)
                {
                    var nodeCoord = MathUtils.RoundToVector3Int(node.coord);
                    nodeArray3D[nodeCoord.x, nodeCoord.y, nodeCoord.z] = node;
                }
            }

            foreach (var link in graph.Links)
            {
                linkMap.Add(link.linkId, link);
            }

            {
                var connectedNodesMap = new Dictionary<DungeonUID, List<DungeonUID>>();
                foreach (var link in graph.Links)
                {
                    if (!connectedNodesMap.ContainsKey(link.source))
                    {
                        connectedNodesMap.Add(link.source, new List<DungeonUID>());
                    }
                    if (!connectedNodesMap.ContainsKey(link.destination))
                    {
                        connectedNodesMap.Add(link.destination, new List<DungeonUID>());
                    }
                    
                    connectedNodesMap[link.source].Add(link.destination);
                    connectedNodesMap[link.destination].Add(link.source);
                }

                foreach (var key in connectedNodesMap.Keys)
                {
                    connectedNodes[key] = connectedNodesMap[key].ToArray();
                }
            }

            {
                var connectedLinkMap = new Dictionary<DungeonUID, List<FlowLayoutGraphLink>>();
                var outgoingNodeMap = new Dictionary<DungeonUID, List<DungeonUID>>();
                var incomingNodeMap = new Dictionary<DungeonUID, List<DungeonUID>>();
                foreach (var link in graph.Links)
                {
                    if (!connectedLinkMap.ContainsKey(link.source)) connectedLinkMap.Add(link.source, new List<FlowLayoutGraphLink>());
                    if (!connectedLinkMap.ContainsKey(link.sourceSubNode)) connectedLinkMap.Add(link.sourceSubNode, new List<FlowLayoutGraphLink>());
                    if (!connectedLinkMap.ContainsKey(link.destination)) connectedLinkMap.Add(link.destination, new List<FlowLayoutGraphLink>());
                    if (!connectedLinkMap.ContainsKey(link.destinationSubNode)) connectedLinkMap.Add(link.destinationSubNode, new List<FlowLayoutGraphLink>());

                    connectedLinkMap[link.source].Add(link);
                    connectedLinkMap[link.sourceSubNode].Add(link);
                    connectedLinkMap[link.destination].Add(link);
                    connectedLinkMap[link.destinationSubNode].Add(link);

                    if (link.state.type != FlowLayoutGraphLinkType.Unconnected)
                    {
                        if (!outgoingNodeMap.ContainsKey(link.source)) outgoingNodeMap.Add(link.source, new List<DungeonUID>());
                        if (!incomingNodeMap.ContainsKey(link.destination)) incomingNodeMap.Add(link.destination, new List<DungeonUID>());

                        outgoingNodeMap[link.source].Add(link.destination);
                        incomingNodeMap[link.destination].Add(link.source);
                    }
                }

                foreach (var key in connectedLinkMap.Keys)
                {
                    connectedLinks[key] = connectedLinkMap[key].ToArray();
                }
                
                foreach (var key in outgoingNodeMap.Keys)
                {
                    outgoingNodes[key] = outgoingNodeMap[key].ToArray();
                }
                
                foreach (var key in incomingNodeMap.Keys)
                {
                    incomingNodes[key] = incomingNodeMap[key].ToArray();
                }
            }
            
            traversal.Build(graph);
        }
        
        private FlowLayoutGraph graph;
        private Dictionary<DungeonUID, FlowLayoutGraphNode> nodeMap = new Dictionary<DungeonUID, FlowLayoutGraphNode>();
        private Dictionary<DungeonUID, FlowLayoutGraphLink> linkMap = new Dictionary<DungeonUID, FlowLayoutGraphLink>();
        private Dictionary<DungeonUID, DungeonUID[]> connectedNodes = new Dictionary<DungeonUID, DungeonUID[]>();
        private Dictionary<DungeonUID, DungeonUID[]> outgoingNodes = new Dictionary<DungeonUID, DungeonUID[]>();
        private Dictionary<DungeonUID, DungeonUID[]> incomingNodes = new Dictionary<DungeonUID, DungeonUID[]>();
        private Dictionary<DungeonUID, DungeonUID> parentNodes = new Dictionary<DungeonUID, DungeonUID>();
        private Dictionary<DungeonUID, FlowLayoutGraphLink[]> connectedLinks = new Dictionary<DungeonUID, FlowLayoutGraphLink[]>();
        private FlowLayoutGraphTraversal traversal = new FlowLayoutGraphTraversal();
        private Dictionary<DungeonUID, FlowLayoutGraphNode> subNodeMap = new Dictionary<DungeonUID, FlowLayoutGraphNode>();
        private Dictionary<Vector3, DungeonUID> coordToNodeMap = new Dictionary<Vector3, DungeonUID>();
        private IntVector graphGridSize;
        private FlowLayoutGraphNode[,,] nodeArray3D = new FlowLayoutGraphNode[0,0,0];
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\FlowLayoutGraphUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout
{
    public class FlowLayoutGraphUtils
    {
        
        public static FlowLayoutGraphNode[] FindNodesOnPath(FlowLayoutGraph graph, string pathName)
        {
            var result = new List<FlowLayoutGraphNode>();

            if (pathName.Length > 0)
            {
                foreach (var node in graph.Nodes)
                {
                    if (node != null && node.pathName == pathName)
                    {
                        result.Add(node);
                    }
                }
            }
            
            return result.ToArray();
        }

        public static FlowLayoutGraphNode[] FindNodesWithItemType(FlowLayoutGraph graph, FlowGraphItemType itemType)
        {
            var result = new List<FlowLayoutGraphNode>();
            foreach (var node in graph.Nodes)
            {
                foreach (var item in node.items)
                {
                    if (item.type == itemType)
                    {
                        result.Add(node);
                        break;
                    }
                }
            }

            return result.ToArray();
        }

        public static FlowLayoutGraphNode FindNodeWithItemType(FlowLayoutGraph graph, FlowGraphItemType itemType)
        {
            foreach (var node in graph.Nodes)
            {
                foreach (var item in node.items)
                {
                    if (item.type == itemType)
                    {
                        return node;
                    }
                }
            }

            return null;
        }

        public static bool ContainsItem(List<FlowItem> items, FlowGraphItemType itemType)
        {
            foreach (var item in items)
            {
                if (item.type == itemType)
                {
                    return true;
                }
            }

            return false;
        }

        public static bool CanReachNode(FlowLayoutGraphQuery graphQuery, DungeonUID startNode, DungeonUID endNode, bool ignoreDirection,
                bool ignoreOneWayDoors, bool traverseTeleporters, Func<FlowLayoutGraphTraversal.FNodeInfo, bool> canTraverse)
        {
            var traversal = graphQuery.Traversal;
            var visitedNodes = new HashSet<DungeonUID>();
            var stack = new Stack<DungeonUID>();
            stack.Push(startNode);
            while (stack.Count > 0) {
                var nodeId = stack.Pop();
                if (nodeId == endNode) {
                    return true;
                }

                visitedNodes.Add(nodeId);

                // Grab the connected nodes
                var connectedNodes = new List<FlowLayoutGraphTraversal.FNodeInfo>();
                connectedNodes.AddRange(traversal.GetOutgoingNodes(nodeId));
                if (ignoreDirection) {
                    connectedNodes.AddRange(traversal.GetIncomingNodes(nodeId));
                }
                
                if (traverseTeleporters) {
                    // TODO: Implement me
                }

                // Traverse through them
                foreach (var connectedNode in connectedNodes) {
                    if (!canTraverse(connectedNode)) continue;
                    if (visitedNodes.Contains(connectedNode.NodeId)) continue;
                    if (!ignoreOneWayDoors) {
                        var link = graphQuery.GetLink(connectedNode.LinkId);
                        if (link != null && link.state.type == FlowLayoutGraphLinkType.OneWay) {
                            // Make sure we can pass through the one-way door
                            if (link.source != nodeId) {
                                // Cannot pass through the one-way link
                                continue;
                            }
                        }
                    }

                    stack.Push(connectedNode.NodeId);
                }
            }

            return false;
        }
        
        protected struct NodeWeightAssignInfo
        {
            public FlowLayoutGraphNode node;
            public int weight;

            public NodeWeightAssignInfo(FlowLayoutGraphNode node, int weight)
            {
                this.node = node;
                this.weight = weight;
            }
        }

        public static Dictionary<FlowLayoutGraphNode, int> CalculateWeights(FlowLayoutGraph graph, int lockedWeight)
        {
            var weights = new Dictionary<FlowLayoutGraphNode, int>();

            // Find the start node
            FlowLayoutGraphNode[] startNodes = FindNodesWithItemType(graph, FlowGraphItemType.Entrance);
            var visited = new HashSet<FlowLayoutGraphNode>();
            var queue = new Queue<NodeWeightAssignInfo>();
            foreach (var startNode in startNodes)
            {
                queue.Enqueue(new NodeWeightAssignInfo(startNode, 0));
                visited.Add(startNode);
            }

            while (queue.Count > 0)
            {
                var front = queue.Dequeue();
                visited.Add(front.node);
                if (weights.ContainsKey(front.node))
                {
                    weights[front.node] = Mathf.Min(weights[front.node], front.weight);
                }
                else
                {
                    weights.Add(front.node, front.weight);
                }

                // Traverse the children
                foreach (var outgoingLink in graph.GetOutgoingLinks(front.node))
                {
                    if (outgoingLink.state.type == FlowLayoutGraphLinkType.Unconnected) continue;
                    var outgoingNode = graph.GetNode(outgoingLink.destination);
                    if (!outgoingNode.active) continue;
                    bool traverseChild = true;
                    if (visited.Contains(outgoingNode))
                    {
                        // The child node has already been traversed.  Do not traverse if the child's weight
                        // is less than the current weight
                        var currentWeight = front.weight;
                        var childWeight = weights[outgoingNode];
                        if (currentWeight > childWeight)
                        {
                            traverseChild = false;
                        }
                    }
                    if (traverseChild)
                    {
                        var nodeWeight = 1;
                        if (ContainsItem(outgoingLink.state.items, FlowGraphItemType.Lock))
                        {
                            nodeWeight = lockedWeight;
                        }

                        queue.Enqueue(new NodeWeightAssignInfo(outgoingNode, front.weight + nodeWeight));
                    }
                }
            }
            return weights;
        }
        
        public static FlowLayoutGraphNode[] FilterNodes(FlowLayoutGraphNode[] nodes, int minWeight, int maxWeight, Dictionary<FlowLayoutGraphNode, int> weights)
        {
            var validNodes = new List<FlowLayoutGraphNode>();
            foreach (var node in nodes)
            {
                var weight = weights[node];
                if (weight >= minWeight && weight <= maxWeight)
                {
                    validNodes.Add(node);
                }
            }
            return validNodes.ToArray();
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\FlowTilemap.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Tilemap
{
    [System.Serializable]
    public enum FlowTilemapCellType
    {
        Empty,
        Floor,
        Wall,
        Door,
        Custom
    }

    [System.Serializable]
    public enum FlowTilemapEdgeType
    {
        Empty,
        Wall,
        Fence,
        Door
    }

    [System.Serializable]
    public class FlowTilemapCustomCellInfo
    {
        public string name;
        public Color defaultColor = Color.white;

        public override string ToString()
        {
            if (name.Length == 0)
            {
                return base.ToString();
            }
            return name;
        }
    }

    [System.Serializable]
    public enum FlowTilemapCellCategory
    {
        Layout,
        Biome,
        Elevation
    }

    [System.Serializable]
    public class FlowTilemapCellOverlay
    {
        public string markerName;
        public Color color;
        public float noiseValue { get; set; }

        /// <summary>
        /// Specifies if the overlay blocks the tile (like a rock overlay) or doesn't block a tile (like grass overlay), so items can be placed on top of it
        /// </summary>
        public bool tileBlockingOverlay = true;

        public FlowTilemapCellOverlayMergeConfig mergeConfig;

        public FlowTilemapCellOverlay Clone()
        {
            var newOverlay = new FlowTilemapCellOverlay();
            newOverlay.markerName = markerName;
            newOverlay.color = color;
            newOverlay.noiseValue = noiseValue;
            newOverlay.tileBlockingOverlay = tileBlockingOverlay;
            newOverlay.mergeConfig = mergeConfig.Clone();

            return newOverlay;
        }
    }

    [System.Serializable]
    public enum FlowTilemapCellOverlayMergeWallOverlayRule
    {
        KeepWallAndOverlay,
        KeepWallRemoveOverlay,
        KeepOverlayRemoveWall
    }

    [System.Serializable]
    public class FlowTilemapCellOverlayMergeConfig
    {
        public float minHeight = 0;
        public float maxHeight = 0;
        public FlowTilemapCellOverlayMergeWallOverlayRule wallOverlayRule = FlowTilemapCellOverlayMergeWallOverlayRule.KeepWallAndOverlay;
        public float markerHeightOffsetForLayoutTiles = 0;
        public float markerHeightOffsetForNonLayoutTiles = 0;
        public bool removeElevationMarker = false;

        public FlowTilemapCellOverlayMergeConfig Clone()
        {
            var newConfig = new FlowTilemapCellOverlayMergeConfig();
            newConfig.minHeight = minHeight;
            newConfig.maxHeight = maxHeight;
            newConfig.wallOverlayRule = wallOverlayRule;
            newConfig.markerHeightOffsetForLayoutTiles = markerHeightOffsetForLayoutTiles;
            newConfig.markerHeightOffsetForNonLayoutTiles = markerHeightOffsetForNonLayoutTiles;
            newConfig.removeElevationMarker = removeElevationMarker;
            return newConfig;
        }
    }


    [System.Serializable]
    public class FlowTilemapEdge
    {
        public FlowTilemapEdgeType EdgeType = FlowTilemapEdgeType.Empty;
        public DungeonUID Item = DungeonUID.Empty;
        public IntVector2 EdgeCoord;
        public bool HorizontalEdge = true;
        public object Userdata = null;

        public FlowTilemapEdge Clone()
        {
            var clone = new FlowTilemapEdge();
            clone.EdgeType = EdgeType;
            clone.Item = Item;
            clone.EdgeCoord = EdgeCoord;
            clone.HorizontalEdge = HorizontalEdge;

            if (Userdata != null && Userdata is System.ICloneable)
            {
                clone.Userdata = (Userdata as System.ICloneable).Clone();
            }
            return clone;
        }
    }

    [System.Serializable]
    public class FlowTilemapCell
    {
        public FlowTilemapCellType CellType = FlowTilemapCellType.Empty;
        public FlowTilemapCustomCellInfo CustomCellInfo = null;
        public DungeonUID Item = DungeonUID.Empty;
        public string[] Tags = new string[0];
        public FlowTilemapCellOverlay Overlay;
        public IntVector2 NodeCoord;
        public IntVector2 TileCoord;
        public bool UseCustomColor = false;
        public Color CustomColor = Color.white;
        public bool MainPath = false;
        public bool LayoutCell = false;
        public int DistanceFromMainPath = int.MaxValue;
        public float Height = 0;
        public object Userdata = null;

        public FlowTilemapCell Clone()
        {
            var newCell = new FlowTilemapCell();
            newCell.CellType = CellType;
            newCell.CustomCellInfo = CustomCellInfo;
            newCell.Item = Item;
            newCell.Tags = new List<string>(Tags).ToArray();
            newCell.Overlay = (Overlay != null) ? Overlay.Clone() : null;
            newCell.NodeCoord = NodeCoord;
            newCell.TileCoord = TileCoord;
            newCell.UseCustomColor = UseCustomColor;
            newCell.CustomColor = CustomColor;
            newCell.MainPath = MainPath;
            newCell.LayoutCell = LayoutCell;
            newCell.DistanceFromMainPath = DistanceFromMainPath;
            newCell.Height = Height;

            if (Userdata != null && Userdata is System.ICloneable)
            {
                newCell.Userdata = (Userdata as System.ICloneable).Clone();
            }
            return newCell;
        }

        public void Clear()
        {
            CellType = FlowTilemapCellType.Empty;
            CustomCellInfo = null;
            Item = DungeonUID.Empty;
            Tags = new string[0];
            Overlay = null;
            UseCustomColor = false;
            MainPath = false;
            LayoutCell = false;
            DistanceFromMainPath = int.MaxValue;
            Height = 0;
            Userdata = null;
        }
    }

    [System.Serializable]
    public class FlowTilemapCellDoorInfo : System.ICloneable
    {
        public bool locked = false;
        public bool oneWay = false;
        public IntVector2 nodeA;
        public IntVector2 nodeB;

        public object Clone()
        {
            var newObj = new FlowTilemapCellDoorInfo();
            newObj.locked = locked;
            newObj.oneWay = oneWay;
            newObj.nodeA = nodeA;
            newObj.nodeB = nodeB;
            return newObj;
        }
    }

    [System.Serializable]
    public class FlowTilemapCellWallInfo : System.ICloneable
    {
        public List<IntVector2> owningNodes = new List<IntVector2>();

        public object Clone()
        {
            var newObj = new FlowTilemapCellWallInfo();
            newObj.owningNodes = new List<IntVector2>(owningNodes);
            return newObj;
        }
    }

    // Disabling serialization as this is making things slow
    // TODO: Fix serialization issue
    //[System.Serializable]
    public class FlowTilemap : ICloneable
    {
        public int Width;
        public int Height;

        [SerializeField]
        [HideInInspector]
        public FlowTilemapCellDatabase Cells;

        [SerializeField]
        [HideInInspector]
        public FlowTilemapEdgeDatabase Edges;

        public FlowTilemap(int width, int height)
        {
            this.Width = width;
            this.Height = height;

            Cells = new FlowTilemapCellDatabase(Width, Height);
            Edges = new FlowTilemapEdgeDatabase(Width, Height);
        }

        public object Clone()
        {
            var newTilemap = new FlowTilemap(Width, Height);

            for (int x = 0; x < Width; x++)
            {
                for (int y = 0; y < Height; y++)
                {
                    newTilemap.Cells[x, y] = Cells[x, y].Clone();
                }
            }

            for (int x = 0; x <= Width; x++)
            {
                for (int y = 0; y <= Height; y++)
                {
                    newTilemap.Edges.SetHorizontal(x, y, Edges.GetHorizontal(x, y).Clone());
                    newTilemap.Edges.SetVertical(x, y, Edges.GetVertical(x, y).Clone());
                }
            }

            return newTilemap;
        }

    }

    [System.Serializable]
    public class FlowTilemapEdgeDatabase : IEnumerable<FlowTilemapEdge>
    {
        [SerializeField]
        private FlowTilemapEdge[] edgesHorizontal;

        [SerializeField]
        private FlowTilemapEdge[] edgesVertical;

        [SerializeField]
        private int width;

        [SerializeField]
        private int height;


        public FlowTilemapEdgeDatabase(int tilemapWidth, int tilemapHeight)
        {
            width = tilemapWidth + 1;
            height = tilemapHeight + 1;
            var numElements = width * height;
            edgesHorizontal = new FlowTilemapEdge[numElements];
            edgesVertical = new FlowTilemapEdge[numElements];

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    var index = Index(x, y);

                    // Create Horizontal edge
                    {
                        var edgeH = new FlowTilemapEdge();
                        edgeH.EdgeCoord = new IntVector2(x, y);
                        edgeH.HorizontalEdge = true;
                        edgesHorizontal[index] = edgeH;
                    }

                    // Create Vertical edge
                    {
                        var edgeV = new FlowTilemapEdge();
                        edgeV.EdgeCoord = new IntVector2(x, y);
                        edgeV.HorizontalEdge = false;
                        edgesVertical[index] = edgeV;
                    }
                }
            }

        }

        public FlowTilemapEdge GetHorizontal(int x, int y)
        {
            if (x < 0 || y < 0 || x >= width || y >= height) return null;
            return edgesHorizontal[Index(x, y)];
        }

        public FlowTilemapEdge GetVertical(int x, int y)
        {
            if (x < 0 || y < 0 || x >= width || y >= height) return null;
            return edgesVertical[Index(x, y)];
        }

        public void SetHorizontal(int x, int y, FlowTilemapEdge edge)
        {
            edgesHorizontal[Index(x, y)] = edge;
        }

        public void SetVertical(int x, int y, FlowTilemapEdge edge)
        {
            edgesVertical[Index(x, y)] = edge;
        }


        private int Index(int x, int y)
        {
            return y * width + x;
        }

        IEnumerator<FlowTilemapEdge> IEnumerable<FlowTilemapEdge>.GetEnumerator()
        {
            return new FlowTilemapEdgeDatabaseEnumerator(edgesHorizontal, edgesVertical);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return new FlowTilemapEdgeDatabaseEnumerator(edgesHorizontal, edgesVertical);
        }
    }

    /// <summary>
    /// This class gives a 2D grid view for an underlying 1D array
    /// Unity serialization requires a 1-dimensional array, hence the need for this class
    /// </summary>
    [System.Serializable]
    public class FlowTilemapCellDatabase : IEnumerable<FlowTilemapCell>
    {
        [SerializeField]
        private FlowTilemapCell[] cells;

        [SerializeField]
        private int width;

        [SerializeField]
        private int height;

        public FlowTilemapCellDatabase(int width, int height)
        {
            this.width = width;
            this.height = height;
            cells = new FlowTilemapCell[width * height];
            for (int x = 0; x < width; x++)
            {
                for (int y = 0; y < height; y++)
                {
                    var cell = new FlowTilemapCell();
                    cell.TileCoord = new IntVector2(x, y);
                    this[x, y] = cell;
                }
            }
        }

        public FlowTilemapCell this[int x, int y]
        {
            get
            {
                return cells[Index(x, y)];
            }
            set
            {
                cells[Index(x, y)] = value;
            }
        }

        public FlowTilemapCell GetCell(int x, int y)
        {
            if (x < 0 || y < 0 || x >= width || y >= height) return null;
            return this[x, y];
        }

        private int Index(int x, int y)
        {
            return y * width + x;
        }

        IEnumerator<FlowTilemapCell> IEnumerable<FlowTilemapCell>.GetEnumerator()
        {
            return new FlowTilemapCellDatabaseEnumerator(cells);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return new FlowTilemapCellDatabaseEnumerator(cells);
        }
    }


    public class FlowTilemapCellDatabaseEnumerator : IEnumerator<FlowTilemapCell>
    {
        int position = -1;
        FlowTilemapCell[] cells = null;
        FlowTilemapCell current;

        public FlowTilemapCellDatabaseEnumerator(FlowTilemapCell[] cells)
        {
            this.cells = cells;
        }

        public void Dispose()
        {
            cells = null;
            current = null;
        }

        public bool MoveNext()
        {
            if (++position >= cells.Length)
            {
                return false;
            }

            // Set current box to next item in collection.
            current = cells[position];
            return true;
        }

        public void Reset()
        {
            position = -1;
            current = null;
        }

        public FlowTilemapCell Current
        {
            get { return current; }
        }


        object IEnumerator.Current
        {
            get { return Current; }
        }
    }

    public class FlowTilemapEdgeDatabaseEnumerator : IEnumerator<FlowTilemapEdge>
    {
        int position = -1;
        FlowTilemapEdge[] edgesH = null;
        FlowTilemapEdge[] edgesV = null;
        FlowTilemapEdge current;

        public FlowTilemapEdgeDatabaseEnumerator(FlowTilemapEdge[] edgesH, FlowTilemapEdge[] edgesV)
        {
            this.edgesH = edgesH;
            this.edgesV = edgesV;
        }

        public void Dispose()
        {
            edgesH = null;
            edgesV = null;
            current = null;
        }

        public bool MoveNext()
        {
            ++position;

            if (position >= edgesH.Length + edgesV.Length)
            {
                return false;
            }

            int index = position;
            if (index < edgesH.Length)
            {
                current = edgesH[index];
            }
            else
            {
                index -= edgesH.Length;
                current = edgesV[index];
            }

            return true;
        }

        public void Reset()
        {
            position = -1;
            current = null;
        }

        public FlowTilemapEdge Current
        {
            get { return current; }
        }


        object IEnumerator.Current
        {
            get { return Current; }
        }
    }


    public class FlowTilemapDistanceFieldCell
    {
        public int DistanceFromEdge = int.MaxValue;
        public int DistanceFromDoor = int.MaxValue;
    }

    public class FlowTilemapDistanceField
    {
        FlowTilemap tilemap;
        public FlowTilemapDistanceFieldCell[,] distanceCells;

        public FlowTilemapDistanceField(FlowTilemap tilemap)
        {
            this.tilemap = tilemap;
            distanceCells = new FlowTilemapDistanceFieldCell[tilemap.Width, tilemap.Height];
            for (int y = 0; y < tilemap.Height; y++)
            {
                for (int x = 0; x < tilemap.Width; x++)
                {
                    distanceCells[x, y] = new FlowTilemapDistanceFieldCell();
                }
            }


            Build();
        }

        private static int[] childOffsets = new int[]
        {
                -1, 0,
                1, 0,
                0, -1,
                0, 1
        };

        void Build()
        {
            FindDistanceFromEdge();
            FindDistanceFromDoor();
        }

        struct NeighborData
        {
            public FlowTilemapCell cell;
            public FlowTilemapEdge edge;
        }

        NeighborData[] GetNeighbourData(FlowTilemapCell cell)
        {
            var coord = cell.TileCoord;
            var left = new NeighborData
            {
                cell = tilemap.Cells.GetCell(coord.x - 1, coord.y),
                edge = tilemap.Edges.GetVertical(coord.x, coord.y)
            };
            
            var right = new NeighborData
            {
                cell = tilemap.Cells.GetCell(coord.x + 1, coord.y),
                edge = tilemap.Edges.GetVertical(coord.x + 1, coord.y)
            };
            
            var down = new NeighborData
            {
                cell = tilemap.Cells.GetCell(coord.x, coord.y - 1),
                edge = tilemap.Edges.GetHorizontal(coord.x, coord.y)
            };

            var up = new NeighborData
            {
                cell = tilemap.Cells.GetCell(coord.x, coord.y + 1),
                edge = tilemap.Edges.GetHorizontal(coord.x, coord.y + 1)
            };

            return new[] { left, up, right, down };
        }
        
        void FindDistanceFromEdge()
        {
            var queue = new Queue<FlowTilemapCell>();
            for (int y = 0; y < tilemap.Height; y++)
            {
                for (int x = 0; x < tilemap.Width; x++)
                {
                    var cell = tilemap.Cells[x, y];
                    if (cell.CellType == FlowTilemapCellType.Floor)
                    {
                        bool allNeighborsWalkable = true;
                        var ndata = GetNeighbourData(cell);
                        foreach (var neighbour in ndata)
                        {
                            var ncell = neighbour.cell;
                            if (ncell != null)
                            {

                                if (ncell.CellType != FlowTilemapCellType.Floor)
                                {
                                    allNeighborsWalkable = false;
                                    break;
                                }

                                // Check if there's a blocking overlay
                                if (cell.Overlay != null && cell.Overlay.tileBlockingOverlay)
                                {
                                    allNeighborsWalkable = false;
                                    break;
                                }
                            }

                            var nedge = neighbour.edge;
                            if (nedge != null)
                            {
                                if (nedge.EdgeType != FlowTilemapEdgeType.Empty)
                                {
                                    allNeighborsWalkable = false;
                                    break;
                                }
                            }
                        }
                        
                        if (!allNeighborsWalkable)
                        {
                            queue.Enqueue(cell);
                            distanceCells[x, y].DistanceFromEdge = 0;
                        }
                    }
                }
            }

            while (queue.Count > 0)
            {
                var cell = queue.Dequeue();

                var x = cell.TileCoord.x;
                var y = cell.TileCoord.y;
                var ndist = distanceCells[x, y].DistanceFromEdge + 1;

                var ndata = GetNeighbourData(cell);
                foreach (var neighbour in ndata)
                {
                    var ncell = neighbour.cell;
                    if (ncell != null)
                    {
                        var ncoord = ncell.TileCoord;
                        var walkableTile = (ncell.CellType == FlowTilemapCellType.Floor);
                        if (walkableTile && cell.Overlay != null && cell.Overlay.tileBlockingOverlay)
                        {
                            walkableTile = false;
                        }

                        var nedge = neighbour.edge;
                        if (nedge != null)
                        {
                            walkableTile &= (nedge.EdgeType == FlowTilemapEdgeType.Empty);
                        }
                        
                        if (walkableTile && ndist < distanceCells[ncoord.x, ncoord.y].DistanceFromEdge)
                        {
                            distanceCells[ncoord.x, ncoord.y].DistanceFromEdge = ndist;
                            queue.Enqueue(ncell);
                        }
                    }
                }
            }
        }

        void FindDistanceFromDoor()
        {
            var queue = new Queue<FlowTilemapCell>();
            for (int y = 0; y < tilemap.Height; y++)
            {
                for (int x = 0; x < tilemap.Width; x++)
                {
                    var cell = tilemap.Cells[x, y];
                    if (cell.CellType == FlowTilemapCellType.Door)
                    {
                        queue.Enqueue(cell);
                        distanceCells[x, y].DistanceFromDoor = 0;
                    }
                    else
                    {
                        var ndata = GetNeighbourData(cell);
                        foreach (var neighbor in ndata)
                        {
                            var nedge = neighbor.edge;
                            if (nedge != null && nedge.EdgeType == FlowTilemapEdgeType.Door)
                            {
                                queue.Enqueue(cell);
                                distanceCells[x, y].DistanceFromDoor = 1;   // 1, Since we are not on the door cell
                                break;
                            }
                        }
                    }
                }
            }

            while (queue.Count > 0)
            {
                var cell = queue.Dequeue();

                var x = cell.TileCoord.x;
                var y = cell.TileCoord.y;
                var ndist = distanceCells[x, y].DistanceFromDoor + 1;

                
                var ndata = GetNeighbourData(cell);
                foreach (var neighbour in ndata)
                {
                    var ncell = neighbour.cell;
                    var nedge = neighbour.edge;
                    if (ncell == null || nedge == null) continue;
                    
                    var ncoord = ncell.TileCoord;
                    
                    var walkableTile = (ncell.CellType == FlowTilemapCellType.Floor && nedge.EdgeType == FlowTilemapEdgeType.Empty);
                    if (walkableTile && cell.Overlay != null && cell.Overlay.tileBlockingOverlay)
                    {
                        walkableTile = false;
                    }

                    if (walkableTile && ndist < distanceCells[ncoord.x, ncoord.y].DistanceFromDoor)
                    {
                        distanceCells[ncoord.x, ncoord.y].DistanceFromDoor = ndist;
                        queue.Enqueue(ncell);
                    }
                }
                
                for (int i = 0; i < 4; i++)
                {
                    var nx = x + childOffsets[i * 2 + 0];
                    var ny = y + childOffsets[i * 2 + 1];
                    var ncell = tilemap.Cells.GetCell(nx, ny);
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\FlowTilemapRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Utils;
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Tilemap
{
    public class FlowTilemapRenderResources
    {
        public Texture2D iconOneWayDoor = Texture2D.whiteTexture;
        public TexturedMaterialInstances materials;
    }

    /// <summary>
    /// Renders the tilemap on to a render texture
    /// </summary>
    public class FlowTilemapRenderer
    {
        public static void Render(RenderTexture tilemapTexture, FlowTilemap tilemap, int tileSize, FlowTilemapRenderResources resources, System.Func<FlowTilemapCell, bool> FuncCellSelected)
        {
            var oldRTT = RenderTexture.active;
            RenderTexture.active = tilemapTexture;

            GL.PushMatrix();
            GL.LoadOrtho();
            float texWidth = tilemapTexture.width;
            float texHeight = tilemapTexture.height;

            var layers = BuildQuadData(tilemap, tileSize, resources, FuncCellSelected);
            foreach (var layer in layers)
            {
                layer.material.SetPass(0);
                GL.Begin(GL.QUADS);
                var quads = layer.quads;
                foreach (var quad in quads)
                {
                    GL.Color(quad.color);

                    for (int i = 0; i < 4; i++)
                    {
                        var vert = quad.verts[(i + quad.rotateUV) % 4];
                        var uv = vert.uv;
                        GL.TexCoord2(uv.x, uv.y);

                        vert = quad.verts[i];
                        var p = vert.position;
                        GL.Vertex3(p.x, p.y, quad.z);
                    }
                }
                GL.End();
            }

            var lineMaterial = resources.materials.GetMaterial(Texture2D.whiteTexture);
            lineMaterial.SetPass(0);
            // Draw the grid lines
            GL.Begin(GL.LINES);
            GL.Color(new Color(0.0f, 0.0f, 0.0f, 0.1f));
            for (int x = 0; x < tilemap.Width; x++)
            {
                float x0 = (x * tileSize) / texWidth;
                GL.Vertex3(x0, 0, 0);
                GL.Vertex3(x0, 1, 0);
            }
            for (int y = 0; y < tilemap.Height; y++)
            {
                float y0 = (y * tileSize) / texHeight;
                GL.Vertex3(0, y0, 0);
                GL.Vertex3(1, y0, 0);
            }
            GL.End();


            GL.PopMatrix();

            RenderTexture.active = oldRTT;
        }

        static Color GetEdgeColor(FlowTilemapEdgeType edgeType)
        {
            if (edgeType == FlowTilemapEdgeType.Wall) return Color.red;
            else if (edgeType == FlowTilemapEdgeType.Fence) return Color.black;
            else if (edgeType == FlowTilemapEdgeType.Door) return Color.blue;
            else return Color.black;
        }

        static TilemapLayerRenderData[] BuildQuadData(FlowTilemap tilemap, int tileSize, FlowTilemapRenderResources resources, System.Func<FlowTilemapCell, bool> FuncCellSelected)
        {
            var textureSize = new IntVector2(tilemap.Width, tilemap.Height) * tileSize;
            float texWidth = textureSize.x;
            float texHeight = textureSize.y;
            float tileSizeU = tileSize / texWidth;
            float tileSizeV = tileSize / texHeight;

            var quadsByMaterial = new Dictionary<Material, List<TilemapRenderQuad>>();
            var materialDefault = resources.materials.GetMaterial(Texture2D.whiteTexture);
            var oneWayTexture = resources.iconOneWayDoor;

            // Draw the cells
            for (int y = 0; y < tilemap.Height; y++)
            {
                for (int x = 0; x < tilemap.Width; x++)
                {
                    var cell = tilemap.Cells[x, y];
                    var selected = FuncCellSelected.Invoke(cell);

                    Color tileColor;
                    bool canUseCustomColor = cell.CellType != FlowTilemapCellType.Door
                        && cell.CellType != FlowTilemapCellType.Wall
                        //&& cell.CellType != FlowTilemapCellType.Empty
                        ;

                    if (canUseCustomColor && cell.UseCustomColor)
                    {
                        tileColor = cell.CustomColor;
                        if (selected)
                        {
                            tileColor = GetSelectedCellColor(tileColor);
                        }
                    }
                    else
                    {
                        tileColor = GetCellColor(cell);
                    }

                    if (cell.CustomCellInfo != null && cell.CellType == FlowTilemapCellType.Custom)
                    {
                        tileColor = cell.CustomCellInfo.defaultColor;
                    }

                    tileColor.a = 1;
                    float x0 = (x * tileSize) / texWidth;
                    float y0 = (y * tileSize) / texHeight;
                    float x1 = x0 + tileSizeU;
                    float y1 = y0 + tileSizeV;

                    TilemapRenderQuad quad;
                    {
                        var v0 = new TilemapRenderVert(new Vector2(x0, y0), new Vector2(0, 1));
                        var v1 = new TilemapRenderVert(new Vector2(x0, y1), new Vector2(0, 0));
                        var v2 = new TilemapRenderVert(new Vector2(x1, y1), new Vector2(1, 0));
                        var v3 = new TilemapRenderVert(new Vector2(x1, y0), new Vector2(1, 1));
                        quad = new TilemapRenderQuad(v0, v1, v2, v3, tileColor, 0);
                        AddLayerQuad(quadsByMaterial, quad, materialDefault);
                    }


                    var overlay = cell.Overlay;
                    if (overlay != null)
                    {
                        float overlayScale = 0.5f;
                        var overlayQuad = quad.Clone();
                        var shrinkY = (overlayQuad.verts[1].position.y - overlayQuad.verts[0].position.y) * Mathf.Clamp01(1 - overlayScale) * 0.5f;
                        var shrinkX = (overlayQuad.verts[2].position.x - overlayQuad.verts[1].position.x) * Mathf.Clamp01(1 - overlayScale) * 0.5f;

                        overlayQuad.verts[0].position.x += shrinkX;
                        overlayQuad.verts[0].position.y += shrinkY;
                        overlayQuad.verts[1].position.x += shrinkX;
                        overlayQuad.verts[1].position.y -= shrinkY;
                        overlayQuad.verts[2].position.x -= shrinkX;
                        overlayQuad.verts[2].position.y -= shrinkY;
                        overlayQuad.verts[3].position.x -= shrinkX;
                        overlayQuad.verts[3].position.y += shrinkY;
                        overlayQuad.color = overlay.color;
                        overlayQuad.z = 1;
                        AddLayerQuad(quadsByMaterial, overlayQuad, materialDefault);
                    }

                    if (cell.CellType == FlowTilemapCellType.Door)
                    {
                        var doorMeta = cell.Userdata as FlowTilemapCellDoorInfo;
                        if (doorMeta != null)
                        {
                            if (doorMeta.oneWay)
                            {
                                var doorQuad = quad.Clone();
                                doorQuad.color = Color.white;
                                if (doorMeta.nodeA.x < doorMeta.nodeB.x) doorQuad.rotateUV = 1;
                                if (doorMeta.nodeA.x > doorMeta.nodeB.x) doorQuad.rotateUV = 3;
                                if (doorMeta.nodeA.y < doorMeta.nodeB.y) doorQuad.rotateUV = 2;
                                if (doorMeta.nodeA.y > doorMeta.nodeB.y) doorQuad.rotateUV = 0;
                                var materialOneWayDoor = resources.materials.GetMaterial(oneWayTexture);

                                AddLayerQuad(quadsByMaterial, doorQuad, materialOneWayDoor);
                            }
                        }
                    }
                }
            }

            // Draw the edges

            for (int y = 0; y <= tilemap.Height; y++)
            {
                for (int x = 0; x <= tilemap.Width; x++)
                {
                    var edgeH = tilemap.Edges.GetHorizontal(x, y);
                    var edgeV = tilemap.Edges.GetVertical(x, y);

                    float x0 = (x * tileSize) / texWidth;
                    float y0 = (y * tileSize) / texHeight;
                    float x1 = x0 + tileSizeU;
                    float y1 = y0 + tileSizeV;

                    float thickness = 0.2f;


                    if (edgeH.EdgeType != FlowTilemapEdgeType.Empty)
                    {
                        var edgeColor = GetEdgeColor(edgeH.EdgeType);
                        float offset = tileSizeV * thickness * 0.5f;

                        if (edgeH.EdgeType == FlowTilemapEdgeType.Door)
                        {
                            offset *= 3;
                        }

                        var ty0 = y0 - offset;
                        var ty1 = y0 + offset;
                        DrawTileEdge(x0, ty0, x1, ty1, edgeH, resources, edgeColor, materialDefault, quadsByMaterial);
                    }

                    if (edgeV.EdgeType != FlowTilemapEdgeType.Empty)
                    {
                        var edgeColor = GetEdgeColor(edgeV.EdgeType);
                        float offset = tileSizeU * thickness * 0.5f;

                        if (edgeV.EdgeType == FlowTilemapEdgeType.Door)
                        {
                            offset *= 3;
                        }

                        var tx0 = x0 - offset;
                        var tx1 = x0 + offset;
                        DrawTileEdge(tx0, y0, tx1, y1, edgeV, resources, edgeColor, materialDefault, quadsByMaterial);
                    }

                }
            }


            var layers = new List<TilemapLayerRenderData>();
            foreach (var entry in quadsByMaterial)
            {
                var layer = new TilemapLayerRenderData();
                layer.material = entry.Key;
                layer.quads = entry.Value.ToArray();
                layers.Add(layer);
            }

            return layers.ToArray();
        }

        static void DrawTileEdge(float x0, float y0, float x1, float y1, FlowTilemapEdge edge, FlowTilemapRenderResources resources, Color color, Material material, Dictionary<Material, List<TilemapRenderQuad>> quadsByMaterial)
        {
            var v0 = new TilemapRenderVert(new Vector2(x0, y0), new Vector2(0, 1));
            var v1 = new TilemapRenderVert(new Vector2(x0, y1), new Vector2(0, 0));
            var v2 = new TilemapRenderVert(new Vector2(x1, y1), new Vector2(1, 0));
            var v3 = new TilemapRenderVert(new Vector2(x1, y0), new Vector2(1, 1));
            var edgeQuad = new TilemapRenderQuad(v0, v1, v2, v3, color, 0);
            AddLayerQuad(quadsByMaterial, edgeQuad, material);

            if (edge != null && edge.EdgeType == FlowTilemapEdgeType.Door)
            {
                var doorMeta = edge.Userdata as FlowTilemapCellDoorInfo;
                if (doorMeta != null)
                {
                    if (doorMeta.oneWay)
                    {
                        var doorQuad = edgeQuad.Clone();
                        doorQuad.color = Color.white;
                        if (doorMeta.nodeA.x < doorMeta.nodeB.x) doorQuad.rotateUV = 1;
                        if (doorMeta.nodeA.x > doorMeta.nodeB.x) doorQuad.rotateUV = 3;
                        if (doorMeta.nodeA.y < doorMeta.nodeB.y) doorQuad.rotateUV = 2;
                        if (doorMeta.nodeA.y > doorMeta.nodeB.y) doorQuad.rotateUV = 0;
                        var materialOneWayDoor = resources.materials.GetMaterial(resources.iconOneWayDoor);

                        AddLayerQuad(quadsByMaterial, doorQuad, materialOneWayDoor);
                    }
                }
            }
        }

        private static void AddLayerQuad(Dictionary<Material, List<TilemapRenderQuad>> quadsByMaterial, TilemapRenderQuad quad, Material material)
        {
            if (!quadsByMaterial.ContainsKey(material))
            {
                quadsByMaterial.Add(material, new List<TilemapRenderQuad>());
            }

            quadsByMaterial[material].Add(quad);
        }

        static Color GetSelectedCellColor(Color color)
        {
            float H, S, V;
            Color.RGBToHSV(color, out H, out S, out V);
            S = Mathf.Clamp01(S * 2);
            return Color.HSVToRGB(H, S, V);
        }

        static Color GetCellColor(FlowTilemapCell cell)
        {
            switch (cell.CellType)
            {
                case FlowTilemapCellType.Empty:
                    return Color.black;

                case FlowTilemapCellType.Floor:
                    return Color.white;

                case FlowTilemapCellType.Door:
                    return Color.blue;

                case FlowTilemapCellType.Wall:
                    return new Color(0.5f, 0.5f, 0.5f);


                default:
                    return Color.magenta;
            }
        }


        struct TilemapRenderVert
        {
            public TilemapRenderVert(Vector2 position, Vector2 uv)
            {
                this.position = position;
                this.uv = uv;
            }

            public Vector2 position;
            public Vector2 uv;

            public TilemapRenderVert Clone()
            {
                return new TilemapRenderVert(position, uv);
            }
        }

        struct TilemapRenderQuad
        {
            public TilemapRenderQuad(TilemapRenderVert v0, TilemapRenderVert v1, TilemapRenderVert v2, TilemapRenderVert v3, Color color, float z)
            {
                verts = new TilemapRenderVert[4];
                verts[0] = v0;
                verts[1] = v1;
                verts[2] = v2;
                verts[3] = v3;
                this.color = color;
                this.z = z;
                rotateUV = 0;
            }

            public TilemapRenderQuad Clone()
            {
                var newQuad = new TilemapRenderQuad(
                    verts[0].Clone(),
                    verts[1].Clone(),
                    verts[2].Clone(),
                    verts[3].Clone(),
                    color, z);

                newQuad.rotateUV = rotateUV;
                return newQuad;
            }

            public TilemapRenderVert[] verts;
            public Color color;
            public float z;
            public int rotateUV;
        }


        struct TilemapLayerRenderData
        {
            public Material material;
            public TilemapRenderQuad[] quads;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Constraints\GridFlowLayoutNodeConstraintProcessorScript.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow.Constraints
{
    public class GridFlowLayoutNodeConstraintProcessorScript : IFlowLayoutNodeCreationConstraint
    {
        private readonly IGridFlowLayoutNodePositionConstraint scriptConstraint;
        private readonly Vector2Int gridSize;
        private readonly System.Random random;

        public GridFlowLayoutNodeConstraintProcessorScript(IGridFlowLayoutNodePositionConstraint scriptConstraint, Vector2Int gridSize, System.Random random)
        {
            this.scriptConstraint = scriptConstraint;
            this.gridSize = gridSize;
            this.random = random;
        }
        
        public bool CanCreateNodeAt(FlowLayoutGraphNode node, int totalPathLength, int currentPathPosition)
        {
            if (scriptConstraint == null || node == null)
            {
                // Ignore
                return true;
            }

            var nodeCoord = MathUtils.RoundToVector2Int(node.coord);
            return scriptConstraint.CanCreateNodeAt(currentPathPosition, totalPathLength, nodeCoord, gridSize);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Constraints\GridFlowLayoutNodeConstraintProcessorStartEnd.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Utils;
using System.Linq;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow.Constraints
{
    public class GridFlowLayoutNodeConstraintProcessorStartEnd : IFlowLayoutNodeCreationConstraint
    {
        readonly Vector2Int[] startPositions;
        readonly Vector2Int[] endPositions;

        public GridFlowLayoutNodeConstraintProcessorStartEnd(Vector2Int[] startPositions, Vector2Int[] endPositions)
        {
            this.startPositions = startPositions;
            this.endPositions = endPositions;
        }

        public bool CanCreateNodeAt(FlowLayoutGraphNode node, int totalPathLength, int currentPathPosition)
        {
            if (currentPathPosition == 0)
            {
                // Start Node
                if (startPositions != null && startPositions.Length > 0)
                {
                    var coord = MathUtils.RoundToVector2Int(node.coord);
                    return startPositions.Contains(coord);
                }
            }
            else if (currentPathPosition == totalPathLength - 1)
            {
                // End Node
                if (endPositions != null && endPositions.Length > 0)
                {
                    var coord = MathUtils.RoundToVector2Int(node.coord);
                    return endPositions.Contains(coord);
                }
            }

            return true;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Constraints\IGridFlowLayoutNodePositionConstraint.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    public interface IGridFlowLayoutNodePositionConstraint
    {
        bool CanCreateNodeAt(int currentPathPosition, int totalPathLength, Vector2Int nodeCoord, Vector2Int gridSize);
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\TilemapPlacement\TilemapItemPlacementStrategy.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Items;

namespace DungeonArchitect.Flow.Impl.GridFlow
{
    public class TilemapItemPlacementStrategyContext
    {
        public FlowTilemap tilemap;
        public FlowTilemapDistanceField distanceField;
        public System.Random random;
        public FlowLayoutGraphNode node;
        public FlowTilemapCell[] chunkTiles;
    }

    public interface ITilemapItemPlacementStrategy
    {
        bool PlaceItems(FlowItem item, FlowTilemapCell[] freeCells, TilemapItemPlacementSettings settings, TilemapItemPlacementStrategyContext context, ref int outFreeTileIndex, ref string errorMessage);
    }

    [System.Serializable]
    public enum TilemapItemPlacementMethod
    {
        RandomTile,
        NearEdges,
        Script
    }

    [System.Serializable]
    public class TilemapItemPlacementSettings : IFlowDomainData
    {
        public TilemapItemPlacementMethod placementMethod = TilemapItemPlacementMethod.RandomTile;
        public bool avoidPlacingNextToDoors = true;
        public string placementScriptClass = "";
        public bool fallbackToRandomPlacement = true;

        public IFlowDomainData Clone()
        {
            var newObj = new TilemapItemPlacementSettings();
            newObj.placementMethod = placementMethod;
            newObj.avoidPlacingNextToDoors = avoidPlacingNextToDoors;
            newObj.placementScriptClass = placementScriptClass;
            newObj.fallbackToRandomPlacement = fallbackToRandomPlacement;
            return newObj;
        }
    }

    public class TilemapItemPlacementStrategyFactory
    {
        public static ITilemapItemPlacementStrategy Create(TilemapItemPlacementMethod method)
        {
            if (method == TilemapItemPlacementMethod.NearEdges)
            {
                return new TilemapItemPlacementStrategyNearEdge();
            }
            else if (method == TilemapItemPlacementMethod.Script)
            {
                return new TilemapItemPlacementStrategyScript();
            }
            else if (method == TilemapItemPlacementMethod.RandomTile)
            {
                return new TilemapItemPlacementStrategyRandom();
            }
            else
            {
                return new TilemapItemPlacementStrategyRandom();
            }
        }
    }

    public class TilemapItemPlacementStrategyUtils
    {
        public static bool Validate(TilemapItemPlacementSettings settings, ref string errorMessage)
        {
            if (settings.placementMethod == TilemapItemPlacementMethod.Script)
            {
                if (settings.placementScriptClass == null || settings.placementScriptClass.Length == 0)
                {
                    errorMessage = "Invalid script reference";
                    return false;
                }
            }
            return true;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Assets\SnapGridFlowAsset.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{
    public class SnapGridFlowAsset : FlowAssetBase
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Assets\SnapGridFlowModuleBounds.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{
    [System.Serializable]
    public class SnapGridFlowModuleBounds : ScriptableObject
    {
        [Tooltip("The world size of a module chunk (1x1x1).  A module can span multiple chunks (e.g 2x2x1)")]
        public Vector3 chunkSize = new Vector3(40, 20, 40);

        [Tooltip("How high do you want the door to be from the lower bounds. This will create a door visual indicator on the bounds actor, aiding your while designing your modules.  This is used for preview only")]
        public float doorOffsetY = 5;

        [Tooltip("The color of the bounds wireframe. Use this bounds as a reference while designing your module prefabs.  This is used for preview only")]
        public Color boundsColor = Color.red;

        [Tooltip("The color of the Door Info. Use this align the doors in your module prefabs.  This is used for preview only")]
        public Color doorColor = Color.blue;

        [Tooltip("Specifies how big the blue door marker visuals will be.  This is used for preview only")]
        public float doorDrawSize = 4;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Assets\SnapGridFlowModuleDatabase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Components;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{   
    
    // Snap Grid Flow Module Database
    [System.Serializable]
    public class SgfModuleDatabaseConnectionInfo
    {
        public int ConnectionIndex = -1;
        public Matrix4x4 Transform = Matrix4x4.identity;
        public string Category = "";
    };

    [System.Serializable]
    public class SgfModuleDatabasePlaceableMarkerInfo
    {
        public PlaceableMarker placeableMarkerTemplate;
        public int count;
    }
    
    [System.Serializable]
    public class SgfModuleDatabaseItem : ISerializationCallbackReceiver {
        [SerializeField]
        public SnapGridFlowModule ModulePrefab;
        [SerializeField]
        public string Category = "Room";
        [SerializeField]
        public bool allowRotation = true;
        // How often do you want this to be selected?  0.0 for least preference, 1.0 for most preference.  Specify a value from 0.0 to 1.0 
        [SerializeField]
        public float SelectionWeight = 1.0f;
        
        [HideInInspector]
        public Bounds ModuleBounds;
        [HideInInspector]
        public Vector3Int NumChunks = new Vector3Int(1, 1, 1);
        [HideInInspector]
        public SgfModuleDatabaseConnectionInfo[] Connections;
        [HideInInspector]
        public SgfModuleAssembly[] RotatedAssemblies;   // 4 Cached module assemblies rotated in 90 degree CW steps
        [HideInInspector]
        public SgfModuleDatabasePlaceableMarkerInfo[] AvailableMarkers;
        public void OnBeforeSerialize()
        {
        }

        public void OnAfterDeserialize()
        {
            if (Category.Length == 0 && ModulePrefab == null && !allowRotation && SelectionWeight == 0)
            {
                Category = "Room";
                allowRotation = true;
                SelectionWeight = 1;
            }
        }
    };

    [Serializable]
    public class SnapGridFlowModuleDatabase : ScriptableObject
    {
        public SnapGridFlowModuleBounds ModuleBoundsAsset;
        public SgfModuleDatabaseItem[] Modules;

        public SgfModuleDatabaseItem[] GetCategoryModules(string category)
        {
            var result = new List<SgfModuleDatabaseItem>();
            
            foreach (var moduleItem in Modules)
            {
                if (moduleItem.Category == category)
                {
                    result.Add(moduleItem);
                }
            }

            return result.ToArray();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Components\SnapGridFlowModule.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Components
{
    public class SnapGridFlowModule : MonoBehaviour
    {
        private readonly Vector3 CHUNK_SIZE = new Vector3(15f, 15f, 15f);
        public Vector3Int numChunks = new Vector3Int(1, 1, 1);
        public SnapGridFlowModuleBounds moduleBounds;
        public bool drawBounds = true;
        
        private void OnValidate()
        {
            AddOrUpdateBoxCollider();
        }
    
        public void AddOrUpdateBoxCollider()
        {
            var boxCollider = GetComponent<BoxCollider>();
            if (boxCollider == null)
            {
                boxCollider = gameObject.AddComponent<BoxCollider>();
            }

            if (CompareTag("Untagged"))
            {
                tag = "Room";
            }
            boxCollider.size = new Vector3(numChunks.x * CHUNK_SIZE.x, numChunks.y * CHUNK_SIZE.y, numChunks.z * CHUNK_SIZE.z);
            boxCollider.center = boxCollider.size * 0.5f;
            boxCollider.isTrigger = true;
        
            if (GetComponent<RoomEnterTriggerDetector>() == null)
            {
                gameObject.AddComponent<RoomEnterTriggerDetector>();
            }
        }
        
        void OnDrawGizmosSelected()
        {
            DrawGizmo(true);
        }

        void OnDrawGizmos()
        {
            DrawGizmo(false);
        }

        void DrawGizmo(bool selected)
        {
            if (!drawBounds || moduleBounds == null) return;
            var localToWorld = transform.localToWorldMatrix;
            
            var boxSize = Vector3.Scale(moduleBounds.chunkSize, MathUtils.ToVector3(numChunks));
            var extent = boxSize * 0.5f;
            var center = extent;
            
            // Draw the module bounds
            Gizmos.color = moduleBounds.boundsColor;
            DrawWireCube(localToWorld, center, extent);
            //Gizmos.DrawWireCube(center, boxSize);

            // Draw internal chunk bounds
            {
                var wireColor = moduleBounds.boundsColor;
                wireColor *= 0.5f;
                Gizmos.color = wireColor;
                
                Func<int, Vector2, Vector3Int, Vector3> funcCoordX = (i, p, chunkCount) => new Vector3(i, p.x * chunkCount.y, p.y * chunkCount.z);
                Func<int, Vector2, Vector3Int, Vector3> funcCoordY = (i, p, chunkCount) => new Vector3(p.x * chunkCount.x, i, p.y * chunkCount.z);
                Func<int, Vector2, Vector3Int, Vector3> funcCoordZ = (i, p, chunkCount) => new Vector3(p.x * chunkCount.x, p.y * chunkCount.y, i);

                Func<Vector3Int, int> funcSizeX = (v) => v.x;
                Func<Vector3Int, int> funcSizeY = (v) => v.y;
                Func<Vector3Int, int> funcSizeZ = (v) => v.z;

                DrawInterChunkBounds(localToWorld, funcCoordX, funcSizeX);
                DrawInterChunkBounds(localToWorld, funcCoordY, funcSizeY);
                DrawInterChunkBounds(localToWorld, funcCoordZ, funcSizeZ);
            }
            
            // Draw door indicators
            {
                Gizmos.color = moduleBounds.doorColor;
                var offsetY = moduleBounds.doorOffsetY;

                Vector3[] doorPoints = new Vector3[Constants.DoorPoints.Length];
                for (var i = 0; i < doorPoints.Length; i++)
                {
                    doorPoints[i] = Constants.DoorPoints[i] * moduleBounds.doorDrawSize;
                }
                Vector3[] verticalDoorPoints = new Vector3[Constants.VerticalDoorPoints.Length];
                for (var i = 0; i < verticalDoorPoints.Length; i++)
                {
                    verticalDoorPoints[i] = Constants.VerticalDoorPoints[i] * moduleBounds.doorDrawSize;
                }

                var localToWorldMatrix = transform.localToWorldMatrix;
                
                // Draw along the X-axis
                {
                    var rotationX = Quaternion.identity;
                    for (int x = 0; x < numChunks.x; x++)
                    {
                        for (int y = 0; y < numChunks.y; y++)
                        {
                            var coordA = new Vector3(x + 0.5f, y, 0);
                            var coordB = new Vector3(x + 0.5f, y, numChunks.z);
                            var rotation = Quaternion.identity;

                            var doorPosA = Vector3.Scale(coordA, moduleBounds.chunkSize);
                            var doorPosB = Vector3.Scale(coordB, moduleBounds.chunkSize);

                            doorPosA.y += offsetY;
                            doorPosB.y += offsetY;

                            var transformA = localToWorldMatrix * Matrix4x4.TRS(doorPosA, rotationX, Vector3.one);
                            DrawLines(transformA, doorPoints);

                            var transformB = localToWorldMatrix * Matrix4x4.TRS(doorPosB, rotationX, Vector3.one);
                            DrawLines(transformB, doorPoints);
                        }
                    }
                }

                // Draw along the Z-axis
                {
                    var rotationZ = Quaternion.AngleAxis(90, Vector3.up);
                    for (int z = 0; z < numChunks.z; z++)
                    {
                        for (int y = 0; y < numChunks.y; y++)
                        {
                            var coordA = new Vector3(0, y, z + 0.5f);
                            var coordB = new Vector3(numChunks.x, y, z + 0.5f);
                            var rotation = Quaternion.identity;

                            var doorPosA = Vector3.Scale(coordA, moduleBounds.chunkSize);
                            var doorPosB = Vector3.Scale(coordB, moduleBounds.chunkSize);

                            doorPosA.y += offsetY;
                            doorPosB.y += offsetY;

                            var transformA = localToWorldMatrix * Matrix4x4.TRS(doorPosA, rotationZ, Vector3.one);
                            DrawLines(transformA, doorPoints);

                            var transformB = localToWorldMatrix * Matrix4x4.TRS(doorPosB, rotationZ, Vector3.one);
                            DrawLines(transformB, doorPoints);
                        }
                    }
                }
                
                // Draw along the Y-axis
                {
                    var rotationY = Quaternion.identity;
                    
                    for (int x = 0; x < numChunks.x; x++)
                    {
                        for (int z = 0; z < numChunks.z; z++)
                        {
                            var coordA = new Vector3(x + 0.5f, 0, z + 0.5f);
                            var coordB = new Vector3(x + 0.5f, numChunks.y, z + 0.5f);
                            var rotation = Quaternion.identity;

                            var doorPosA = Vector3.Scale(coordA, moduleBounds.chunkSize);
                            var doorPosB = Vector3.Scale(coordB, moduleBounds.chunkSize);

                            var transformA = localToWorldMatrix * Matrix4x4.TRS(doorPosA, rotationY, Vector3.one);
                            DrawLines(transformA, verticalDoorPoints);

                            var transformB = localToWorldMatrix * Matrix4x4.TRS(doorPosB, rotationY, Vector3.one);
                            DrawLines(transformB, verticalDoorPoints);
                        }
                    }
                }
            }
        }

        class Constants
        {
            public static readonly Vector2[] LocalPoints = new Vector2[]
            {
                new Vector2(0, 0),
                new Vector2(1, 0),
                new Vector2(1, 1),
                new Vector2(0, 1)
            };

            static readonly float doorSizeX = 0.5f;
            static readonly float doorSizeY = 1;

            public static readonly Vector3[] DoorPoints = new Vector3[]
            {
                // Horizontal Line
                new Vector3(-doorSizeX, 0, 0),
                new Vector3(doorSizeX, 0, 0),

                // Vertical Line
                new Vector3(0, 0, 0),
                new Vector3(0, doorSizeY, 0)
            };

            public static readonly Vector3[] VerticalDoorPoints;

            static Constants()
            {
                // Build the vertical door points
                {
                    float circleRadius = 0.5f;
                    float plusRadius = 0.25f;
                    var circlePoints  = new List<Vector3>();
                    int numPoints = 12;
                    for (int i = 0; i < numPoints; i++)
                    {
                        var angle = i / (float) numPoints * 2 * Mathf.PI;
                        var x = Mathf.Cos(angle) * circleRadius;
                        var z = Mathf.Sin(angle) * circleRadius;
                        circlePoints.Add(new Vector3(x, 0, z));
                    }

                    var verticalDoorPoints = new List<Vector3>();
                    for (var i = 0; i < circlePoints.Count; i++)
                    {
                        var p0 = circlePoints[i];
                        var p1 = circlePoints[(i + 1) % circlePoints.Count];
                        verticalDoorPoints.Add(p0);
                        verticalDoorPoints.Add(p1);
                    }

                    verticalDoorPoints.Add(new Vector3(-plusRadius, 0, 0));
                    verticalDoorPoints.Add(new Vector3(plusRadius, 0, 0));
                    verticalDoorPoints.Add(new Vector3(0, 0, -plusRadius));
                    verticalDoorPoints.Add(new Vector3(0, 0, plusRadius));

                    VerticalDoorPoints = verticalDoorPoints.ToArray();
                }
            }
        }

        void DrawLines(Matrix4x4 transform, Vector3[] points)
        {
            for (var i = 0; i + 1 < points.Length; i += 2)
            {
                var p0 = transform.MultiplyPoint(points[i]);
                var p1 = transform.MultiplyPoint(points[i + 1]);
                Gizmos.DrawLine(p0, p1);
            }
        }
        
        void DrawInterChunkBounds(Matrix4x4 transform, Func<int, Vector2, Vector3Int, Vector3> funcCoord, Func<Vector3Int, int> funcSize)
        {
            int count = funcSize(numChunks);
            for (int i = 1; i < count; i++)
            {
                var points = new List<Vector3>();
                foreach (var localPoint in Constants.LocalPoints)
                {
                    var coord = funcCoord(i, localPoint, numChunks);
                    points.Add(Vector3.Scale(coord, moduleBounds.chunkSize));
                }
                    
                // Draw the points
                for (var ip = 0; ip < points.Count; ip++)
                {
                    var p0 = transform.MultiplyPoint(points[ip]);
                    var p1 = transform.MultiplyPoint(points[(ip + 1) % points.Count]);
                    Gizmos.DrawLine(p0, p1);
                }
            }
        }

        private static readonly Vector3[] LocalCubeVerts = new Vector3[]
        {
            new Vector3(-1, -1, -1),
            new Vector3(1, -1, -1),
            new Vector3(1, 1, -1),
            new Vector3(-1, 1, -1),
            new Vector3(-1, -1, 1),
            new Vector3(1, -1, 1),
            new Vector3(1, 1, 1),
            new Vector3(-1, 1, 1),
        };
        
        void DrawWireCube(Matrix4x4 transform, Vector3 center, Vector3 extent)
        {
            var boxLines = new List<Vector3>();
            var wirePoints = new List<Vector3>();
            foreach (var localVert in LocalCubeVerts)
            {
                wirePoints.Add(Vector3.Scale(localVert, extent));
            }
            
            // Bottom
            for (int i = 0; i < 4; i++)
            {
                boxLines.Add(wirePoints[i]);
                boxLines.Add(wirePoints[(i + 1) % 4]);
            }
            
            // Top
            for (int i = 0; i < 4; i++)
            {
                boxLines.Add(wirePoints[4 + i]);
                boxLines.Add(wirePoints[4 + (i + 1) % 4]);
            }
            
            // Sides
            for (int i = 0; i < 4; i++)
            {
                boxLines.Add(wirePoints[i]);
                boxLines.Add(wirePoints[i + 4]);
            }

            var boxTransform = transform * Matrix4x4.Translate(center);
            DrawLines(boxTransform, boxLines.ToArray());
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Constraints\ISGFLayoutNodeCategoryConstraint.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect
{
    public interface ISGFLayoutNodeCategoryConstraint
    {
        string[] GetModuleCategoriesAtNode(int currentPathPosition, int pathLength);
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Constraints\ISGFLayoutNodePositionConstraint.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    public struct SGFLayoutNodePositionConstraintSettings
    {
        public int CurrentPathPosition;
        public int TotalPathLength;
        public Vector3Int NodeCoord;
        public Vector3Int GridSize;
        public System.Random Random;
    }
    public interface ISGFLayoutNodePositionConstraint
    {
        bool CanCreateNodeAt(SGFLayoutNodePositionConstraintSettings settings);
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Constraints\SGFLayoutNodeConstraintProcessorScript.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Constraints
{
    public class SGFLayoutNodeConstraintProcessorScript : IFlowLayoutNodeCreationConstraint
    {
        private readonly ISGFLayoutNodePositionConstraint scriptConstraint;
        private readonly Vector3Int gridSize;
        private readonly System.Random random;

        public SGFLayoutNodeConstraintProcessorScript(ISGFLayoutNodePositionConstraint scriptConstraint, Vector3Int gridSize, System.Random random)
        {
            this.scriptConstraint = scriptConstraint;
            this.gridSize = gridSize;
            this.random = random;
        }
        
        public bool CanCreateNodeAt(FlowLayoutGraphNode node, int totalPathLength, int currentPathPosition)
        {
            if (scriptConstraint == null || node == null)
            {
                // Ignore
                return true;
            }

            var nodeCoord = MathUtils.RoundToVector3Int(node.coord);
            var settings = new SGFLayoutNodePositionConstraintSettings
            {
                CurrentPathPosition = currentPathPosition,
                TotalPathLength = totalPathLength,
                NodeCoord = nodeCoord,
                GridSize = gridSize,
                Random = random
            };
            return scriptConstraint.CanCreateNodeAt(settings);
        }
    }
    
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Constraints\SGFLayoutNodeConstraintProcessorStartEnd.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Linq;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Constraints
{
    public class SGFLayoutNodeConstraintProcessorStartEnd : IFlowLayoutNodeCreationConstraint
    {
        readonly Vector3Int[] startPositions;
        readonly Vector3Int[] endPositions;

        public SGFLayoutNodeConstraintProcessorStartEnd(Vector3Int[] startPositions, Vector3Int[] endPositions)
        {
            this.startPositions = startPositions;
            this.endPositions = endPositions;
        }

        public bool CanCreateNodeAt(FlowLayoutGraphNode node, int totalPathLength, int currentPathPosition)
        {
            if (currentPathPosition == 0)
            {
                // Start Node
                if (startPositions != null && startPositions.Length > 0)
                {
                    var coord = MathUtils.RoundToVector3Int(node.coord);
                    return startPositions.Contains(coord);
                }
            }
            else if (currentPathPosition == totalPathLength - 1)
            {
                // End Node
                if (endPositions != null && endPositions.Length > 0)
                {
                    var coord = MathUtils.RoundToVector3Int(node.coord);
                    return endPositions.Contains(coord);
                }
            }

            return true;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Module\SGFModuleStructures.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Components;
using DungeonArchitect.Frameworks.Snap;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{
    [System.Serializable]
    public class SgfModuleDoor
    {
        // The transform of the door relative to the module
        public Matrix4x4 LocalTransform;

        // The module that hosts this door
        [NonSerialized] 
        public SgfModuleNode Owner;

        // The other door that is connected to this door
        public SgfModuleDoor ConnectedDoor;

        // The spawned door component
        public SnapConnection SpawnedDoor;

        public SgfModuleAssemblySideCell CellInfo;
    };

    [System.Serializable]
    public class SgfModuleNode {
        public DungeonUID ModuleInstanceId;
        public Matrix4x4 WorldTransform = Matrix4x4.identity;
        
        [NonSerialized]
        public SgfModuleDatabaseItem ModuleDBItem;

        [NonSerialized]
        public FlowLayoutGraphNode LayoutNode;
        
        // The spawned module prefab
        public SnapGridFlowModule SpawnedModule;

        // The doors in this module
        public SgfModuleDoor[] Doors = new SgfModuleDoor[0];

        public HashSet<SgfModuleDoor> Incoming = new HashSet<SgfModuleDoor>();
        public HashSet<SgfModuleDoor> Outgoing = new HashSet<SgfModuleDoor>();

        public Bounds GetModuleBounds()
        {
            return MathUtils.TransformBounds(WorldTransform, ModuleDBItem.ModuleBounds);
        }
    };
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Module\SnapGridFlowModuleAssembly.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow
{
    
    // Snap Grid Flow Module Assembly Structures
    [System.Serializable]
    public struct SgfModuleAssemblySideCell
    {
        public SgfModuleAssemblySideCell(int connectionIdx)
        {
            this.connectionIdx = connectionIdx;
            this.nodeId = DungeonUID.Empty;
            this.linkedNodeId = DungeonUID.Empty;
            this.linkId = DungeonUID.Empty;
        }

        public static readonly SgfModuleAssemblySideCell Empty = new SgfModuleAssemblySideCell()
        {
            connectionIdx = -1,
            nodeId = DungeonUID.Empty,
            linkedNodeId = DungeonUID.Empty,
            linkId = DungeonUID.Empty
        };
        
        public int connectionIdx;
        public DungeonUID nodeId;
        public DungeonUID linkedNodeId;
        public DungeonUID linkId;

        public bool HasConnection() { return connectionIdx != -1; }
    }
    
    [System.Serializable]
    public class SgfModuleAssemblySide {
        [SerializeField]
        public int width = 0;
        
        [SerializeField]
        public int height = 0;
        
        [SerializeField]
        public SgfModuleAssemblySideCell[] connectionIndices;

        public void Init(int width, int height)
        {
            this.width = width;
            this.height = height;
            
            this.connectionIndices = new SgfModuleAssemblySideCell[width * height];
            for (var i = 0; i < connectionIndices.Length; i++)
            {
                connectionIndices[i] = SgfModuleAssemblySideCell.Empty;
            }
        }

        public void SetZeroValues()
        {
            for (var i = 0; i < connectionIndices.Length; i++)
            {
                connectionIndices[i] = SgfModuleAssemblySideCell.Empty;
            }
        }
        
        public SgfModuleAssemblySide Clone()
        {
            var clone = new SgfModuleAssemblySide();
            clone.width = width;
            clone.height = height;
            clone.connectionIndices = new SgfModuleAssemblySideCell[width * height];
            for (var i = 0; i < connectionIndices.Length; i++)
            {
                clone.connectionIndices[i] = connectionIndices[i];
            }

            return clone;
        }
        
        public SgfModuleAssemblySideCell Get(int x, int y) {
            Debug.Assert(IsCoordValid(x, y));
            return connectionIndices[y * width + x];
        }

        public bool Set(int x, int y, SgfModuleAssemblySideCell cell)
        {
            if (!IsCoordValid(x, y)) return false;
            
            connectionIndices[y * width + x] = cell;
            return true;
        }

        public bool IsCoordValid(int x, int y)
        {
            return x >= 0 && x < width && y >= 0 && y < height;
        }

        public SgfModuleAssemblySide Rotate90Cw()
        {
            var rotatedSide = new SgfModuleAssemblySide();
            rotatedSide.Init(height, width);
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    var cell = Get(x, y);
                    int xx = height - 1 - y;
                    int yy = x;
                    rotatedSide.Set(xx, yy, cell);
                }
            }
    
            return rotatedSide;
        }
        
        public static readonly int IndexValidUnknown = -2;
    };

    [System.Serializable]
    public class SgfModuleAssembly
    {
        public Vector3Int numChunks;
        public SgfModuleAssemblySide front = new SgfModuleAssemblySide();
        public SgfModuleAssemblySide left = new SgfModuleAssemblySide();
        public SgfModuleAssemblySide back = new SgfModuleAssemblySide();
        public SgfModuleAssemblySide right = new SgfModuleAssemblySide();
        public SgfModuleAssemblySide top = new SgfModuleAssemblySide();
        public SgfModuleAssemblySide down = new SgfModuleAssemblySide();

        public void Initialize(Vector3Int numChunks)
        {
            this.numChunks = numChunks;
            front.Init(this.numChunks.x, this.numChunks.y);
            left.Init(this.numChunks.z, this.numChunks.y);
            back.Init(this.numChunks.x, this.numChunks.y);
            right.Init(this.numChunks.z, this.numChunks.y);

            top.Init(this.numChunks.x, this.numChunks.z);
            down.Init(this.numChunks.x, this.numChunks.z);
        }

        public void SetZeroValues()
        {
            front.SetZeroValues();
            left.SetZeroValues();
            back.SetZeroValues();
            right.SetZeroValues();

            top.SetZeroValues();
            down.SetZeroValues();
        }
        

        public bool CanFit(SgfModuleAssembly assemblyToFit, out SgfModuleAssemblySideCell[] outDoorIndices)
        {
            if (numChunks != assemblyToFit.numChunks)
            {
                outDoorIndices = new SgfModuleAssemblySideCell[0];
                return false;
            }
            
            var hostSides = new SgfModuleAssemblySide[] { front, left, back, right, top, down };
            var targetSides = new SgfModuleAssemblySide[] { assemblyToFit.front, assemblyToFit.left, assemblyToFit.back, assemblyToFit.right, assemblyToFit.top, assemblyToFit.down };

            var doorIndices = new List<SgfModuleAssemblySideCell>();
            for (int s = 0; s < 6; s++) {
                var hostSide = hostSides[s];
                var targetSide = targetSides[s];
                Debug.Assert(hostSide.width == targetSide.width && hostSide.height == targetSide.height);
                var numEntries = hostSide.connectionIndices.Length;
                for (int i = 0; i < numEntries; i++) {
                    bool bTargetRequiresConnection = targetSide.connectionIndices[i].HasConnection();
                    if (bTargetRequiresConnection) {
                        bool bHostContainsConnection = hostSide.connectionIndices[i].HasConnection();
                        if (bHostContainsConnection) {
                            var doorCell = new SgfModuleAssemblySideCell();
                            doorCell.connectionIdx = hostSide.connectionIndices[i].connectionIdx;
                            doorCell.nodeId = targetSide.connectionIndices[i].nodeId;
                            doorCell.linkedNodeId = targetSide.connectionIndices[i].linkedNodeId;
                            doorIndices.Add(doorCell);
                        }
                        else {
                            outDoorIndices = new SgfModuleAssemblySideCell[0];
                            return false;
                        }
                    }
                }
            }

            outDoorIndices = doorIndices.ToArray();
            return true;
        }
    }
    
    
    public class SGFModuleAssemblyBuilder {
        
        enum EAssemblySide  { Unknown, Front, Left, Back, Right, Down, Top };

        class AssemblyDoorPositions
        {
            public EAssemblySide Side;
            public Vector3 LocalPosition;
            public IntVector2 Coord;

            public AssemblyDoorPositions(EAssemblySide side, Vector3 localPosition, IntVector2 coord)
            {
                this.Side = side;
                this.LocalPosition = localPosition;
                this.Coord = coord;
            }
        }
        
        public static void Build(SnapGridFlowModuleBounds moduleBoundsAsset, SgfModuleDatabaseItem moduleInfo, out SgfModuleAssembly outAssembly)
        {
            var chunkSize = moduleBoundsAsset.chunkSize;
            var numChunks = moduleInfo.NumChunks;
            outAssembly = new SgfModuleAssembly();
            outAssembly.Initialize(numChunks);
            
            Vector3 baseOffset = -moduleInfo.ModuleBounds.min;
            for (int connectionIdx = 0; connectionIdx < moduleInfo.Connections.Length; connectionIdx++) {
                var connectionInfo = moduleInfo.Connections[connectionIdx];
                Vector3 connectionLocation = Matrix.GetTranslation(ref connectionInfo.Transform) + baseOffset;
                
                var doorPositions = GetDoorPositions(moduleBoundsAsset.chunkSize, moduleBoundsAsset.doorOffsetY, moduleInfo.NumChunks);

                AssemblyDoorPositions bestDoor = null;
                float bestDistance = float.MaxValue;
                foreach (var doorInfo in doorPositions) {
                    // Check if the connection is aligned with this door's direction
                    
                    
                    float distance = (doorInfo.LocalPosition - connectionLocation).magnitude;
                    if (distance < bestDistance) {
                        bestDistance = distance;
                        bestDoor = doorInfo;
                    }
                }

                var connectionCell = new SgfModuleAssemblySideCell(connectionIdx);
                if (bestDoor != null)
                {
                    var cx = bestDoor.Coord.x;
                    var cy = bestDoor.Coord.y;
                    var bestSide = bestDoor.Side;
                    if (bestSide == EAssemblySide.Front)
                    {
                        if (!outAssembly.front.Set(cx, cy, connectionCell))
                        {
                            Debug.LogError("Failed to register connection on module side: FRONT");
                        }
                        //Debug.Log("FRONT: " + string.Format("Location ({0}, {1})", cx, cy));
                    }
                    else if (bestSide == EAssemblySide.Left)
                    {
                        if (!outAssembly.left.Set(cx, cy, connectionCell))
                        {
                            Debug.LogError("Failed to register connection on module side: LEFT");
                        }
                        //Debug.Log("LEFT: " + string.Format("Location ({0}, {1})", cx, cy));
                    }
                    else if (bestSide == EAssemblySide.Back)
                    {
                        if (!outAssembly.back.Set(cx, cy, connectionCell))
                        {
                            Debug.LogError("Failed to register connection on module side: BACK");
                        }
                        //Debug.Log("BACK: " + string.Format("Location ({0}, {1})", cx, cy));
                    }
                    else if (bestSide == EAssemblySide.Right)
                    {
                        if (!outAssembly.right.Set(cx, cy, connectionCell))
                        {
                            Debug.LogError("Failed to register connection on module side: RIGHT");
                        }
                        //Debug.Log("RIGHT: " + string.Format("Location ({0}, {1})", cx, cy));
                    }
                    else if (bestSide == EAssemblySide.Down)
                    {
                        if (!outAssembly.down.Set(cx, cy, connectionCell))
                        {
                            Debug.LogError("Failed to register connection on module side: DOWN");
                        }
                        //Debug.Log("DOWN: " + string.Format("Location ({0}, {1})", cx, cy));
                    }
                    else if (bestSide == EAssemblySide.Top)
                    {
                        if (!outAssembly.top.Set(cx, cy, connectionCell))
                        {
                            Debug.LogError("Failed to register connection on module side: TOP");
                        }
                        //Debug.Log("TOP: " + string.Format("Location ({0}, {1})", cx, cy));
                    }
                }
            }
        }

        static AssemblyDoorPositions[] GetDoorPositions(Vector3 chunkSize, float offsetY, Vector3Int numChunks)
        {
            var doorPositions = new List<AssemblyDoorPositions>();
            
            // Process along the X-axis
            {
                for (int x = 0; x < numChunks.x; x++)
                {
                    for (int y = 0; y < numChunks.y; y++)
                    {
                        var coordFront = new Vector3(x + 0.5f, y, 0);               // Front
                        var coordBack = new Vector3(x + 0.5f, y, numChunks.z);        // Back
                        var rotation = Quaternion.identity;

                        var doorPosFront = Vector3.Scale(coordFront, chunkSize);
                        var doorPosBack = Vector3.Scale(coordBack, chunkSize);

                        doorPosFront.y += offsetY;
                        doorPosBack.y += offsetY;

                        var icoordFront = new IntVector2(x, y);
                        var icoordBack = new IntVector2(numChunks.x - 1 - x, y);
                        
                        doorPositions.Add(new AssemblyDoorPositions(EAssemblySide.Front, doorPosFront, icoordFront));
                        doorPositions.Add(new AssemblyDoorPositions(EAssemblySide.Back, doorPosBack, icoordBack));
                    }
                }
            }

            // Process along the Z-axis
            {
                for (int z = 0; z < numChunks.z; z++)
                {
                    for (int y = 0; y < numChunks.y; y++)
                    {
                        var coordRight = new Vector3(0, y, z + 0.5f);           // Right
                        var coordLeft = new Vector3(numChunks.x, y, z + 0.5f);    // Left
                        var rotation = Quaternion.identity;

                        var doorPosRight = Vector3.Scale(coordRight, chunkSize);
                        var doorPosLeft = Vector3.Scale(coordLeft, chunkSize);

                        doorPosRight.y += offsetY;
                        doorPosLeft.y += offsetY;

                        var icoordRight = new IntVector2(numChunks.z - 1 - z, y);
                        var icoordLeft = new IntVector2(z, y);
                        
                        doorPositions.Add(new AssemblyDoorPositions(EAssemblySide.Right, doorPosRight, icoordRight));
                        doorPositions.Add(new AssemblyDoorPositions(EAssemblySide.Left, doorPosLeft, icoordLeft));
                    }
                }
            }

            // Process along the Y-axis
            {
                for (int x = 0; x < numChunks.x; x++)
                {
                    for (int z = 0; z < numChunks.z; z++)
                    {
                        var coordDown = new Vector3(x + 0.5f, 0, z + 0.5f);            // Down
                        var coordTop = new Vector3(x + 0.5f, numChunks.y, z + 0.5f);    // Top
                        var rotation = Quaternion.identity;

                        var doorPosDown = Vector3.Scale(coordDown, chunkSize);
                        var doorPosTop = Vector3.Scale(coordTop, chunkSize);

                        var icoordDown = new IntVector2(x, z);
                        var icoordTop = new IntVector2(x, z);
                        
                        doorPositions.Add(new AssemblyDoorPositions(EAssemblySide.Down, doorPosDown, icoordDown));
                        doorPositions.Add(new AssemblyDoorPositions(EAssemblySide.Top, doorPosTop, icoordTop));
                    }
                }
            }

            return doorPositions.ToArray();
        }

        private static readonly Dictionary<Vector3Int, SgfModuleAssembly> AssemblyInstanceBySize = new Dictionary<Vector3Int, SgfModuleAssembly>();
        private static SgfModuleAssemblySideCell _cellCache = new SgfModuleAssemblySideCell();
        
        public static void Build(FlowLayoutGraphQuery graphQuery, FlowLayoutPathNodeGroup group, FFAGConstraintsLink[] incomingNodes, out SgfModuleAssembly outAssembly)
        {
            var minCoordF = new Vector3();
            var maxCoordF = new Vector3();
            
            for (int i = 0; i < group.GroupNodes.Count; i++) {
                var nodeId = group.GroupNodes[i];
                var node = graphQuery.GetNode(nodeId);
                if (node == null) {
                    node = graphQuery.GetSubNode(nodeId);
                }
                Debug.Assert(node != null);
                
                if (i == 0) {
                    minCoordF = maxCoordF = node.coord; 
                }
                else {
                    minCoordF = MathUtils.ComponentMin(minCoordF, node.coord);
                    maxCoordF = MathUtils.ComponentMax(maxCoordF, node.coord);
                }
            }

            var minCoord = MathUtils.RoundToVector3Int(minCoordF);
            var maxCoord = MathUtils.RoundToVector3Int(maxCoordF);

            var numChunks = maxCoord - minCoord + new Vector3Int(1, 1, 1);
            
            if (AssemblyInstanceBySize.ContainsKey(numChunks))
            {
                outAssembly = AssemblyInstanceBySize[numChunks];
                outAssembly.SetZeroValues();
            }
            else
            {
                outAssembly = new SgfModuleAssembly();
                outAssembly.Initialize(numChunks);
                AssemblyInstanceBySize.Add(numChunks, outAssembly);
            }

            void SetAssemblyCell(SgfModuleAssemblySide side, int x, int y, SgfModuleAssemblySideCell cell, string sideText)
            {
                if (!side.Set(x, y, cell))
                {
                    Debug.LogError("Failed to register connection on module side: " + sideText);
                }
            }
            
            foreach (var link in incomingNodes) {
                if (link.IncomingNode == null) continue;
                var c = MathUtils.RoundToVector3Int(link.Node.coord) - minCoord;
                var ic = MathUtils.RoundToVector3Int(link.IncomingNode.coord) - minCoord;
                
                //var cellCache = new SgfModuleAssemblySideCell();     // TODO: Do not create a new object, instead overwrite it
                _cellCache.connectionIdx = SgfModuleAssemblySide.IndexValidUnknown;
                _cellCache.nodeId = (link.Node != null) ? link.Node.nodeId : DungeonUID.Empty;
                _cellCache.linkedNodeId = (link.IncomingNode != null) ? link.IncomingNode.nodeId : DungeonUID.Empty;
                _cellCache.linkId = link.Link.linkId;

                if (c.z > ic.z) {
                    // Front
                    SetAssemblyCell(outAssembly.front, c.x, c.y, _cellCache, "FRONT");
                    /*
                    if (!outAssembly.front.Set(c.x, c.y, _cellCache))
                    {
                        Debug.LogError("Failed to register connection on module side: FRONT");
                    }
                    */
                }
                else if (ic.x > c.x) {
                    // Left
                    SetAssemblyCell(outAssembly.left, c.z, c.y, _cellCache, "LEFT");
                    /*
                    if (!outAssembly.left.Set(c.z, c.y, _cellCache))
                    {
                        Debug.LogError("Failed to register connection on module side: LEFT");
                    }
                    */
                }
                else if (ic.z > c.z) {
                    // Back
                    SetAssemblyCell(outAssembly.back, numChunks.x - 1 - c.x, c.y, _cellCache, "BACK");
                    /*
                    if (!outAssembly.back.Set(numChunks.x - 1 - c.x, c.y, _cellCache))
                    {
                        Debug.LogError("Failed to register connection on module side: BACK");
                    }
                    */
                }
                else if (c.x > ic.x) {
                    // Right
                    SetAssemblyCell(outAssembly.right, numChunks.z - 1 - c.z, c.y, _cellCache, "RIGHT");
                    /*
                    if (!outAssembly.right.Set(numChunks.z - 1 - c.z, c.y, _cellCache))
                    {
                        Debug.LogError("Failed to register connection on module side: RIGHT");
                    }
                    */
                }
                else if (c.y > ic.y) {
                    // Down
                    SetAssemblyCell(outAssembly.down, c.x, c.z, _cellCache, "DOWN");
                    /*
                    if (!outAssembly.down.Set(c.x, c.z, _cellCache))
                    {
                        Debug.LogError("Failed to register connection on module side: DOWN");
                    }
                    */
                }
                else if (ic.y > c.y) {
                    // Top
                    SetAssemblyCell(outAssembly.top, c.x, c.z, _cellCache, "TOP");
                    /*
                    if (!outAssembly.top.Set(c.x, c.z, _cellCache))
                    {
                        Debug.LogError("Failed to register connection on module side: TOP");
                    }
                    */
                }
            }
        }

        public static void Rotate90Cw(SgfModuleAssembly inAssembly, out SgfModuleAssembly outAssembly)
        {
            outAssembly = new SgfModuleAssembly();
            outAssembly.numChunks = new Vector3Int(inAssembly.numChunks.z, inAssembly.numChunks.y, inAssembly.numChunks.x);
            outAssembly.left = inAssembly.front.Clone();
            outAssembly.back = inAssembly.left.Clone();
            outAssembly.right = inAssembly.back.Clone();
            outAssembly.front = inAssembly.right.Clone();
            outAssembly.top = inAssembly.top.Rotate90Cw();
            outAssembly.down = inAssembly.down.Rotate90Cw();
        }
    }

} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\ISGFLayoutTaskPathBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{
    public interface ISGFLayoutTaskPathBuilder
    {
        string[] GetSnapModuleCategories();
        string[] GetCategoriesAtNode(int pathIndex, int pathLength);
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\SGFLayoutTaskAddPadding.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{
    [FlowExecNodeInfo("Add Padding", "Layout Graph/", 3000)]
    public class SGFLayoutTaskAddPadding : FlowExecTask
    {
        public bool paddingAlongX = true;
        public bool paddingAlongY = false;
        public bool paddingAlongZ = true;
        public Color color = new Color(0.5f, 0.5f, 0.75f);
        public string[] categories = new string[0];
        
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            output.State = input.CloneInputState();
            var graph = output.State.GetState<FlowLayoutGraph>();
            if (graph == null || graph.Nodes.Count == 0)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            
            var activeNodes = new Dictionary<Vector3Int, FlowLayoutGraphNode>();
            foreach (var node in graph.Nodes)
            {
                if (!node.active) continue;
                if (node.MergedCompositeNodes.Count > 0)
                {
                    foreach (var subNode in node.MergedCompositeNodes)
                    {
                        activeNodes[MathUtils.RoundToVector3Int(subNode.coord)] = subNode;
                    }
                }
                else
                {
                    activeNodes[MathUtils.RoundToVector3Int(node.coord)] = node;
                }
            }

            var paddingNodes = new List<FlowLayoutGraphNode>();
            
            foreach (var node in graph.Nodes)
            {
                if (!node.active)
                {
                    // Check if we have a surrounding active node
                    var coord = MathUtils.RoundToVector3Int(node.coord);
                    if (HasNeighbour(coord, activeNodes))
                    {
                        paddingNodes.Add(node);
                    }
                }
            }
            
            foreach (var node in paddingNodes)
            {
                node.active = true;
                node.color = color;
                
                var snapNodeData = node.GetDomainData<FlowLayoutNodeSnapDomainData>();
                snapNodeData.Categories = categories;
            }
            
            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }

        bool HasNeighbour(Vector3Int coord, Dictionary<Vector3Int, FlowLayoutGraphNode> activeNodes)
        {
            if (paddingAlongX)
            {
                if (activeNodes.ContainsKey(coord + new Vector3Int(1, 0, 0)) || activeNodes.ContainsKey(coord + new Vector3Int(-1, 0, 0)))
                {
                    return true;
                }
            }
            
            if (paddingAlongY)
            {
                if (activeNodes.ContainsKey(coord + new Vector3Int(0, 1, 0)) || activeNodes.ContainsKey(coord + new Vector3Int(0, -1, 0)))
                {
                    return true;
                }
            }

            if (paddingAlongZ)
            {
                if (activeNodes.ContainsKey(coord + new Vector3Int(0, 0, 1)) || activeNodes.ContainsKey(coord + new Vector3Int(0, 0, -1)))
                {
                    return true;
                }
            }

            return false;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\SGFLayoutTaskCreateGrid.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{
    [FlowExecNodeInfo("Create Grid", "Layout Graph/", 1000)]
    public class SGFLayoutTaskCreateGrid : FlowExecTask
    {
        public Vector3Int resolution = new Vector3Int(6, 4, 5);

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var graph = new FlowLayoutGraph();

            int sizeX = resolution.x;
            int sizeY = resolution.y;
            int sizeZ = resolution.z;
            
            var nodes = new FlowLayoutGraphNode[sizeX, sizeY, sizeZ];
            for (int z = 0; z < sizeZ; z++)
            {
                for (int y = 0; y < sizeY; y++)
                {
                    for (int x = 0; x < sizeX; x++)
                    {
                        var node = new FlowLayoutGraphNode();
                        node.position = new Vector3(x, y, z) * 4;
                        node.coord = new Vector3(x, y, z);
                        nodes[x, y, z] = node;

                        if (x > 0)
                        {
                            var srcNode = nodes[x - 1, y, z];
                            var dstNode = nodes[x, y, z];
                            graph.MakeLinkFastUnsafe(srcNode, dstNode);
                        }

                        if (y > 0)
                        {
                            var srcNode = nodes[x, y - 1, z];
                            var dstNode = nodes[x, y, z];
                            graph.MakeLinkFastUnsafe(srcNode, dstNode);
                        }
                        
                        if (z > 0)
                        {
                            var srcNode = nodes[x, y, z - 1];
                            var dstNode = nodes[x, y, z];
                            graph.MakeLinkFastUnsafe(srcNode, dstNode);
                        }
                        
                        graph.AddNode(node);
                    }
                }
            }

            var output = new FlowTaskExecOutput();
            output.State.SetState(typeof(FlowLayoutGraph), graph);
            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\SGFLayoutTaskCreateKeyLock.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{
    [FlowExecNodeInfo("Create Key Lock", "Layout Graph/", 1040)]
    public class SGFLayoutTaskCreateKeyLock : LayoutBaseFlowTaskCreateKeyLock
    {
        
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\SGFLayoutTaskCreateMainPath.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Linq;
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Constraints;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{
    [FlowExecNodeInfo("Create Main Path", "Layout Graph/", 1010)]
    public class SGFLayoutTaskCreateMainPath : LayoutBaseFlowTaskCreateMainPath, ISGFLayoutTaskPathBuilder
    {
        [System.Serializable]
        public enum NodeConstraintType
        {
            None,
            StartEndNode,
            Script
        }
        
        public string[] snapModuleCategories = new string[] { "Room" };
        
        // Node position constraints
        public NodeConstraintType positionConstraintMode;
        public Vector3Int[] startNodePositionConstraints;
        public Vector3Int[] endNodePositionConstraints;
        // A ScriptableObject that implements ISGFLayoutNodePositionConstraint
        public string nodePositionConstraintScriptClassName;

        // Snap module category constraints
        public NodeConstraintType categoryConstraintMode;
        public string[] startNodeCategoryConstraints;
        public string[] endNodeCategoryConstraints;
        // A ScriptableObject that implements ISGFLayoutNodeCategoryConstraint
        public string categoryConstraintScriptClassName;
        

        private readonly InstanceCache instanceCache = new InstanceCache();

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            FlowTaskExecOutput output;
            if (snapModuleCategories.Length == 0)
            {
                output = new FlowTaskExecOutput();
                output.ErrorMessage = "Missing Module Categories";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output = base.Execute(context, input);
            instanceCache.Clear();
            
            return output;
        }
        
        protected override void FinalizePath(FlowLayoutStaticGrowthState staticState, FlowLayoutSharedGrowthState sharedState, FlowLayoutGrowthState state)
        {
            base.FinalizePath(staticState, sharedState, state);
            
            // Extend the path nodes with the snap domain data
            var pathLength = state.Path.Count;
            for (var i = 0; i < pathLength; i++)
            {
                var pathItem = state.Path[i];
                var node = staticState.GraphQuery.GetNode(pathItem.NodeId);
                if (node == null) continue;

                node.mainPath = true;

                var sgfNodeGroupData = pathItem.userdata as SGFNodeGroupUserData;
                if (sgfNodeGroupData != null)
                {
                    node.SetDomainData(pathItem.userdata as SGFNodeGroupUserData);
                }

                var snapNodeData = node.GetDomainData<FlowLayoutNodeSnapDomainData>();
                snapNodeData.Categories = GetCategoriesAtNode(i, pathLength);
            }
        }

        public string[] GetSnapModuleCategories()
        {
            return snapModuleCategories;
        }

        public string[] GetCategoriesAtNode(int pathIndex, int pathLength)
        {
            if (categoryConstraintMode == NodeConstraintType.StartEndNode)
            {
                bool startNode = pathIndex == 0;
                bool endNode = pathIndex + 1 >= pathLength;
                if (startNode || endNode)
                {
                    var categoriesUnfiltered = startNode ? startNodeCategoryConstraints : endNodeCategoryConstraints;
                    var categories = categoriesUnfiltered.Where(s => !string.IsNullOrWhiteSpace(s)).Distinct().ToArray();
                    if (categories.Length > 0)
                    {
                        return categories;
                    }
                }
            }
            else if (categoryConstraintMode == NodeConstraintType.Script)
            {
                if (instanceCache != null && !string.IsNullOrWhiteSpace(categoryConstraintScriptClassName))
                {
                    var instance = instanceCache.GetInstance(categoryConstraintScriptClassName) as ISGFLayoutNodeCategoryConstraint;
                    if (instance != null)
                    {
                        return instance.GetModuleCategoriesAtNode(pathIndex, pathLength);
                    }
                }
            }
            
            return snapModuleCategories;
        }
        
        private SnapGridFlowModuleDatabase GetModuleDatabase(FlowDomainExtensions domainExtensions)
        {
            var extension = domainExtensions.GetExtension<SnapGridFlowDomainExtension>();
            return extension.ModuleDatabase;
        }
        
        protected override FlowLayoutNodeGroupGenerator CreateNodeGroupGenerator(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            var moduleDatabase = GetModuleDatabase(domainExtensions);
            if (moduleDatabase == null)
            {
                return new NullFlowLayoutNodeGroupGenerator();
            }
            else
            {
                return new SnapFlowLayoutNodeGroupGenerator(moduleDatabase, this, random);
            }
        }

        protected override IFlowLayoutGraphConstraints CreateGraphConstraint(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            var moduleDatabase = GetModuleDatabase(domainExtensions);
            if (moduleDatabase == null)
            {
                return new NullFlowLayoutGraphConstraints();
            }
            else
            {             
                return new SnapFlowLayoutGraphConstraints(moduleDatabase, this, random);   
            }
        }

        private Vector3Int FindGridSize(FlowLayoutGraph graph)
        {
            var gridSize = Vector3Int.zero;
            foreach (var node in graph.Nodes)
            {
                if (node != null)
                {
                    var coord = MathUtils.RoundToVector3Int(node.coord);
                    gridSize.x = Mathf.Max(gridSize.x, coord.x + 1);
                    gridSize.y = Mathf.Max(gridSize.y, coord.y + 1);
                    gridSize.z = Mathf.Max(gridSize.z, coord.z + 1);
                }
            }
            return gridSize;
        }
        
        protected override IFlowLayoutNodeCreationConstraint CreateNodeCreationConstraint(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            if (graph != null)
            {
                if (positionConstraintMode == NodeConstraintType.Script)
                {
                    // Try to instantiate the script
                    var scriptInstance = instanceCache.GetInstance(nodePositionConstraintScriptClassName) as ISGFLayoutNodePositionConstraint;
                    if (scriptInstance != null)
                    {
                        var gridSize = FindGridSize(graph);
                        return new SGFLayoutNodeConstraintProcessorScript(scriptInstance, gridSize, random);
                    }
                }
                else if (positionConstraintMode == NodeConstraintType.StartEndNode)
                {
                    return new SGFLayoutNodeConstraintProcessorStartEnd(startNodePositionConstraints, endNodePositionConstraints);
                }
            }
            return new NullFlowLayoutNodeCreationConstraint();
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\SGFLayoutTaskCreatePath.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Impl.SnapGridFlow.Constraints;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{
    [FlowExecNodeInfo("Create Path", "Layout Graph/", 1020)]
    public class SGFLayoutTaskCreatePath : LayoutBaseFlowTaskCreatePath, ISGFLayoutTaskPathBuilder
    {
        [System.Serializable]
        public enum NodeConstraintType
        {
            None,
            Script
        }
        
        public string[] snapModuleCategories = new string[] { "Room" };
        
        // Node position constraints
        public NodeConstraintType positionConstraintMode;
        // A ScriptableObject that implements ISGFLayoutNodePositionConstraint
        public string nodePositionConstraintScriptClassName;

        // Snap module category constraints
        public NodeConstraintType categoryConstraintMode;
        // A ScriptableObject that implements ISGFLayoutNodeCategoryConstraint
        public string categoryConstraintScriptClassName;
        
        private readonly InstanceCache instanceCache = new InstanceCache();
        
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            FlowTaskExecOutput output;
            if (snapModuleCategories.Length == 0)
            {
                output = new FlowTaskExecOutput();
                output.ErrorMessage = "Missing Module Categories";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output = base.Execute(context, input);
            instanceCache.Clear();
            
            return output;
        }

        protected override void FinalizePath(FlowLayoutStaticGrowthState staticState, FlowLayoutSharedGrowthState sharedState, FlowLayoutGrowthState state)
        {
            base.FinalizePath(staticState, sharedState, state);
            
            // Extend the path nodes with the snap domain data
            for (var i = 0; i < state.Path.Count; i++)
            {
                var pathItem = state.Path[i];
                var node = staticState.GraphQuery.GetNode(pathItem.NodeId);
                if (node == null) continue;

                var sgfNodeGroupData = pathItem.userdata as SGFNodeGroupUserData;
                if (sgfNodeGroupData != null)
                {
                    node.SetDomainData(sgfNodeGroupData);
                }

                var snapNodeData = node.GetDomainData<FlowLayoutNodeSnapDomainData>();
                var pathLength = Mathf.Max(i + 1, minPathSize);
                snapNodeData.Categories = GetCategoriesAtNode(i, pathLength);
            }
        }

        public string[] GetSnapModuleCategories()
        {
            return snapModuleCategories;
        }

        public string[] GetCategoriesAtNode(int pathIndex, int pathLength)
        {
            if (categoryConstraintMode == NodeConstraintType.Script)
            {
                if (instanceCache != null && !string.IsNullOrWhiteSpace(categoryConstraintScriptClassName))
                {
                    var instance = instanceCache.GetInstance(categoryConstraintScriptClassName) as ISGFLayoutNodeCategoryConstraint;
                    if (instance != null)
                    {
                        return instance.GetModuleCategoriesAtNode(pathIndex, pathLength);
                    }
                }
            }
            return snapModuleCategories;
        }

        private SnapGridFlowModuleDatabase GetModuleDatabase(FlowDomainExtensions domainExtensions)
        {
            var extension = domainExtensions.GetExtension<SnapGridFlowDomainExtension>();
            return extension.ModuleDatabase;
        }
        
        protected override FlowLayoutNodeGroupGenerator CreateNodeGroupGenerator(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            var moduleDatabase = GetModuleDatabase(domainExtensions);
            if (moduleDatabase == null)
            {
                return new NullFlowLayoutNodeGroupGenerator();
            }
            else
            {
                return new SnapFlowLayoutNodeGroupGenerator(moduleDatabase, this, random);
            }
        }

        protected override IFlowLayoutGraphConstraints CreateGraphConstraint(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            var moduleDatabase = GetModuleDatabase(domainExtensions);
            if (moduleDatabase == null)
            {
                return new NullFlowLayoutGraphConstraints();
            }
            else
            {             
                return new SnapFlowLayoutGraphConstraints(moduleDatabase, this, random);   
            }
        }

        private Vector3Int FindGridSize(FlowLayoutGraph graph)
        {
            var gridSize = Vector3Int.zero;
            foreach (var node in graph.Nodes)
            {
                if (node != null)
                {
                    var coord = MathUtils.RoundToVector3Int(node.coord);
                    gridSize.x = Mathf.Max(gridSize.x, coord.x + 1);
                    gridSize.y = Mathf.Max(gridSize.y, coord.y + 1);
                    gridSize.z = Mathf.Max(gridSize.z, coord.z + 1);
                }
            }
            return gridSize;
        }

        protected override IFlowLayoutNodeCreationConstraint CreateNodeCreationConstraint(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {           if (graph != null)
            {
                if (positionConstraintMode == NodeConstraintType.Script)
                {
                    // Try to instantiate the script
                    var scriptInstance = instanceCache.GetInstance(nodePositionConstraintScriptClassName) as ISGFLayoutNodePositionConstraint;
                    if (scriptInstance != null)
                    {
                        var gridSize = FindGridSize(graph);
                        return new SGFLayoutNodeConstraintProcessorScript(scriptInstance, gridSize, random);
                    }
                }
            }
            return new NullFlowLayoutNodeCreationConstraint();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\SGFLayoutTaskExpandGridSize.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;
using UnityEditor;
using UnityEngine;
using MathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{
    [FlowExecNodeInfo("Expand Grid", "Layout Graph/", 2000)]
    public class SGFLayoutTaskExpandGridSize : FlowExecTask
    {
        public int expandAlongX = 1;
        public int expandAlongY = 0;
        public int expandAlongZ = 1;
        

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (expandAlongX <= 0 && expandAlongY <= 0 && expandAlongZ <= 0)
            {
                output.ErrorMessage = "Invalid expansion size";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            output.State = input.CloneInputState();
            var graph = output.State.GetState<FlowLayoutGraph>();
            if (graph == null || graph.Nodes.Count == 0)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            // Find the min-max coords of the existing graph
            Vector3 min = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
            Vector3 max = -min;

            var nodes = new Dictionary<Vector3Int, FlowLayoutGraphNode>();
            foreach (var node in graph.Nodes)
            {
                if (node.MergedCompositeNodes.Count > 0)
                {
                    foreach (var subNode in node.MergedCompositeNodes)
                    {
                        nodes[MathUtils.RoundToVector3Int(subNode.coord)] = subNode;
                        
                        min = MathUtils.ComponentMin(min, subNode.coord);
                        max = MathUtils.ComponentMax(max, subNode.coord);

                    }
                }
                else
                {
                    nodes[MathUtils.RoundToVector3Int(node.coord)] = node;
                    
                    min = MathUtils.ComponentMin(min, node.coord);
                    max = MathUtils.ComponentMax(max, node.coord);
                }
            }

            var oldMin = min;
            var oldMax = max;
            min -= new Vector3(expandAlongX, expandAlongY, expandAlongZ);
            max += new Vector3(expandAlongX, expandAlongY, expandAlongZ);

            var coordMin = MathUtils.RoundToVector3Int(min);
            var coordMax = MathUtils.RoundToVector3Int(max);

            var coordOldMin = MathUtils.RoundToVector3Int(oldMin);
            var coordOldMax = MathUtils.RoundToVector3Int(oldMax);
            
            for (int z = coordMin.z; z <= coordMax.z; z++)
            {
                for (int y = coordMin.y; y <= coordMax.y; y++)
                {
                    for (int x = coordMin.x; x <= coordMax.x; x++)
                    {
                        FlowLayoutGraphNode node;
                        var coord = new Vector3Int(x, y, z);
                        if (nodes.ContainsKey(coord))
                        {
                            node = nodes[coord];
                        }
                        else
                        {
                            node = new FlowLayoutGraphNode();
                            node.position = new Vector3(x, y, z) * 4;
                            node.coord = new Vector3(x, y, z);
                            node.active = false;
                            nodes[coord] = node;
                            graph.AddNode(node);
                        }

                        if (x > coordMin.x)
                        {
                            if (x <= coordOldMin.x || x > coordOldMax.x)
                            {
                                var srcNode = nodes[new Vector3Int(x - 1, y, z)];
                                var dstNode = nodes[new Vector3Int(x, y, z)];
                                graph.MakeLink(srcNode, dstNode);
                            }
                        }

                        if (y > coordMin.y)
                        {
                            if (y <= coordOldMin.y || y > coordOldMax.y)
                            {
                                var srcNode = nodes[new Vector3Int(x, y - 1, z)];
                                var dstNode = nodes[new Vector3Int(x, y, z)];
                                graph.MakeLink(srcNode, dstNode);
                            }
                        }
                        
                        if (z > coordMin.z)
                        {
                            if (z <= coordOldMin.z || z > coordOldMax.z)
                            {
                                var srcNode = nodes[new Vector3Int(x, y, z - 1)];
                                var dstNode = nodes[new Vector3Int(x, y, z)];
                                graph.MakeLink(srcNode, dstNode);
                            }
                        }
                    }
                }
            }
            
            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\SGFLayoutTaskFinalizeGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{
    [FlowExecNodeInfo("Finalize Graph", "Layout Graph/", 1050)]
    public class SGFLayoutTaskFinalizeGraph : LayoutBaseFlowTaskFinalizeGraph
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\SnapGridFlow\Tasks\SGFLayoutTaskSpawnItems.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Impl.SnapGridFlow.Tasks
{

    [FlowExecNodeInfo("Spawn Items", "Layout Graph/", 1030)]
    public class SGFLayoutTaskSpawnItems : LayoutBaseFlowTaskSpawnItems
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Execution\GrammarExecGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Grammar
{
    public class GrammarExecGraph : Graph
    {
        [SerializeField]
        public GrammarExecEntryNode entryNode;
        public override void OnEnable()
        {
            base.OnEnable();

            hideFlags = HideFlags.HideInHierarchy;
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Grammar\GrammarGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Grammar
{
    public class GrammarGraph : Graph
    {
        public bool useProceduralScript = false;
        public string generatorScriptClass;

        public KeyValueData editorData = new KeyValueData();

        public override void OnEnable()
        {
            base.OnEnable();

            hideFlags = HideFlags.HideInHierarchy;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Graph\GraphLayout\Implementations\DefaultGraphLayout.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Graphs.Layouts
{
    public class DefaultGraphLayoutNodeActions : IGraphLayoutNodeActions<GraphNode>
    {
        Dictionary<GraphNode, List<GraphNode>> outgoingNodes = new Dictionary<GraphNode, List<GraphNode>>();

        public DefaultGraphLayoutNodeActions(Graph graph) {
            // Cache the outgoing nodes to avoid O(N^2) with GetOutgoingNodes function
            if (graph != null)
            {
                foreach (var link in graph.Links)
                {
                    if (link != null && link.Output != null && link.Input != null)
                    {
                        var startNode = link.Output.Node;
                        var endNode = link.Input.Node;
                        if (startNode != null && endNode != null)
                        {
                            if (!outgoingNodes.ContainsKey(startNode))
                            {
                                outgoingNodes.Add(startNode, new List<GraphNode>());
                            }
                            outgoingNodes[startNode].Add(endNode);
                        }
                    }
                }
            }
        }

        public void SetNodePosition(GraphNode node, Vector2 position)
        {
            node.Position = position;
        }

        public Vector2 GetNodePosition(GraphNode node)
        {
            return node.Position;
        }

        public GraphNode[] GetOutgoingNodes(GraphNode node)
        {
            if (outgoingNodes.ContainsKey(node))
            {
                return outgoingNodes[node].ToArray();
            }
            return new GraphNode[0];
        }
    }
}


 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\TriangleProviders\Collision2DTriangleProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using STE = SharpNav.Geometry.TriangleEnumerable;
using SVector3 = SharpNav.Geometry.Vector3;
using Triangle3 = SharpNav.Geometry.Triangle3;

namespace DungeonArchitect.Navigation {
	public class Collision2DTriangleProvider : NavigationTriangleProvider {
		
		public override void AddNavTriangles(List<Triangle3> triangles) {
            var dataList = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
            foreach (var data in dataList)
            {
                if (data == null) continue;
                if (data.affectsNavigation)
                {
                    AddTriangles(triangles, data.gameObject);
                }
            }
		}
		
		void AddTriangles(List<Triangle3> triangles, GameObject gameObject) {
			var colliders = gameObject.GetComponentsInChildren<Collider2D>();
			foreach (var collider in colliders) {
				var transform = Matrix.FromGameTransform(collider.gameObject.transform);
				if (collider is BoxCollider2D) {
					var boxCollider = collider as BoxCollider2D;
					Vector3 goPosition;
					Quaternion goRotation;
					Vector3 goScale;
					Matrix.DecomposeMatrix(ref transform, out goPosition, out goRotation, out goScale);

					var collisionheight = 5;
					var size = new Vector3(boxCollider.size.x, collisionheight, boxCollider.size.y);
					Vector3 scale = Vector3.Scale(goScale, size);
					var boxCenterXZ = boxCollider.offset;
					var boxCenter = new Vector3(boxCenterXZ.x, 0, boxCenterXZ.y); 
					Vector3 position = goPosition + goRotation * Vector3.Scale(boxCenter, goScale);
                    position = MathUtils.FlipYZ(position);
                    position.y = 0;
					transform = Matrix4x4.TRS (position, goRotation, scale);
					
					StaticMeshTriangleProvider.AddMeshTriangles(triangles, cubeVertices, cubeIndices, transform);
				}
				else if (collider is CircleCollider2D) {
					// TODO: Implement
				}
			}
		}
		
		
		static readonly Vector3[] cubeVertices = new Vector3[] { 
			new Vector3(-0.5f, -0.5f, 0.5f), 
			new Vector3(0.5f, -0.5f, 0.5f), 
			new Vector3(0.5f, 0.5f, 0.5f), 
			new Vector3(-0.5f, 0.5f, 0.5f), 
			new Vector3(-0.5f, -0.5f, -0.5f), 
			new Vector3(0.5f, -0.5f, -0.5f), 
			new Vector3(0.5f, 0.5f, -0.5f), 
			new Vector3(-0.5f, 0.5f, -0.5f) 
		};
		
		static readonly int[] cubeIndices = new int[] { 
			// front
			0, 1, 2,
			2, 3, 0,
			// top
			3, 2, 6,
			6, 7, 3,
			// back
			7, 6, 5,
			5, 4, 7,
			// bottom
			4, 5, 1,
			1, 0, 4,
			// left
			4, 0, 3,
			3, 7, 4,
			// right
			1, 5, 6,
			6, 2, 1,
		};
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\TriangleProviders\CollisionTriangleProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using STE = SharpNav.Geometry.TriangleEnumerable;
using SVector3 = SharpNav.Geometry.Vector3;
using Triangle3 = SharpNav.Geometry.Triangle3;

namespace DungeonArchitect.Navigation {
	public class CollisionTriangleProvider : NavigationTriangleProvider {

		public override void AddNavTriangles(List<Triangle3> triangles) {
            var dataList = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
            foreach (var data in dataList)
            {
                if (data == null) continue;
                if (data.affectsNavigation)
                {
                    AddTriangles(triangles, data.gameObject);
                }
            }
		}

		void AddTriangles(List<Triangle3> triangles, GameObject gameObject) {
			var colliders = gameObject.GetComponentsInChildren<Collider>();
			foreach (var collider in colliders) {
				var transform = Matrix.FromGameTransform(collider.gameObject.transform);
				if (collider is BoxCollider) {
					var boxCollider = collider as BoxCollider;
					Vector3 goPosition;
					Quaternion goRotation;
					Vector3 goScale;
					Matrix.DecomposeMatrix(ref transform, out goPosition, out goRotation, out goScale);
					
					Vector3 scale = Vector3.Scale(goScale, boxCollider.size);
					Vector3 boxCenter = boxCollider.center;
					Vector3 position = goPosition + goRotation * Vector3.Scale(boxCenter, goScale);
					transform = Matrix4x4.TRS (position, goRotation, scale);
					
					StaticMeshTriangleProvider.AddMeshTriangles(triangles, cubeVertices, cubeIndices, transform);
				}
				else if (collider is MeshCollider) {
					var meshCollider = collider as MeshCollider;
					StaticMeshTriangleProvider.AddMeshTriangles(triangles, meshCollider.sharedMesh, transform);
				}
				else if (collider is SphereCollider) {
					// TODO: Implement
				}
				else if (collider is CapsuleCollider) {
					// TODO: Implement
				} 
			}
		}
		
		
		static readonly Vector3[] cubeVertices = new Vector3[] { 
			new Vector3(-0.5f, -0.5f, 0.5f), 
			new Vector3(0.5f, -0.5f, 0.5f), 
			new Vector3(0.5f, 0.5f, 0.5f), 
			new Vector3(-0.5f, 0.5f, 0.5f), 
			new Vector3(-0.5f, -0.5f, -0.5f), 
			new Vector3(0.5f, -0.5f, -0.5f), 
			new Vector3(0.5f, 0.5f, -0.5f), 
			new Vector3(-0.5f, 0.5f, -0.5f) 
		};
		
		static readonly int[] cubeIndices = new int[] { 
			// front
			0, 1, 2,
			2, 3, 0,
			// top
			3, 2, 6,
			6, 7, 3,
			// back
			7, 6, 5,
			5, 4, 7,
			// bottom
			4, 5, 1,
			1, 0, 4,
			// left
			4, 0, 3,
			3, 7, 4,
			// right
			1, 5, 6,
			6, 2, 1,
			/*
			0, 1, 2, 2, 3, 0, 
			3, 2, 6, 6, 7, 3, 
			7, 6, 5, 5, 4, 7, 
			4, 0, 3, 3, 7, 4, 
			0, 1, 5, 5, 4, 0,
			1, 5, 6, 6, 2, 1 
			*/
		};
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\TriangleProviders\StaticMeshTriangleProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using STE = SharpNav.Geometry.TriangleEnumerable;
using SVector3 = SharpNav.Geometry.Vector3;
using Triangle3 = SharpNav.Geometry.Triangle3;

namespace DungeonArchitect.Navigation {
	public class StaticMeshTriangleProvider : NavigationTriangleProvider {
		
		public override void AddNavTriangles(List<Triangle3> triangles) {
            var dataList = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
            foreach (var data in dataList)
            {
                if (data == null) continue;
                if (data.affectsNavigation)
                {
                    AddTriangles(triangles, data.gameObject);
                }
            }
		}

		void AddTriangles (List<Triangle3> triangles, GameObject gameObject) {
			var filters = gameObject.GetComponentsInChildren<MeshFilter>();
			foreach (MeshFilter filter in filters) {
				var transform = Matrix.FromGameTransform(filter.gameObject.transform);
				AddMeshTriangles(triangles, filter.sharedMesh, transform);
			}
		}
		
		public static void AddMeshTriangles(List<Triangle3> triangles, Mesh mesh, Matrix4x4 transform) {
			AddMeshTriangles(triangles, mesh.vertices, mesh.triangles, transform);
		}
		
		public static void AddMeshTriangles(List<Triangle3> triangles, Vector3[] vertices, int[] indices, Matrix4x4 transform) {
			List<SVector3> svertices = new List<SVector3>();
			foreach (var vert in vertices) {
				var gvert = transform.MultiplyPoint(vert);
				svertices.Add (new SVector3(gvert.x, gvert.y, gvert.z));
			}
			
			for (int i = 0; i + 2 < indices.Length; i += 3) {
				var tri = new Triangle3(
					svertices[indices[i]],
					svertices[indices[i + 1]],
					svertices[indices[i + 2]]);
				triangles.Add(tri);
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Navigation2D\SharpNav\TriangleProviders\TerrainTriangleProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using STE = SharpNav.Geometry.TriangleEnumerable;
using SVector3 = SharpNav.Geometry.Vector3;
using Triangle3 = SharpNav.Geometry.Triangle3;

namespace DungeonArchitect.Navigation {
	public class TerrainTriangleProvider : NavigationTriangleProvider {
		public float terrainCellSize = 2;
		
		public override void AddNavTriangles(List<Triangle3> triangles) {
			var terrain = Terrain.activeTerrain;
			if (terrain != null && terrain.terrainData != null) {
				AddTerrainTriangles(triangles, terrain);
			}
		}
		
		void AddTerrainTriangles(List<Triangle3> triangles, Terrain terrain) {
			var data = terrain.terrainData;
			var terrainSize = data.size;
			var terrainWidth = data.heightmapResolution;
			var terrainHeight = data.heightmapResolution;
			var terrainScale = data.heightmapScale;
			
			int incrementX = Mathf.Max (1, Mathf.RoundToInt(terrainCellSize / terrainScale.x));
			int incrementZ = Mathf.Max (1, Mathf.RoundToInt(terrainCellSize / terrainScale.z));
			
			var multiplierX = terrainSize.x / (terrainWidth - 1);
			var multiplierZ = terrainSize.z / (terrainHeight - 1);
			var heights = data.GetHeights(0, 0, terrainWidth, terrainHeight);
			
			var optimizedWidth = Mathf.Floor(terrainWidth / incrementX);
			var optimizedHeight = Mathf.Floor(terrainHeight / incrementZ);
			
			var worldHeights = new SVector3[terrainWidth, terrainHeight];
			var resolution = terrain.terrainData.size.y;
			int ox = 0;
			for (var hx = 0; hx < terrainWidth; hx += incrementX) {
				int oz = 0;
				for (var hz = 0; hz < terrainHeight; hz += incrementZ) {
					var x = hx * multiplierX + terrain.transform.position.x;
					var z = hz * multiplierZ + terrain.transform.position.z;
					var y = heights[hx, hz] * resolution + terrain.transform.position.y;
					worldHeights[ox, oz] = new SVector3(z, y, x);
					oz++;
				}
				ox++;
			}
			
			var vertices = new SVector3[4];
			for (var hx = 0; hx < optimizedWidth - 1; hx++) {
				for (var hz = 0; hz < optimizedHeight - 1; hz++) {
					vertices[0] = worldHeights[hx, hz];
					vertices[1] = worldHeights[hx, hz + 1];
					vertices[2] = worldHeights[hx + 1, hz + 1];
					vertices[3] = worldHeights[hx + 1, hz];
					
					triangles.Add (new Triangle3(
						vertices[0],
						vertices[1],
						vertices[2]
						));
					
					triangles.Add (new Triangle3(
						vertices[2],
						vertices[3],
						vertices[0]
						));
				}
			}
		}
	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\SxEngine\Meshing\Utils\SxMeshImporter.cs:
 using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.SxEngine.Utils
{
    public class SxMeshImporter
    {
        public static void Import(Mesh unityMesh, SxMesh sxMesh)
        {
            if (unityMesh == null) return;
            
            sxMesh.ClearAllSections();
            for (int subMeshIdx = 0; subMeshIdx < unityMesh.subMeshCount; subMeshIdx++)
            {
                var subMesh = unityMesh.GetSubMesh(subMeshIdx);
                int drawMode = 0;
                if (subMesh.topology == MeshTopology.Quads)
                {
                    drawMode = GL.QUADS;
                }
                else if (subMesh.topology == MeshTopology.Triangles)
                {
                    drawMode = GL.TRIANGLES;
                }
                else
                {
                    continue;
                }

                var vertices = new List<SxMeshVertex>();
                var indices = unityMesh.GetIndices(subMeshIdx);
                foreach (var index in indices)
                {
                    var normal = index < unityMesh.normals.Length ? unityMesh.normals[index] : Vector3.zero;
                    normal = normal * 0.5f + new Vector3(0.5f, 0.5f, 0.5f);
                    var vertex = new SxMeshVertex();
                    vertex.Position = unityMesh.vertices[index];
                    vertex.Color = new Color(normal.x, normal.y, normal.z, 1); 
                    vertex.UV0 = index < unityMesh.uv.Length ? unityMesh.uv[index] : Vector2.zero; 
                    vertices.Add(vertex);
                }
                sxMesh.CreateSection(subMeshIdx, drawMode, vertices.ToArray());
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Core\BorderWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class BorderWidget : WidgetBase
    {
        IWidget Content;

        float paddingLeft = 5;
        float paddingTop = 26;
        float paddingRight = 5;
        float paddingBottom = 5;
        Color color = new Color(0.3f, 0.3f, 0.3f);
        Color borderColor = Color.black;
        string title = "";
        int titleFontSize = 14;
        Color titleColor = new Color(0.75f, 0.75f, 0.75f);
        Vector2 titleOffset = new Vector2(5, 4);
        bool drawOutline = true;

        IWidget titleWidget;
        System.Func<string> TitleGetter;

        public BorderWidget() { }
        public BorderWidget(IWidget content)
        {
            this.Content = content;
        }

        public BorderWidget SetContent(IWidget content)
        {
            this.Content = content;
            return this;
        }

        public BorderWidget SetPadding(float left, float top, float right, float bottom)
        {
            paddingLeft = left;
            paddingTop = top;
            paddingRight = right;
            paddingBottom = bottom;
            return this;
        }

        public BorderWidget SetColor(Color color)
        {
            this.color = color;
            return this;
        }

        public BorderWidget SetBorderColor(Color borderColor)
        {
            this.borderColor = borderColor;
            return this;
        }

        public BorderWidget SetTransparent()
        {
            this.color = new Color(0, 0, 0, 0);
            this.borderColor = new Color(0, 0, 0, 0);
            return this;
        }

        public BorderWidget SetTitle(string title)
        {
            this.title = title;
            return this;
        }

        public BorderWidget SetTitleGetter(System.Func<string> getter)
        {
            this.TitleGetter = new System.Func<string>(getter);
            return this;
        }

        public BorderWidget SetTitleFontSize(int size)
        {
            this.titleFontSize = size;
            return this;
        }

        public BorderWidget SetTitleColor(Color color)
        {
            this.titleColor = color;
            return this;
        }

        public BorderWidget SetTitleOffset(Vector2 offset)
        {
            this.titleOffset = offset;
            return this;
        }

        public BorderWidget SetTitleWidget(IWidget widget)
        {
            this.titleWidget = widget;
            return this;
        }

        public BorderWidget SetDrawOutline(bool drawOutline)
        {
            this.drawOutline = drawOutline;
            return this;
        }


        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            var contentBounds = new Rect(Vector2.zero, WidgetBounds.size);
            contentBounds.x += paddingLeft;
            contentBounds.y += paddingTop;
            contentBounds.width -= paddingLeft + paddingRight;
            contentBounds.height -= paddingTop + paddingBottom;
            Content.UpdateWidget(uiSystem, contentBounds);

            if (titleWidget != null)
            {
                titleWidget.UpdateWidget(uiSystem, bounds);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            Rect borderBounds = new Rect(Vector2.zero, WidgetBounds.size);
            
            if (IsPaintEvent(uiSystem))
            {
                // Draw the border
                renderer.DrawRect(borderBounds, color);

                if (drawOutline)
                {
                    WidgetUtils.DrawWidgetFocusHighlight(renderer, borderBounds, borderColor);
                }
            }
            
                // Draw the label
                if (titleWidget != null)
                {
                    titleWidget.Draw(uiSystem, renderer);
                }
                else if (title.Length > 0 || TitleGetter != null)
                {
                    if (IsPaintEvent(uiSystem))
                    {
                        var titleStyle = new GUIStyle(GUI.skin.label);
                        titleStyle.fontSize = titleFontSize;
                        titleStyle.normal.textColor = titleColor;
                        titleStyle.alignment = TextAnchor.UpperLeft;
                        var titleBounds = borderBounds;
                        titleBounds.position += titleOffset;
                        string caption = title;
                        if (TitleGetter != null)
                        {
                            caption = TitleGetter();
                        }

                        renderer.Label(titleBounds, caption, titleStyle);
                    }
                }

            // Draw the content
            if (Content != null)
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, Content);
            }
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { Content };
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            var contentSize = size;
            contentSize.x -= paddingLeft + paddingRight;
            contentSize.y -= paddingTop + paddingBottom;
            var desiredSize = Content.GetDesiredSize(contentSize, uiSystem);
            desiredSize.x += paddingLeft + paddingRight;
            desiredSize.y += paddingTop + paddingBottom;
            return desiredSize;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Core\ButtonWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class ButtonWidget : WidgetBase
    {
        GUIContent content;
        Color color = new Color(0.8f, 0.8f, 0.8f);

        public delegate void OnButtonPressed(UISystem uiSystem);
        public event OnButtonPressed ButtonPressed;

        public ButtonWidget(GUIContent content)
        {
            this.content = content;
        }

        public ButtonWidget SetColor(Color color)
        {
            this.color = color;
            return this;
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            var style = new GUIStyle(GUI.skin.button);
            style.normal.textColor = Color.black;

            var state = new GUIState(renderer);
            var bounds = new Rect(Vector2.zero, WidgetBounds.size);
            renderer.color = color;
            if (renderer.Button(bounds, content, style))
            {
                if (ButtonPressed != null)
                {
                    ButtonPressed.Invoke(uiSystem);
                }
            }
            state.Restore();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Core\CheckboxWidget.cs:
 using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class CheckboxWidget : WidgetBase
    {
        public bool Value = false;
        
        private string label;
        Color color = new Color(0.8f, 0.8f, 0.8f);

        public CheckboxWidget(bool defaultValue, string label)
        {
            this.Value = defaultValue;
            this.label = label;
        }

        public CheckboxWidget SetColor(Color color)
        {
            this.color = color;
            return this;
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            var style = new GUIStyle(GUI.skin.button);
            style.normal.textColor = Color.black;

            var state = new GUIState(renderer);
            var bounds = new Rect(Vector2.zero, WidgetBounds.size);
            renderer.color = color;
            Value = renderer.Toggle(bounds, Value, label);
            state.Restore();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Core\ImageWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public enum ImageWidgetDrawMode
    {
        Streach,
        Fit,
        Fill,
        Fixed
    }

    public class ImageWidget : WidgetBase
    {
        Texture2D texture;
        ImageWidgetDrawMode drawMode = ImageWidgetDrawMode.Streach;
        Color tint = Color.white;

        public ImageWidget() {}
        public ImageWidget(Texture2D texture)
        {
            this.texture = texture;
        }

        public ImageWidget SetImage(Texture2D texture)
        {
            this.texture = texture;
            return this;
        }

        public ImageWidget SetDrawMode(ImageWidgetDrawMode drawMode)
        {
            this.drawMode = drawMode;
            return this;
        }

        public ImageWidget SetTint(Color tint)
        {
            this.tint = tint;
            return this;
        }

        Vector2 CalculateFitSize(Vector2 size)
        {
            if (texture == null) return size;

            var scale = size.x / texture.width;
            scale = Mathf.Min(1, scale);
            var sizeX = texture.width * scale;
            var sizeY = texture.height * scale;
            return new Vector2(sizeX, sizeY);
        }

        Vector2 CalculateFillSize(Vector2 size)
        {
            if (texture == null) return size;

            var scaleX = size.x / texture.width;
            var scaleY = size.y / texture.height;

            var scale = Mathf.Max(scaleX, scaleY);
            
            var sizeX = texture.width * scale;
            var sizeY = texture.height * scale;
            return new Vector2(sizeX, sizeY);
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            if (texture == null)
            {
                return size;
            }

            if (drawMode == ImageWidgetDrawMode.Fit)
            {
                return CalculateFitSize(size);
            }
            else if (drawMode == ImageWidgetDrawMode.Fill)
            {
                return CalculateFillSize(size);
            }
            else if (drawMode == ImageWidgetDrawMode.Fit)
            {
                return new Vector2(texture.width, texture.height);
            }
            else
            {
                return new Vector2(texture.width, texture.height);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (IsPaintEvent(uiSystem) && texture != null)
            {
                var size = WidgetBounds.size;
                size.x--;
                var bounds = new Rect(Vector2.zero, size);
                var state = new GUIState(renderer);

                var drawSize = bounds.size;
                Vector2 offset = Vector2.zero;
                if (drawMode == ImageWidgetDrawMode.Fit)
                {
                    drawSize = CalculateFitSize(size);
                    var offsetX = (bounds.size.x - drawSize.x) * 0.5f;
                    offset = new Vector2(offsetX, 0);
                }
                else if (drawMode == ImageWidgetDrawMode.Fill)
                {
                    drawSize = CalculateFillSize(size);
                    var offsetX = (bounds.size.x - drawSize.x) * 0.5f;
                    var offsetY = (bounds.size.y - drawSize.y) * 0.5f;
                    offset = new Vector2(offsetX, offsetY);
                }
                else if (drawMode == ImageWidgetDrawMode.Fixed)
                {
                    drawSize = new Vector2(texture.width, texture.height);
                    var offsetX = (bounds.size.x - drawSize.x) * 0.5f;
                    var offsetY = (bounds.size.y - drawSize.y) * 0.5f;
                    offset = new Vector2(offsetX, offsetY);
                }

                var drawBounds = new Rect(bounds.position + offset, drawSize);
                renderer.DrawTexture(drawBounds, texture, ScaleMode.StretchToFill, true, tint);
                state.Restore();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Core\LabelWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class LabelWidget : WidgetBase
    {
        GUIStyle style;
        public string Text { get; private set; }
        public Color Color { get; private set; }
        public int FontSize { get; private set; }
        public bool WordWrap { get; set; }
        public TextAnchor TextAlign { get; private set; }

        public LabelWidget(string text)
        {
            this.Text = text;
            Color = Color.black;
            WordWrap = false;
            TextAlign = TextAnchor.UpperLeft;
        }

        public LabelWidget SetColor(Color color)
        {
            this.Color = color;
            style = null;
            return this;
        }

        public LabelWidget SetFontSize(int size)
        {
            this.FontSize = size;
            style = null;
            return this;
        }

        public LabelWidget SetTextAlign(TextAnchor align)
        {
            this.TextAlign = align;
            style = null;
            return this;
        }

        public LabelWidget SetWordWrap(bool wordWrap)
        {
            this.WordWrap = wordWrap;
            style = null;
            return this;
        }

        GUIStyle CreateStyle(UIStyleManager styleManager)
        {
            var style = styleManager.GetLabelStyle();
            style.fontSize = FontSize;
            style.alignment = TextAlign;
            style.normal.textColor = Color;
            style.wordWrap = WordWrap;
            return style;
        }

        public float CalcHeight(UIStyleManager styleManager, string text, float width)
        {
            if (style == null)
            {
                style = CreateStyle(styleManager);
            }
            return style.CalcHeight(new GUIContent(text), width);
        }

        public Vector2 CalcSize(UISystem uiSystem, string text)
        {
            if (style == null)
            {
                style = CreateStyle(uiSystem.StyleManager);
            }
            return style.CalcSize(new GUIContent(text));
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            if (WordWrap)
            {
                var height = CalcHeight(uiSystem.StyleManager, Text, size.x);
                return new Vector2(size.x, height);
            }
            else
            {
                return CalcSize(uiSystem, Text);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (IsPaintEvent(uiSystem))
            {
                var bounds = new Rect(Vector2.zero, WidgetBounds.size);
                if (style == null)
                {
                    style = CreateStyle(uiSystem.StyleManager);
                }
                renderer.Label(bounds, Text, style);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Core\LinkWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class LinkWidget : WidgetBase
    {
        IWidget content;
        bool drawLinkOutline = true;
        bool hovered = false;
        object userdata = null;
        Color highlightColor = WidgetUtils.FOCUS_HIGHLITE_COLOR;

        public event OnWidgetClicked LinkClicked;

        public LinkWidget() : this(null) { }
        public LinkWidget(IWidget content)
        {
            this.content = content;
        }

        public LinkWidget SetContent(IWidget content)
        {
            this.content = content;
            return this;
        }

        public LinkWidget SetHighlightColor(Color color)
        {
            this.highlightColor = color;
            return this;
        }

        public LinkWidget SetUserData(object userdata)
        {
            this.userdata = userdata;
            return this;
        }

        public LinkWidget SetDrawLinkOutline(bool drawLinkOutline)
        {
            this.drawLinkOutline = drawLinkOutline;
            return this;
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            var contentBounds = new Rect(Vector2.zero, WidgetBounds.size);
            content.UpdateWidget(uiSystem, contentBounds);
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (content != null)
            {
                Rect linkBounds = new Rect(Vector2.zero, WidgetBounds.size);
                renderer.AddCursorRect(linkBounds, UICursorType.Link);

                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, content);

                var eventType = uiSystem.Platform.CurrentEvent.type;
                if (eventType == EventType.Repaint || eventType == EventType.MouseMove)
                {
                    if (hovered && drawLinkOutline)
                    {
                        WidgetUtils.DrawWidgetFocusHighlight(renderer, linkBounds, highlightColor);
                    }
                }
            }
            hovered = false;
        }

        public override bool RequiresInputEveryFrame() { return true; }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { content };
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            return content.GetDesiredSize(size, uiSystem);
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);

            Rect linkBounds = new Rect(Vector2.zero, WidgetBounds.size);
            bool insideBounds = linkBounds.Contains(e.mousePosition);

            hovered = insideBounds;
            if (e.type == EventType.MouseDown && insideBounds)
            {
                if (LinkClicked != null)
                {
                    var clickEvent = new WidgetClickEvent();
                    clickEvent.e = e;
                    clickEvent.uiSystem = uiSystem;
                    clickEvent.userdata = userdata;
                    LinkClicked.Invoke(clickEvent);
                }
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Core\ListViewWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public abstract class ListViewSource<T>
    {
        public abstract T[] GetItems();
        public abstract IWidget CreateWidget(T item);
    }

    public delegate void OnListViewItemSelected(object data);
    public interface IListViewItemWidget
    {
        event OnListViewItemSelected ItemSelected;
        event OnListViewItemSelected ItemDoubleClicked;
        bool Selected { get; set; }
        object ItemData { get; set; }
        string GetCaption();
    }

    public class ListViewWidget<T> : WidgetBase
    {
        ListViewSource<T> dataSource;
        T selectedItem;

        public delegate void OnSelectionChanged(T Item);
        public event OnSelectionChanged SelectionChanged;
        public event OnSelectionChanged ItemClicked;
        public event OnSelectionChanged ItemDoubleClicked;

        public ScrollPanelWidget ScrollView;
        public int ItemHeight = 40;
        public Color backgroundColor = new Color(0.1f, 0.1f, 0.1f);

        StackPanelWidget panel;
        IWidget layout;

        public void Bind(ListViewSource<T> dataSource)
        {
            this.dataSource = dataSource;
            selectedItem = default(T);
            NotifyDataChanged();
        }

        bool IsEqual(T a, T b)
        {
            return EqualityComparer<T>.Default.Equals(a, b);
        }

        void BuildLayout()
        {
            panel = new StackPanelWidget(StackPanelOrientation.Vertical);

            if (dataSource != null)
            {
                var items = dataSource.GetItems();
                if (items != null)
                {
                    foreach (var item in items)
                    {
                        var itemWidget = dataSource.CreateWidget(item);
                        if (itemWidget is IListViewItemWidget)
                        {
                            var listViewItemWidget = itemWidget as IListViewItemWidget;
                            listViewItemWidget.ItemSelected += ListViewItemWidget_ItemSelected;
                            listViewItemWidget.ItemDoubleClicked += ListViewItemWidget_ItemDoubleClicked;
                        }
                        panel.AddWidget(itemWidget, ItemHeight);
                    }
                }
            }

            ScrollView = new ScrollPanelWidget(panel);
            layout = ScrollView;
        }

        private void ListViewItemWidget_ItemDoubleClicked(object data)
        {
            if (ItemDoubleClicked != null)
            {
                ItemDoubleClicked.Invoke((T)data);
            }
        }

        private void ListViewItemWidget_ItemSelected(object data)
        {
            var items = dataSource.GetItems();
            int index = System.Array.IndexOf(items, data);
            SetSelectedIndex(index);

            if (ItemClicked != null)
            {
                ItemClicked.Invoke((T)data);
            }
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            return layout.GetDesiredSize(size, uiSystem);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { layout };
        }
        
        public void NotifyDataChanged()
        {
            BuildLayout();
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            var layoutBounds = new Rect(Vector2.zero, bounds.size);
            layout.UpdateWidget(uiSystem, layoutBounds);
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            var guiState = new GUIState(renderer);
            if (IsPaintEvent(uiSystem))
            {
                var bounds = new Rect(Vector2.zero, WidgetBounds.size);
                renderer.DrawRect(bounds, backgroundColor);
            }

            WidgetUtils.DrawWidgetGroup(uiSystem, renderer, layout);

            guiState.Restore(); 
        }

        public override bool CanAcquireFocus() { return false; }

        public int GetSelectedIndex()
        {
            if (IsNull(selectedItem))
            {
                return -1;
            }

            var items = dataSource.GetItems();
            return System.Array.IndexOf(items, selectedItem);
        }
        public T GetSelectedItem()
        {
            return selectedItem;
        }

        public T GetItem(int index)
        {
            var items = dataSource.GetItems();
            if (items == null || index < 0 || index >= items.Length)
            {
                return default(T);
            }
            return items[index];
        }

        public void SetSelectedItem(UISystem uiSystem, T item)
        {
            SetSelectedItem(uiSystem, item, false);
        }

        public void SetSelectedItem(UISystem uiSystem, T item, bool selectOnInspector)
        {
            if (item == null)
            {
                return;
            }
            var items = dataSource.GetItems();
            if (items == null) return;
            
            int index = System.Array.IndexOf(items, item);
            SetSelectedIndex(index);

            if (selectOnInspector)
            {
                uiSystem.Platform.ShowObjectProperty(item as Object);
            }
        }

        bool IsNull(T item)
        {
            return IsEqual(selectedItem, default(T));
        }

        public void SetSelectedIndex(int index)
        {
            var items = dataSource.GetItems();
            if (items == null || index < 0 || index >= items.Length)
            {
                // invalid hit index. deselect
                
                if (!IsNull(selectedItem) && System.Array.IndexOf(items, selectedItem) == -1)
                {
                    selectedItem = default(T);

                    if (SelectionChanged != null)
                    {
                        SelectionChanged.Invoke(selectedItem);
                    }
                }
                return;
            }

            T previousSelectedItem = selectedItem;
            selectedItem = items[index];
            if (!IsEqual(previousSelectedItem, selectedItem))
            {
                // Notify the selection change event
                if (SelectionChanged != null)
                {
                    SelectionChanged.Invoke(selectedItem);
                }
            }

            var children = panel != null ? panel.GetChildWidgets() : null;
            if (children != null)
            {
                foreach (var itemWidget in children)
                {
                    if (itemWidget is IListViewItemWidget)
                    {
                        var listItemWidget = itemWidget as IListViewItemWidget;
                        listItemWidget.Selected = false;
                        if (listItemWidget.ItemData != null && !IsNull(selectedItem))
                        {
                            listItemWidget.Selected = listItemWidget.ItemData.Equals(selectedItem);
                        }
                    }
                }
            }
        }
    }

    public class ListViewTextItemWidget : WidgetBase, IListViewItemWidget
    {
        public bool Selected { get; set; }
        public object ItemData { get; set; }

        public GUIStyle TextStyle = new GUIStyle();
        public GUIStyle SelectedTextStyle = new GUIStyle();
        public Color SelectedColor = new Color(1.0f, 0.5f, 0.0f);
        public float OffsetX = 10;
        System.Func<string> captionGetter;

        public event OnListViewItemSelected ItemSelected;
        public event OnListViewItemSelected ItemDoubleClicked;

        public ListViewTextItemWidget(object itemData, System.Func<string> captionGetter)
        {
            this.captionGetter = captionGetter;
            this.ItemData = itemData;
            TextStyle.normal.textColor = new Color(0.8f, 0.8f, 0.8f);
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            var guiState = new GUIState(renderer);
            var bounds = new Rect(Vector2.zero, WidgetBounds.size);
            if (Selected)
            {
                renderer.DrawRect(bounds, SelectedColor);
            }

            DrawText(renderer, bounds);

            guiState.Restore();
        }

        public virtual void DrawText(UIRenderer renderer, Rect bounds)
        {
            var style = Selected ? SelectedTextStyle : TextStyle;
            float x = OffsetX;
            float y = (bounds.height - style.lineHeight) / 2.0f;
            var content = new GUIContent(GetCaption());
            var textSize = style.CalcSize(content);
            var textBounds = new Rect(new Vector2(x, y), textSize);
            renderer.Label(textBounds, content, style);
        }

        public string GetCaption()
        {
            return captionGetter != null ? captionGetter() : "-";
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);

            var localBounds = new Rect(Vector2.zero, WidgetBounds.size);
            if (localBounds.Contains(e.mousePosition))
            {
                if (e.type == EventType.MouseDown)
                {
                    if (e.clickCount == 1)
                    {
                        if (ItemSelected != null)
                        {
                            ItemSelected.Invoke(ItemData);
                        }
                    }
                    else if (e.clickCount == 2)
                    {
                        if (ItemDoubleClicked != null)
                        {
                            ItemDoubleClicked.Invoke(ItemData);
                        }
                    }
                }
            }
        }

        protected override void HandleDragStart(Event e, UISystem uiSystem)
        {
            var bounds = new Rect(Vector2.zero, WidgetBounds.size);
            if (bounds.Contains(e.mousePosition))
            {
                base.HandleDragStart(e, uiSystem);
            }
        }

        public override bool CanAcquireFocus()
        {
            return true;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Core\SplitterWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public enum SplitterDirection
    {
        Horizontal,
        Vertical
    }

    public class SplitterNode
    {
        public IWidget Content;
        public float Weight;
        public bool IsSplitBar = false;
    }

    public delegate void OnSplitBarResized(SplitterNode prev, SplitterNode next);

    public class Splitter : WidgetBase
    {
        SplitterDirection direction;
        public SplitterDirection Direction { get { return direction; } }

        public bool freeSize = false;
        public float minWindowSize = 100;
        public float barSize = 6;
        public Color barColor = new Color(0.20f, 0.20f, 0.20f);
        public Color barHighlightColor = new Color(0.15f, 0.15f, 0.15f);
        public event OnSplitBarResized SplitBarDragged;

        public Splitter(SplitterDirection direction)
        {
            this.direction = direction;
        }

        private List<SplitterNode> nodes = new List<SplitterNode>();

        public Splitter SetMinWindowSize(float minWindowSize)
        {
            this.minWindowSize = minWindowSize;
            return this;
        }

        public Splitter SetBarSize(float barSize)
        {
            this.barSize = barSize;
            return this;
        }

        public Splitter SetFreeSize(bool freeSize)
        {
            this.freeSize = freeSize;
            return this;
        }

        public Splitter AddWidget(IWidget widget)
        {
            return AddWidget(widget, 1);
        }

        public Splitter AddWidget(IWidget widget, float weight)
        {
            if (nodes.Count > 0)
            {
                // Add a split bar widget
                var barNode = new SplitterNode();
                barNode.Content = new SplitterDragBarWidget(this);
                barNode.Weight = freeSize ? barSize : 0;
                barNode.IsSplitBar = true;
                nodes.Add(barNode);
            }

            var node = new SplitterNode();
            node.Content = widget;
            node.Weight = weight;
            nodes.Add(node);

            return this;
        }

        public override bool IsCompositeWidget() { return true; }
        public override IWidget[] GetChildWidgets()
        {
            var widgets = new List<IWidget>();
            foreach (var node in nodes)
            {
                if (node.Content != null)
                {
                    widgets.Add(node.Content);
                }
            }
            return widgets.ToArray();
        }

        public void OnSplitBarDragged(SplitterDragBarWidget barWidget, Vector2 delta)
        {
            float dragDistance = (direction == SplitterDirection.Horizontal) ? delta.x : delta.y;
            var sizes = GetLayoutSizes(WidgetBounds.size);
            var totalContentSize = 0.0f;

            for (int i = 0; i < nodes.Count; i++)
            {
                if (!nodes[i].IsSplitBar)
                {
                    totalContentSize += sizes[i];
                }

            }

            for (int i = 1; i + 1 < sizes.Length; i++)
            {
                var node = nodes[i];
                if (node.Content == barWidget)
                {
                    var sizePrev = sizes[i - 1];
                    var sizeNext = sizes[i + 1];

                    var newSizePrev = sizePrev + dragDistance;
                    var newSizeNext = freeSize ? sizeNext : sizeNext - dragDistance;

                    var invalid = (newSizePrev < sizePrev && newSizePrev < minWindowSize)
                        || (newSizeNext < sizeNext && newSizeNext < minWindowSize);

                    if (!invalid)
                    {
                        sizes[i - 1] = newSizePrev;
                        sizes[i + 1] = newSizeNext;

                        // Recalculate the weights 
                        for (int n = 0; n < nodes.Count; n++)
                        {
                            if (freeSize)
                            {
                                nodes[n].Weight = sizes[n];
                            }
                            else
                            {
                                nodes[n].Weight = sizes[n] / totalContentSize;
                            }
                        }

                        // Notify the event
                        if (SplitBarDragged != null)
                        {
                            var nodePrev = nodes[i - 1];
                            var nodeNext = nodes[i + 1];
                            SplitBarDragged.Invoke(nodePrev, nodeNext);
                        }
                    }
                    break;
                }
            }
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            var sizes = GetLayoutSizes(bounds.size);
            float offset = 0;
            for (int i = 0; i < nodes.Count; i++)
            {
                var size = sizes[i];
                var node = nodes[i];

                if (node.Content != null)
                {
                    var nodeBounds = GetWidgetBounds(WidgetBounds.size, offset, size);
                    node.Content.UpdateWidget(uiSystem, nodeBounds);
                }

                offset += size;
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            var children = GetChildWidgets();
            foreach (var childWidget in children)
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, childWidget);
            }
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);
            

        }

        Rect GetWidgetBounds(Vector2 hostSize, float offset, float size)
        {
            Rect bounds = new Rect(Vector2.zero, hostSize);
            if (Direction == SplitterDirection.Horizontal)
            {
                bounds.x += offset;
                bounds.width = size;
            }
            else
            {
                bounds.y += offset;
                bounds.height = size;
            }
            return bounds;
        }

        float[] GetLayoutSizes(Vector2 windowSize)
        {
            float totalSize = (Direction == SplitterDirection.Horizontal) ? windowSize.x : windowSize.y;
            float totalWeight = 0;
            float totalBarSizes = 0;
            foreach (var node in nodes)
            {
                if (node.IsSplitBar)
                {
                    totalBarSizes += barSize;
                }
                else
                {
                    totalWeight += node.Weight;
                }
            }

            if (freeSize) {
                totalSize = totalWeight + totalBarSizes;
            }

            float availableSize = totalSize - totalBarSizes;

            var sizes = new List<float>();
            foreach (var node in nodes)
            {
                if (node.IsSplitBar)
                {
                    sizes.Add(barSize);
                }
                else
                {
                    var ratio = node.Weight / totalWeight;
                    var size = availableSize * ratio;
                    sizes.Add(size);
                }
            }

            return sizes.ToArray();
        }


        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            if (freeSize)
            {
                var totalSize = 0.0f;
                foreach (var node in nodes)
                {
                    totalSize += node.Weight;
                }
                return (direction == SplitterDirection.Horizontal)
                    ? new Vector2(totalSize, size.x)
                    : new Vector2(size.x, totalSize);
            }
            else
            {
                return size;
            }
        }
    }


    public class SplitterDragBarWidget : WidgetBase
    {
        Splitter parent;

        public SplitterDragBarWidget(Splitter parent) 
        {
            this.parent = parent;
            ShowFocusHighlight = true;
        }


        public override bool CanAcquireFocus() { return true; }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            var bounds = new Rect(Vector2.zero, WidgetBounds.size);
            DrawBar(renderer, bounds, parent.barColor);

            // Draw focus highlight
            bool isFocused = (uiSystem != null) ? uiSystem.FocusedWidget == this as IWidget : false;
            if (isFocused && ShowFocusHighlight)
            {
                DrawFocusHighlight(uiSystem, renderer);
            }
        }

        void DrawBar(UIRenderer renderer, Rect bounds, Color barColor)
        {
            renderer.Box(bounds, new GUIContent());

            renderer.DrawRect(bounds, barColor);
            var cursor = parent.Direction == SplitterDirection.Horizontal
                ? UICursorType.ResizeHorizontal
                : UICursorType.ResizeVertical;

            renderer.AddCursorRect(bounds, cursor);
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);

            if (e.type == EventType.MouseDrag)
            {
                parent.OnSplitBarDragged(this, e.delta);
            }
            else if (e.type == EventType.MouseUp)
            {
                uiSystem.RequestFocus(null);
            }
            
        }

        protected override void DrawFocusHighlight(UISystem uiSystem, UIRenderer renderer)
        {
            var bounds = new Rect(Vector2.zero, WidgetBounds.size);
            DrawBar(renderer, bounds, parent.barHighlightColor);
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Debug\DebugWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class DebugWidget : WidgetBase
    {
        Color debugColor = Color.red;
        string caption = "Panel";

        public DebugWidget() : this("", new Color(0.1f, 0.1f, 0.1f))
        {
        }
        public DebugWidget(string caption, Color color)
        {
            this.debugColor = color;
            this.caption = caption;
            ShowFocusHighlight = true;
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            var guiState = new GUIState(renderer);
            if (IsPaintEvent(uiSystem))
            {
                var bounds = new Rect(Vector2.zero, WidgetBounds.size);
                renderer.Box(bounds, new GUIContent(caption));
                renderer.DrawRect(bounds, debugColor);
            }

            guiState.Restore();
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\GraphEditor\GraphContextMenu.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{

    /// <summary>
    /// The graph context menu event data
    /// </summary>
    public class GraphContextMenuEvent
    {
        public GraphPin sourcePin;
        public Vector2 mouseWorldPosition;
        public object userdata;
        public UISystem uiSystem;
    }

    /// <summary>
    /// The context menu shown when the user right clicks on the theme graph editor
    /// </summary>
    public abstract class GraphContextMenu
    {
        protected bool dragged;
        protected int dragButtonId = 1;


        protected GraphPin sourcePin;
        protected Vector2 mouseWorldPosition;

        public delegate void OnRequestContextMenuCreation(Event e, UISystem uiSystem);
        public event OnRequestContextMenuCreation RequestContextMenuCreation;

        public delegate void OnMenuItemClicked(object userdata, GraphContextMenuEvent e);
        public event OnMenuItemClicked MenuItemClicked;

        /// <summary>
        /// Handles mouse input
        /// </summary>
        /// <param name="e">Input event data</param>
        public void HandleInput(Event e, UISystem uiSystem)
        {
            switch (e.type)
            {
                case EventType.MouseDown:
                    if (e.button == dragButtonId)
                    {
                        dragged = false;
                    }
                    break;

                case EventType.MouseDrag:
                    if (e.button == dragButtonId)
                    {
                        dragged = true;
                    }
                    break;

                case EventType.MouseUp:
                    if (e.button == dragButtonId && !dragged)
                    {
                        if (RequestContextMenuCreation != null)
                        {
                            RequestContextMenuCreation.Invoke(e, uiSystem);
                        }
                    }
                    break;
            }

        }

        protected GraphContextMenuEvent BuildEvent(object userdata, UISystem uiSystem)
        {
            var e = new GraphContextMenuEvent();
            e.userdata = userdata;
            e.sourcePin = sourcePin;
            e.mouseWorldPosition = mouseWorldPosition;
            e.uiSystem = uiSystem;
            return e;
        }


        /// <summary>
        /// Shows the context menu in the theme graph editor
        /// </summary>
        /// <param name="graph">The graph shown in the graph editor</param>
        /// <param name="sourcePin">The source pin, if the user dragged a link out of a pin. null otherwise</param>
        /// <param name="mouseWorld">The position of the mouse. The context menu would be shown from here</param>
        public abstract void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem);

        protected void DispatchMenuItemEvent(object action, GraphContextMenuEvent e)
        {
            if (MenuItemClicked != null)
            {
                MenuItemClicked(action, e);
            }
        }
    }


    public class NullGraphContextMenu : GraphContextMenu
    {
        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\GraphEditor\GraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Linq;
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DMathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{
    /// <summary>
    /// The rendering context for drawing the theme editor
    /// </summary>
    public class GraphRendererContext
    {
        public UIResourceLookup Resources = new UIResourceLookup();
        public GraphEditor GraphEditor;
    }

    [Serializable]
    public class GraphEditorStyle
    {
        public Color backgroundColor = new Color(0.2f, 0.2f, 0.2f);
        public Color gridLineColorThick = new Color(1, 1, 1, 0.1f);
        public Color gridLineColorThin = new Color(1, 1, 1, 0.05f);
        public float gridCellSpacing = 20;
        public bool gridScaling = false;
        public int gridNumCells = 150;
        public string branding = "Dungeon Architect";
        public Color brandingColor = new Color(1, 1, 1, 0.1f);
        public int brandingSize = 40;
        public string readonlyText = "[READ ONLY]";
        public Color readonlyColor = new Color(1, 1, .5f, 0.4f);
        public int readonlySize = 40;
        public Color overlayTextColorLo = new Color(1, 1, 1, 0.2f);
        public Color overlayTextColorHi = new Color(1, 1, 1, 0.6f);
        public Color selectionBoxColor = new Color(1, 0.6f, 0, 0.6f);
        public Color commentTextColor = Color.white;
        public bool displayAssetFilename = true;
    }
    
    /// <summary>
    /// The graph editor script for managing a graph.  This contains the bulk of the logic for graph editing
    /// </summary>
    [Serializable]
    public abstract class GraphEditor : ScriptableObject, IWidget
    {
        [SerializeField]
        protected Graph graph;

        [SerializeField]
        protected GraphCamera camera;
        public GraphCamera Camera
        {
            get { return camera; }
        }

        [SerializeField]
        private GraphEditorStyle editorStyle;
        public GraphEditorStyle EditorStyle
        {
            get {
                if (editorStyle == null)
                {
                    editorStyle = CreateEditorStyle();
                }
                return editorStyle;
            }
        }

        [SerializeField]
        protected UnityEngine.Object assetObject;

        [SerializeField]
        protected GraphEditorEvents events = new GraphEditorEvents();
        public GraphEditorEvents Events
        {
            get { return events; }
        }

        public bool supportInteractiveWidgets = false;
        
        // The no. of pixels to add during the camera culling
        [SerializeField]
        protected float renderCullingBias = 0;

        private bool showFocusHighlight = false;
        private Rect widgetBounds = Rect.zero;
        private Vector2 scrollPosition = Vector2.zero;

        public bool ShowFocusHighlight
        {
            get { return showFocusHighlight; }
            set { showFocusHighlight = value; }
        }

        public Rect WidgetBounds
        {
            get { return widgetBounds; }
            set { widgetBounds = value; }
        }

        public virtual Vector2 ScrollPosition
        {
            get { return scrollPosition; }
            set { scrollPosition = value; }
        }

        public IGraphLinkRenderer GraphLinkRenderer { get; private set; }

        public delegate void OnGraphChanged(Graph graph, UISystem uiSystem);
        public event OnGraphChanged GraphChanged;
        
        protected GraphSelectionBox selectionBox;
        KeyboardState keyboardState;
        CursorDragLink cursorDragLink;
        protected GraphContextMenu contextMenu;
        protected GraphNodeRendererFactory nodeRenderers;
        protected GraphRendererContext rendererContext = new GraphRendererContext();

        protected Vector2 lastMousePosition = new Vector2();
        public Vector2 LastMousePosition { get { return lastMousePosition; } }

        protected Rect lastDrawBounds = Rect.zero;

        private bool graphReadOnly = false;

        /// <summary>
        /// The owning graph
        /// </summary>
        public Graph Graph
        {
            get
            {
                return graph;
            }
        }

        public bool CanAcquireFocus() { return true; }
        protected abstract GraphContextMenu CreateContextMenu();
        protected abstract void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers);
        protected abstract IGraphLinkRenderer CreateGraphLinkRenderer();
        protected abstract void OnMenuItemClicked(object userdata, GraphContextMenuEvent e);

        protected virtual void SortNodesForDeletion(GraphNode[] nodesToDelete) { }
        public virtual void SortPinsForDrawing(GraphPin[] pins) { }
        protected virtual GraphEditorStyle CreateEditorStyle() { return new GraphEditorStyle(); }
        public Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem) { return size; }

        public virtual void HandleMessage(UISystem uiSystem, WidgetMessage message)
        {

        }

        protected virtual void DrawHighlight(UIRenderer renderer)
        {
            var hilightBounds = new Rect(new Vector2(0.5f, 0.5f), WidgetBounds.size - Vector2.one);
            WidgetUtils.DrawWidgetFocusHighlight(renderer, hilightBounds, WidgetUtils.FOCUS_HIGHLITE_COLOR);
        }


        /// <summary>
        /// Initializes the graph editor with the specified graph
        /// </summary>
        /// <param name="graph">The owning graph</param>
        /// <param name="editorBounds">The bounds of the editor window</param>
        public virtual void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            rendererContext.GraphEditor = this;
            this.assetObject = assetObject;
            GraphLinkRenderer = CreateGraphLinkRenderer();

            events = new GraphEditorEvents();
            editorStyle = CreateEditorStyle();
            SetGraph(graph);

            // Reset the camera
            camera = new GraphCamera();
            FocusCameraOnBestFit(editorBounds);

            uiSystem.Undo.UndoRedoPerformed += OnUndoRedoPerformed;
            graphReadOnly = false;
        }

        public void SetReadOnly(bool graphReadOnly)
        {
            this.graphReadOnly = graphReadOnly;
        }

        public virtual void Release(UISystem uiSystem)
        {
            uiSystem.Undo.UndoRedoPerformed -= OnUndoRedoPerformed;
        }

        protected void SetGraph(Graph graph)
        {
            this.graph = graph;
        }


        /// <summary>
        /// Moves the graph editor viewport to show the marker on the screen
        /// </summary>
        /// <param name="markerName">The name of the marker to focus on</param>
        /// <param name="editorBounds">The bounds of the editor</param>
        public void FocusCameraOnNode(GraphNode node)
        {
            if (graph.Nodes.Contains(node))
            {
                camera.FocusOnNode(node, lastDrawBounds);
            }
            else
            {
                Debug.LogWarning("Cannot focus on graph node as it doesn't belong to the graph");
            }
        }

        public virtual void OnFocus()
        {
            
        }

        public virtual void LostFocus()
        {
            
        }
        
        public virtual bool RequiresInputEveryFrame() { return false; }

        /// <summary>
        /// Moves the graph editor viewport to show as many markers as possible. 
        /// Called when a new graph is loaded
        /// </summary>
        /// <param name="editorBounds">The bounds of the editor window</param>
        public void FocusCameraOnBestFit(Rect editorBounds)
        {
            camera.FocusOnBestFit(graph, editorBounds);
        }

        public void FocusCameraOnBestFit()
        {
            camera.FocusOnBestFit(graph, lastDrawBounds);
        }

        public virtual void OnEnable()
        {
            hideFlags = HideFlags.HideAndDontSave;
            if (camera == null)
            {
                camera = new GraphCamera();
            }
            if (selectionBox == null)
            {
                selectionBox = new GraphSelectionBox();
                selectionBox.SelectionPerformed += HandleBoxSelection;
            }
            if (keyboardState == null)
            {
                keyboardState = new KeyboardState();
            }
            if (cursorDragLink == null)
            {
                cursorDragLink = new CursorDragLink();
                cursorDragLink.DraggedLinkReleased += HandleMouseDraggedLinkReleased;
            }
            if (contextMenu == null)
            {
                contextMenu = CreateContextMenu();
                if (contextMenu != null)
                {
                    contextMenu.RequestContextMenuCreation += OnRequestContextMenuCreation;
                    contextMenu.MenuItemClicked += OnMenuItemClicked;
                }
            }
            
            if (nodeRenderers == null)
            {
                nodeRenderers = new GraphNodeRendererFactory();
                InitializeNodeRenderers(nodeRenderers);
            }
        }

        public void OnDisable()
        {
            if (cursorDragLink != null)
            {
                cursorDragLink.DraggedLinkReleased -= HandleMouseDraggedLinkReleased;
                cursorDragLink.Destroy();
                cursorDragLink = null;
            }
            
            if (selectionBox != null)
            {
                selectionBox.SelectionPerformed -= HandleBoxSelection;
            }
            if (cursorDragLink != null)
            {
                cursorDragLink.DraggedLinkReleased -= HandleMouseDraggedLinkReleased;
            }
            if (contextMenu != null)
            {
                contextMenu.RequestContextMenuCreation += OnRequestContextMenuCreation;
                contextMenu.MenuItemClicked += OnMenuItemClicked;
            }

            // TODO: Check if we need to unsubscribe from the events registered in OnEnable

        }

        public virtual void OnDestroy()
        {
            if (cursorDragLink != null)
            {
                cursorDragLink.Destroy();
                cursorDragLink = null;
            }

            if (nodeRenderers != null)
            {
                nodeRenderers.Release();
            }
        }

        void OnUndoRedoPerformed(UISystem uiSystem)
        {
            HandleGraphStateChanged(uiSystem);
        }
        
        public virtual void HandleMarkedDirty(UISystem uiSystem)
        {
            uiSystem.Platform.MarkAssetDirty(graph);
        }

        public virtual void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            WidgetBounds = bounds;
        }

        public virtual void Update()
        {
        }

        public virtual void HandleGraphStateChanged(UISystem uiSystem)
        {
            GraphChanged?.Invoke(graph, uiSystem);
        }

        public virtual void HandleNodePropertyChanged(GraphNode node)
        {
        }

        void HandleBoxSelection(Rect boundsScreenSpace, UISystem uiSystem)
        {
            bool multiSelect = keyboardState.ShiftPressed;
            bool selectedStateChanged = false;
            foreach (var node in graph.Nodes)
            {
                // node bounds in world space
                var nodeBounds = new Rect(node.Bounds);

                // convert the position to screen space
                nodeBounds.position = camera.WorldToScreen(nodeBounds.position);
				nodeBounds.size /= camera.ZoomLevel;

                var selected = nodeBounds.Overlaps(boundsScreenSpace);
                if (multiSelect)
                {
                    if (selected)
                    {
                        selectedStateChanged |= SetSelectedState(node, selected);
                    }
                }
                else
                {
                    selectedStateChanged |= SetSelectedState(node, selected);
                }
            }

            if (selectedStateChanged)
            {
                OnNodeSelectionChanged(uiSystem);
            }
        }

        bool SetSelectedState(GraphNode node, bool selected)
        {
            bool stateChanged = (node.Selected != selected);
            node.Selected = selected;
            return stateChanged;
        }

        void HandleSelect(Event e, UISystem uiSystem)
        {
            // Update the node selected flag
            var mousePosition = e.mousePosition;
            var mousePositionWorld = camera.ScreenToWorld(mousePosition);
            var buttonId = 0;
            if (e.type == EventType.MouseDown && e.button == buttonId)
            {
                bool multiSelect = keyboardState.ShiftPressed;
                bool toggleSelect = keyboardState.ControlPressed;
                // sort the nodes front to back
                GraphNode[] sortedNodes = graph.Nodes.ToArray();
                System.Array.Sort(sortedNodes, new NodeReversedZIndexComparer());

                GraphNode mouseOverNode = null;
                foreach (var node in sortedNodes)
                {
                    var mouseOver = node.Bounds.Contains(mousePositionWorld);
                    if (mouseOver)
                    {
                        mouseOverNode = node;
                        break;
                    }
                }

                bool mouseOverNodePreviouslySelected = mouseOverNode != null ? mouseOverNode.Selected : false;
                foreach (var node in sortedNodes)
                {
                    var mouseOver = (node == mouseOverNode);

                    if (mouseOverNode != null && mouseOverNodePreviouslySelected && !toggleSelect)
                    {
                        multiSelect = true;	// select multi-select so that we can drag multiple objects
                    }
                    if (multiSelect || toggleSelect)
                    {
                        if (mouseOver && multiSelect)
                        {
                            node.Selected = true;
                        }
                        else if (mouseOver && toggleSelect)
                        {
                            node.Selected = !node.Selected;
                        }
                    }
                    else
                    {
                        node.Selected = mouseOver;
                    }

                    if (node.Selected)
                    {
                        BringToFront(node);
                    }

                    if (node.Selected && mouseOver && e.clickCount == 2)
                    {
                        OnNodeDoubleClicked(uiSystem, node);
                    }
                }

                if (mouseOverNode == null)
                {
                    // No nodes were selected 
                    uiSystem.Platform.ShowObjectProperty(null);
                }

                OnNodeSelectionChanged(uiSystem);
            }
        }

        protected GraphNode[] GetSelectedNodes()
        {
            var nodes = new List<GraphNode>();
            foreach (var node in graph.Nodes)
            {
                if (node.Selected)
                {
                    nodes.Add(node);
                }
            }
            return nodes.ToArray();
        }

        protected bool draggingNodes = false;
        void HandleDrag(Event e, UISystem uiSystem)
        {
            int dragButton = 0;
            if (draggingNodes)
            {
                if (e.type == EventType.MouseUp && e.button == dragButton)
                {
                    draggingNodes = false;
                    var selectedNodes = GetSelectedNodes();
                    foreach (var node in selectedNodes)
                    {
                        node.Dragging = false;
                    }
                    events.OnNodeDragEnd.Notify(new GraphNodeEventArgs(uiSystem, selectedNodes));
                }
                else if (e.type == EventType.MouseDrag && e.button == dragButton)
                {
                    // Drag all the selected nodes
                    var draggedNodes = new List<GraphNode>();
                    foreach (var node in graph.Nodes)
                    {
                        if (node.Selected)
                        {
                            uiSystem.Undo.RecordObject(node, "Move Node");
							var delta = e.delta * camera.ZoomLevel;
                            node.DragNode(delta);

                            draggedNodes.Add(node);
                        }
                    }

                    Events.OnNodeDragged.Notify(new GraphNodeEventArgs(uiSystem, draggedNodes.ToArray()));
                    HandleMarkedDirty(uiSystem);
                }
            }
            else
            {
                // Check if we have started to drag
                if (e.type == EventType.MouseDown && e.button == dragButton)
                {
                    // Find the node that was clicked below the mouse
                    var mousePosition = e.mousePosition;
                    var mousePositionWorld = camera.ScreenToWorld(mousePosition);

                    // sort the nodes front to back
                    GraphNode[] sortedNodes = graph.Nodes.ToArray();
                    System.Array.Sort(sortedNodes, new NodeReversedZIndexComparer());

                    GraphNode mouseOverNode = null;
                    foreach (var node in sortedNodes)
                    {
                        var mouseOver = node.Bounds.Contains(mousePositionWorld);
                        if (mouseOver)
                        {
                            mouseOverNode = node;
                            break;
                        }
                    }

                    if (mouseOverNode != null && mouseOverNode.Selected)
                    {
                        // Make sure we are not over a pin
                        var pins = new List<GraphPin>();
                        pins.AddRange(mouseOverNode.InputPins);
                        pins.AddRange(mouseOverNode.OutputPins);
                        bool isOverPin = false;
                        GraphPin overlappingPin = null;
                        foreach (var pin in pins)
                        {
                            if (pin.ContainsPoint(mousePositionWorld))
                            {
                                isOverPin = true;
                                overlappingPin = pin;
                                break;
                            }
                        }
                        if (!isOverPin)
                        {
                            draggingNodes = true;
                            var selectedNodes = GetSelectedNodes();
                            foreach (var node in selectedNodes)
                            {
                                node.Dragging = true;
                            }
                            events.OnNodeDragStart.Notify(new GraphNodeEventArgs(uiSystem, selectedNodes));
                        }
                        else
                        {
                            HandleDragPin(overlappingPin, uiSystem);
                        }
                    }
                }
            }
        }

        void HandleDragPin(GraphPin pin, UISystem uiSystem)
        {
            cursorDragLink.Activate(pin, uiSystem);
        }

        /// <summary>
        /// Handles user input (mouse and keyboard)
        /// </summary>
        /// <param name="e"></param>
        public virtual void HandleInput(Event _e, UISystem uiSystem)
        {
            var e = new Event(_e);

            var bounds = WidgetBounds;
            //e.mousePosition = DMathUtils.ClampToRect(e.mousePosition, bounds);

            if (graph == null)
            {
                // Graph is not yet initialized
                return;
            }


            lastMousePosition = e.mousePosition;
            camera.HandleInput(e);
            if (!graphReadOnly)
            {
                keyboardState.HandleInput(e);

                HandleKeyboard(e, uiSystem);
                HandleDelete(e, uiSystem);
                HandleSelect(e, uiSystem);
                HandleDrag(e, uiSystem);

                // sort the nodes front to back
                GraphNode[] sortedNodes = graph.Nodes.ToArray();
                System.Array.Sort(sortedNodes, new NodeReversedZIndexComparer());

                // Handle the input from front to back
                bool inputProcessed = false;
                foreach (var node in sortedNodes)
                {
                    if (node == null) continue;
                    inputProcessed = GraphInputHandler.HandleNodeInput(node, e, this, uiSystem);
                    if (inputProcessed)
                    {
                        break;
                    }
                }

                cursorDragLink.HandleInput(e, uiSystem);

                if (contextMenu != null)
                {
                    contextMenu.HandleInput(e, uiSystem);
                }

                if (!inputProcessed)
                {
                    selectionBox.HandleInput(e, uiSystem);
                }
            }
        }

        void PerformCopy(Event e, UISystem uiSystem)
        {
            // Fetch all selected nodes
            var selectedNodes = from node in graph.Nodes
                                where node.Selected
                                select node.Id;

			var serializer = new System.Xml.Serialization.XmlSerializer(typeof(string[]));
            var writer = new System.IO.StringWriter();
            serializer.Serialize(writer, selectedNodes.ToArray());
            var copyText = writer.GetStringBuilder().ToString();

            uiSystem.Platform.clipboardText = copyText;
        }

        protected virtual GraphNode DuplicateNode(GraphNode sourceNode, UISystem uiSystem)
        {
            var copiedNode = CreateNode(Vector2.zero, sourceNode.GetType(), uiSystem);
            copiedNode.CopyFrom(sourceNode);
            return copiedNode;
        }

        void PerformPaste(Event e, UISystem uiSystem)
        {
            var copyText = uiSystem.Platform.clipboardText;
            var serializer = new System.Xml.Serialization.XmlSerializer(typeof(string[]));
            string[] copyNodeIds;
            try
            {
                copyNodeIds = (string[])serializer.Deserialize(new System.IO.StringReader(copyText));
            }
            catch (System.Xml.XmlException)
            {
                copyNodeIds = new string[0];
            }

            var mouseWorld = camera.ScreenToWorld(e.mousePosition);
            float offsetXDelta = 130;
            float offsetX = 0;

            var copiedNodes = new List<GraphNode>();

            foreach (var id in copyNodeIds)
            {
                var sourceNode = graph.GetNode(id);
                var copiedNode = DuplicateNode(sourceNode, uiSystem);
                
                // Update the bounds of the node to move it near the cursor
                var bounds = copiedNode.Bounds;
                bounds.x = mouseWorld.x + offsetX;
                bounds.y = mouseWorld.y;
                copiedNode.Bounds = bounds;
                copiedNodes.Add(copiedNode);
                offsetX += offsetXDelta;

            }

            if (copiedNodes.Count > 0)
            {
                events.OnNodeCreated.Notify(new GraphNodeEventArgs(uiSystem, copiedNodes.ToArray()));
            }
        }

        void HandleKeyboard(Event e, UISystem uiSystem)
        {
            if (!e.isKey) return;
			var controlPressed = (e.control || e.command);
			if (e.keyCode == KeyCode.C && controlPressed && e.type == EventType.KeyUp)
            {
                PerformCopy(e, uiSystem);
            }
			else if (e.keyCode == KeyCode.V && controlPressed && e.type == EventType.KeyUp)
            {
                PerformPaste(e, uiSystem);
            }
        }

        public virtual void OnNodeSelectionChanged(UISystem uiSystem)
        {
            // Fetch all selected nodes
            var selectedNodes = from node in graph.Nodes
                                where node.Selected
                                select node;

            uiSystem.Platform.ShowObjectProperties(selectedNodes.ToArray());

            events.OnNodeSelectionChanged.Notify(new GraphNodeEventArgs(uiSystem, selectedNodes.ToArray()));
        }

        public virtual void OnNodeDoubleClicked(UISystem uiSystem, GraphNode node)
        {
            events.OnNodeDoubleClicked.Notify(new GraphNodeEventArgs(uiSystem, new GraphNode[] { node }));
        }

        /*
		/// <summary>
		/// Called when the user right clicks on a node
		/// </summary>
		/// <param name="e">E.</param>
		void OnRequestNodeContextMenuCreation(GraphNode node, Event e) {
			var nodeMenu = new GenericMenu();
			nodeMenu.AddItem(new GUIContent("Copy"), false, () => PerformCopy(e));
			nodeMenu.AddItem(new GUIContent("Delete"), false, () => PerformDelete(e));
			nodeMenu.ShowAsContext();
        }
        */

        void OnRequestContextMenuCreation(Event e, UISystem uiSystem)
        {
            // Make sure we are not over an existing node
            var mouseWorld = camera.ScreenToWorld(e.mousePosition);
            foreach (var node in graph.Nodes)
            {
                if (node.Bounds.Contains(mouseWorld))
                {
                    // the user has clicked on a node. Handle this with a separate logic
					//OnRequestNodeContextMenuCreation(node, e);
					return;
                }
            }

            contextMenu.Show(this, null, e.mousePosition, uiSystem);
        }



        void HandleDelete(Event e, UISystem uiSystem)
        {
            if (e.type == EventType.KeyDown) {
				var deletePressed = (e.keyCode == KeyCode.Delete);
				deletePressed |= (e.keyCode == KeyCode.Backspace && e.command);

				if (deletePressed) {
					PerformDelete(e, uiSystem);
				}
            }
        }

        public void DeleteNodes(GraphNode[] nodesToDelete, UISystem uiSystem)
        {
            if (nodesToDelete.Length == 0)
            {
                return;
            }

            SortNodesForDeletion(nodesToDelete);
            foreach (var node in nodesToDelete)
            {
                DestroyNode(node, uiSystem);
            }
            
            HandleMarkedDirty(uiSystem);
            HandleGraphStateChanged(uiSystem);
        }

        protected virtual void DestroyNode(GraphNode node, UISystem uiSystem)
        {
            var schema = GetGraphSchema();
            if (schema.CanDestroyNode(node))
            {
                GraphOperations.DestroyNode(node, uiSystem.Undo);
                HandleMarkedDirty(uiSystem);
            }
        }

        void PerformDelete(Event e, UISystem uiSystem) {
            var nodesToDelete = new List<GraphNode>();
            foreach (var node in graph.Nodes)
            {
                if (node.Selected)
                {
                    nodesToDelete.Add(node);
                }
            }
            var deletionList = nodesToDelete.ToArray();
            SortNodesForDeletion(deletionList);

            foreach (var node in deletionList)
            {
                DestroyNode(node, uiSystem);
            }

            if (deletionList.Length > 0)
            {
                HandleMarkedDirty(uiSystem);
                HandleGraphStateChanged(uiSystem);
                OnNodeSelectionChanged(uiSystem);
            }
        }

        protected virtual void DrawOverlay(UIRenderer renderer, Rect bounds) { }

        public virtual bool IsCompositeWidget() { return false; }
        public IWidget[] GetChildWidgets() { return null; }

        /// <summary>
        /// Renders the graph editor in the editor window
        /// </summary>
        /// <param name="bounds">The bounds of the editor window</param>
        public virtual void Draw(UISystem uiSystem, UIRenderer renderer)
        {
            var e = Event.current;
            if (!supportInteractiveWidgets && e != null && e.type != EventType.Repaint)
            {
                return;
            }
            
            rendererContext.GraphEditor = this;
            var bounds = WidgetBounds;
            camera.ScreenOffset = bounds.position;

            if (graph == null)
            {
                // Graph is not yet initialized
                DrawGraphNotInitializedMessage(renderer, bounds);
                return;
            }

            if (GraphLinkRenderer == null)
            {
                GraphLinkRenderer = CreateGraphLinkRenderer();
            }

            var cullingBias = new Vector2(renderCullingBias, renderCullingBias);

            var windowWorldPos = camera.ScreenToWorld(bounds.position);
			var windowWorldBounds = new Rect(windowWorldPos, bounds.size * camera.ZoomLevel);
            windowWorldBounds.position -= cullingBias;
            windowWorldBounds.size += cullingBias * 2;

            DrawGrid(renderer, bounds, windowWorldBounds.size);
            DrawBranding(renderer, bounds);
            if (graphReadOnly)
            {
                DrawReadOnly(renderer, bounds);
            }
            DrawEditorStats(renderer, bounds);
            DrawOverlay(renderer, bounds);

            // Draw the links
            cursorDragLink.Draw(renderer, rendererContext, camera);
            foreach (var link in graph.Links)
            {
                if (GraphUtils.Intersects(windowWorldBounds, link))
                {
                    GraphLinkRenderer.DrawGraphLink(renderer, rendererContext, link, camera);
                }
            }

            // Draw the nodes
            GraphNode[] sortedNodes = graph.Nodes.ToArray();
            System.Array.Sort(sortedNodes, new NodeZIndexComparer());

            // Draw the nodes
            {
                bool stateChanged = false;
                NotifyNodeRendererBeginFrame(graph, sortedNodes.ToArray());
                foreach (var node in sortedNodes)
                {
                    if (node == null) continue;
                    // Draw only if this node is visible in the editor
                    if (DMathUtils.Intersects(windowWorldBounds, node.Bounds))
                    {
                        var nodeRenderer = nodeRenderers.GetRenderer(node.GetType());
                        nodeRenderer.Draw(renderer, rendererContext, node, camera);

                        if (nodeRenderer.GraphStateChanged)
                        {
                            stateChanged = true;
                            nodeRenderer.GraphStateChanged = false;
                        }
                    }
                }
                NotifyNodeRendererEndFrame(graph, sortedNodes.ToArray());

                if (stateChanged)
                {
                    HandleGraphStateChanged(uiSystem);
                }
            }

            selectionBox.Draw(renderer, editorStyle);
            DrawHUD(uiSystem, renderer, bounds);

            GraphTooltipRenderer.Draw(renderer, rendererContext, lastMousePosition);
            GraphTooltip.Clear();

            // Draw focus highlight
            bool isFocused = (uiSystem != null) ? uiSystem.FocusedWidget == this as IWidget : false;
            if (isFocused && ShowFocusHighlight)
            {
                DrawHighlight(renderer);
            }

            lastDrawBounds = bounds;
        }

        private void NotifyNodeRendererBeginFrame(Graph graph, GraphNode[] nodes)
        {
            var renderers = new HashSet<GraphNodeRenderer>();
            foreach (var node in nodes)
            {
                renderers.Add(nodeRenderers.GetRenderer(node.GetType()));
            }
            foreach (var renderer in renderers)
            {
                renderer.BeginFrame(graph);
            }
        }

        private void NotifyNodeRendererEndFrame(Graph graph1, GraphNode[] nodes)
        {
            var renderers = new HashSet<GraphNodeRenderer>();
            foreach (var node in nodes)
            {
                renderers.Add(nodeRenderers.GetRenderer(node.GetType()));
            }
            foreach (var renderer in renderers)
            {
                renderer.EndFrame();
            }
        }
        
        protected bool IsPaintEvent(UISystem uiSystem)
        {
            if (uiSystem.Platform.CurrentEvent.type == EventType.Repaint)
            {
                return true;
            }

            if (supportInteractiveWidgets)
            {
                if (uiSystem.Platform.CurrentEvent.type == EventType.MouseUp)
                {
                    return true;
                }
            }
            
            return false;
        }
        
        void DrawEditorStats(UIRenderer renderer, Rect bounds) {
			var skin = renderer.GetResource<GUISkin>(UIResourceLookup.GUI_STYLE_BANNER) as GUISkin;
			var style = skin.GetStyle("label");
			style.fontSize = 20;
			style.normal.textColor = editorStyle.overlayTextColorLo;
			var x = bounds.x + 20;
			var y = bounds.y + bounds.height - 100;
			var textBounds = new Rect(x, y, bounds.width - 20, 70);
			style.alignment = TextAnchor.LowerLeft;
			if (camera.ZoomLevel > 1) {
				float zoomLevel = (float)System.Math.Round (camera.ZoomLevel, 1);
				renderer.Label(textBounds, "Zoom Level: " + zoomLevel.ToString("0.0"), style);
			}
		}

        void DrawBranding(UIRenderer renderer, Rect bounds)
        {
            var skin = renderer.GetResource<GUISkin>(UIResourceLookup.GUI_STYLE_BANNER) as GUISkin;
            var style = skin.GetStyle("label");
            style.fontSize = editorStyle.brandingSize;
            style.normal.textColor = editorStyle.brandingColor;
            var x = bounds.x;
            var y = bounds.y + bounds.height - 80;
            var textBounds = new Rect(x, y, bounds.width - 20, 70);
            style.alignment = TextAnchor.LowerRight;
            renderer.Label(textBounds, EditorStyle.branding, style);
        }

        private void DrawReadOnly(UIRenderer renderer, Rect bounds)
        {
            var skin = renderer.GetResource<GUISkin>(UIResourceLookup.GUI_STYLE_BANNER) as GUISkin;
            var style = new GUIStyle(skin.GetStyle("label"));
            style.fontSize = editorStyle.readonlySize;
            style.normal.textColor = editorStyle.readonlyColor;
            var x = bounds.x;
            var y = bounds.y + bounds.height - 80;
            var textBounds = new Rect(x + 20, y, bounds.width, 70);
            style.alignment = TextAnchor.LowerLeft;
            renderer.Label(textBounds, EditorStyle.readonlyText, style);
        }

        /// <summary>
        /// Draws non-interactive textual information for the user
        /// </summary>
        /// <param name="bounds">Bounds.</param>
        protected virtual void DrawHUD(UISystem uiSystem, UIRenderer renderer, Rect bounds)
        {
            // Print out the current file being edited
            if (editorStyle.displayAssetFilename) {
                var style = new GUIStyle(GUI.skin.GetStyle("label"));
                style.normal.textColor = editorStyle.overlayTextColorLo;
                var x = bounds.x + 10;
                var y = bounds.y + bounds.height - 50;
                var textBounds = new Rect(x, y, bounds.width, 40);
                style.alignment = TextAnchor.LowerLeft;
                var path = uiSystem.Platform.GetAssetPath(assetObject);
                renderer.Label(textBounds, "Editing file: " + path, style);
            }
        }
        
        /// <summary>
        /// Creates a new node in the specified screen coordinate
        /// </summary>
        /// <typeparam name="T">The type of node to created. Should be a subclass of GraphNode</typeparam>
        /// <param name="screenCoord">The screen coordinate to place the node at</param>
        /// <returns>The created graph node</returns>
        public virtual T CreateNode<T>(Vector2 screenCoord, UISystem uiSystem) where T : GraphNode, new()
        {
            return CreateNode(screenCoord, typeof(T), uiSystem) as T;
        }

        public virtual GraphNode CreateNode(Vector2 screenCoord, System.Type nodeType, UISystem uiSystem)
        {
            var node = GraphOperations.CreateNode(graph, nodeType, uiSystem.Undo);
            GraphEditorUtils.AddToAsset(uiSystem.Platform, assetObject, node);

            var nodeScreenSize = node.Bounds.size / camera.ZoomLevel;
			var screenPosition = screenCoord - nodeScreenSize / 2;
            node.Position = camera.ScreenToWorld(screenPosition);
            BringToFront(node);

            events.OnNodeCreated.Notify(new GraphNodeEventArgs(uiSystem, node));
            return node;
        }

        protected void BringToFront(GraphNode node)
        {
            node.ZIndex = graph.TopZIndex.GetNext();
        }

        void DrawGrid(UIRenderer renderer, Rect bounds, Vector2 worldSize)
        {
            var guiState = new GUIState(renderer);
            renderer.DrawRect(new Rect(bounds.position.x, bounds.position.y, worldSize.x, worldSize.y), editorStyle.backgroundColor);

            float cellSizeWorld = EditorStyle.gridCellSpacing;
            if (!editorStyle.gridScaling) {
                cellSizeWorld *= camera.ZoomLevel;
            }

            //var worldStart = camera.ScreenToWorld(new Vector2(0, 0));
            Vector2 worldStart, worldEnd;

            worldStart = camera.ScreenToWorld(new Vector2(0, 0));
            worldEnd = camera.ScreenToWorld(worldSize);

            int sx = Mathf.FloorToInt(worldStart.x / cellSizeWorld);
            int sy = Mathf.FloorToInt(worldStart.y / cellSizeWorld);

            int ex = Mathf.CeilToInt(worldEnd.x / cellSizeWorld);
            int ey = Mathf.CeilToInt(worldEnd.y / cellSizeWorld);


            var lineSegmentsThick = new List<Vector3>();
            var lineSegmentsThin = new List<Vector3>();
            
            for (int x = sx; x <= ex; x++)
            {
                var startWorld = new Vector2(x, sy) * cellSizeWorld;
                var endWorld = new Vector2(x, ey) * cellSizeWorld;

                Vector2 startScreen, endScreen;
                startScreen = camera.WorldToScreen(startWorld);
                endScreen = camera.WorldToScreen(endWorld);

                startScreen += bounds.position;
                endScreen += bounds.position;

                var segments = (x % 2 == 0) ? lineSegmentsThick : lineSegmentsThin; 
                segments.Add(startScreen);
                segments.Add(endScreen);
                //var color = (x % 2 == 0) ? EditorStyle.gridLineColorThick : EditorStyle.gridLineColorThin;
                //renderer.DrawLine(color, startScreen, endScreen);
            }

            for (int y = sy; y <= ey; y++)
            {
                var startWorld = new Vector2(sx, y) * cellSizeWorld;
                var endWorld = new Vector2(ex, y) * cellSizeWorld;

                Vector2 startScreen, endScreen;
                startScreen = camera.WorldToScreen(startWorld);
                endScreen = camera.WorldToScreen(endWorld);

                startScreen += bounds.position;
                endScreen += bounds.position;

                var segments = (y % 2 == 0) ? lineSegmentsThick : lineSegmentsThin;
                segments.Add(startScreen);
                segments.Add(endScreen);
                
                //var color = (y % 2 == 0) ? EditorStyle.gridLineColorThick : EditorStyle.gridLineColorThin;
                //renderer.DrawLine(color, startScreen, endScreen);
            }
            
            renderer.DrawLines(EditorStyle.gridLineColorThick, lineSegmentsThick.ToArray());
            renderer.DrawLines(EditorStyle.gridLineColorThin, lineSegmentsThin.ToArray());
            
            guiState.Restore();
        }

        /// <summary>
        /// Selects and highlights a node 
        /// </summary>
        /// <param name="nodeToSelect"></param>
        public void SelectNode(GraphNode nodeToSelect, UISystem uiSystem)
        {
            bool selectionChanged = false;
            foreach (var node in graph.Nodes)
            {
                var oldSelection = node.Selected;
                node.Selected = (node == nodeToSelect);
                var newSelection = node.Selected;
                selectionChanged |= (oldSelection != newSelection);
            }
            OnNodeSelectionChanged(uiSystem);
        }

        /// <summary>
        /// Gets the node pin under the mouse position.   Takes the owning node's Z-order into consideration
        /// </summary>
        /// <param name="worldPosition">The world position in graph coordinates</param>
        /// <returns>The pin under the specified position. null otherwise</returns>
        public GraphPin GetPinUnderPosition(Vector2 worldPosition)
        {
            // Check if the mouse was released over a pin
            GraphNode[] sortedNodes = graph.Nodes.ToArray();
            System.Array.Sort(sortedNodes, new NodeReversedZIndexComparer());

            foreach (var node in sortedNodes)
            {
                if (node.Bounds.Contains(worldPosition))
                {
                    // Check if we are above a pin in this node
                    var pins = new List<GraphPin>();
                    pins.AddRange(node.InputPins);
                    pins.AddRange(node.OutputPins);
                    foreach (var pin in pins)
                    {
                        if (pin.ContainsPoint(worldPosition))
                        {
                            return pin;
                        }
                    }
                    return null;
                }
            }
            return null;
        }

        // Called when the mouse is released after dragging a link out of an existing pin
        void HandleMouseDraggedLinkReleased(Vector2 mousePositionScreen, UISystem uiSystem)
        {
            var mouseWorld = camera.ScreenToWorld(mousePositionScreen);
            var sourcePin = cursorDragLink.AttachedPin;

            // Check if the mouse was released over a pin
            GraphPin targetPin = null;
            GraphNode[] sortedNodes = graph.Nodes.ToArray();
            System.Array.Sort(sortedNodes, new NodeReversedZIndexComparer());

            foreach (var node in sortedNodes)
            {
                if (node.Bounds.Contains(mouseWorld))
                {
                    // Check if we are above a pin in this node
                    var pins = new List<GraphPin>();
                    pins.AddRange(node.InputPins);
                    pins.AddRange(node.OutputPins);
                    foreach (var pin in pins)
                    {
                        if (pin.ContainsPoint(mouseWorld))
                        {
                            targetPin = pin;
                            break;
                        }
                    }
                    break;
                }
            }

            if (targetPin != null)
            {
                GraphPin source, target;
                if (sourcePin.PinType == GraphPinType.Output)
                {
                    source = sourcePin;
                    target = targetPin;
                }
                else
                {
                    source = targetPin;
                    target = sourcePin;
                }
                if (source.Node != target.Node)
                {
                    CreateLinkBetweenPins(source, target, uiSystem);
                }
            }
            else
            {
                // We stopped drag on an empty space.  Show a context menu to allow user to create nodes from this position
                contextMenu.Show(this, sourcePin, mouseWorld, uiSystem);
            }
        }

        protected virtual void CreateLinkBetweenPins(GraphPin outputPin, GraphPin inputPin, UISystem uiSystem)
        {
            // Make sure they are not from the same node
            if (outputPin == null || inputPin == null)
            {
                //Debug.LogWarning("Invalid link references");
                return;
            }

            if (outputPin.Node == inputPin.Node)
            {
                Debug.LogError("Linking pins from the same node");
                return;
            }

            // Create a link
            var link = CreateLink<GraphLink>(graph, outputPin, inputPin, uiSystem);
            if (link != null)
            {
                GraphEditorUtils.AddToAsset(uiSystem.Platform, assetObject, link);
                HandleGraphStateChanged(uiSystem);
            }
        }

        public virtual GraphSchema GetGraphSchema()
        {
            return new GraphSchema();
        }

        /// <summary>
        /// Creates a graph link between the two specified pins
        /// </summary>
        /// <typeparam name="T">The type of the link. Should be GraphLink or one of its subclass</typeparam>
        /// <param name="output">The output pin from where the link originates</param>
        /// <param name="input">The input pin, where the link points to</param>
        /// <returns></returns>
        public virtual T CreateLink<T>(Graph graph, GraphPin output, GraphPin input, UISystem uiSystem) where T : GraphLink
        {
            var graphSchema = GetGraphSchema();
            if (!graphSchema.CanCreateLink(output, input))
            {
                return null;
            }

            // Make sure a link doesn't already exists
            foreach (T link in graph.Links)
            {
                if (link.Input == input && link.Output == output)
                {
                    return link;
                }
            }

            {
                uiSystem.Undo.RecordObject(graph, "Create Link");

                // Create the link
                T link = graphSchema.TryCreateLink<T>(graph, output, input);

                uiSystem.Undo.RegisterCreatedObjectUndo(link, "Create Link");
                return link;
            }
        }


        protected abstract string GetGraphNotInitializedMessage();

        void DrawGraphNotInitializedMessage(UIRenderer renderer, Rect bounds)
        {
            var guiState = new GUIState(renderer);
            var area = bounds;
            renderer.DrawRect(area, EditorStyle.backgroundColor);
            var style = new GUIStyle(GUI.skin.GetStyle("label"));
            style.normal.textColor = EditorStyle.overlayTextColorHi;
            style.alignment = TextAnchor.MiddleCenter;
            renderer.Label(area, GetGraphNotInitializedMessage(), style);
            guiState.Restore();
        }

        void ClearBackground(UIRenderer renderer, Rect bounds, Color color)
        {
            var guiState = new GUIState(renderer);
            renderer.backgroundColor = color;
            renderer.DrawRect(bounds, color);
            guiState.Restore();
        }
    }

    /// <summary>
    /// Manages the selection box for selecting multiple objects in the graph editor
    /// </summary>
    public class GraphSelectionBox
    {
        public delegate void OnSelectionPerformed(Rect boundsScreenSpace, UISystem uiSystem);
        public event OnSelectionPerformed SelectionPerformed;

        // The bounds of the selection box in screen space
        Rect bounds = new Rect();
        public Rect Bounds
        {
            get
            {
                return bounds;
            }
            set
            {
                bounds = value;
            }
        }

        Vector2 dragStart = new Vector2();
        int dragButton = 0;
        bool dragging = false;
        public bool Dragging
        {
            get
            {
                return dragging;
            }
        }

        /// <summary>
        /// Handles user input (mouse)
        /// </summary>
        /// <param name="e"></param>
        public void HandleInput(Event e, UISystem uiSystem)
        {
            switch (e.type)
            {
                case EventType.MouseDown:
                    ProcessMouseDown(e);
                    break;

                case EventType.MouseDrag:
                    ProcessMouseDrag(e, uiSystem);
                    break;

                case EventType.MouseUp:
                case EventType.MouseLeaveWindow:
                    ProcessMouseUp(e, uiSystem);
                    break;
                    
                case EventType.Layout:
                    ProcessLayoutEvent(e);
                    break;

            }
            // Handled captured mouse up event
            {
                var controlId = GUIUtility.GetControlID(FocusType.Passive);
                if (GUIUtility.hotControl == controlId && Event.current.rawType == EventType.MouseUp)
                {
                    ProcessMouseUp(e, uiSystem);
                }
            }
        }

        void ProcessMouseDrag(Event e, UISystem uiSystem)
        {
            if (dragging && e.button == dragButton)
            {
                var dragEnd = e.mousePosition;
                UpdateBounds(dragStart, dragEnd);

                if (IsSelectionValid() && SelectionPerformed != null)
                {
                    SelectionPerformed(bounds, uiSystem);
                }
            }
        }

        void ProcessMouseDown(Event e)
        {
            if (e.button == dragButton)
            {
                dragStart = e.mousePosition;
                UpdateBounds(dragStart, dragStart);
                dragging = true;
                if (GUIUtility.hotControl == 0)
                {
                    GUIUtility.hotControl = GUIUtility.GetControlID(FocusType.Passive);
                }
            }
        }

        void ProcessMouseUp(Event e, UISystem uiSystem)
        {
            if (e.button == dragButton && dragging)
            {
                dragging = false;
                if (IsSelectionValid() && SelectionPerformed != null)
                {
                    SelectionPerformed(bounds, uiSystem);
                }
                GUIUtility.hotControl = 0;
            }
        }

        void ProcessLayoutEvent(Event e)
        {
            if (dragging && e.button != dragButton)
            {
                dragging = false;
            }
        }

        public bool IsSelectionValid()
        {
            return bounds.width > 0 && bounds.height > 0;
        }

        public void Draw(UIRenderer renderer, GraphEditorStyle style)
        {
            if (!dragging || !IsSelectionValid()) return;

            var guiState = new GUIState(renderer);
            renderer.DrawRect(bounds, style.selectionBoxColor);
            guiState.Restore();
        }

        void UpdateBounds(Vector2 start, Vector2 end)
        {
            var x0 = Mathf.Min(start.x, end.x);
            var x1 = Mathf.Max(start.x, end.x);
            var y0 = Mathf.Min(start.y, end.y);
            var y1 = Mathf.Max(start.y, end.y);
            bounds.Set(x0, y0, x1 - x0, y1 - y0);
        }

    }

    /// <summary>
    /// Caches the keyboard state 
    /// </summary>
    class KeyboardState
    {
        Dictionary<KeyCode, bool> state = new Dictionary<KeyCode, bool>();
        bool shift;
        bool control;
        bool alt;

        public void SetState(KeyCode keyCode, bool pressed)
        {
            if (!state.ContainsKey(keyCode))
            {
                state.Add(keyCode, false);
            }
            state[keyCode] = pressed;
        }

        public void HandleInput(Event e)
        {

            if (e.type == EventType.KeyDown)
            {
                SetState(e.keyCode, true);
            }
            else if (e.type == EventType.KeyUp)
            {
                SetState(e.keyCode, false);
            }

            alt = e.alt;
            shift = e.shift;
            control = e.control || e.command;
        }

        public bool GetSate(KeyCode keyCode)
        {
            if (!state.ContainsKey(keyCode))
            {
                return false;
            }
            return state[keyCode];
        }

        public bool ControlPressed
        {
            get
            {
                return control;
            }
        }
        public bool ShiftPressed
        {
            get
            {
                return shift;
            }
        }
        public bool AltPressed
        {
            get
            {
                return alt;
            }
        }
    }

    /// <summary>
    /// Manages a link dragged out of a node with the other end following the mouse cursor
    /// </summary>
    class CursorDragLink
    {
        GraphLink link;

        GraphPin attachedPin;
        public GraphPin AttachedPin
        {
            get
            {
                return attachedPin;
            }
        }

        GraphPin mousePin;
        bool active = false;
        Vector2 mouseScreenPosition = new Vector2();

        public delegate void OnDraggedLinkReleased(Vector2 mousePositionScreen, UISystem uiSystem);
        public event OnDraggedLinkReleased DraggedLinkReleased;

        public CursorDragLink()
        {
            mousePin = ScriptableObject.CreateInstance<GraphPin>();
            mousePin.PinType = GraphPinType.Input;
            mousePin.name = "Cursor_DragPin";

            link = ScriptableObject.CreateInstance<GraphLink>();
            link.name = "Cursor_DragLink";

            mousePin.hideFlags = HideFlags.HideAndDontSave;
            link.hideFlags = HideFlags.HideAndDontSave;
        }

        public void Destroy()
        {
            UnityEngine.Object.DestroyImmediate(mousePin);
            UnityEngine.Object.DestroyImmediate(link);
            mousePin = null;
            link = null;
        }

        public void Activate(GraphPin fromPin, UISystem uiSystem)
        {
            active = true;
            attachedPin = fromPin;
            mousePin.PinType = (attachedPin.PinType == GraphPinType.Input) ? GraphPinType.Output : GraphPinType.Input;
            mousePin.Tangent = -attachedPin.Tangent;
            mousePin.TangentStrength = attachedPin.TangentStrength;
            AttachPinToLink(mousePin);
            AttachPinToLink(attachedPin);
        }

        public void Deactivate(UISystem uiSystem)
        {
            active = false;
            if (DraggedLinkReleased != null)
            {
                DraggedLinkReleased(mouseScreenPosition, uiSystem);
            }
        }

        public void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphCamera camera)
        {
            if (!active)
            {
                return;
            }

            var mouseWorld = camera.ScreenToWorld(mouseScreenPosition);
            mousePin.Position = mouseWorld;


            var graphEditor = rendererContext.GraphEditor;
            graphEditor.GraphLinkRenderer.DrawGraphLink(renderer, rendererContext, link, camera);

            // Check the pin that comes under the mouse pin
            var targetPin = graphEditor.GetPinUnderPosition(mouseWorld);
            if (targetPin != null)
            {
                var sourcePin = attachedPin;
                var pins = new GraphPin[] { sourcePin, targetPin };
                graphEditor.SortPinsForDrawing(pins);

                string errorMessage;
                var graphSchema = graphEditor.GetGraphSchema();
                if (!graphSchema.CanCreateLink(pins[0], pins[1], out errorMessage))
                {
                    GraphTooltip.message = errorMessage;
                }
            }
        }

        public void HandleInput(Event e, UISystem uiSystem)
        {
            mouseScreenPosition = e.mousePosition;
            if (!active) return;
            int dragButton = 0;
            if (e.type == EventType.MouseUp && e.button == dragButton)
            {
                Deactivate(uiSystem);
            }
        }

        void AttachPinToLink(GraphPin pin)
        {
            if (pin.PinType == GraphPinType.Input)
            {
                link.Input = pin;
            }
            else
            {
                link.Output = pin;
            }
        }
    }

    /// <summary>
    /// Sorts based on the node's Z-index
    /// </summary>
    class NodeZIndexComparer : IComparer<GraphNode>
    {
        public int Compare(GraphNode x, GraphNode y)
        {
            if (x == null || y == null) return 0;
            if (x.ZIndex == y.ZIndex) return 0;
            return x.ZIndex < y.ZIndex ? -1 : 1;
        }
    }

    /// <summary>
    /// Sorts based on the node's Z-index in descending order
    /// </summary>
    class NodeReversedZIndexComparer : IComparer<GraphNode>
    {
        public int Compare(GraphNode x, GraphNode y)
        {
            if (x == null || y == null) return 0;
            if (x.ZIndex == y.ZIndex) return 0;
            return x.ZIndex > y.ZIndex ? -1 : 1;
        }
    }

    [Serializable]
    public class GraphEvent<T> where T : EventArgs
    {
        [SerializeField]
        private event EventHandler<T> _Event;

        [SerializeField]
        private List<EventHandler<T>> delegates = new List<EventHandler<T>>();

        public event EventHandler<T> Event
        {
            add
            {
                _Event += value;
                delegates.Add(value);
            }

            remove
            {
                _Event -= value;
                delegates.Remove(value);
            }
        }


        public void Notify(T args)
        {
            if (_Event != null)
            {
                _Event(this, args);
            }
        }

        public void Clear()
        {
            foreach (var handler in delegates)
            {
                _Event -= handler;
            }
            delegates.Clear();
        }
    }

    public class GraphNodeEventArgs : EventArgs
    {
        public GraphNodeEventArgs(UISystem uiSystem, GraphNode[] nodes)
        {
            this.uiSystem = uiSystem;
            this.Nodes = nodes;
        }
        public GraphNodeEventArgs(UISystem uiSystem, GraphNode node)
            : this(uiSystem, new GraphNode[] { node })
        {
        }

        public UISystem uiSystem { get; private set; }
        public GraphNode[] Nodes { get; private set; }
    }

    public class GraphEventArgs : EventArgs
    {
        public GraphEventArgs(Graph graph)
        {
            this.graph = graph;
        }

        Graph graph;
        public Graph Graph
        {
            get { return graph; }
        }
    }

    [Serializable]
    public class GraphEditorEvents
    {
        public GraphEvent<GraphNodeEventArgs> OnNodeDragStart = new GraphEvent<GraphNodeEventArgs>();
        public GraphEvent<GraphNodeEventArgs> OnNodeDragEnd = new GraphEvent<GraphNodeEventArgs>();
        public GraphEvent<GraphNodeEventArgs> OnNodeDragged = new GraphEvent<GraphNodeEventArgs>();
        public GraphEvent<GraphNodeEventArgs> OnNodeCreated = new GraphEvent<GraphNodeEventArgs>();
        public GraphEvent<GraphNodeEventArgs> OnNodeSelectionChanged = new GraphEvent<GraphNodeEventArgs>();
        public GraphEvent<GraphNodeEventArgs> OnNodeDoubleClicked = new GraphEvent<GraphNodeEventArgs>();
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\GraphEditor\GraphEditorUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;
using System.Collections.Generic;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{
    public class GraphEditorUtils
    {
        /// <summary>
        /// Adds the node to the graph asset so it can be serialized to disk
        /// </summary>
        /// <param name="graph">The owning graph</param>
        /// <param name="link">The link to add to the graph</param>
        public static void AddToAsset(UIPlatform platform, Object assetObject, GraphLink link)
        {
            platform.AddObjectToAsset(link, assetObject);
        }

        /// <summary>
        /// Adds the node to the graph asset so it can be serialized to disk
        /// </summary>
        /// <param name="graph">The owning graph</param>
        /// <param name="node">The node to add to the graph</param>
        public static void AddToAsset(UIPlatform platform, Object assetObject, GraphNode node)
        {
            if (assetObject != null && node != null)
            {
                platform.AddObjectToAsset(node, assetObject);
                // Add all the pins in this node to the graph asset as well
                var pins = new List<GraphPin>();
                pins.AddRange(node.InputPins);
                pins.AddRange(node.OutputPins);
                foreach (var pin in pins)
                {
                    if (pin != null)
                    {
                        platform.AddObjectToAsset(pin, assetObject);
                    }
                }
            }
        }

    }

    /// <summary>
    /// Graph editor constants
    /// </summary>
    public class GraphEditorConstants
    {

        public static readonly Color PIN_COLOR = new Color(0.4f, 0.4f, 0.4f);
        public static readonly Color PIN_COLOR_HOVER = new Color(1, 0.6f, 0.0f);
        public static readonly Color PIN_COLOR_CLICK = new Color(1, 0.9f, 0.0f);

        public static readonly Color NODE_COLOR = new Color(0.2824f, 0.2824f, 0.2824f); //new Color(0.1f, 0.1f, 0.1f);
        public static readonly Color NODE_COLOR_SELECTED = new Color(.9f, 0.5f, 0.0f);

        public static readonly Color TEXT_COLOR = new Color(0.9f, 0.9f, 0.9f);
        public static readonly Color TEXT_COLOR_SELECTED = Color.white;

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\GraphEditor\GraphOperations.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System;
using System.Collections.Generic;
using DungeonArchitect.Graphs;
using Object = UnityEngine.Object;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{
    public class GraphOperations
    {
        /// <summary>
        /// Creates a new graph node of the specified type
        /// </summary>
        /// <typeparam name="T">The type of node to create. Should be a subclass of GraphNode</typeparam>
        /// <returns>The created graph node</returns>
        public static T CreateNode<T>(Graph graph, UIUndoSystem undo) where T : GraphNode
        {
            T node = ScriptableObject.CreateInstance<T>();
            InitializeCreatedNode(graph, node, undo);
            return node;
        }

        /// <summary>
        /// Creates a graph node of the specified type
        /// </summary>
        /// <param name="t">The type of node to create. Should be a subclass of GraphNode</param>
        /// <returns>The created graph node</returns>
        public static GraphNode CreateNode(Graph graph, Type t, UIUndoSystem undo)
        {
            GraphNode node = ScriptableObject.CreateInstance(t) as GraphNode;
            InitializeCreatedNode(graph, node, undo);
            return node;
        }

        private static void InitializeCreatedNode(Graph graph, GraphNode node, UIUndoSystem undo)
        {
			var id = System.Guid.NewGuid().ToString(); // graph.IndexCounter.GetNext();
            if (undo != null)
            {
                undo.RecordObject(graph, "Create Node");
            }

            node.Initialize(id, graph);

            if (undo != null)
            {
                undo.RegisterCreatedObjectUndo(node, "Create Node");
            }

            var pins = new List<GraphPin>();
            pins.AddRange(node.InputPins);
            pins.AddRange(node.OutputPins);

            foreach (var pin in pins)
            {
                if (undo != null)
                {
                    undo.RegisterCompleteObjectUndo(pin, "Create Node");
                }
            }

            graph.Nodes.Add(node);
        }

        /// <summary>
        /// Makes a deep copy of a node.  Called when a node is copy pasted
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="originalNode"></param>
        /// <returns></returns>
        public static T DuplicateNode<T>(Graph graph, T originalNode, UIUndoSystem undo) where T : GraphNode
        {
            var node = CreateNode(graph, originalNode.GetType(), undo);
            node.CopyFrom(originalNode);
            return node as T;
        }
        
        /// <summary>
        /// Destroys a node and removes all references of it from the graph model. Called when the node is deleted from the editor
        /// </summary>
        /// <param name="node"></param>
        public static void DestroyNode(GraphNode node, UIUndoSystem undo)
        {
            if (!node.CanBeDeleted)
            {
                // Cannot be deleted
                return;
            }

            var graph = node.Graph;
            if (undo != null)
            {
                undo.RegisterCompleteObjectUndo(graph, "Delete Node");
                undo.RegisterCompleteObjectUndo(node, "Delete node");
            }
            
            // Break link connections
            BreakInputLinks(node, undo);
            BreakOutputLinks(node, undo);

            // De-register from the graph
            graph.Nodes.Remove(node);

            // Destroy the pins
            var pins = new List<GraphPin>();
            pins.AddRange(node.InputPins);
            pins.AddRange(node.OutputPins);
            foreach (var pin in pins)
            {
                if (undo != null)
                {
                    undo.DestroyObjectImmediate(pin);
                }
            }

            graph.Nodes.Remove(node);

            if (undo != null)
            {
                undo.DestroyObjectImmediate(node);
            }
        }

        
        /// <summary>
        /// Destroys a node and removes all references of it from the graph model. Called when the node is deleted from the editor
        /// </summary>
        /// <param name="node"></param>
        public static void DestroyLink(GraphLink link, UIUndoSystem undo)
        {
            var graph = link.Graph;
            if (undo != null)
            {
                undo.RecordObject(graph, "Destroy Link");
            }
            graph.Links.Remove(link);

            if (undo != null)
            {
                undo.DestroyObjectImmediate(link);
            }
        }

        public static void DestroyPinLinks(Graph graph, GraphPin pin, UIUndoSystem undo)
        {
            var linksToRemove = new HashSet<GraphLink>();
            foreach (var link in graph.Links)
            {
                if (link.Input == pin || link.Output == pin)
                {
                    linksToRemove.Add(link);       
                }
            }
            
            if (undo != null)
            {
                undo.RecordObject(graph, "Destroy Link");
            }
            foreach (var link in linksToRemove)
            {
                graph.Links.Remove(link);
                
                if (undo != null)
                {
                    undo.DestroyObjectImmediate(link);
                }
            }

        }

        /// <summary>
        /// Breaks all links connected to the input pins
        /// </summary>
        public static void BreakInputLinks(GraphNode node, UIUndoSystem undo)
        {
            BreakLinks(node.InputPins, undo);
        }

        /// <summary>
        /// Breaks all links connected to the output pins
        /// </summary>
        public static void BreakOutputLinks(GraphNode node, UIUndoSystem undo)
        {
            BreakLinks(node.OutputPins, undo);
        }

        private static void BreakLinks(GraphPin[] pins, UIUndoSystem undo)
        {
            foreach (var pin in pins)
            {
                BreakLinks(pin, undo);
            }
        }

        // Breaks all the links attached to the pin
        private static void BreakLinks(GraphPin pin, UIUndoSystem undo)
        {
            GraphLink[] links = pin.GetConntectedLinks();
            foreach (var link in links)
            {
                DestroyLink(link, undo);
            }
        }

        
        /// <summary>
        /// Creates a link of the specified type
        /// </summary>
        /// <typeparam name="T">The type of the link. Should be GraphLink or one of its subclass</typeparam>
        /// <returns></returns>
        public static T CreateLink<T>(Graph graph) where T : GraphLink
        {
            T link = ScriptableObject.CreateInstance<T>();
            link.Id = graph.IndexCounter.GetNext();
            link.Graph = graph;
            graph.Links.Add(link);
            return link;
        }


    }


    class GraphInputHandler
    {
        /// <summary>
        /// Handles user input (keyboard and mouse)
        /// </summary>
        /// <param name="e">Input event</param>
        /// <param name="camera">Graph camera to convert to / from screen to world coordinates</param>
        /// <returns>true if the input was processed, false otherwise.</returns>
        public static bool HandleNodeInput(GraphNode node, Event e, GraphEditor graphEditor, UISystem uiSystem)
        {
            bool inputProcessed = false;
            if (!node.Dragging)
            {
                // let the pins handle the input first
                foreach (var pin in node.InputPins)
                {
                    if (inputProcessed) break;
                    inputProcessed |= HandlePinInput(pin, e, graphEditor, uiSystem);
                }
                foreach (var pin in node.OutputPins)
                {
                    if (inputProcessed) break;
                    inputProcessed |= HandlePinInput(pin, e, graphEditor, uiSystem);
                }
            }

            var mousePosition = e.mousePosition;
            var mousePositionWorld = graphEditor.Camera.ScreenToWorld(mousePosition);
            int dragButton = 0;
            // If the pins didn't already handle the input, then let the node handle it
            if (!inputProcessed)
            {
                bool insideRect = node.Bounds.Contains(mousePositionWorld);
                if (e.type == EventType.MouseDown && insideRect && e.button == dragButton)
                {
                    node.Dragging = true;
                    inputProcessed = true;
                }
                else if (e.type == EventType.MouseUp && insideRect && e.button == dragButton)
                {
                    node.Dragging = false;
                }
            }

            if (node.Dragging && !node.Selected)
            {
                node.Dragging = false;
            }

            if (node.Dragging && e.type == EventType.MouseDrag)
            {
                inputProcessed = true;
            }

            return inputProcessed;
        }


        /// <summary>
        /// Handles the mouse input and returns true if handled
        /// </summary>
        public static bool HandlePinInput(GraphPin pin, Event e, GraphEditor graphEditor, UISystem uiSystem)
        {
            var camera = graphEditor.Camera;
            var mousePosition = e.mousePosition;
            var mousePositionWorld = camera.ScreenToWorld(mousePosition);
            int buttonIdDrag = 0;
            int buttonIdDestroyLinks = 1;
            if (pin.ContainsPoint(mousePositionWorld))
            {
                if (e.type == EventType.MouseDown && e.button == buttonIdDrag)
                {
                    pin.ClickState = GraphPinMouseState.Clicked;
                    return true;
                }

                if (e.button == buttonIdDestroyLinks)
                {
                    if (e.type == EventType.MouseDown)
                    {
                        pin.RequestLinkDeletionInitiated = true;
                    }
                    else if (e.type == EventType.MouseDrag)
                    {
                        pin.RequestLinkDeletionInitiated = false;
                    }
                    else if (e.type == EventType.MouseUp)
                    {
                        if (pin.RequestLinkDeletionInitiated)
                        {
                            DestroyPinLinks(pin, uiSystem.Undo);
                            if (pin.Node != null && pin.Node.Graph != null)
                            {
                                graphEditor.HandleGraphStateChanged(uiSystem);
                            }
                        }
                    }
                    return true;
                }

                if (pin.ClickState != GraphPinMouseState.Clicked)
                {
                    pin.ClickState = GraphPinMouseState.Hover;
                }
            }
            else
            {
                pin.ClickState = GraphPinMouseState.None;
            }

            return false;
        }

        /// <summary>
        /// Destroys all links connected to this pin
        /// </summary>
        private static void DestroyPinLinks(GraphPin pin, UIUndoSystem undo)
        {
            var pinLinks = pin.GetConntectedLinks();
            foreach (var link in pinLinks)
            {
                GraphOperations.DestroyLink(link, undo);
            }

            pin.NotifyPinLinksDestroyed();
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Navigation\BreadCrumbWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class BreadCrumbWidgetNode
    {
        public BreadCrumbWidgetNode(string displayText, object userdata)
        {
            this.displayText = displayText;
            this.userdata = userdata;
        }

        public string displayText;
        public object userdata;
    }

    public delegate void OnBreadCrumbLinkClicked(object userdata);
    public class BreadCrumbWidget : WidgetBase
    {
        IWidget content;
        int padding = 5;
        bool requestRebuild = false;

        List<BreadCrumbWidgetNode> items = new List<BreadCrumbWidgetNode>();
        public event OnBreadCrumbLinkClicked LinkClicked;
        public int FontSize { get; set; }
        public Color TextColor { get; set; }

        public BreadCrumbWidget()
        {
            content = new NullWidget();
        }

        public BreadCrumbWidget SetPadding(int padding)
        {
            this.padding = padding;
            requestRebuild = true;
            return this;
        }

        public object GetTopItemUserData()
        {
            if (items.Count == 0) return null;
            return items[items.Count - 1].userdata;
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { content };
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            return content.GetDesiredSize(size, uiSystem);
        }

        public void PushPage(string displayName, object userdata)
        {
            items.Add(new BreadCrumbWidgetNode(displayName, userdata));
            requestRebuild = true;
        }

        public void MoveToPage(BreadCrumbWidgetNode node)
        {
            while (items.Count > 0)
            {
                var lastIndex = items.Count - 1;
                var lastItem = items[lastIndex];
                if (lastItem == node)
                {
                    break;
                }
                items.RemoveAt(lastIndex);
            }
            requestRebuild = true;
        }
        
        public void Clear()
        {
            items.Clear();
            requestRebuild = true;
        }

        void Rebuild(UISystem uiSystem)
        {
            var stackPanel = new StackPanelWidget(StackPanelOrientation.Horizontal);
            var firstNode = true;
            foreach (var node in items)
            {
                if (!firstNode)
                {
                    var arrow = 
                        new BorderWidget(
                            new LabelWidget(">")
                                .SetFontSize(FontSize)
                                .SetColor(TextColor))
                            .SetPadding(padding, padding, padding, padding)
                            .SetTransparent();

                    stackPanel.AddWidget(arrow, 0, true);
                }
                firstNode = false;

                var crumb = new LinkWidget(
                    new BorderWidget(
                        new LabelWidget(node.displayText)
                            .SetFontSize(FontSize)
                            .SetColor(TextColor))
                        .SetPadding(padding, padding, padding, padding)
                        .SetTransparent());
                crumb.SetUserData(node);
                crumb.SetDrawLinkOutline(false);

                crumb.LinkClicked += OnCrumbItemClicked;

                stackPanel.AddWidget(crumb, 0, true);
            }

            content = stackPanel;

            requestRebuild = false;
        }

        private void OnCrumbItemClicked(WidgetClickEvent clickEvent)
        {
            var node = clickEvent.userdata as BreadCrumbWidgetNode;
            if (node != null)
            {
                MoveToPage(node);
                if (LinkClicked != null)
                {
                    LinkClicked.Invoke(node.userdata);
                }
            }
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (content == null || requestRebuild)
            {
                Rebuild(uiSystem);
            }
            var contentBounds = new Rect(Vector2.zero, WidgetBounds.size);
            content.UpdateWidget(uiSystem, contentBounds);
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (content != null)
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, content);
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Panels\GraphPanel.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class GraphPanel<TGraphEditor> : WidgetBase where TGraphEditor : GraphEditor
    {
        IWidget host;

        public BorderWidget Border;
        public ToolbarWidget FloatingToolbar;
        public ToolbarWidget Toolbar;
        public TGraphEditor GraphEditor;

        readonly static string BTN_FOCUS_ON_GRAPH = "FocusOnGraph";

        public GraphPanel(Graph graph, Object assetObject, UISystem uiSystem)
            : this(graph, assetObject, uiSystem, null)
        {
        }

        public GraphPanel(Graph graph, Object assetObject, UISystem uiSystem, ToolbarWidget toolbar)
        {
            GraphEditor = ScriptableObject.CreateInstance<TGraphEditor>();
            GraphEditor.Init(graph, Rect.zero, assetObject, uiSystem);
            GraphEditor.ShowFocusHighlight = true;

            FloatingToolbar = new ToolbarWidget();
            FloatingToolbar.ButtonSize = 24;
            FloatingToolbar.Padding = 0;
            FloatingToolbar.Background = new Color(0, 0, 0, 0);
            FloatingToolbar.AddButton(BTN_FOCUS_ON_GRAPH, UIResourceLookup.ICON_ZOOMFIT_16x);

            FloatingToolbar.ButtonPressed += Toolbar_ButtonPressed;

            IWidget widget = new OverlayPanelWidget()
                        .AddWidget(new HighlightWidget()
                            .SetContent(GraphEditor)
                            .SetObjectOfInterest(graph)
                        )
                        .AddWidget(FloatingToolbar, OverlayPanelHAlign.Right, OverlayPanelVAlign.Top, new Vector2(24, 24), new Vector2(10, 10));

            if (toolbar != null)
            {
                var toolbarSize = new Vector2(
                    toolbar.Padding * 2 + toolbar.ButtonSize * toolbar.buttons.Count, 
                    toolbar.Padding * 2 + toolbar.ButtonSize);

                IWidget toolWidget = new StackPanelWidget(StackPanelOrientation.Horizontal)
                                    .AddWidget(toolbar, toolbarSize.x)
                                    .AddWidget(new NullWidget())
                                    ;

                toolWidget = new BorderWidget(toolWidget)
                    .SetPadding(0, 0, 0, 0)
                    .SetDrawOutline(false)
                    .SetColor(new Color(0, 0, 0, 0.25f));

                widget = new StackPanelWidget(StackPanelOrientation.Vertical)
                        .AddWidget(toolWidget, toolbarSize.y)
                        .AddWidget(widget);
            }

            Border = new BorderWidget()
                   .SetContent(widget);

            host = Border;
        }

        private void Toolbar_ButtonPressed(UISystem uiSystem, string id)
        {
            if (uiSystem != null)
            {
                uiSystem.RequestFocus(GraphEditor);
            }

            if (id == BTN_FOCUS_ON_GRAPH)
            {
                ResetCamera();
            }
        }

        public void ResetCamera()
        {
            GraphEditor.FocusCameraOnBestFit();
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (host != null)
            {
                var childBounds = new Rect(Vector2.zero, bounds.size);
                host.UpdateWidget(uiSystem, childBounds);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            host.Draw(uiSystem, renderer);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { host };
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Panels\GridPanelWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public enum GridPanelArrangementType
    {
        VerticalScroll
    }

    class GridPanelNode
    {
        public IWidget Widget;
    }


    public class GridPanelWidget : WidgetBase
    {
        List<GridPanelNode> nodes = new List<GridPanelNode>();
        GridPanelArrangementType arrangement = GridPanelArrangementType.VerticalScroll;
        IntVector2 padding = new IntVector2(10, 10);
        public Vector2 cellSize = new Vector2(100, 100);
        public Vector2 desiredCellSize = Vector2.zero;
        public bool autoSize = false;


        IntVector2 renderedCells = new IntVector2(0, 0);

        public GridPanelWidget(GridPanelArrangementType arrangement)
        {
            this.arrangement = arrangement;
        }

        public GridPanelWidget AddWidget(IWidget Widget)
        {
            var node = new GridPanelNode();
            node.Widget = Widget;
            nodes.Add(node);
            return this;
        }

        public GridPanelWidget SetArrangementType(GridPanelArrangementType arrangement)
        {
            this.arrangement = arrangement;
            return this;
        }

        public GridPanelArrangementType GetArrangementType()
        {
            return arrangement;
        }

        public GridPanelWidget SetPadding(int x, int y)
        {
            this.padding = new IntVector2(x, y);
            return this;
        }

        public GridPanelWidget SetAutoSize(bool autoSize)
        {
            this.autoSize = autoSize;
            return this;
        }

        public GridPanelWidget SetCellSize(float width, float height)
        {
            this.cellSize = new Vector2(width, height);
            return this;
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            UpdateDesiredCellSize(uiSystem);
            var cellHeight = padding.y + desiredCellSize.y;
            var targetWidth = size.x;
            var targetHeight = renderedCells.y * cellHeight + padding.y;
            return new Vector2(targetWidth, targetHeight);
        }


        void UpdateDesiredCellSize(UISystem uiSystem)
        {
            if (autoSize)
            {
                desiredCellSize = Vector2.zero;
                foreach (var node in nodes)
                {
                    if (node.Widget != null)
                    {
                        var nodeSize = node.Widget.GetDesiredSize(Vector2.zero, uiSystem);
                        desiredCellSize.x = Mathf.Max(desiredCellSize.x, nodeSize.x);
                        desiredCellSize.y = Mathf.Max(desiredCellSize.y, nodeSize.y);
                    }
                }
            }
            else
            {
                desiredCellSize = cellSize;
            }
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            UpdateDesiredCellSize(uiSystem);
            if (autoSize)
            {
                cellSize = desiredCellSize;
            }

            var targetWidth = WidgetBounds.size.x;

            var cellWidth = padding.x + cellSize.x;
            int numCellsX = Mathf.FloorToInt(targetWidth / (float)cellWidth);
            numCellsX = Mathf.Max(1, numCellsX);
            int numCellsY = Mathf.CeilToInt(nodes.Count / (float)numCellsX);
            renderedCells = new IntVector2(numCellsX, numCellsY);

            for (int i = 0; i < nodes.Count; i++)
            {
                int ix = i % numCellsX;
                int iy = i / numCellsX;
                float x = (cellSize.x + padding.x) * ix;
                float y = (cellSize.y + padding.y) * iy;

                var nodeBounds = new Rect(
                    x + padding.x,
                    y + padding.y,
                    cellSize.x,
                    cellSize.y);

                var node = nodes[i];
                node.Widget.UpdateWidget(uiSystem, nodeBounds);
            }
        }


        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            foreach (var childWidget in GetChildWidgets())
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, childWidget);
            }
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            var children = new List<IWidget>();

            foreach (var node in nodes)
            {
                if (node.Widget != null)
                {
                    children.Add(node.Widget);
                }
            }

            return children.ToArray();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Panels\OverlayPanelWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public enum OverlayPanelVAlign
    {
        Fill,
        Top,
        Center,
        Bottom
    }

    public enum OverlayPanelHAlign
    {
        Fill,
        Left,
        Center,
        Right
    }

    class OverlayPanelNode
    {
        public IWidget Widget;
        public Vector2 Size = new Vector2(100, 100);
        public Vector2 Offset = Vector2.zero;

        public OverlayPanelVAlign VAlign = OverlayPanelVAlign.Fill;
        public OverlayPanelHAlign HAlign = OverlayPanelHAlign.Fill;

        public Rect Bounds = Rect.zero;
    }

    public class OverlayPanelWidget : WidgetBase
    {
        List<OverlayPanelNode> nodes = new List<OverlayPanelNode>();

        public OverlayPanelWidget AddWidget(IWidget widget, OverlayPanelHAlign HAlign, OverlayPanelVAlign VAlign, Vector2 size, Vector2 offset)
        {
            var node = new OverlayPanelNode();
            node.Widget = widget;
            node.Size = size;
            node.Offset = offset;
            node.VAlign = VAlign;
            node.HAlign = HAlign;
            nodes.Add(node);

            return this;
        }

        public OverlayPanelWidget AddWidget(IWidget widget)
        {
            return AddWidget(widget, OverlayPanelHAlign.Fill, OverlayPanelVAlign.Fill, Vector2.zero, Vector2.zero);
        }


        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            UpdateNodeBounds(uiSystem);
                        
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            foreach (var node in nodes)
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, node.Widget);
            }
        }

        OverlayPanelNode FindIntersectingNode(Vector2 position)
        {
            foreach (var node in nodes)
            {
                if (node.Bounds.Contains(position))
                {
                    return node;
                }
            }
            return null;
        }

        public void UpdateNodeBounds(UISystem uiSystem)
        {
            var windowSize = WidgetBounds.size;
            foreach (var node in nodes)
            {
                var position = Vector2.zero;
                var size = node.Size;

                // Find horizontal alignment
                if (node.HAlign == OverlayPanelHAlign.Fill)
                {
                    position.x = node.Offset.x;
                    size.x = windowSize.x - node.Offset.x * 2;
                }
                else if (node.HAlign == OverlayPanelHAlign.Left)
                {
                    position.x = node.Offset.x;
                }
                else if (node.HAlign == OverlayPanelHAlign.Right)
                {
                    position.x = windowSize.x - node.Size.x - node.Offset.x;
                }
                else if (node.HAlign == OverlayPanelHAlign.Center)
                {
                    position.x = (windowSize.x - node.Size.x) / 2.0f;
                }

                // Find vertical alignment
                if (node.VAlign == OverlayPanelVAlign.Fill)
                {
                    position.y = node.Offset.y;
                    size.y = windowSize.y - node.Offset.y * 2;
                }
                else if (node.VAlign == OverlayPanelVAlign.Top)
                {
                    position.y = node.Offset.y;
                }
                else if (node.VAlign == OverlayPanelVAlign.Bottom)
                {
                    position.y = windowSize.y - node.Size.y - node.Offset.y;
                }
                else if (node.VAlign == OverlayPanelVAlign.Center)
                {
                    position.y = (windowSize.y - node.Size.y) / 2.0f;
                }

                var nodeBounds = new Rect(position, size);
                node.Widget.UpdateWidget(uiSystem, nodeBounds);
            }
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            var children = new List<IWidget>();

            foreach (var node in nodes)
            {
                if (node.Widget != null)
                {
                    children.Add(node.Widget);
                }
            }

            return children.ToArray();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Panels\PanelWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class PanelWidget : WidgetBase
    {
        protected IWidget Content;

        public PanelWidget() { }

        public PanelWidget(IWidget content)
        {
            this.Content = content;
        }

        public PanelWidget SetContent(IWidget content)
        {
            this.Content = content;
            return this;
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (Content != null)
            {
                var contentBounds = new Rect(Vector2.zero, WidgetBounds.size);
                Content.UpdateWidget(uiSystem, contentBounds);
            }
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            // Draw the content
            if (Content != null)
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, Content);
            }
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { Content };
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            if (Content != null)
            {
                return Content.GetDesiredSize(size, uiSystem);
            }
            else
            {
                return base.GetDesiredSize(size, uiSystem);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Panels\ScrollPanelWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class ScrollPanelWidget : WidgetBase
    {
        IWidget content;
        bool MouseScrollingEnabled = true;

        public ScrollPanelWidget(IWidget content)
            : this(content, true)
        {
        }

        public ScrollPanelWidget(IWidget content, bool mouseScrollingEnabled)
        {
            this.content = content;
            this.MouseScrollingEnabled = mouseScrollingEnabled;
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            var bounds = new Rect(Vector2.zero, WidgetBounds.size);
            ScrollPosition = renderer.BeginScrollView(bounds, ScrollPosition, content.WidgetBounds);
            content.Draw(uiSystem, renderer);
            renderer.EndScrollView(MouseScrollingEnabled);
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            var contentSize = content.GetDesiredSize(bounds.size, uiSystem);
            contentSize.x = Mathf.Max(contentSize.x, bounds.size.x);
            if (contentSize.y > bounds.height)
            {
                contentSize.x -= 16;
            }
            var contentBounds = new Rect(Vector2.zero, contentSize);
            content.UpdateWidget(uiSystem, contentBounds);
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            return content.GetDesiredSize(size, uiSystem);
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return new[] { content };
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Panels\StackPanelWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    class StackPanelNode
    {
        public IWidget Widget;
        public bool AutoSize = false;
        public bool AdjustToDynamicDesiredSize = false;
        public float Size = 100;
    }

    public enum StackPanelOrientation
    {
        Horizontal,
        Vertical
    }

    public class StackPanelWidget : WidgetBase
    {
        List<StackPanelNode> nodes = new List<StackPanelNode>();
        StackPanelOrientation Orientation = StackPanelOrientation.Vertical;

        public StackPanelWidget(StackPanelOrientation orientation)
        {
            this.Orientation = orientation;
        }

        public StackPanelWidget AddWidget(IWidget Widget)
        {
            var node = new StackPanelNode();
            node.Widget = Widget;
            node.AutoSize = true;
            nodes.Add(node);

            return this;
        }

        public StackPanelWidget AddWidget(IWidget Widget, float size)
        {
            return AddWidget(Widget, size, false);
        }

        public StackPanelWidget AddWidget(IWidget Widget, float size, bool adjustToDynamicDesiredSize)
        {
            var node = new StackPanelNode();
            node.Widget = Widget;
            node.Size = size;
            node.AdjustToDynamicDesiredSize = adjustToDynamicDesiredSize;
            nodes.Add(node);

            return this;
        }

        public override Vector2 GetDesiredSize(Vector2 size, UISystem uiSystem)
        {
            var fixedLength = 0.0f;
            foreach (var node in nodes)
            {
                if (!node.AutoSize)
                {
                    var nodeSize = node.Size;
                    if (Orientation == StackPanelOrientation.Horizontal)
                    {
                        var nodeDesiredSize = new Vector2(nodeSize, size.y);
                        nodeDesiredSize = node.Widget.GetDesiredSize(nodeDesiredSize, uiSystem);
                        nodeSize = nodeDesiredSize.x;
                        if (node.AdjustToDynamicDesiredSize)
                        {
                            size.y = nodeDesiredSize.y;
                        }
                    }
                    else if (Orientation == StackPanelOrientation.Vertical)
                    {
                        var nodeDesiredSize = new Vector2(size.x, nodeSize);
                        nodeDesiredSize = node.Widget.GetDesiredSize(nodeDesiredSize, uiSystem);
                        nodeSize = nodeDesiredSize.y;
                        if (node.AdjustToDynamicDesiredSize)
                        {
                            size.x = nodeDesiredSize.x;
                        }
                    }

                    fixedLength += nodeSize;
                }
            }

            var desiredSize = size;
            if (Orientation == StackPanelOrientation.Horizontal)
            {
                desiredSize.x = Mathf.Max(desiredSize.x, fixedLength);
            }
            else if (Orientation == StackPanelOrientation.Vertical)
            {
                desiredSize.y = Mathf.Max(desiredSize.y, fixedLength);
            }

            return desiredSize;
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            foreach (var node in nodes)
            {
                if (!node.AutoSize && node.AdjustToDynamicDesiredSize)
                {
                    var size = bounds.size;
                    var ds = (Orientation == StackPanelOrientation.Horizontal)
                    ? new Vector2(node.Size, size.y)
                    : new Vector2(size.x, node.Size);

                    ds = node.Widget.GetDesiredSize(ds, uiSystem);
                    node.Size = (Orientation == StackPanelOrientation.Horizontal)
                        ? ds.x
                        : ds.y;
                }
            }

            float availableSize = (Orientation == StackPanelOrientation.Horizontal) ? WidgetBounds.width : WidgetBounds.height;
            int autoSizedNodeCount = 0;
            // find the available size after the fixed sized nodes have been processed
            for (int i = 0; i < nodes.Count; i++)
            {
                var node = nodes[i];
                if (!node.AutoSize)
                {
                    availableSize -= node.Size;
                }
                else
                {
                    autoSizedNodeCount++;
                }
            }

            float autoSize = autoSizedNodeCount > 0 ? Mathf.Max(0.0f, availableSize) / autoSizedNodeCount : 0;
            float offset = 0;
            foreach (var node in nodes)
            {
                float nodeSize;
                if (!node.AutoSize)
                {

                    nodeSize = node.Size;
                }
                else
                {
                    nodeSize = autoSize;
                }

                var nodeBounds = (Orientation == StackPanelOrientation.Horizontal)
                    ? new Rect(offset, 0, nodeSize, WidgetBounds.height)
                    : new Rect(0, offset, WidgetBounds.width, nodeSize);

                node.Widget.UpdateWidget(uiSystem, nodeBounds);

                offset += nodeSize;
            }

        }


        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            foreach (var childWidget in GetChildWidgets())
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, childWidget);
            }
        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            var children = new List<IWidget>();

            foreach (var node in nodes)
            {
                if (node.Widget != null)
                {
                    children.Add(node.Widget);
                }
            }

            return children.ToArray();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Rendering\SxViewportWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System.Collections.Generic;
using DungeonArchitect.SxEngine;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class SxViewportWidget : WidgetBase
    {
        public SxWorld World { get; }
        public SxRenderer Renderer => renderer;
        public float MoveSpeed = 4.0f;
        
        protected SxRenderer renderer;
        protected FrameTime frameTime = new FrameTime();
        protected float pitch = 0;
        protected float yaw = 0;
        protected float OrbitAnglePerPixel = 0.5f;
        protected float ZoomPerScrollUnit = 0.5f;
        
        protected Vector3 targetCamLocation;
            

        private Matrix4x4 lastRenderViewMatrix;
        protected bool renderStateInvalidated = false;
        
        public bool RenderEveryFrame { get; set; } = false;

        
        public SxCamera Camera
        {
            get => renderer != null ? renderer.Camera : null;
        }

        public void LookAt(Vector3 target)
        {
            // Calculate the yaw
            {
                var cameraDirection = Vector3.forward;

                var targetDirection = (targetCamLocation - target).normalized;
                targetDirection.y = 0;
                targetDirection.Normalize();

                yaw = Mathf.Acos(Vector3.Dot(cameraDirection, targetDirection)) * Mathf.Rad2Deg;
                var cross = Vector3.Cross(cameraDirection, targetDirection);
                if (cross.y < 0)
                {
                    yaw = -yaw;
                }
            }
            
            // Calculate the pitch
            {
                var v1 = (target - targetCamLocation).normalized;
                var v2 = v1;
                v2.y = 0;
                v2.Normalize();
                
                pitch = -Mathf.Acos(Vector3.Dot(v1, v2)) * Mathf.Rad2Deg;
                if (v1.y > 0)
                {
                    pitch = -pitch;
                }
            }
            
            renderStateInvalidated = true;
        } 
        
        
        protected class FrameTime
        {
            private double lastUpdateTimestamp = 0;

            public float DeltaTime
            {
                get
                {
                    consumed = true;
                    return deltaTime;
                }
                set
                {
                    Debug.Assert(consumed);
                    consumed = false;
                    deltaTime = value;
                }
            }
            private float deltaTime = 0;
            public bool SkipNextFrameTime { get; set; }= false;
            private bool consumed = true;

            public void Tick(double timeSinceStartup)
            {
                double currentTime = timeSinceStartup;

                if (lastUpdateTimestamp > 0)
                {
                    deltaTime = (float)(currentTime - lastUpdateTimestamp);
                    deltaTime = Mathf.Min(0.066f, deltaTime);
                }

                if (SkipNextFrameTime)
                {
                    SkipNextFrameTime = false;
                    deltaTime = 0;
                }

                lastUpdateTimestamp = currentTime;
            }
        }

        public void ResetFrameTimer()
        {
            frameTime.SkipNextFrameTime = true;
        }

        public float AnglePerPixelX { get; set; } = 0.4f;
        public float AnglePerPixelY { get; set; } = 0.4f;
        public float PivotDistance = 10; 

        public float FOV
        {
            get => renderer != null ? renderer.Camera.FOV : 0;
        }

        public float AspectRatio
        {
            get => renderer != null ? renderer.Camera.AspectRatio : 1;
        }

        public SxViewportWidget()
        {
            ShowFocusHighlight = true;

            renderer = new SxRenderer();
            renderer.SetClearState(true, true, Color.white);

            ResetCamera(true);
            
            PivotDistance = targetCamLocation.magnitude;
            
            UpdateCamera();

            World = new SxWorld();
        }
        
        public void Release()
        {
            if (renderer != null)
            {
                renderer.Release();
            }
        }

        public void ResetCamera(bool immediate)
        {
            SetCameraLocation(new Vector3(6, 6, -6), immediate);
            LookAt(Vector3.zero);
            UpdateCamera();
        }
        
        public void SetCameraLocation(Vector3 location, bool immediate)
        {
            targetCamLocation = location;
            if (immediate)
            {
                renderer.Camera.Location = location;
            }

            renderStateInvalidated = true;
        }

        public void SetClearState(bool clearDepth, bool clearColor, Color color)
        {
            renderer.SetClearState(clearDepth, clearColor, color);
        }

        public override bool CanAcquireFocus()
        {
            return true;
        }

        public override bool RequiresInputEveryFrame() { return true; }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer uiRenderer)
        {
            var guiState = new GUIState(uiRenderer);
            var bounds = new Rect(Vector2.zero, WidgetBounds.size);

            if (IsPaintEvent(uiSystem) || RenderEveryFrame)
            {
                uiRenderer.DrawTexture(bounds, renderer.Texture);
            }
            
            guiState.Restore();
        }
        
        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);
            frameTime.Tick(uiSystem.Platform.timeSinceStartup);
            UpdateCamera();
            World.Tick(renderer.CreateRenderContext(), frameTime.DeltaTime);

            if (renderStateInvalidated || IsCameraMoving() || RenderEveryFrame || renderer.Texture == null)
            {
                RenderTexture();
                renderStateInvalidated = false;
            }
        }

        public void Invalidate()
        {
            renderStateInvalidated = true;
        }

        public void RenderTexture()
        {
            renderer.Render(WidgetBounds.size, World);
            lastRenderViewMatrix = Camera.ViewMatrix;
        }

        protected virtual void UpdateCamera()
        {
            var rotPitch = Quaternion.AngleAxis(pitch, Vector3.right);
            var rotYaw = Quaternion.AngleAxis(yaw, Vector3.up);
            renderer.Camera.Rotation = rotYaw * rotPitch;

            float elasticPower = 12.0f;
            float t = frameTime.DeltaTime * elasticPower;
            var currentCamLocation = renderer.Camera.Location;
            currentCamLocation = Vector3.Lerp(currentCamLocation, targetCamLocation, t);
            renderer.Camera.Location = currentCamLocation;
        }
        
        public void FocusCameraOnPoints(Vector3[] points, float radius)
        {
            var rotation = Quaternion.Inverse(Camera.Rotation);
            var sum = Vector3.zero;
            foreach (var point in points)
            {
                sum += point;
            }

            var center = sum / points.Length;

            var bounds = new Bounds();
            for (var i = 0; i < points.Length; i++)
            {
                var point = points[i];
                var p = rotation * (point - center);
                if (i == 0)
                {
                    bounds.SetMinMax(p, p);
                }
                else
                {
                    bounds.Encapsulate(p);
                }
            }

            float distanceV, distanceH;
            {
                var frustumHeight = bounds.extents.y * 2 + radius * 4;
                distanceV = frustumHeight * 0.5f / Mathf.Tan(FOV * 0.5f * Mathf.Deg2Rad) + bounds.extents.z;
            }
            {
                var frustumWidth = bounds.extents.x * 2 + radius * 4;
                var frustumHeight = frustumWidth / AspectRatio;
                distanceH = frustumHeight * 0.5f / Mathf.Tan(FOV * 0.5f * Mathf.Deg2Rad) + bounds.extents.z;
            }
            var distance = Mathf.Max(distanceV, distanceH);
            var offset = Camera.Rotation * (Vector3.forward * distance * 1.1f);
            var target = center + offset;
            SetCameraLocation(target, false);
            PivotDistance = (center - target).magnitude;
        }

        private bool keyStrafeLeft = false;
        private bool keyStrafeRight = false;
        private bool keyMoveForward = false;
        private bool keyMoveBackward = false;
        private bool keyMoveUp = false;
        private bool keyMoveDown = false;
        private bool keyOrbit = false;

        public bool IsCameraMoving()
        {
            var moveKeyPressed = keyStrafeLeft || keyStrafeRight || keyMoveForward || keyMoveBackward || keyMoveUp || keyMoveDown || keyOrbit;
            if (moveKeyPressed) return true;
            
            // Check if the cam is lagging behind the target location
            var distance = (targetCamLocation - renderer.Camera.Location).magnitude;
            return distance > 0.01f;
        }

        public bool RequiresRepaint()
        {
            return IsCameraMoving();
        }
        
        public override void OnFocus()
        {

        }

        public override void LostFocus()
        {
            keyStrafeLeft = false;
            keyStrafeRight = false;
            keyMoveForward = false;
            keyMoveBackward = false;
            keyMoveUp = false;
            keyMoveDown = false;
            keyOrbit = false;
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);

            bool isFocused = (uiSystem != null) ? uiSystem.FocusedWidget == this as IWidget : false;
            if (e.isKey)
            {
                if (e.type == EventType.KeyDown)
                {
                    if (e.keyCode == KeyCode.A) keyStrafeLeft = true;
                    if (e.keyCode == KeyCode.D) keyStrafeRight = true;
                    if (e.keyCode == KeyCode.W) keyMoveForward = true;
                    if (e.keyCode == KeyCode.S) keyMoveBackward = true;
                    if (e.keyCode == KeyCode.E) keyMoveUp = true;
                    if (e.keyCode == KeyCode.Q) keyMoveDown = true;
                }
                else if (e.type == EventType.KeyUp)
                {
                    if (e.keyCode == KeyCode.A) keyStrafeLeft = false;
                    if (e.keyCode == KeyCode.D) keyStrafeRight = false;
                    if (e.keyCode == KeyCode.W) keyMoveForward = false;
                    if (e.keyCode == KeyCode.S) keyMoveBackward = false;
                    if (e.keyCode == KeyCode.E) keyMoveUp = false;
                    if (e.keyCode == KeyCode.Q) keyMoveDown = false;
                }
            }

            keyOrbit = e.alt;

            if (e.button == 0 && keyOrbit)
            {
                if (e.type == EventType.MouseDrag)
                {
                    var direction = Camera.Rotation * -Vector3.forward;
                    var pivot = targetCamLocation + direction * PivotDistance;
                    var pivotToCam = targetCamLocation - pivot;
                    var newPivotToCam = Quaternion.AngleAxis(e.delta.x * OrbitAnglePerPixel, Vector3.up) * pivotToCam;

                    {
                        var pitchRotAxis = Vector3.Cross(newPivotToCam.normalized, Vector3.up);
                        var newYawPivotToCam = Quaternion.AngleAxis(e.delta.y * OrbitAnglePerPixel, pitchRotAxis) * newPivotToCam;
                        var dot = Vector3.Dot(newYawPivotToCam.normalized, Vector3.up);
                        if (1 - Mathf.Abs(dot) > 1e-3f)
                        {
                            newPivotToCam = newYawPivotToCam;
                        }
                    }

                    var newCamLocation = pivot + newPivotToCam;
                    SetCameraLocation(newCamLocation, true);
                    LookAt(pivot);
                    UpdateCamera();

                    renderStateInvalidated = true;
                }
            }

            if (e.type == EventType.ScrollWheel)
            {
                var direction = Camera.Rotation * -Vector3.forward;
                var distance = ZoomPerScrollUnit * e.delta.y * -1;
                var newCamLocation = targetCamLocation + direction * distance;
                PivotDistance -= distance;
                PivotDistance = Mathf.Max(1, PivotDistance);
                SetCameraLocation(newCamLocation, false);

                renderStateInvalidated = true;
            }
            
            
            if (e.button == 1)
            {
                if (e.type == EventType.MouseDrag)
                {
                    pitch = Mathf.Clamp(pitch - AnglePerPixelX * e.delta.y, -90, 90);
                    yaw = yaw + AnglePerPixelY * e.delta.x;
                    UpdateCamera();
                    
                    renderStateInvalidated = true;
                }

                float strafeDirection = 0;
                float forwardDirection = 0;
                float verticalDirection = 0;
                if (keyStrafeLeft) strafeDirection = 1;
                if (keyStrafeRight) strafeDirection = -1;
                if (keyMoveForward) forwardDirection = 1;
                if (keyMoveBackward) forwardDirection = -1;
                if (keyMoveUp) verticalDirection = 1;
                if (keyMoveDown) verticalDirection = -1;

                var accumulatedMoveDist = Vector3.zero;
                
                float deltaTime = frameTime.DeltaTime;
                var directionalMoveDist = deltaTime * MoveSpeed;
                if (strafeDirection != 0)
                {
                    var right = Quaternion.AngleAxis(yaw, Vector3.up) * Vector3.right;
                    accumulatedMoveDist += right * (strafeDirection * directionalMoveDist);
                }

                if (forwardDirection != 0)
                {
                    var forward = renderer.Camera.Rotation * -Vector3.forward;
                    accumulatedMoveDist += forward * (forwardDirection * directionalMoveDist);
                }

                if (verticalDirection != 0)
                {
                    accumulatedMoveDist += Vector3.up * (verticalDirection * directionalMoveDist);
                }

                var moveDistance = accumulatedMoveDist.magnitude;
                if (moveDistance > 0)
                {
                    if (moveDistance > directionalMoveDist)
                    {
                        accumulatedMoveDist = accumulatedMoveDist.normalized * directionalMoveDist;
                    }

                    targetCamLocation += accumulatedMoveDist;
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Window\HighlightWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DMathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.UI.Widgets
{
    public class HighlightWidget : WidgetBase
    {
        public IWidget Widget;
        public object ObjectOfInterest;
        public Color HighlightColor = Color.red;
        public float HighlightThickness = 3.0f;
        public float HighlightTime = 1.0f;
        double lastUpdateTime = 0;

        float remainingTime = 0;
        Texture2D lineTexture;
        

        public HighlightWidget()
        { 
            lastUpdateTime = 0;
        }

        public HighlightWidget SetContent(IWidget widget)
        {
            this.Widget = widget;
            return this;
        }

        public HighlightWidget SetHighlightColor(Color highlightColor)
        {
            this.HighlightColor = highlightColor;
            return this;
        }

        public HighlightWidget SetHighlightThickness(float highlightThickness)
        {
            this.HighlightThickness = highlightThickness;
            return this;
        }

        public HighlightWidget SetHighlightTime(float highlightTime)
        {
            this.HighlightTime = highlightTime;
            return this;
        }

        public HighlightWidget SetObjectOfInterest(object objectOfInterest)
        {
            this.ObjectOfInterest = objectOfInterest;
            return this;
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (lineTexture == null)
            {
                lineTexture = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_WHITE_16x) as Texture2D;
            }

            if (Widget != null)
            {
                WidgetUtils.DrawWidgetGroup(uiSystem, renderer, Widget);
            }

            if (remainingTime > 0 && IsPaintEvent(uiSystem))
            {
                var bounds = new Rect(Vector2.zero, WidgetBounds.size);
                bounds = DMathUtils.ExpandRect(bounds, -HighlightThickness * 0.5f);
                float intensity = Mathf.Sin(Mathf.PI * remainingTime * 2);
                intensity = Mathf.Abs(intensity);
                var color = HighlightColor;
                color.a *= intensity;
                WidgetUtils.DrawWidgetFocusHighlight(renderer, bounds, color, HighlightThickness, lineTexture);
            }
        }

        public void Activate(UISystem uiSystem)
        {
            remainingTime = HighlightTime;
            lastUpdateTime = uiSystem.Platform.timeSinceStartup;
        }

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            if (remainingTime > 0)
            {
                double currentTime = uiSystem.Platform.timeSinceStartup;
                float deltaTime = (float)(currentTime - lastUpdateTime);

                remainingTime -= deltaTime;
                remainingTime = Mathf.Max(0, remainingTime);
                lastUpdateTime = currentTime;
            }

            if (Widget != null)
            {
                var contentBounds = new Rect(Vector2.zero, WidgetBounds.size);
                Widget.UpdateWidget(uiSystem, contentBounds);
            }

        }

        public override bool IsCompositeWidget()
        {
            return true;
        }

        public override IWidget[] GetChildWidgets()
        {
            return Widget != null ? new[] { Widget } : null;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Window\RuntimeWindow.cs:
 namespace DungeonArchitect.UI.Windows
{
    /*
    public class RuntimeUIWindow<TImpl> : IUIWindow<TImpl> where TImpl : IUIWindowImpl
    {
        public TImpl Impl { get; private set; }
    }
    */
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Window\ToolbarWidget.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.UI.Widgets
{
    public class ToolbarWidget : WidgetBase
    {
        public float ButtonSize = 20;
        public float Padding = 0;
        public Color Background = new Color(0, 0, 0, 0.25f);
        public delegate void OnButtonPressed(UISystem uiSystem, string id);
        public event OnButtonPressed ButtonPressed;
        public List<ButtonInfo> buttons = new List<ButtonInfo>();

        public class ButtonInfo
        {
            public string ButtonId;
            public string IconId;
            public Rect Bounds;
        }
        GUIStyle buttonStyle;

        public override void UpdateWidget(UISystem uiSystem, Rect bounds)
        {
            base.UpdateWidget(uiSystem, bounds);

            var size = new Vector2(
                Padding * 2 + buttons.Count * ButtonSize,
                Padding * 2 + ButtonSize);
            WidgetBounds = new Rect(WidgetBounds.position, size);
            UpdateButtonBounds();
        }

        protected override void DrawImpl(UISystem uiSystem, UIRenderer renderer)
        {
            if (buttonStyle == null)
            {
                var skin = renderer.GetResource<GUISkin>(UIResourceLookup.SKIN_TOOLBAR_BUTTONS) as GUISkin;
                buttonStyle = skin.button;
            }
            if (buttonStyle == null)
            {
                buttonStyle = renderer.StyleManager.GetToolbarButtonStyle();
            }

            if (IsPaintEvent(uiSystem))
            {
                var toolbarBounds = WidgetBounds;
                renderer.DrawRect(toolbarBounds, Background);
            }

            foreach (var button in buttons)
            {
                var icon = renderer.GetResource<Texture>(button.IconId) as Texture;
                if (renderer.Button(button.Bounds, new GUIContent(icon), buttonStyle))
                {
                    if (ButtonPressed != null)
                    {
                        ButtonPressed.Invoke(uiSystem, button.ButtonId);
                    }
                }
            }
        }

        public void AddButton(string buttonId, string iconId)
        {
            var button = new ButtonInfo();
            button.ButtonId = buttonId;
            button.IconId = iconId;
            buttons.Add(button);
        }

        void UpdateButtonBounds()
        {
            float x = Padding;
            float y = Padding;
            foreach (var button in buttons)
            {
                button.Bounds = new Rect(x, y, ButtonSize, ButtonSize);
                x += ButtonSize;
            }
        }

        public ToolbarWidget SetBackground(Color background)
        {
            this.Background = background;
            return this;
        }

        public ToolbarWidget SetButtonSize(int buttonSize)
        {
            this.ButtonSize = buttonSize;
            return this;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\Window\Window.cs:
 

using System;
using UnityEngine;

namespace DungeonArchitect.UI.Windows
{
    public delegate void UIWindowRepaintDelegate();
    
    public interface IUIWindowImpl
    {
        void OnEnable();
        void OnDisable();
        void OnDestroy();
        
        void Awake();
        void Update();
        
        void CreateGUI();
        void OnGUI();
        void OnInspectorUpdate();
        void Repaint();
        
        Vector4 position { get; }
        string titleContent { get; set; }
        bool wantsMouseMove { get; set; }

        UIWindowRepaintDelegate OnRepaint { get; }
    }

    public interface IUIWindow<out TImpl> where TImpl : IUIWindowImpl
    {
        TImpl Impl { get; }

        void Repaint();
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionCloneGridFlow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionCloneGridFlow : LaunchPadActionBase
    {
        string templatePath;
        bool resourcePath;
        public LaunchPadActionCloneGridFlow(string templatePath, bool resourcePath)
        {
            this.templatePath = templatePath;
            this.resourcePath = resourcePath;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_gridflow_new");
        }

        public override string GetText()
        {
            return "Clone Grid\r\nFlow Graph";
        }

        public override void Execute()
        {
            string targetPath;
            if (CloneAsset(templatePath, resourcePath, out targetPath, "Create a Grid Flow Graph from Template"))
            {
                PingAsset(targetPath);
                new LaunchPadActionOpenGridFlow(targetPath, false).Execute();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionCloneInfinityScene.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Graphs;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionCloneInfinityScene : LaunchPadActionBase
    {
        string templatePath;
        bool resourcePath;
        public LaunchPadActionCloneInfinityScene(string templatePath, bool resourcePath)
        {
            this.templatePath = templatePath;
            this.resourcePath = resourcePath;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/create_scene");
        }

        public override string GetText()
        {
            return "Clone Scene";
        }

        protected virtual bool ShouldRebuildDungeon() { return false; }

        public override void Execute()
        {
            if (!EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo())
            {
                Debug.Log("Bailing out of clone");
                return;
            }

            string targetPath;
            if (CloneAsset(templatePath, resourcePath, out targetPath, "Create a Scene from Template"))
            {
                PingAsset(targetPath);
                EditorSceneManager.OpenScene(targetPath);

                var dungeons = GameObject.FindObjectsOfType<InfinityDungeon>();

                var destFileInfo = new System.IO.FileInfo(targetPath);
                var destFilename = destFileInfo.Name;
                var destFolder = targetPath.Substring(0, targetPath.Length - destFilename.Length);

                foreach (var dungeon in dungeons)
                {
                    var clonedThemes = new List<Graph>();
                    foreach (var theme in dungeon.dungeonThemes)
                    {
                        // Clone the themes
                        string destThemePath;
                        if (CloneTemplateReferencedAsset(theme, destFolder, out destThemePath))
                        {
                            var clonedTheme = AssetDatabase.LoadAssetAtPath<Graph>(destThemePath);
                            clonedThemes.Add(clonedTheme);
                        }
                        else
                        {
                            Debug.Log("Failed to copy referenced theme files while cloning the scene");
                        }
                    }

                    dungeon.dungeonThemes.Clear();
                    dungeon.dungeonThemes.AddRange(clonedThemes);
                    EditorUtility.SetDirty(dungeon);

                    if (ShouldRebuildDungeon())
                    {
                        dungeon.BuildDungeon();
                    }
                }
                if (dungeons.Length > 0)
                {
                    Selection.activeGameObject = dungeons[0].gameObject;
                }

                var currentScene = SceneManager.GetActiveScene();
                EditorSceneManager.MarkSceneDirty(currentScene);
                EditorSceneManager.SaveScene(currentScene);

                // Ping the cloned scene asset
                {
                    Object sceneAsset = AssetDatabase.LoadAssetAtPath<Object>(targetPath);
                    EditorGUIUtility.PingObject(sceneAsset);
                }

            }
        }
    }

    public class LaunchPadActionCloneInfinitySceneAndBuild : LaunchPadActionCloneInfinityScene
    {
        public LaunchPadActionCloneInfinitySceneAndBuild(string templatePath, bool resourcePath) : base(templatePath, resourcePath) { }
        protected override bool ShouldRebuildDungeon() { return true; }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionCloneScene.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Builders.Snap;
using DungeonArchitect.Grammar;
using DungeonArchitect.Graphs;
using System.Collections.Generic;
using DungeonArchitect.Builders.SnapGridFlow;
using DungeonArchitect.Flow.Impl.GridFlow;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionCloneScene : LaunchPadActionBase
    {
        string templatePath;
        bool resourcePath;
        public LaunchPadActionCloneScene(string templatePath, bool resourcePath)
        {
            this.templatePath = templatePath;
            this.resourcePath = resourcePath;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/create_scene");
        }

        public override string GetText()
        {
            return "Clone Scene";
        }

        protected virtual bool ShouldRebuildDungeon() { return false; }

        public override void Execute()
        {
            var deferredCommands = new List<ILaunchPadAction>();

            if (!EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo())
            {
                Debug.Log("Bailing out of clone");
                return;
            }

            string targetPath;
            if (CloneAsset(templatePath, resourcePath, out targetPath, "Create a Scene from Template"))
            {
                PingAsset(targetPath);
                EditorSceneManager.OpenScene(targetPath);
                {
                    var dungeons = GameObject.FindObjectsOfType<Dungeon>();

                    var destFileInfo = new System.IO.FileInfo(targetPath);
                    var destFilename = destFileInfo.Name;
                    var destFolder = targetPath.Substring(0, targetPath.Length - destFilename.Length);

                    foreach (var dungeon in dungeons)
                    {
                        var clonedThemes = new List<Graph>();
                        foreach (var theme in dungeon.dungeonThemes)
                        {
                            // Clone the themes
                            string destThemePath;
                            if (CloneTemplateReferencedAsset(theme, destFolder, out destThemePath))
                            {
                                var clonedTheme = AssetDatabase.LoadAssetAtPath<Graph>(destThemePath);
                                clonedThemes.Add(clonedTheme);
                            }
                            else
                            {
                                Debug.Log("Failed to copy referenced theme files while cloning the scene");
                            }
                        }
                        dungeon.dungeonThemes.Clear();
                        dungeon.dungeonThemes.AddRange(clonedThemes);
                        EditorUtility.SetDirty(dungeon);

                        if (clonedThemes.Count > 0 && clonedThemes[0] != null)
                        {
                            var themePath = AssetDatabase.GetAssetPath(clonedThemes[0]);
                            deferredCommands.Add(new LaunchPadActionOpenTheme(themePath));
                        }

                        // Snap flow asset
                        {
                            var snapConfig = dungeon.gameObject.GetComponent<SnapConfig>();
                            if (snapConfig != null && snapConfig.snapFlow != null)
                            {
                                string clonedFlowAssetPath;
                                if (CloneTemplateReferencedAsset(snapConfig.snapFlow, destFolder, out clonedFlowAssetPath))
                                {
                                    var clonedFlowAsset = AssetDatabase.LoadAssetAtPath<SnapFlowAsset>(clonedFlowAssetPath);
                                    snapConfig.snapFlow = clonedFlowAsset;

                                    if (clonedFlowAsset != null)
                                    {
                                        var graphPath = AssetDatabase.GetAssetPath(clonedFlowAsset);
                                        deferredCommands.Add(new LaunchPadActionOpenSnapFlow(graphPath));
                                    }
                                    
                                    EditorUtility.SetDirty(snapConfig);
                                }
                                else
                                {
                                    Debug.Log("Failed to copy snap flow asset while cloning the scene");
                                }
                            }
                        }

                        // Grid flow asset
                        {
                            var config = dungeon.gameObject.GetComponent<GridFlowDungeonConfig>();
                            if (config != null && config.flowAsset != null)
                            {
                                string clonedFlowAssetPath;
                                if (CloneTemplateReferencedAsset(config.flowAsset, destFolder, out clonedFlowAssetPath))
                                {
                                    var clonedFlowAsset = AssetDatabase.LoadAssetAtPath<GridFlowAsset>(clonedFlowAssetPath);
                                    config.flowAsset = clonedFlowAsset;

                                    if (clonedFlowAsset != null)
                                    {
                                        var graphPath = AssetDatabase.GetAssetPath(clonedFlowAsset);
                                        deferredCommands.Add(new LaunchPadActionOpenGridFlow(graphPath));
                                    }
                                    
                                    EditorUtility.SetDirty(config);
                                }
                                else
                                {
                                    Debug.Log("Failed to copy grid flow asset while cloning the scene");
                                }
                            }
                        }
                        
                        // Snap Grid Flow asset
                        {
                            var config = dungeon.gameObject.GetComponent<SnapGridFlowConfig>();
                            if (config != null && config.flowGraph != null && config.moduleDatabase != null)
                            {
                                SnapGridFlowModuleDatabase clonedModuleDB = null;
                                string clonedModuleDBPath;
                                if (CloneTemplateReferencedAsset(config.moduleDatabase, destFolder, out clonedModuleDBPath))
                                {
                                    clonedModuleDB = AssetDatabase.LoadAssetAtPath<SnapGridFlowModuleDatabase>(clonedModuleDBPath);
                                    config.moduleDatabase = clonedModuleDB;
                                }
                                else
                                {
                                    Debug.Log("Failed to copy snap grid flow module database while cloning the scene");
                                }
                                
                                string clonedFlowAssetPath;
                                if (CloneTemplateReferencedAsset(config.flowGraph, destFolder, out clonedFlowAssetPath))
                                {
                                    var clonedFlowAsset = AssetDatabase.LoadAssetAtPath<SnapGridFlowAsset>(clonedFlowAssetPath);
                                    config.flowGraph = clonedFlowAsset;

                                    if (clonedFlowAsset != null)
                                    {
                                        var graphPath = AssetDatabase.GetAssetPath(clonedFlowAsset);
                                        deferredCommands.Add(new LaunchPadActionOpenSnapGridFlow(graphPath, false, clonedModuleDB));
                                    }
                                }
                                else
                                {
                                    Debug.Log("Failed to copy snap grid flow graph asset while cloning the scene");
                                }

                                
                                EditorUtility.SetDirty(config);
                            }
                        }

                        if (ShouldRebuildDungeon())
                        {
                            dungeon.Build(new EditorDungeonSceneObjectInstantiator());
                        }
                    }
                    if (dungeons.Length > 0)
                    {
                        Selection.activeGameObject = dungeons[0].gameObject;
                    }
                    var currentScene = SceneManager.GetActiveScene();
                    EditorSceneManager.MarkSceneDirty(currentScene);
                    EditorSceneManager.SaveScene(currentScene);

                    // Ping the cloned scene asset
                    {
                        Object sceneAsset = AssetDatabase.LoadAssetAtPath<Object>(targetPath);
                        EditorGUIUtility.PingObject(sceneAsset);
                    }

                    foreach (var command in deferredCommands)
                    {
                        command.Execute();
                    }
                }
            }
        }
    }

    public class LaunchPadActionCloneSceneAndBuild : LaunchPadActionCloneScene
    {
        public LaunchPadActionCloneSceneAndBuild(string templatePath, bool resourcePath) : base(templatePath, resourcePath) { }
        protected override bool ShouldRebuildDungeon() { return true; }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionCloneSnapFlow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionCloneSnapFlow : LaunchPadActionBase
    {
        string templatePath;
        bool resourcePath;
        public LaunchPadActionCloneSnapFlow(string templatePath, bool resourcePath)
        {
            this.templatePath = templatePath;
            this.resourcePath = resourcePath;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_graph_new");
        }

        public override string GetText()
        {
            return "Clone Snap\r\nFlow Graph";
        }

        public override void Execute()
        {
            string targetPath;
            if (CloneAsset(templatePath, resourcePath, out targetPath, "Create a Snap Flow graph from template"))
            {
                PingAsset(targetPath);
                new LaunchPadActionOpenSnapFlow(targetPath).Execute();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionCloneSnapGridFlow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionCloneSnapGridFlow : LaunchPadActionBase
    {
        string templatePath;
        bool resourcePath;
        public LaunchPadActionCloneSnapGridFlow(string templatePath, bool resourcePath)
        {
            this.templatePath = templatePath;
            this.resourcePath = resourcePath;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_gridflow_new");
        }

        public override string GetText()
        {
            return "Clone Snap\r\nGrid Flow";
        }

        public override void Execute()
        {
            string targetPath;
            if (CloneAsset(templatePath, resourcePath, out targetPath, "Create a Snap Grid Flow Graph from Template"))
            {
                PingAsset(targetPath);
                new LaunchPadActionOpenSnapGridFlow(targetPath, false).Execute();
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionCloneTheme.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionCloneTheme : LaunchPadActionBase
    {
        string templatePath;
        bool resourcePath;
        public LaunchPadActionCloneTheme(string templatePath, bool resourcePath)
        {
            this.templatePath = templatePath;
            this.resourcePath = resourcePath;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_theme_new");
        }

        public override string GetText()
        {
            return "Clone Theme";
        }

        public override void Execute()
        {

            string targetPath;
            if (CloneAsset(templatePath, resourcePath, out targetPath, "Create a Theme from Template"))
            {
                PingAsset(targetPath);
                new LaunchPadActionOpenTheme(targetPath).Execute();
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionDocumentation.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionDocumentation : LaunchPadActionBase
    {
        string path;
        public LaunchPadActionDocumentation(string path)
        {
            this.path = path;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_docs");
        }

        public override string GetText()
        {
            return "Open Docs";
        }

        public override void Execute()
        {
            OpenLink(path);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionOpenFolder.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionOpenFolder : LaunchPadActionBase
    {
        string path;
        public LaunchPadActionOpenFolder(string path)
        {
            this.path = path;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_open_folder");
        }

        public override string GetText()
        {
            return "Open Folder";
        }

        public override void Execute()
        {
            PingAsset(path);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionOpenGridFlow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Editors.Flow.Impl;
using DungeonArchitect.Flow.Impl.GridFlow;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionOpenGridFlow : LaunchPadActionBase
    {
        string path;
        bool readOnly;

        public LaunchPadActionOpenGridFlow(string path)
            : this(path, false)
        {
        }

        public LaunchPadActionOpenGridFlow(string path, bool readOnly)
        {
            this.path = path;
            this.readOnly = readOnly;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_gridflow");
        }

        public override string GetText()
        {
            return "Open Grid\r\nFlow Graph";
        }

        public override void Execute()
        {
            var flowAsset = AssetDatabase.LoadAssetAtPath<GridFlowAsset>(path);
            if (flowAsset != null)
            {
                var window = EditorWindow.GetWindow<GridFlowEditorWindow>();
                if (window != null)
                {
                    window.Init(flowAsset);
                    window.HandleExecuteButtonPressed();
                    window.SetReadOnly(readOnly);
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionOpenScene.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEditor.SceneManagement;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionOpenScene : LaunchPadActionBase
    {
        string path;
        public LaunchPadActionOpenScene(string path)
        {
            this.path = path;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/unity_logo");
        }

        public override string GetText()
        {
            return "Open Scene";
        }

        public override void Execute()
        {
            EditorSceneManager.OpenScene(path);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionOpenSnapFlow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Editors.SnapFlow;
using DungeonArchitect.Grammar;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionOpenSnapFlow : LaunchPadActionBase
    {
        string path;
        public LaunchPadActionOpenSnapFlow(string path)
        {
            this.path = path;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_graph");
        }

        public override string GetText()
        {
            return "Open Snap\r\nFlow Graph";
        }

        public override void Execute()
        {
            var flowAsset = AssetDatabase.LoadAssetAtPath<SnapFlowAsset>(path);
            if (flowAsset != null)
            {
                var window = EditorWindow.GetWindow<SnapEditorWindow>();
                if (window != null)
                {
                    window.Init(flowAsset);
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionOpenSnapGridFlow.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Editors.Flow.Impl;
using DungeonArchitect.Flow.Impl.SnapGridFlow;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionOpenSnapGridFlow : LaunchPadActionBase
    {
        string path;
        bool readOnly;
        SnapGridFlowModuleDatabase moduleDatabase;

        public LaunchPadActionOpenSnapGridFlow(string path)
            : this(path, false, null)
        {
        }

        public LaunchPadActionOpenSnapGridFlow(string path, bool readOnly)
            : this(path, readOnly, null)
        {
            
        }

        public LaunchPadActionOpenSnapGridFlow(string path, bool readOnly, SnapGridFlowModuleDatabase moduleDatabase)
        {
            this.path = path;
            this.readOnly = readOnly;
            this.moduleDatabase = moduleDatabase;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_gridflow");
        }

        public override string GetText()
        {
            return "Open Snap\r\nGrid Flow";
        }

        public override void Execute()
        {
            var flowAsset = AssetDatabase.LoadAssetAtPath<SnapGridFlowAsset>(path);
            if (flowAsset != null)
            {
                var window = EditorWindow.GetWindow<SnapGridFlowEditorWindow>();
                if (window != null)
                {
                    window.Init(flowAsset);
                    if (moduleDatabase != null)
                    {
                        window.SetModuleDatabase(moduleDatabase);
                    }
                    window.HandleExecuteButtonPressed();
                    window.SetReadOnly(readOnly);
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionOpenTheme.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Graphs;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionOpenTheme : LaunchPadActionBase
    {
        string path;
        public LaunchPadActionOpenTheme(string path)
        {
            this.path = path;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_theme");
        }

        public override string GetText()
        {
            return "Open Theme";
        }

        public override void Execute()
        {
            var graph = AssetDatabase.LoadAssetAtPath<Graph>(path);
            if (graph != null)
            {
                var window = EditorWindow.GetWindow<DungeonThemeEditorWindow>();
                if (window != null)
                {
                    window.Init(graph);
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Actions\Impl\LaunchPadActionVideo.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad.Actions.Impl
{
    public class LaunchPadActionVideo : LaunchPadActionBase
    {
        string path;
        public LaunchPadActionVideo(string path)
        {
            this.path = path;
        }

        public override Texture2D GetIcon()
        {
            return ScreenPageLoader.LoadImageAsset("icons/font_awesome/icon_video");
        }

        public override string GetText()
        {
            return "Watch Demo";
        }

        public override void Execute()
        {
            OpenLink(path);
        }

        public override bool IsValid()
        {
            if (path.Length == 0)
            {
                return false;
            }
            return true;
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Screens\PageLayouts\ScreenPageCardGrid.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad
{
    [System.Serializable]
    class DataCardEntry
    {
        public string title = "";
        public string desc = "";
        public string image = "";
        public string link = "";
        public string url = "";
    }

    [System.Serializable]
    class DataCategory
    {
        public string category = "";
        public DataCardEntry[] cards = new DataCardEntry[0];
    }

    [System.Serializable]
    class ScreenPageGridCardJsonData : ScreenPageJsonDataBase
    {
        public DataCategory[] categories = new DataCategory[0];
        public bool showCategories = false;
        public bool showDescription = true;
        public int heightOverride = 0;
        public string description = "";
    }

    public class ScreenPageCardGrid : ScreenPage
    {
        public override void Load(string json)
        {
            var jsonData = JsonUtility.FromJson<ScreenPageGridCardJsonData>(json);
            Title = jsonData.title;
            StackPanelWidget content = new StackPanelWidget(StackPanelOrientation.Vertical);

            foreach (var category in jsonData.categories)
            {
                if (category.cards == null) continue;

                var showDescription = jsonData.showDescription;
                var cellHeight = 220;

                if (jsonData.heightOverride > 0)
                {
                    cellHeight = jsonData.heightOverride;
                }

                var cards = new GridPanelWidget(GridPanelArrangementType.VerticalScroll)
                .SetPadding(10, 10)
                .SetCellSize(180, cellHeight);

                foreach (var entry in category.cards)
                {
                    var data = new LaunchPadCardWidgetData();
                    data.thumbnail = ScreenPageLoader.LoadImageAsset(entry.image);
                    data.title = entry.title;
                    data.description = entry.desc;
                    data.link = entry.link;
                    data.url = entry.url;
                    var card = new LaunchPadCardWidget(data, showDescription);
                    card.LinkClicked += Card_LinkClicked;
                    cards.AddWidget(card);
                }

                if (jsonData.showCategories)
                {
                    content.AddWidget(
                        new BorderWidget(
                            new LabelWidget(category.category)
                                .SetFontSize(18)
                                .SetColor(new Color(0.6f, 0.6f, 0.6f)))
                            .SetTransparent()
                            .SetPadding(10, 20, 5, 5)
                        , 0, true);
                }
                content.AddWidget(cards, 0, true);
            }

            var containsDescription = (jsonData.description != null && jsonData.description.Length > 0);
            if (!containsDescription)
            {
                Widget = content;
            }
            else
            {
                var descPaddingOut = 20;
                Widget = new StackPanelWidget(StackPanelOrientation.Vertical)
                    .AddWidget(
                        new BorderWidget(
                            new LabelWidget(jsonData.description)
                                .SetFontSize(16)
                                .SetColor(new Color(0.8f, 0.8f, 0.8f))
                                .SetWordWrap(true))
                            .SetPadding(descPaddingOut, 5, descPaddingOut, 5)
                            .SetTransparent()
                    , 0, true)
                    .AddWidget(content, 0, true);
            }
        }

        private void Card_LinkClicked(string path)
        {
            NotifyLinkClicked(path);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Screens\PageLayouts\ScreenPageDetails.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.Editors.LaunchPad.Actions;
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad
{
    [System.Serializable]
    class ScreenPageActionJsonData
    {
        public string type = "";
        public LaunchPadActionData data = new LaunchPadActionData();
    }


    [System.Serializable]
    class ScreenPageDetailJsonData : ScreenPageJsonDataBase
    {
        public string header = "";
        public string desc = "";
        public string image = "";
        public ScreenPageActionJsonData[] actions = new ScreenPageActionJsonData[0];
    }

    public class ScreenPageDetails : ScreenPage
    {
        public override void Load(string json)
        {
            var jsonData = JsonUtility.FromJson<ScreenPageDetailJsonData>(json);
            Title = jsonData.title;
            var image = ScreenPageLoader.LoadImageAsset(jsonData.image);
            if (image == null)
            {
                image = Texture2D.whiteTexture;
            }

            StackPanelWidget content = new StackPanelWidget(StackPanelOrientation.Vertical);
            content.AddWidget(
                new ImageWidget(image)
                .SetDrawMode(ImageWidgetDrawMode.Fit)
            , 0, true);

            content.AddWidget(
                new BorderWidget(
                    new LabelWidget(jsonData.header)
                        .SetFontSize(18)
                        .SetWordWrap(true)
                        .SetColor(new Color(0.85f, 0.85f, 0.85f))
                        .SetTextAlign(TextAnchor.MiddleCenter))
                    .SetTransparent()
                    .SetPadding(5, 5, 5, 5)
                , 0, true);

            content.AddWidget(
                new BorderWidget(
                    new LabelWidget(jsonData.desc)
                        .SetFontSize(14)
                        .SetWordWrap(true)
                        .SetColor(new Color(0.6f, 0.6f, 0.6f)))
                    .SetTransparent()
                    .SetPadding(10, 0, 10, 10)
                , 0, true);

            if (jsonData.actions.Length > 0)
            {
                var actions = new GridPanelWidget(GridPanelArrangementType.VerticalScroll);
                actions.SetAutoSize(true);
                foreach (var actionInfo in jsonData.actions)
                {
                    
                    try
                    {
                        LaunchPadActionType actionType = (LaunchPadActionType)System.Enum.Parse(typeof(LaunchPadActionType), actionInfo.type);
                        var action = LaunchPadActionFactory.Create(actionType, actionInfo.data);
                        if (action != null && action.IsValid())
                        {
                            var actionWidget = new LaunchPadActionWidget(actionType, action, actionInfo.data);
                            actions.AddWidget(actionWidget);
                        }
                    }
                    catch {}
                }

                content.AddWidget(actions, 0, true);
            }

            Widget = content;
        }

        private void OnActionLinkClicked(WidgetClickEvent clickEvent)
        {
            Debug.Log("Clicked");
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect_LaunchPad\Editor\Scripts\LaunchPad\Screens\PageLayouts\ScreenPageNews.cs:
 //\$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved \$//\n
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Editors.LaunchPad
{
    [System.Serializable]
    class ScreenPageNewsJsonData : ScreenPageJsonDataBase
    {
        public DataCardEntry featured = new DataCardEntry();
        public DataCardEntry[] cards = new DataCardEntry[0];
        public float featuredHeight = 0;
        public float thumbHeight = 0;
        public float cardHeight = 0;
    }

    public class ScreenPageNews : ScreenPage
    {
        IWidget BuildFeaturedWidget(ScreenPageNewsJsonData jsonData)
        {
            if (jsonData.featured == null) return new NullWidget();

            float featuredHeight = 300;
            if (jsonData.featuredHeight > 0)
            {
                featuredHeight = jsonData.featuredHeight;
            }

            var card = BuildCardWidget(jsonData.featured, 200);
            card.LinkClicked += Card_LinkClicked;

            var cards = new GridPanelWidget(GridPanelArrangementType.VerticalScroll)
                .SetPadding(10, 10)
                .SetCellSize(560, featuredHeight);

            cards.AddWidget(card);
            return cards;
        }

        LaunchPadCardWidget BuildCardWidget(DataCardEntry entry, float height)
        {
            var data = new LaunchPadCardWidgetData();
            data.thumbnail = ScreenPageLoader.LoadImageAsset(entry.image);
            data.title = entry.title;
            data.description = entry.desc;
            data.link = entry.link;
            data.url = entry.url;
            return
                new LaunchPadCardWidget(data, true)
                .SetThumbnailHeight(height);
        }

        IWidget BuildCardsWidget(ScreenPageNewsJsonData jsonData)
        {
            float cardHeight = 220;
            if (jsonData.cardHeight > 0)
            {
                cardHeight = jsonData.cardHeight;
            }

            float thumbHeight = 100;
            if (jsonData.thumbHeight > 0)
            {
                thumbHeight = jsonData.thumbHeight;
            }

            var cards = new GridPanelWidget(GridPanelArrangementType.VerticalScroll)
            .SetPadding(10, 10)
            .SetCellSize(180, cardHeight);

            foreach (var entry in jsonData.cards)
            {
                var card = BuildCardWidget(entry, thumbHeight);
                card.LinkClicked += Card_LinkClicked;
                cards.AddWidget(card);
            }
            return cards;
        }
        public override void Load(string json)
        {
            var jsonData = JsonUtility.FromJson<ScreenPageNewsJsonData>(json);
            Title = jsonData.title;


            var featured = BuildFeaturedWidget(jsonData);
            var cards = BuildCardsWidget(jsonData);

            StackPanelWidget content = new StackPanelWidget(StackPanelOrientation.Vertical);
            content.AddWidget(featured, 0, true);
            content.AddWidget(cards, 0, true);

            Widget = content;
        }

        private void Card_LinkClicked(string path)
        {
            NotifyLinkClicked(path);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\ExecGraphEditor\FlowExecGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Domains;
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.UI;

namespace DungeonArchitect.Editors.Flow
{
    public class FlowExecGraphEditor : GraphEditor
    {

        public IFlowDomain[] Domains = new IFlowDomain[0];

        public override void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            base.Init(graph, editorBounds, assetObject, uiSystem);
            EditorStyle.branding = "Execution Flow";
        }

        protected override GraphContextMenu CreateContextMenu()
        {
            return new FlowExecGraphContextMenu(this);
        }

        public override GraphSchema GetGraphSchema()
        {
            return new FlowExecGraphSchema();
        }

        protected override void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers)
        {
            nodeRenderers.RegisterNodeRenderer(typeof(FlowExecRuleGraphNode), new FlowExecRuleNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(FlowExecResultGraphNode), new FlowExecResultNodeRenderer());
            nodeRenderers.RegisterNodeRenderer(typeof(CommentNode), new CommentNodeRenderer(EditorStyle.commentTextColor));
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            return new StraightLineGraphLinkRenderer();
        }

        private FlowExecTask GetNodeHandler(GraphNode node)
        {
            if (node != null)
            {
                var ruleNode = node as FlowExecRuleGraphNode;
                if (ruleNode != null)
                {
                    return ruleNode.task;
                }
            }
            return null;
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {
            var menuContext = userdata as FlowExecGraphContextMenuUserData;

            if (menuContext != null)
            {
                if (menuContext.Action == FlowExecGraphEditorAction.CreateRuleNode)
                {
                    CreateExecRuleNode(lastMousePosition, menuContext.NodeHandlerType, e.uiSystem);
                }
                else if (menuContext.Action == FlowExecGraphEditorAction.CreateCommentNode)
                {
                    CreateCommentNode(lastMousePosition, e.uiSystem);
                }
            }
        }

        protected override string GetGraphNotInitializedMessage()
        {
            return "Graph not initialized";
        }

        void CreateExecRuleNode(Vector2 screenPos, System.Type nodeHandlerType, UISystem uiSystem)
        {
            if (nodeHandlerType == null)
            {
                return;
            }

            var nodeHandler = ScriptableObject.CreateInstance(nodeHandlerType) as FlowExecTask;
            if (nodeHandler != null)
            {
                nodeHandler.hideFlags = HideFlags.HideInHierarchy;
                uiSystem.Platform.AddObjectToAsset(nodeHandler, assetObject);

                var worldPos = camera.ScreenToWorld(screenPos);
                var execNode = CreateNode<FlowExecRuleGraphNode>(worldPos, uiSystem);
                execNode.task = nodeHandler;
                execNode.Position = worldPos;

                BringToFront(execNode);
                SelectNode(execNode, uiSystem);
            }
        }

        void CreateCommentNode(Vector2 screenPos, UISystem uiSystem)
        {
            var worldPos = camera.ScreenToWorld(screenPos);
            var commentNode = CreateNode<CommentNode>(worldPos, uiSystem);
            commentNode.Position = worldPos;
            commentNode.background = new Color(0.224f, 1.0f, 0.161f, 0.7f);
            BringToFront(commentNode);
            SelectNode(commentNode, uiSystem);
        }
    }


    public class FlowExecGraphSchema : GraphSchema
    {
        public override bool CanCreateLink(GraphPin output, GraphPin input, out string errorMessage)
        {
            errorMessage = "";
            if (output == null || input == null)
            {
                errorMessage = "Invalid connection";
                return false;
            }

            if (input.Node != null)
            {
                input = input.Node.InputPin;
            }

            var sourceNode = output.Node;
            var destNode = input.Node;

            if (sourceNode is FlowExecResultGraphNode)
            {
                errorMessage = "Not Allowed: Cannot connect from Result node";
                return false;
            }

            var graph = sourceNode.Graph;
            foreach (var link in graph.Links)
            {
                if (link.Input.Node == input.Node && link.Output.Node == output.Node)
                {
                    errorMessage = "Not Allowed: Already connected";
                    return false;
                }
            }

            return true;
        }

        public override bool CanDestroyNode(GraphNode node)
        {
            if (node is FlowExecResultGraphNode)
            {
                return false;
            }

            return true;
        }
    }

    public enum FlowExecGraphEditorAction
    {
        CreateCommentNode,
        CreateRuleNode
    }

    class FlowExecGraphContextMenuUserData
    {
        public FlowExecGraphContextMenuUserData(UISystem uiSystem, FlowExecGraphEditorAction action)
            : this(uiSystem, action, null)
        {
        }

        public FlowExecGraphContextMenuUserData(UISystem uiSystem, FlowExecGraphEditorAction action, System.Type nodeHandlerType)
        {
            this.uiSystem = uiSystem;
            this.Action = action;
            this.NodeHandlerType = nodeHandlerType;
        }

        public FlowExecGraphEditorAction Action { get; set; }
        public System.Type NodeHandlerType { get; set; }
        public UISystem uiSystem { get; set; }
    }

    class FlowExecGraphContextMenu : GraphContextMenu
    {
        private FlowExecGraphEditor host;
        
        struct MenuItemInfo
        {
            public MenuItemInfo(string title, float weight, System.Type handlerType)
            {
                this.title = title;
                this.weight = weight;
                this.handlerType = handlerType;
            }

            public string title;
            public float weight;
            public System.Type handlerType;
        }

        public FlowExecGraphContextMenu(FlowExecGraphEditor host)
        {
            this.host = host;
        }
        
        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
            var menu = uiSystem.Platform.CreateContextMenu();
            //var handlerTypes = GetNodeHandlerTypes();
            var supportedTasks = new List<System.Type>();
            foreach (var domain in host.Domains)
            {
                supportedTasks.AddRange(domain.SupportedTasks);
            }

            var items = new List<MenuItemInfo>();
            foreach (var taskType in supportedTasks)
            {
                var menuAttribute = FlowExecNodeInfoAttribute.GetHandlerAttribute(taskType);
                var weight = 0.0f;
                if (menuAttribute != null)
                {
                    var nodeTitle = menuAttribute.MenuPrefix + menuAttribute.Title;
                    weight = menuAttribute.Weight;
                    items.Add(new MenuItemInfo(nodeTitle, weight, taskType));
                }
            }
            items.Sort((a, b) => a.weight < b.weight ? -1 : 1);
            foreach (var item in items)
            {
                menu.AddItem(item.title, HandleContextMenu, new FlowExecGraphContextMenuUserData(uiSystem, FlowExecGraphEditorAction.CreateRuleNode, item.handlerType));
            }

            menu.AddSeparator("");
            menu.AddItem("Add Comment Node", HandleContextMenu, new FlowExecGraphContextMenuUserData(uiSystem, FlowExecGraphEditorAction.CreateCommentNode));
            menu.Show();
        }

        void HandleContextMenu(object action)
        {
            var item = action as FlowExecGraphContextMenuUserData;
            DispatchMenuItemEvent(action, BuildEvent(null, item.uiSystem));
        }

        System.Type[] GetNodeHandlerTypes()
        {
            var assembly = System.Reflection.Assembly.GetAssembly(typeof(FlowExecTask)); // Search the runtime module
            var handlers = from t in assembly.GetTypes()
                           where t.IsClass && t.IsSubclassOf(typeof(FlowExecTask))
                           select t;

            return handlers.ToArray();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\PreviewLayoutGraphEditor\FlowPreviewLayoutGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using DungeonArchitect.Graphs;
using DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Editors.Flow.Layout
{
    public delegate void OnGridFlowAbstractItemSelectionChanged(FlowItem item);

    public class FlowPreviewLayoutGraphEditor : GraphEditor
    {
        private Dictionary<DungeonUID, List<Rect>> itemScreenPositions = new Dictionary<DungeonUID, List<Rect>>();
        FlowItem selectedItem = null;

        public event OnGridFlowAbstractItemSelectionChanged ItemSelectionChanged;

        public override void Init(Graph graph, Rect editorBounds, UnityEngine.Object assetObject, UISystem uiSystem)
        {
            base.Init(graph, editorBounds, assetObject, uiSystem);
            EditorStyle.branding = "Result";
            selectedItem = null;
        }

        protected override GraphContextMenu CreateContextMenu()
        {
            return new DungeonGridFlowAbstractGraphContextMenu();
        }

        protected override void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers)
        {
            var abstractNodeRenderer = new FlowPreviewLayoutNodeRenderer();
            abstractNodeRenderer.FlowLayoutGraphItemRendered += OnGraphItemRendered;
            nodeRenderers.RegisterNodeRenderer(typeof(FlowLayoutToolGraph2DNode), abstractNodeRenderer);
            nodeRenderers.RegisterNodeRenderer(typeof(CommentNode), new CommentNodeRenderer(EditorStyle.commentTextColor));
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            var linkRenderer = new FlowPreviewLayoutLinkRenderer();
            linkRenderer.GridFlowLayoutGraphItemRendered += OnGraphItemRendered;
            return linkRenderer;
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {
            var action = (DungeonGridFlowAbstractGraphEditorAction)userdata;

            if (action == DungeonGridFlowAbstractGraphEditorAction.CreateCommentNode)
            {
                var mouseScreen = lastMousePosition;
                CreateCommentNode(mouseScreen, e.uiSystem);
            }
        }

        protected override string GetGraphNotInitializedMessage()
        {
            return "Graph not initialized";
        }

        private void OnGraphItemRendered(FlowItem item, Rect screenBounds)
        {
            if (!itemScreenPositions.ContainsKey(item.itemId))
            {
                itemScreenPositions[item.itemId] = new List<Rect>();
            }
            itemScreenPositions[item.itemId].Add(screenBounds);
        }

        IntVector2 GetNodeCoord(Vector3 coordF)
        {
            return new IntVector2(Mathf.RoundToInt(coordF.x), Mathf.RoundToInt(coordF.y));
        }

        public void SelectNodeAtCoord(IntVector2 nodeCoord, UISystem uiSystem)
        {
            FlowLayoutToolGraph2DNode target = null;
            foreach (var node in graph.Nodes)
            {
                var previewNode = node as FlowLayoutToolGraph2DNode;
                if (previewNode != null)
                {
                    var previewNodeCoord = GetNodeCoord(previewNode.LayoutNode.coord);
                    if (previewNodeCoord.Equals(nodeCoord))
                    {
                        target = previewNode;
                        break;
                    }
                }
            }

            if (target != null)
            {
                SelectNode(target, uiSystem);
            }
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);


            var buttonId = 0;
            if (e.type == EventType.MouseDown && e.button == buttonId)
            {
                // A button was pressed. Check if any of the items were clicked
                FlowItem newSelectedItem = null;
                var items = FlowLayoutToolGraph2DUtils.GetAllItems(graph as FlowLayoutToolGraph2D);
                foreach (var item in items)
                {
                    if (itemScreenPositions.ContainsKey(item.itemId))
                    {
                        var itemBoundsList = itemScreenPositions[item.itemId];
                        foreach (var itemBounds in itemBoundsList)
                        {
                            if (itemBounds.Contains(lastMousePosition))
                            {
                                newSelectedItem = item;
                                break;
                            }
                        }
                    }
                }

                if (selectedItem != newSelectedItem)
                {
                    SelectNodeItem(newSelectedItem);
                }
            }
        }

        public void SelectNodeItem(DungeonUID itemId)
        {
            if (itemId == DungeonUID.Empty)
            {
                SelectNodeItem(null);
                return;
            }

            var items = FlowLayoutToolGraph2DUtils.GetAllItems(graph as FlowLayoutToolGraph2D);
            foreach (var item in items)
            {
                if (item.itemId == itemId)
                {
                    SelectNodeItem(item);
                    break;
                }
            }
        }

        public void SelectNodeItem(FlowItem newSelectedItem)
        {
            if (selectedItem != newSelectedItem)
            {
                var oldSelectedItem = selectedItem;
                selectedItem = newSelectedItem;

                if (oldSelectedItem != null)
                {
                    oldSelectedItem.editorSelected = false;
                }

                if (newSelectedItem != null)
                {
                    newSelectedItem.editorSelected = true;
                }

                if (ItemSelectionChanged != null)
                {
                    ItemSelectionChanged.Invoke(selectedItem);
                }
            }
        }

        public override void Draw(UISystem uiSystem, UIRenderer renderer)
        {
            itemScreenPositions.Clear();

            base.Draw(uiSystem, renderer);

            // Draw the graph item references
            if (graph != null && IsPaintEvent(uiSystem))
            {
                foreach (var node in graph.Nodes)
                {
                    var previewNode = node as FlowLayoutToolGraph2DNode;
                    if (previewNode != null)
                    {
                        foreach (var item in previewNode.LayoutNode.items)
                        {
                            foreach (var refItem in item.referencedItemIds)
                            {
                                // Draw a reference between the two bounds
                                if (itemScreenPositions.ContainsKey(item.itemId) && itemScreenPositions.ContainsKey(refItem))
                                {
                                    var startBoundsList = itemScreenPositions[item.itemId];
                                    var endBoundsList = itemScreenPositions[refItem];

                                    foreach (var startBounds in startBoundsList)
                                    {
                                        foreach (var endBounds in endBoundsList)
                                        {
                                            DrawReferenceLink(renderer, startBounds, endBounds);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        void DrawReferenceLink(UIRenderer renderer, Rect start, Rect end)
        {
            var centerA = start.center;
            var centerB = end.center;
            var radiusA = Mathf.Max(start.size.x, start.size.y) * 0.5f;
            var radiusB = Mathf.Max(end.size.x, end.size.y) * 0.5f;
            var vecAtoB = (centerB - centerA);
            var lenAtoB = vecAtoB.magnitude;
            var dirAtoB = vecAtoB / lenAtoB;

            var startPos = centerA + dirAtoB * radiusA;
            var endPos = centerA + dirAtoB * (lenAtoB - radiusB);
            StraightLineGraphLinkRenderer.DrawLine(renderer, startPos, endPos, camera, Color.red, 2);
        }

        void CreateCommentNode(Vector2 screenPos, UISystem uiSystem)
        {
            var worldPos = camera.ScreenToWorld(screenPos);
            var commentNode = CreateNode<CommentNode>(worldPos, uiSystem);
            commentNode.Position = worldPos;
            commentNode.background = new Color(0.224f, 1.0f, 0.161f, 0.7f);
            BringToFront(commentNode);
            SelectNode(commentNode, uiSystem);
        }
    }

    public enum DungeonGridFlowAbstractGraphEditorAction
    {
        CreateCommentNode
    }

    public class DungeonGridFlowAbstractGraphContextMenu : GraphContextMenu
    {
        class ItemInfo
        {
            public ItemInfo(UISystem uiSystem, DungeonGridFlowAbstractGraphEditorAction action)
            {
                this.uiSystem = uiSystem;
                this.action = action;
            }

            public UISystem uiSystem;
            public DungeonGridFlowAbstractGraphEditorAction action;
        }

        public override void Show(GraphEditor graphEditor, GraphPin sourcePin, Vector2 mouseWorld, UISystem uiSystem)
        {
            var menu = new GenericMenu();
            menu.AddItem(new GUIContent("Add Comment Node"), false, HandleContextMenu, new ItemInfo(uiSystem, DungeonGridFlowAbstractGraphEditorAction.CreateCommentNode));
            menu.ShowAsContext();
        }

        void HandleContextMenu(object userdata)
        {
            var item = userdata as ItemInfo;
            DispatchMenuItemEvent(item.action, BuildEvent(null, item.uiSystem));
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\PreviewTilemapGraphEditor\FlowPreviewTilemapGraphEditor.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Domains.Tilemap.Tooling;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.Tilemap
{

    public delegate void OnFlowPreviewTileClicked(FlowTilemap tilemap, int tileX, int tileY);

    public class FlowPreviewTilemapGraphEditor : GraphEditor
    {
        private Dictionary<DungeonUID, List<Rect>> itemScreenPositions = new Dictionary<DungeonUID, List<Rect>>();
        public event OnFlowPreviewTileClicked TileClicked;

        protected override GraphContextMenu CreateContextMenu()
        {
            return null;
        }

        protected override IGraphLinkRenderer CreateGraphLinkRenderer()
        {
            return new StraightLineGraphLinkRenderer();
        }

        protected override string GetGraphNotInitializedMessage()
        {
            return "Graph not initialized";
        }

        protected override void InitializeNodeRenderers(GraphNodeRendererFactory nodeRenderers)
        {
            var tilemapRenderer = new FlowPreviewTilemapNodeRenderer();
            tilemapRenderer.FlowAbstractGraphItemRendered += OnGraphItemRendered;
            nodeRenderers.RegisterNodeRenderer(typeof(FlowTilemapToolGraphNode), tilemapRenderer);
        }

        private void OnGraphItemRendered(FlowItem item, Rect screenBounds)
        {
            if (!itemScreenPositions.ContainsKey(item.itemId))
            {
                itemScreenPositions[item.itemId] = new List<Rect>();
            }
            itemScreenPositions[item.itemId].Add(screenBounds);
        }

        public override void Draw(UISystem uiSystem, UIRenderer renderer)
        {
            itemScreenPositions.Clear();
            base.Draw(uiSystem, renderer);

            if (IsPaintEvent(uiSystem))
            {
                var node = graph.Nodes.Count > 0 ? graph.Nodes[0] as FlowTilemapToolGraphNode : null;
                if (node != null)
                {
                    var items = node.LayoutGraph.GetAllItems();
                    foreach (var item in items)
                    {
                        if (!itemScreenPositions.ContainsKey(item.itemId)) continue;
                        foreach (var referencedItemId in item.referencedItemIds)
                        {
                            if (!itemScreenPositions.ContainsKey(referencedItemId)) continue;
                            var startBoundsList = itemScreenPositions[item.itemId];
                            var endBoundsList = itemScreenPositions[referencedItemId];
                            
                            foreach (var startBounds in startBoundsList)
                            {
                                foreach (var endBounds in endBoundsList)
                                {
                                    DrawReferenceLink(renderer, startBounds, endBounds);
                                }
                            }
                        }
                    }
                }
            }
        }

        void DrawReferenceLink(UIRenderer renderer, Rect start, Rect end)
        {
            var centerA = start.center;
            var centerB = end.center;
            var radiusA = Mathf.Max(start.size.x, start.size.y) * 0.5f;
            var radiusB = Mathf.Max(end.size.x, end.size.y) * 0.5f;
            var vecAtoB = (centerB - centerA);
            var lenAtoB = vecAtoB.magnitude;
            var dirAtoB = vecAtoB / lenAtoB;

            var startPos = centerA + dirAtoB * radiusA;
            var endPos = centerA + dirAtoB * (lenAtoB - radiusB);
            StraightLineGraphLinkRenderer.DrawLine(renderer, startPos, endPos, camera, Color.red, 2);
        }

        public override void HandleInput(Event e, UISystem uiSystem)
        {
            base.HandleInput(e, uiSystem);


            var buttonId = 0;
            if (e.type == EventType.MouseDown && e.button == buttonId)
            {
                var clickPos = camera.ScreenToWorld(e.mousePosition);

                var node = graph.Nodes.Count > 0 ? graph.Nodes[0] as FlowTilemapToolGraphNode : null;
                if (node != null)
                {
                    var tilemap = node.Tilemap;
                    clickPos -= node.Position;
                    var tileX = Mathf.FloorToInt(clickPos.x / node.tileRenderSize);
                    var tileY = Mathf.FloorToInt(clickPos.y / node.tileRenderSize);
                    tileY = tilemap.Height - tileY - 1;
                    if (tileX >= 0 && tileX < tilemap.Width && tileY >= 0 && tileY < tilemap.Height)
                    {
                        if (TileClicked != null)
                        {
                            TileClicked.Invoke(tilemap, tileX, tileY);
                        }
                    }
                }
            }
        }

        protected override void OnMenuItemClicked(object userdata, GraphContextMenuEvent e)
        {

        }

        public void UpdateGridSpacing()
        {
            var node = graph.Nodes.Count > 0 ? graph.Nodes[0] as FlowTilemapToolGraphNode : null;
            if (node != null)
            {
                EditorStyle.gridCellSpacing = node.tileRenderSize * 2;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\PreviewTilemapGraphEditor\FlowPreviewTilemapNodeRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using System.Collections.Generic;
using UnityEngine;
using DungeonArchitect.Editors.Flow.Layout;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Domains.Tilemap.Tooling;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.Flow.Tilemap
{
    public class FlowPreviewTilemapNodeRenderer : GraphNodeRenderer
    {
        string tilemapNodeId;
        RenderTexture tilemapTexture;
        public event OnFlowLayoutGraphItemRendered FlowAbstractGraphItemRendered;


        IntVector2 GetNodeCoord(Vector3 coordF)
        {
            return new IntVector2(Mathf.RoundToInt(coordF.x), Mathf.RoundToInt(coordF.y));
        }
        
        private bool IsCellSelected(FlowTilemapCell cell, FlowTilemapToolGraphNode node)
        {
            if (node == null || node.SelectedNode == null || cell == null) return false;

            var nodeCoord = GetNodeCoord(node.SelectedNode.coord);
            return nodeCoord.Equals(cell.NodeCoord);
        }


        private void RecreateTilemapTexture(FlowTilemapRenderResources resources, FlowTilemapToolGraphNode node)
        {
            if (tilemapTexture != null) {
                tilemapTexture.Release();
                tilemapTexture = null;
            }

            node.RequestRecreatePreview = false;
            tilemapNodeId = node.Id;
            var tileSize = node.tileRenderSize;
            var tilemap = node.Tilemap;
            var textureSize = new IntVector2(tilemap.Width, tilemap.Height) * tileSize;
            tilemapTexture = new RenderTexture(textureSize.x, textureSize.y, 0);
            node.Bounds = new Rect(0, 0, textureSize.x, textureSize.y);

            FlowTilemapRenderer.Render(tilemapTexture, tilemap, tileSize, resources, cell => IsCellSelected(cell, node));
        }

        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            var guiState = new GUIState(renderer);

            var tilemapNode = node as FlowTilemapToolGraphNode;
            if (tilemapNode == null) return;

            if (tilemapTexture == null || tilemapNode.Id != tilemapNodeId || tilemapNode.RequestRecreatePreview)
            {
                var tileShader = Shader.Find("DungeonArchitect/UnlitColorShader");
                var resources = new FlowTilemapRenderResources();
                resources.materials = new TexturedMaterialInstances(tileShader);
                resources.iconOneWayDoor = renderer.GetResource<Texture2D>(UIResourceLookup.ICON_MOVEUP_16x) as Texture2D;
                RecreateTilemapTexture(resources, tilemapNode);
            }

            if (tilemapTexture == null)
            {
                return;
            }

            // Draw the tilemap texture
            {
                Rect tileBounds;
                var positionScreen = camera.WorldToScreen(node.Position);
                var sizeScreen = node.Size / camera.ZoomLevel;
                tileBounds = new Rect(positionScreen, sizeScreen);
                renderer.color = Color.white;
                renderer.DrawTexture(tileBounds, tilemapTexture);
            }

            // Draw the items
            {
                DrawItems(renderer, rendererContext, tilemapNode, camera);
            }

            guiState.Restore();
        }

        struct ItemDrawInfo
        {
            public FlowItem item;
            public Vector2 position;
            public Vector2 size;
        }

        void DrawItems(UIRenderer renderer, GraphRendererContext rendererContext, FlowTilemapToolGraphNode node, GraphCamera camera)
        {
            if (node == null || node.LayoutGraph == null || node.Tilemap == null) return;
            var offset = node.Position;
            var tilemap = node.Tilemap;
            var abstractGraph = node.LayoutGraph;

            var allItems = abstractGraph.GetAllItems();
            var itemMap = new Dictionary<DungeonUID, List<FlowItem>>();
            foreach (var item in allItems)
            {
                if (!itemMap.ContainsKey(item.itemId))
                {
                    itemMap[item.itemId] = new List<FlowItem>();
                }
                itemMap[item.itemId].Add(item);
            }

            var itemDrawList = new List<ItemDrawInfo>();
            foreach (var cell in tilemap.Cells)
            {
                if (cell.Item == DungeonUID.Empty) continue;
                var items = itemMap.ContainsKey(cell.Item) ? itemMap[cell.Item] : null;
                if (items == null || items.Count == 0) continue;

                var tileCoord = cell.TileCoord;
                tileCoord.y = tilemap.Height - tileCoord.y - 1;
                var position = offset + tileCoord.ToVector2() * node.tileRenderSize;
                var size = new Vector2(node.tileRenderSize, node.tileRenderSize);

                var drawInfo = new ItemDrawInfo();
                drawInfo.item = items[0];
                drawInfo.position = position;
                drawInfo.size = size;
                itemDrawList.Add(drawInfo);
            }

            foreach (var edge in tilemap.Edges)
            {
                if (edge == null || edge.Item == DungeonUID.Empty) continue;
                var items = itemMap.ContainsKey(edge.Item) ? itemMap[edge.Item] : null;
                if (items == null || items.Count == 0) continue;

                var tileCoord = edge.EdgeCoord;
                tileCoord.y = tilemap.Height - tileCoord.y - 1;
                var position = offset + tileCoord.ToVector2() * node.tileRenderSize;        // TODO: Update me for edge
                if (edge.HorizontalEdge)
                {
                    position.y += node.tileRenderSize * 0.5f;
                }
                else
                {
                    position.x -= node.tileRenderSize * 0.5f;
                }
                var size = new Vector2(node.tileRenderSize, node.tileRenderSize);

                var drawInfo = new ItemDrawInfo();
                drawInfo.item = items[0];
                drawInfo.position = position;
                drawInfo.size = size;
                itemDrawList.Add(drawInfo);
            }

            foreach (var itemDrawInfo in itemDrawList)
            {
                var position = itemDrawInfo.position;
                var size = itemDrawInfo.size;
                position = camera.WorldToScreen(position);
                size /= camera.ZoomLevel;

                var itemBounds = new Rect(position, size);

                float scaleFactor = FlowPreviewLayoutItemRenderer.GetItemScaleFactor(rendererContext.GraphEditor.LastMousePosition, itemBounds);
                var scaledSize = itemBounds.size * scaleFactor;
                itemBounds = new Rect(itemBounds.center - scaledSize * 0.5f, scaledSize);

                float preferedNodeSizeForText = 14.0f;
                float textScaleFactor = node.tileRenderSize / preferedNodeSizeForText;
                FlowPreviewLayoutItemRenderer.DrawItem(renderer, rendererContext, camera, itemDrawInfo.item, itemBounds, scaleFactor * textScaleFactor);
                if (FlowAbstractGraphItemRendered != null)
                {
                    FlowAbstractGraphItemRendered.Invoke(itemDrawInfo.item, itemBounds);
                }
            }
        }

        public override void Release()
        {
            base.Release();
            if (tilemapTexture != null)
            {
                tilemapTexture.Release();
                tilemapTexture = null;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Editors\Grid\Actors\CursorActor.cs:
 using DungeonArchitect.SxEngine;
using DungeonArchitect.SxEngine.Utils;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.Editors.Grid.Actors
{
    public class SxCursorActor : SxMeshActor
    {
        private readonly SxCursorMaterial material;
        private SmoothValueVector3 animPosition;
        public bool Animating => (animPosition != null && !animPosition.HasArrived);
        
        public SxCursorActor()
        {
            SetMesh(SxMeshRegistry.Get<SxMGGroundTileMesh>());
            
            material = new SxCursorMaterial();
            SetMaterial(material);
            animPosition = new SmoothValueVector3(Vector3.zero);
            animPosition.TimeToArrive = 0.05f;
        }

        public override void Tick(SxRenderContext context, float deltaTime)
        {
            base.Tick(context, deltaTime);
            if (!animPosition.HasArrived)
            {
                animPosition.Update(deltaTime);
                Position = animPosition.Value;
            }
        }

        public void SetSmoothPosition(Vector3 pos, bool immediate = false)
        {
            if (immediate)
            {
                animPosition.Set(pos);
            }
            else
            {
                animPosition.Value = pos;
            }
        }
    }

    public class SxCursorMaterial : SxUnityResourceCopyMaterial
    {
        public SxCursorMaterial() : base("MarkerGen/materials/MatCursor")
        {
            DepthBias = -2;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Editors\Grid\Actors\GroundActor.cs:
 using System;
using System.Collections.Generic;
using DungeonArchitect.MarkerGenerator.Rule.Grid;
using DungeonArchitect.SxEngine;
using DungeonArchitect.SxEngine.Utils;
using UnityEngine;

namespace DungeonArchitect.Editors.MarkerGenerator.Editors.Grid.Actors
{
    public class SxGridGroundObjectMaterial : SxUnityResourceMaterial
    {
        public SxGridGroundObjectMaterial() : base("MarkerGen/materials/MatGroundQuad")
        {
            DepthBias = -2;
        }
    }
    public class SxGridGroundObjectSelectedMaterial : SxUnityResourceMaterial
    {
        public SxGridGroundObjectSelectedMaterial() : base("MarkerGen/materials/MatGroundQuadSelected")
        {
            DepthBias = -2;
        }
    }

    
    
    public class GridMarkerGenGroundActorSettings
    {
        public Vector2Int Start = Vector2Int.zero;
        public Vector2Int End = Vector2Int.zero;
        public float TileSize = 4;
        public float EdgeSize = 1;
    }

    public class SxGridMarkerGenGroundItemComponent : SxMeshComponent
    {
        public Vector2Int Coord;
        public GridMarkerGenRuleType ItemType;
        
        private static int idScale = Shader.PropertyToID("_Scale");
        private static Dictionary<Vector3, SxMaterial> materialRegistryNormal = new Dictionary<Vector3, SxMaterial>();
        private static Dictionary<Vector3, SxMaterial> materialRegistryHover = new Dictionary<Vector3, SxMaterial>();
        private bool hovered = false;

        public void Initialize(Vector3 location, Vector2 scale)
        {
            RequiresTick = false;
            Mesh = SxMeshRegistry.Get<SxMGGroundTileMesh>();
            
            var scale3D = new Vector3(scale.x, 1, scale.y);
            RelativeTransform.SetTRS(location, Quaternion.identity, scale3D);

            UpdateMaterialParameters();
        }
        

        public void SetHover(bool newHoveredState)
        {
            if (hovered != newHoveredState)
            {
                this.hovered = newHoveredState;
                UpdateMaterialParameters();
            }
        }

        private void UpdateMaterialParameters()
        {
            Material = GetCachedMaterial(RelativeTransform.lossyScale, hovered);
        }
        
        private static T CreateQuadMat<T>(Vector3 scale) where T : SxMaterial, new()
        {
            var mat = new T();
            mat.UnityMaterial.SetVector(idScale, scale);
            return mat;
        }
        
        private static SxMaterial GetCachedMaterial(Vector3 scale, bool selected)
        {
            if (!materialRegistryNormal.ContainsKey(scale))
            {
                materialRegistryNormal.Add(scale, CreateQuadMat<SxGridGroundObjectMaterial>(scale));
            }
            
            if (!materialRegistryHover.ContainsKey(scale))
            {
                materialRegistryHover.Add(scale, CreateQuadMat<SxGridGroundObjectSelectedMaterial>(scale));
            }

            return selected ? materialRegistryHover[scale] : materialRegistryNormal[scale];
        }

    }
    
    public class SxGridMarkerGenGroundActor : SxActor
    {
        readonly Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent> tiles = new Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent>();
        readonly Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent> edgesX = new Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent>();
        readonly Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent> edgesZ = new Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent>();
        readonly Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent> corners = new Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent>();

        public Rect WorldBounds { get; private set; } = Rect.zero;
        public GridMarkerGenGroundActorSettings Settings { get; private set; }
        
        public void Build(GridMarkerGenGroundActorSettings buildSettings)
        {
            Settings = buildSettings;

            var tileMeshNormal = new Color(0, 1, 0);    // The normal is expected in the color channel on the used shader
            var tileMesh = new SxMGGroundTileMesh(tileMeshNormal);
            
            var itemTileScale = new Vector2(Settings.TileSize, Settings.TileSize);
            var edgeScaleX = new Vector2(Settings.TileSize, Settings.EdgeSize);
            var edgeScaleZ = new Vector2(Settings.EdgeSize, Settings.TileSize);
            var cornerScale = new Vector2(Settings.EdgeSize, Settings.EdgeSize);
            
            float offset = Settings.TileSize + Settings.EdgeSize;

            // Build the tiles, edgesX, edgesY and corners separately so they are sorted correctly for rendering in fewer batches
            
            // Tiles
            for (int X = Settings.Start.x; X <= Settings.End.x; X++)
            {
                for (int Y = Settings.Start.y; Y <= Settings.End.y; Y++)
                {
                    var key = new Vector2Int(X, Y);
                    var tileLoc = new Vector3(X, 0, Y) * offset;
                    var tileItem = CreateItem(tileLoc, itemTileScale);
                    tileItem.Coord = key;
                    tileItem.ItemType = GridMarkerGenRuleType.Ground;
                    tiles.Add(key, tileItem);
                }
            }
            
            // Edges X
            for (int X = Settings.Start.x; X <= Settings.End.x; X++)
            {
                for (int Y = Settings.Start.y; Y <= Settings.End.y; Y++)
                {
                    var key = new Vector2Int(X, Y);
                    var edgeLocX = new Vector3(X, 0, Y - 0.5f) * offset;
                    var edgeItemX = CreateItem(edgeLocX, edgeScaleX);
                    edgeItemX.Coord = key;
                    edgeItemX.ItemType = GridMarkerGenRuleType.EdgeX;
                    edgesX.Add(key, edgeItemX);
                }
            }

            // Edges Z
            for (int X = Settings.Start.x; X <= Settings.End.x; X++)
            {
                for (int Y = Settings.Start.y; Y <= Settings.End.y; Y++)
                {
                    var key = new Vector2Int(X, Y);
                    var edgeLocZ = new Vector3(X - 0.5f, 0, Y) * offset;
                    var edgeItemZ = CreateItem(edgeLocZ, edgeScaleZ);
                    edgeItemZ.Coord = key;
                    edgeItemZ.ItemType = GridMarkerGenRuleType.EdgeZ;
                    edgesZ.Add(key, edgeItemZ);
                }
            }
            
            // Corners
            for (int X = Settings.Start.x; X <= Settings.End.x; X++)
            {
                for (int Y = Settings.Start.y; Y <= Settings.End.y; Y++)
                {
                    var key = new Vector2Int(X, Y);
                    var cornerLoc = new Vector3(X - 0.5f, 0, Y - 0.5f) * offset;
                    var cornerItem = CreateItem(cornerLoc, cornerScale);
                    cornerItem.Coord = key;
                    cornerItem.ItemType = GridMarkerGenRuleType.Corner;
                    corners.Add(key, cornerItem);
                }
            }
            
            // Setup the world bounds
            {
                var start = new Vector2(Settings.Start.x - 0.5f, Settings.Start.y - 0.5f) * offset - new Vector2(Settings.EdgeSize, Settings.EdgeSize) * 0.5f;
                var end = new Vector2(Settings.End.x, Settings.End.y) * offset + new Vector2(Settings.TileSize, Settings.TileSize) * 0.5f;
                WorldBounds = new Rect(start, end - start);
            }
        }

        public void OnMouseHover(Vector3 worldIntersection)
        {
            Deproject(worldIntersection, out var hoveredItem, out _);
            foreach (var item in Components)
            {
                if (item is SxGridMarkerGenGroundItemComponent groundItem)
                {
                    groundItem.SetHover(item == hoveredItem);
                }
            }
        }

        public bool Deproject(Vector3 worldIntersection, out SxGridMarkerGenGroundItemComponent item, out GridMarkerGenRuleType itemType)
        {
            GridMarkerGenEditorUtils.DeprojectGround(worldIntersection, Settings.TileSize, Settings.EdgeSize, out var coord, out itemType);

            Dictionary<Vector2Int, SxGridMarkerGenGroundItemComponent> itemMap;
            if (itemType == GridMarkerGenRuleType.Corner) {
                itemMap = corners;
            }
            else if (itemType == GridMarkerGenRuleType.EdgeZ) {
                itemMap = edgesZ;
            }
            else if (itemType == GridMarkerGenRuleType.EdgeX) {
                itemMap = edgesX;
            }
            else {	// Ground
                itemMap = tiles;
            }

            if (itemMap.ContainsKey(coord))
            {
                item = itemMap[coord];
                return true;
            }
            else
            {
                item = null;
                return false;
            }
        }

        SxGridMarkerGenGroundItemComponent CreateItem(Vector3 location, Vector2 scale)
        {
            var item = AddComponent<SxGridMarkerGenGroundItemComponent>();
            item.Initialize(location, scale);
            
            return item;
        }

    }
    
    
    public class SxMGGroundTileMesh : SxMesh
    {
        public SxMGGroundTileMesh()
        {
            Build(Color.white);
        }

        public SxMGGroundTileMesh(Color color)
        {
            Build(color);
        }
        
        void Build(Color color)
        {

            const float size = 0.5f;
            var vertices = new SxMeshVertex[]
            {
                new SxMeshVertex(new Vector3(-size, 0, -size), color, new Vector2(0, 0)),   // a
                new SxMeshVertex(new Vector3(-size, 0, size), color, new Vector2(0, 1)),     // d
                new SxMeshVertex(new Vector3(size, 0, size), color, new Vector2(1, 1)),     // c
                new SxMeshVertex(new Vector3(size, 0, -size), color, new Vector2(1, 0)),    // b
            };

            CreateSection(0, GL.QUADS, vertices);   
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\Editors\Grid\Actors\RuleActor.cs:
 using DungeonArchitect.MarkerGenerator.Rule.Grid;
using DungeonArchitect.SxEngine;
using DungeonArchitect.SxEngine.Utils;
using DungeonArchitect.Utils;
using UnityEditor;
using UnityEngine;
using MathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Editors.MarkerGenerator.Editors.Grid.Actors
{
    public class SxGridPatternRuleActor : SxMeshActor
    {
        private readonly SxGridRuleObjectMaterial material;
        private bool selected = false;
        private bool hovered = false;
        private SxTextComponent textComponent1;
        private SxTextComponent textComponent2;
        private SmoothValueVector3 animPosition;
        private SmoothValueVector3 animScale;

        public GridMarkerGenRule Rule { get; private set; }
        public float EdgeSize { get; private set; }
        public float TileSize { get; private set; }
        
        public SxGridPatternRuleActor()
        {
            SetMesh(new SxCubeBaseMesh());
            
            material = new SxGridRuleObjectMaterial();
            SetMaterial(material);
            UpdateMaterialParameters();
        }

        public void Initialize(GridMarkerGenRule rule, float tileSize, float edgeSize)
        {
            Rule = rule;
            TileSize = tileSize;
            EdgeSize = edgeSize;
            selected = false;
            animPosition = new SmoothValueVector3(Position);
            animScale = new SmoothValueVector3(Scale);

            var textSettings = new SxTextComponentSettings()
            {
                Font = Resources.Load<Font>("MarkerGen/fonts/roboto/RobotoCondensed-Bold"),
                Color = Color.black,
                Scale = 0.10f,
                HAlign = SxTextHAlign.Center,
                VAlign = SxTextVAlign.Center,
                DepthBias = -2,
                CustomMaterial = new SxGridRuleTextMaterial(),
                WordWrap = true,
                WordWrapWidth = 0.9f,
                WordWrapHeight = 0.9f
            };

            textComponent1 = AddComponent<SxTextComponent>();
            textComponent1.Initialize(textSettings);
            
            textComponent2 = AddComponent<SxTextComponent>();
            textComponent2.Initialize(textSettings);

            UpdateRuleText();
            UpdateTransform(false);
            UpdateMaterial();
        }

        public void UpdateMaterial()
        {
            if (material != null && Rule != null)
            {
                var color = Rule.color;
                if (!Rule.visuallyDominant)
                {
                    color = GridMarkerGenEditorUtils.CreatePaleColor(color);
                }
                material.SetBodyColor(color);
                material.SetBodyHoverColor(GridMarkerGenEditorUtils.CreateHoverColor(color));
            }
        }

        public bool Animating => (animPosition != null && !animPosition.HasArrived) || (animScale != null && !animScale.HasArrived);
        
        public override void Tick(SxRenderContext context, float deltaTime)
        {
            base.Tick(context, deltaTime);

            if (Animating)
            {
                animPosition.Update(deltaTime);
                animScale.Update(deltaTime);
                ApplyTransform();
            }
        }

        public void UpdateRuleText()
        {
            var lines = new SxTextLineList();
            if (Rule != null)
            {
                if (Rule.previewTextCondition.Trim().Length > 0)
                {
                    lines.AddLine("CONDITION:", 0.6f);
                    lines.AddLine(Rule.previewTextCondition);
                }

                if (Rule.previewTextActions.Length > 0)
                {
                    lines.AddLine("ACTIONS:", 0.6f, 30);
                    foreach (var actionText in Rule.previewTextActions)
                    {
                        lines.AddLine(actionText);
                    }
                }
            }
            textComponent1.SetLines(lines);
            textComponent2.SetLines(lines);
        }
        
        float GetHeightScale()
        {
            if (Rule == null) return 1;
            switch (Rule.ruleType)
            {
                case GridMarkerGenRuleType.Ground:
                    return TileSize * 0.1f;
                
                case GridMarkerGenRuleType.EdgeX:
                case GridMarkerGenRuleType.EdgeZ:
                case GridMarkerGenRuleType.Corner:
                    return Rule.visuallyDominant ? TileSize : TileSize * 0.3f;
                
                default:
                    return 1;
                    
            }
        }

        public void UpdateTransform(bool animate)
        {
            if (Rule == null) return;
            
            float offset = TileSize + EdgeSize;
            float padding = TileSize / 10.0f;
            
            var position2D = Vector2.zero;
            var scale2D = Vector2.one;

            if (Rule.ruleType == GridMarkerGenRuleType.Ground)
            {
                var coord2D = MathUtils.ToVector2(Rule.coord); 
                position2D = coord2D * offset;
                scale2D = new Vector2(TileSize, TileSize);
            }
            else if (Rule.ruleType == GridMarkerGenRuleType.EdgeX)
            {
                var coord2D = MathUtils.ToVector2(Rule.coord) + new Vector2(0, -0.5f); 
                position2D = coord2D * offset;
                scale2D = new Vector2(TileSize, EdgeSize);
            }
            else if (Rule.ruleType == GridMarkerGenRuleType.EdgeZ)
            {
                var coord2D = MathUtils.ToVector2(Rule.coord) + new Vector2(-0.5f, 0); 
                position2D = coord2D * offset;
                scale2D = new Vector2(EdgeSize, TileSize);
            }
            else if (Rule.ruleType == GridMarkerGenRuleType.Corner)
            {
                var coord2D = MathUtils.ToVector2(Rule.coord) + new Vector2(-0.5f, -0.5f); 
                position2D = coord2D * offset;
                scale2D = new Vector2(EdgeSize, EdgeSize);
            }

            var position = new Vector3(position2D.x, 0, position2D.y);
            var scale = new Vector3(scale2D.x - padding, GetHeightScale(), scale2D.y - padding);

            if (position != Position || Scale != scale)
            {
                if (animate)
                {
                    animPosition.Value = position;
                    animScale.Value = scale;
                }
                else
                {
                    animPosition.Set(position);
                    animScale.Set(scale);
                    ApplyTransform();
                }
            }
            
            UpdateTextTransform();
        }

        private void ApplyTransform()
        {
            WorldTransform = new SxTransform(animPosition.Value, Quaternion.identity, animScale.Value);
            material.SetScale(Scale);
        }

        private void UpdateTextTransform()
        {
            if (Rule.visuallyDominant)
            {
                if (Rule.ruleType == GridMarkerGenRuleType.Ground)
                {
                    textComponent1.Visible = true;
                    textComponent2.Visible = false;
                    textComponent1.RelativeTransform = Matrix4x4.TRS(new Vector3(0, 1.01f, 0), Quaternion.AngleAxis(90, new Vector3(1, 0, 0)), Vector3.one);
                }
                else if (Rule.ruleType == GridMarkerGenRuleType.EdgeX)
                {
                    textComponent1.Visible = true;
                    textComponent2.Visible = true;
                    textComponent1.RelativeTransform = Matrix4x4.TRS(new Vector3(0, 0.5f, -0.51f), Quaternion.AngleAxis(0, Vector3.up), Vector3.one);
                    textComponent2.RelativeTransform = Matrix4x4.TRS(new Vector3(0, 0.5f, 0.51f), Quaternion.AngleAxis(180, Vector3.up), Vector3.one);
                } 
                else if (Rule.ruleType == GridMarkerGenRuleType.EdgeZ)
                {
                    textComponent1.Visible = true;
                    textComponent2.Visible = true;
                    textComponent1.RelativeTransform = Matrix4x4.TRS(new Vector3(-0.51f, 0.5f, 0), Quaternion.AngleAxis(90, Vector3.up), Vector3.one);
                    textComponent2.RelativeTransform = Matrix4x4.TRS(new Vector3(0.51f, 0.5f, 0), Quaternion.AngleAxis(-90, Vector3.up), Vector3.one);
                } 
                else if (Rule.ruleType == GridMarkerGenRuleType.Corner)
                {
                    textComponent1.Visible = false;
                    textComponent2.Visible = false;
                } 
            }
            else
            {
                // Not visually dominant and should fade into the background (not get in the way).  Hide the text on everything except the ground tiles
                if (Rule.ruleType == GridMarkerGenRuleType.Ground)
                {
                    textComponent1.Visible = true;
                    textComponent2.Visible = false;
                    textComponent1.RelativeTransform = Matrix4x4.TRS(new Vector3(0, 1.01f, 0), Quaternion.AngleAxis(90, new Vector3(1, 0, 0)), Vector3.one);
                }
                else
                {
                    textComponent1.Visible = false;
                    textComponent2.Visible = false;
                }
            }
        }

        public Bounds GetBounds()
        {
            var min = Position + Vector3.Scale(new Vector3(-0.5f, 0, -0.5f), Scale);
            var max = Position + Vector3.Scale(new Vector3(0.5f, 1, 0.5f), Scale);
            return new Bounds((min + max) * 0.5f, max - min);
        }

        public void SetHovered(bool newHoveredState)
        {
            if (hovered != newHoveredState)
            {
                hovered = newHoveredState;
                material.SetHovered(hovered);
            }
            
        }
        
        public void SetSelected(bool newSelectState)
        {
            if (selected != newSelectState)
            {
                selected = newSelectState;
                material.SetSelected(selected);
            }
        }

        private void UpdateMaterialParameters()
        {
            material.SetSelected(selected);
            material.SetHovered(hovered);
            material.SetScale(Scale);
        }
    }

    
    public class SxGridRuleObjectMaterial : SxUnityResourceCopyMaterial
    {
        private readonly int idxSelected;
        private readonly int idxHovered;
        private readonly int idxScale;
        private readonly int idxBodyColor;
        private readonly int idxBodyHoverColor;
        
        public SxGridRuleObjectMaterial() : base("MarkerGen/materials/MatRuleObject")
        {
            DepthBias = -2;
            idxSelected = Shader.PropertyToID("_Selected");
            idxHovered = Shader.PropertyToID("_Hovered");
            idxScale = Shader.PropertyToID("_Scale");
            idxBodyColor = Shader.PropertyToID("_BodyColor");
            idxBodyHoverColor = Shader.PropertyToID("_BodyHoverColor");
        }
        
        public void SetSelected(bool selected)
        {
            UnityMaterial.SetInt(idxSelected, selected ? 1 : 0);
        }
        
        public void SetHovered(bool hovered)
        {
            UnityMaterial.SetInt(idxHovered, hovered ? 1 : 0);
        }

        public void SetScale(Vector3 scale)
        {
            UnityMaterial.SetVector(idxScale, scale);
        }
        
        public void SetBodyColor(Color color)
        {
            UnityMaterial.SetColor(idxBodyColor, color);
        }
        
        public void SetBodyHoverColor(Color color)
        {
            UnityMaterial.SetColor(idxBodyHoverColor, color);
        }
    }

    
    public class SxGridRuleTextMaterial : SxUnityResourceCopyMaterial
    {
        public SxGridRuleTextMaterial() : base("MarkerGen/materials/MatRuleText")
        {
            DepthBias = -2;
        }
     
    }
    
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\MarkerGenEditor\UI\GraphEditor\NodeRenderers\MarkerGenRuleNodeRenderer.cs:
 using System.Collections.Generic;
using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator;
using DungeonArchitect.MarkerGenerator.Pins;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using UnityEditor;
using UnityEngine;
using MathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Editors.MarkerGenerator.UI.NodeRenderers
{
    public class MarkerGenRuleNodeRenderer : GraphNodeRenderer
    {
        private GUIStyle styleBody;
        private GUIStyle styleSelectBorder;
        private GUIStyle styleTitle;
        private GUIStyle styleToggle;
        private Texture2D pinTexDefault;
        private Texture2D pinTexDefaultHollow;
        private Texture2D pinTexExec;
        private Texture2D pinTexExecHollow;

        bool IsStateInvalid()
        {
            return styleBody == null || styleTitle == null;
        }

        void InitializeState(UIRenderer renderer)
        {
            GUISkin skin = renderer.GetResource<GUISkin>("skins/graph_editor/GuiSkinGraphNode") as GUISkin;
            if (skin == null)
            {
                skin = EditorGUIUtility.GetBuiltinSkin(EditorSkin.Inspector);
            }

            if (skin != null) 
            {
                styleBody = new GUIStyle(skin.box);
                styleBody.normal.background = renderer.GetResource<Texture2D>("skins/graph_editor/NodeBorderTex") as Texture2D;
                
                styleTitle = new GUIStyle(skin.box);
                styleTitle.normal.background = renderer.GetResource<Texture2D>("skins/graph_editor/NodeTitleTex") as Texture2D;
                
                styleSelectBorder = new GUIStyle(skin.box);
                styleSelectBorder.normal.background = renderer.GetResource<Texture2D>("skins/graph_editor/NodeBorderSelectTex") as Texture2D;

                styleToggle = new GUIStyle(skin.toggle);
                
                pinTexDefault = renderer.GetResource<Texture2D>("skins/graph_editor/pin_12") as Texture2D;
                pinTexDefaultHollow = renderer.GetResource<Texture2D>("skins/graph_editor/pin_hollow_12") as Texture2D;
                
                pinTexExec = renderer.GetResource<Texture2D>("skins/graph_editor/pin_exec_12") as Texture2D;
                pinTexExecHollow = renderer.GetResource<Texture2D>("skins/graph_editor/pin_exec_hollow_12") as Texture2D;
            }
        }

        private Dictionary<GraphPin, List<GraphPin>> linkedTo = new Dictionary<GraphPin, List<GraphPin>>();

        public override void BeginFrame(Graph graph)
        {
            if (graph == null) return;

            foreach (var link in graph.Links)
            {
                var pinInput = link.Input as MarkerGenRuleGraphPin;
                var pinOutput = link.Output as MarkerGenRuleGraphPin;
                if (pinInput == null || pinOutput == null) continue;
                
                if (!linkedTo.ContainsKey(pinInput))
                {
                    linkedTo.Add(pinInput, new List<GraphPin>());
                }

                if (!linkedTo.ContainsKey(pinOutput))
                {
                    linkedTo.Add(pinOutput, new List<GraphPin>());
                }
                
                linkedTo[pinInput].Add(pinOutput);
                linkedTo[pinOutput].Add(pinInput);
            }
        }

        bool IsPinConnected(GraphPin pin)
        {
            if (pin == null || !linkedTo.ContainsKey(pin))
            {
                return false;
            }

            return linkedTo[pin].Count > 0;
        }

        public override void EndFrame()
        {
            linkedTo.Clear();
        }

        Texture2D GetPinTexture(MarkerGenRuleGraphPin pin)
        {
            bool connected = IsPinConnected(pin);
            if (pin is MarkerGenRuleGraphPinExec)
            {
                return connected ? pinTexExec : pinTexExecHollow;
            }
            return connected ? pinTexDefault : pinTexDefaultHollow;
        }

        private Vector2 pinPadding = new Vector2(4, 4);
        
        Vector2 CalcSize(MarkerGenRuleGraphPin pin, GUIStyle style)
        {
            if (pin == null) return Vector2.zero;
            var pinTex = GetPinTexture(pin);
            var textureSize = new Vector2(pinTex.width, pinTex.height);
            var size = textureSize + pinPadding * 2;
            
            if (pin is MarkerGenRuleGraphPinBool boolPin)
            {
                if (pin.PinType == GraphPinType.Input)
                {
                    var toggleSize = new Vector2(16, 16);
                    size.x += toggleSize.x + pinPadding.x;
                    size.y = Mathf.Max(size.y, toggleSize.y);
                }

                if (boolPin.text.Length > 0)
                {
                    var textSize = style.CalcSize(new GUIContent(boolPin.text));
                    size.x += textSize.x;
                    size.y = Mathf.Max(size.y, textSize.y);
                }
            }

            size.y += pinPadding.y;

            return size;
        }

        private void DrawPin(UIRenderer renderer, MarkerGenRuleGraphPin pin, GUIStyle style, Rect bounds, GraphCamera camera)
        {
            float cameraZoomLevel = camera.ZoomLevel;
            bool isInput = pin.PinType == GraphPinType.Input;
            var pinTex = GetPinTexture(pin);
            var texSize = new Vector2(pinTex.width, pinTex.height) / cameraZoomLevel;

            var centerY = bounds.y + bounds.size.y * 0.5f;
            var currentX = isInput
                ? bounds.x 
                : bounds.xMax - texSize.x;
            
            var pinPos = new Vector2(currentX, centerY - pinTex.height * 0.5f);
            var pinBounds = new Rect(pinPos, texSize);
            renderer.DrawTexture(pinBounds, pinTex, ScaleMode.ScaleToFit, true, pin.GetPinColor());

            // Update the bounds offset
            {
                var hoverBounds = MathUtils.ExpandRect(pinBounds, pinPadding.x);
                var localBounds = camera.ScreenToWorld(hoverBounds);
                localBounds.position -= pin.Node.Position;
                if (isInput)
                {
                    pin.Position = new Vector2(localBounds.x, localBounds.y + localBounds.height * 0.5f);
                    pin.BoundsOffset = new Rect(new Vector2(0, -localBounds.height * 0.5f), localBounds.size);
                    pin.Tangent = new Vector2(-1, 0);
                }
                else
                {
                    pin.Position = new Vector2(localBounds.xMax, localBounds.y + localBounds.height * 0.5f);
                    pin.BoundsOffset = new Rect(new Vector2(-localBounds.width, -localBounds.height * 0.5f), localBounds.size);
                    pin.Tangent = new Vector2(1, 0);
                }
            }

            if (isInput)
            {
                currentX += texSize.x + pinPadding.x / cameraZoomLevel;
            }
            else
            {
                currentX -= pinPadding.x / cameraZoomLevel;
            }

            if (pin is MarkerGenRuleGraphPinBool)
            {
                var boolPin = pin as MarkerGenRuleGraphPinBool;
                
                bool checkboxVisible = isInput && !IsPinConnected(pin);

                if (checkboxVisible)
                {
                    const float checkboxSize = 16;
                    Rect toggleBounds = new Rect();
                    toggleBounds.width = checkboxSize / cameraZoomLevel;
                    toggleBounds.height = checkboxSize / cameraZoomLevel;
                    toggleBounds.x = currentX;
                    toggleBounds.y = centerY - toggleBounds.height * 0.5f;

                    renderer.backgroundColor = Color.white;
                    renderer.color = Color.white;
                    bool oldValue = boolPin.defaultValue; 
                    boolPin.defaultValue = renderer.Toggle(toggleBounds, boolPin.defaultValue, "");
                    if (oldValue != boolPin.defaultValue)
                    {
                        GraphStateChanged = true;
                    }

                    currentX += toggleBounds.width;
                }
            }

            var pinTextSize = style.CalcSize(new GUIContent(pin.text));

            var pinTextBounds = new Rect();
            {
                pinTextBounds.x = currentX;
                pinTextBounds.y = centerY - pinTextSize.y * 0.5f;
                pinTextBounds.width = pinTextSize.x;
                pinTextBounds.height = pinTextSize.y;
            }

            if (!isInput)
            {
                pinTextBounds.x -= pinTextBounds.width;
            }
                
            style.normal.textColor = Color.white;
            renderer.Label(pinTextBounds, pin.text, style);
        }

        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            if (IsStateInvalid())
            {
                InitializeState(renderer);
            }
            
            var ruleNode = node as MarkerGenRuleGraphNode;
            if (ruleNode == null)
            {
                return;
            }
            
            var title = ruleNode.Title;
            var titleColor = Color.white;

            var style = CreateStyle(node.Selected, camera.ZoomLevel);

            var guiState = new GUIState(renderer);

            
            // Update the node bounds
            Vector2 nodeSize;
            Vector2 nodeHeaderSize;
            var screenTitlePadding = new Vector2(5, 5) / camera.ZoomLevel;
            var screenBodyPadding = new Vector2(4, 4) / camera.ZoomLevel;
            
            const float pinLaneGap = 0;

            var desiredPinSizes = new Dictionary<MarkerGenRuleGraphPin, Vector2>();
            Vector2 desiredBodySize;
            float maxRightPinWidth = 0;
            {
                var bodySizeLeft = Vector2.zero;
                foreach (var pin in node.InputPins)
                {
                    var rulePin = pin as MarkerGenRuleGraphPin;
                    if (rulePin == null) continue;
                    var pinSize = CalcSize(rulePin, style);
                    bodySizeLeft.x = Mathf.Max(bodySizeLeft.x, pinSize.x);
                    bodySizeLeft.y += pinSize.y;

                    desiredPinSizes.Add(rulePin, pinSize);
                }
                var bodySizeRight = Vector2.zero;
                foreach (var pin in node.OutputPins)
                {
                    var rulePin = pin as MarkerGenRuleGraphPin;
                    if (rulePin == null) continue;
                    var pinSize = CalcSize(rulePin, style);
                    bodySizeRight.x = Mathf.Max(bodySizeRight.x, pinSize.x);
                    bodySizeRight.y += pinSize.y;
                    
                    desiredPinSizes.Add(rulePin, pinSize);
                    maxRightPinWidth = Mathf.Max(maxRightPinWidth, pinSize.x);
                }

                desiredBodySize = new Vector2(bodySizeLeft.x + pinLaneGap + bodySizeRight.x, Mathf.Max(bodySizeLeft.y, bodySizeRight.y));
                desiredBodySize /= camera.ZoomLevel;
                maxRightPinWidth /= camera.ZoomLevel;
            }

            float minWidth = 20;
            var titleSize = style.CalcSize(new GUIContent(title));
            desiredBodySize.x = Mathf.Max(desiredBodySize.x, titleSize.x);
            titleSize.x = Mathf.Max(titleSize.x, desiredBodySize.x);
            {
                int maxPins = Mathf.Max(node.InputPins.Length, node.OutputPins.Length);
                nodeHeaderSize = new Vector2(
                    Mathf.Max(titleSize.x, minWidth) + screenTitlePadding.x * 2,
                    titleSize.y + screenTitlePadding.y * 2);

                nodeSize = new Vector2(
                    Mathf.Max(titleSize.x, minWidth) + screenBodyPadding.x * 2,
                    nodeHeaderSize.y + desiredBodySize.y + screenBodyPadding.y * 2);


                nodeSize.x = Mathf.Max(nodeSize.x, nodeHeaderSize.x);
                nodeSize.y = Mathf.Max(nodeSize.y, nodeHeaderSize.y + 10);
            }

            Rect titleBounds;
            Rect boxBounds;
            {
                var positionScreen = camera.WorldToScreen(node.Position);
                var sizeScreen = nodeSize;
                boxBounds = new Rect(positionScreen, sizeScreen);
                titleBounds = new Rect(positionScreen, nodeHeaderSize);
            }

            Rect textBounds;
            {
                var positionScreen = camera.WorldToScreen(node.Position + screenTitlePadding);
                var sizeScreen = titleSize;
                textBounds = new Rect(positionScreen, sizeScreen);
            }

            // Draw the body
            {
                renderer.backgroundColor = ruleNode.BodyColor;
                renderer.Box(boxBounds, new GUIContent(), styleBody);
            }

            // Draw the title
            {
                renderer.backgroundColor = ruleNode.TitleColor;
                renderer.Box(titleBounds, new GUIContent(), styleTitle);
            }

            // Draw the input pins
            {
                float currentX = boxBounds.xMin + screenBodyPadding.x;
                float currentY = titleBounds.yMax + screenBodyPadding.y;
                foreach (var pin in node.InputPins)
                {
                    var rulePin = pin as MarkerGenRuleGraphPin;
                    if (rulePin == null || !desiredPinSizes.ContainsKey(rulePin)) continue;

                    var pinSizeScreen = desiredPinSizes[rulePin] / camera.ZoomLevel;
                    var pinBounds = new Rect(new Vector2(currentX, currentY), pinSizeScreen);
                    DrawPin(renderer, rulePin, style, pinBounds, camera);
                    
                    
                    currentY += pinSizeScreen.y;
                }
                
            }
            // Draw the output pins
            {
                float currentX = boxBounds.xMax - screenBodyPadding.x - maxRightPinWidth;
                float currentY = titleBounds.yMax + screenBodyPadding.y;
                foreach (var pin in node.OutputPins)
                {
                    var rulePin = pin as MarkerGenRuleGraphPin;
                    if (rulePin == null || !desiredPinSizes.ContainsKey(rulePin)) continue;

                    var pinSizeScreen = desiredPinSizes[rulePin] / camera.ZoomLevel;
                    var pinBounds = new Rect(new Vector2(currentX, currentY), pinSizeScreen);

                    DrawPin(renderer, rulePin, style, pinBounds, camera);
                    
                    currentY += pinSizeScreen.y;
                }
            }
            
            // Draw the selection
            if (node.Selected)
            {
                var selectionColor = new Color(1.0f, 0.5f, 0.0f);
                renderer.backgroundColor = selectionColor;
                var selectionBounds = MathUtils.ExpandRect(boxBounds, 1);
                renderer.Box(selectionBounds, new GUIContent(), styleSelectBorder);
            }
            
            style.normal.textColor = titleColor;
            renderer.Label(textBounds, title, style);

            var updateWorldSize = nodeSize * camera.ZoomLevel;
            {
                var nodeBounds = node.Bounds;
                nodeBounds.size = updateWorldSize;
                node.Bounds = nodeBounds;
            }

            guiState.Restore();
        }

        private GUIStyle CreateStyle(bool selected, float zoomLevel)
        {
            var style = new GUIStyle(EditorStyles.label);
            style.alignment = TextAnchor.UpperLeft;
            style.normal.textColor = selected ? GraphEditorConstants.TEXT_COLOR_SELECTED : GraphEditorConstants.TEXT_COLOR;
            
            style.font = EditorStyles.standardFont;
            float scaledFontSize = style.fontSize == 0 ? style.font.fontSize : style.fontSize;
            scaledFontSize = Mathf.Max(1.0f, scaledFontSize / zoomLevel);
            style.fontSize = Mathf.RoundToInt(scaledFontSize);

            return style;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\NodeRenderers\GrammarExecEntryNodeRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class GrammarExecEntryNodeRenderer : GrammarNodeRendererBase
    {
        protected override string GetCaption(GraphNode node)
        {
            return "Entry";
        }

        protected override Color GetPinColor(GraphNode node)
        {
            return new Color(0.1f, 0.4f, 0.4f);
        }

        protected override Color GetBodyColor(GraphNode node)
        {
            return new Color(0.1f, 0.1f, 0.1f, 1);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\NodeRenderers\GrammarExecRuleNodeRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI;
using DungeonArchitect.Grammar;
using DungeonArchitect.Graphs;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class GrammarExecRuleNodeRenderer : GrammarNodeRendererBase
    {
        protected override string GetCaption(GraphNode node)
        {
            var ruleNode = node as GrammarExecRuleNode;
            var rule = (ruleNode != null) ? ruleNode.rule : null;
            return (rule != null) ? rule.ruleName : "[DELETED]";
        }

        protected override Color GetPinColor(GraphNode node)
        {
            var ruleNode = node as GrammarExecRuleNode;
            var rule = (ruleNode != null) ? ruleNode.rule : null;
            return (rule != null) ? new Color(0.3f, 0.3f, 0.5f) : Color.red;
        }

        protected override Color GetBodyColor(GraphNode node)
        {
            var ruleNode = node as GrammarExecRuleNode;
            var prodRule = (ruleNode != null) ? ruleNode.rule : null;
            return (prodRule != null) ? new Color(0.1f, 0.1f, 0.1f, 1) : Color.red;
        }

        string GetModeText(GraphNode node)
        {
            if (node is GrammarExecRuleNode)
            {
                var execNode = node as GrammarExecRuleNode;
                if (execNode.runMode == GrammarExecRuleRunMode.RunOnce)
                {
                    return "Run Once";
                }
                else if (execNode.runMode == GrammarExecRuleRunMode.RunWithProbability)
                {
                    return string.Format("Run Probability: {0}", execNode.runProbability);
                }
                else if (execNode.runMode == GrammarExecRuleRunMode.Iterate)
                {
                    return string.Format("Run {0} times", execNode.iterateCount);
                }
                else if (execNode.runMode == GrammarExecRuleRunMode.IterateRange)
                {
                    return string.Format("Run {0}-{1} times", execNode.minIterateCount, execNode.maxIterateCount);
                }

                return execNode.runMode.ToString();
            }
            return "";
        }

        GUIStyle GetModeStyle(GUIStyle style)
        {
            var modeStyle = new GUIStyle(style);
            modeStyle.fontSize = 12;
            return modeStyle;
        }

        struct ExecRuleNodeLayoutInfo
        {
            public GUIContent messageContent;
            public Vector2 messageSize;
            public GUIStyle messageStyle;

            public GUIContent modeContent;
            public Vector2 modeSize;
            public GUIStyle modeStyle;
        }

        ExecRuleNodeLayoutInfo CalcLayoutInfo(GraphNode node, GUIStyle style)
        {
            var layout = new ExecRuleNodeLayoutInfo();

            // Calculate the message size
            {
                string nodeMessage = GetCaption(node);

                layout.messageContent = new GUIContent(nodeMessage);
                layout.messageSize = style.CalcSize(layout.messageContent);
                layout.messageStyle = style;
            }

            // Calculate the mode size
            {
                var modeStyle = GetModeStyle(style);
                modeStyle.font = EditorStyles.standardFont;
                modeStyle.fontSize = Mathf.RoundToInt(style.fontSize * 0.8f);
                string modeText = GetModeText(node);

                layout.modeContent = new GUIContent(modeText);
                layout.modeSize = modeStyle.CalcSize(layout.modeContent);
                layout.modeStyle = modeStyle;
            }

            return layout;
        }

        protected override Vector2 GetContentScreenSize(GraphNode node, GUIStyle style)
        {
            var layout = CalcLayoutInfo(node, style);

            var size = new Vector2(
                Mathf.Max(layout.messageSize.x, layout.modeSize.x),
                layout.messageSize.y + layout.modeSize.y);

            return size;
        }

        protected override void DrawNodeContent(UIRenderer renderer, GraphNode node, GUIStyle style, Rect bounds)
        {
            var layout = CalcLayoutInfo(node, style);
            layout.messageStyle.normal.textColor = Color.white;
            layout.modeStyle.normal.textColor = Color.white;

            var messageOffsetX = Mathf.Max(0, (bounds.width - layout.messageSize.x) * 0.5f);
            var modeOffsetX = Mathf.Max(0, (bounds.width - layout.modeSize.x) * 0.5f);

            var messageBounds = new Rect(bounds.position + new Vector2(messageOffsetX, 0), layout.messageSize);
            renderer.Label(messageBounds, layout.messageContent, layout.messageStyle);

            var modeBounds = new Rect(bounds.position + new Vector2(modeOffsetX, layout.messageSize.y), layout.modeSize);
            renderer.Label(modeBounds, layout.modeContent, layout.modeStyle);
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\NodeRenderers\GrammarNodeRendererBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI;
using DungeonArchitect.Grammar;
using DungeonArchitect.Graphs;
using UnityEditor;
using UnityEngine;
using DMathUtils = DungeonArchitect.Utils.MathUtils;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.SnapFlow
{

    public abstract class GrammarNodeRendererBase : GraphNodeRenderer
    {
        protected abstract string GetCaption(GraphNode node);
        protected abstract Color GetPinColor(GraphNode node);
        protected virtual Color GetBodyColor(GraphNode node)
        {
            return new Color(0.1f, 0.1f, 0.1f, 1);
        }

        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            var pinColor = GetPinColor(node);

            NodeBoundLayoutData layoutData;
            {
                // Update the node bounds
                var style = GetNodeStyle(node, camera.ZoomLevel);
                var contentScreenSize = GetContentScreenSize(node, style);
                UpdateNodeBounds(node, camera.ZoomLevel, contentScreenSize, style, out layoutData);
            }
            
            // Draw the pins
            DrawPins(renderer, rendererContext, node, camera, pinColor);

            // Draw the node body
            DrawNodeBody(renderer, layoutData, node, camera);
        }

        void DrawPins(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera, Color nodeColor)
        {
            var outputPin = node.OutputPin;
            var nodeSize = node.Bounds.size;
            var offset = nodeSize / 2.0f;
            outputPin.Position = offset;
            outputPin.BoundsOffset = new Rect(-offset, nodeSize);

            var inputPin = node.InputPin;
            inputPin.Position = offset;
            inputPin.BoundsOffset = outputPin.BoundsOffset;

            DrawPin(renderer, rendererContext, outputPin, camera, nodeColor);
        }

        class GrammarNodeEditorConstants
        {
            public static readonly Color PIN_COLOR_HOVER = new Color(1, 0.6f, 0.0f);
            public static readonly Color PIN_COLOR_CLICK = new Color(1, 0.9f, 0.0f);
            public static readonly Color FOCUS_HIGHLITE_COLOR = new Color(1, 0.5f, 0, 1);
            public static readonly Vector2 BASE_PADDING = new Vector2(16, 16);
        }

        static Color GetPinColor(GraphPin pin, Color nodeColor)
        {
            Color color;
            if (pin.ClickState == GraphPinMouseState.Clicked)
            {
                color = GrammarNodeEditorConstants.PIN_COLOR_CLICK;
            }
            else if (pin.ClickState == GraphPinMouseState.Hover)
            {
                color = GrammarNodeEditorConstants.PIN_COLOR_HOVER;
            }
            else
            {
                color = nodeColor;
            }
            return color;
        }

        void DrawPin(UIRenderer renderer, GraphRendererContext rendererContext, GraphPin pin, GraphCamera camera, Color nodeColor)
        {
            if (pin.Node == null)
            {
                Debug.Log("pin node null. skipping");
                return;

            }
            var guiState = new GUIState(renderer);

            var pinBounds = new Rect(pin.GetBounds());
            var positionWorld = pin.Node.Position + pinBounds.position;
            var positionScreen = camera.WorldToScreen(positionWorld);
            pinBounds.position = positionScreen;
            pinBounds.size /= camera.ZoomLevel;

            if (pin.Node != null && pin.Node.Selected)
            {
                var focusboundsScreen = DMathUtils.ExpandRect(pinBounds, 2);
                renderer.DrawRect(focusboundsScreen, GrammarNodeEditorConstants.FOCUS_HIGHLITE_COLOR);
            }

            renderer.DrawRect(pinBounds, GetPinColor(pin, nodeColor));

            guiState.Restore();

        }

        public void UpdateNodeBounds(GraphNode node, float zoomLevel)
        {
            var style = GetNodeStyle(node, zoomLevel);
            var contentScreenSize = GetContentScreenSize(node, style);
            NodeBoundLayoutData layoutData;
            UpdateNodeBounds(node, zoomLevel, contentScreenSize, style, out layoutData);
        }

        struct NodeBoundLayoutData
        {
            public Vector2 screenTextSize;
            public Vector2 screenNodeSize;
        }
        static void UpdateNodeBounds(GraphNode node, float zoomLevel, Vector2 contentScreenSize, GUIStyle style, out NodeBoundLayoutData outLayoutData)
        {
            var screenPadding = GrammarNodeEditorConstants.BASE_PADDING / zoomLevel;
            var screenTextSize = contentScreenSize;
            var screenNodeSize = screenTextSize + screenPadding * 2;
            var updateWorldSize = screenNodeSize * zoomLevel;
            var nodeBounds = node.Bounds;
            nodeBounds.size = updateWorldSize;
            node.Bounds = nodeBounds;

            outLayoutData = new NodeBoundLayoutData();
            outLayoutData.screenTextSize = screenTextSize;
            outLayoutData.screenNodeSize = screenNodeSize;
        }

        public static GUIStyle GetNodeStyle(GraphNode node, float zoomLevel)
        {
            var style = new GUIStyle(EditorStyles.boldLabel);
            style.alignment = TextAnchor.UpperLeft;

            style.normal.textColor = node.Selected ? GraphEditorConstants.TEXT_COLOR_SELECTED : GraphEditorConstants.TEXT_COLOR;

            {
                style.font = EditorStyles.boldFont;
                float scaledFontSize = style.fontSize == 0 ? style.font.fontSize : style.fontSize;
                scaledFontSize = Mathf.Max(1.0f, scaledFontSize / zoomLevel);
                style.fontSize = Mathf.RoundToInt(scaledFontSize);
            }
            return style;
        }

        protected virtual Vector2 GetContentScreenSize(GraphNode node, GUIStyle style)
        {
            string nodeMessage = GetCaption(node);
            var content = new GUIContent(nodeMessage);
            return style.CalcSize(content);
        }

        protected virtual void DrawNodeContent(UIRenderer renderer, GraphNode node, GUIStyle style, Rect bounds)
        {
            string nodeMessage = GetCaption(node);
            var content = new GUIContent(nodeMessage);

            Color textColor = Color.white;
            style.normal.textColor = textColor;
            renderer.Label(bounds, content, style);
        }

        void DrawNodeBody(UIRenderer renderer, NodeBoundLayoutData layoutData, GraphNode node, GraphCamera camera)
        {
            var style = GetNodeStyle(node, camera.ZoomLevel);

            var guiState = new GUIState(renderer);
            Color nodeColor = GetBodyColor(node);

            var outputPin = node.OutputPin as GrammarNodePin;
            var pinPadding = new Vector2(12, 12);
            var screenPinPadding = pinPadding / camera.ZoomLevel;
            if (outputPin != null)
            {
                outputPin.Padding = pinPadding;
            }

            // Draw the node pin
            Rect boxBounds;
            {
                var positionScreen = camera.WorldToScreen(node.Position + pinPadding);
                var sizeScreen = layoutData.screenNodeSize - screenPinPadding * 2;
                boxBounds = new Rect(positionScreen, sizeScreen);
            }
            renderer.DrawRect(boxBounds, nodeColor);

            // Draw the node content
            Rect textBounds;
            {
                var positionScreen = camera.WorldToScreen(node.Position + GrammarNodeEditorConstants.BASE_PADDING);
                var sizeScreen = layoutData.screenTextSize;
                textBounds = new Rect(positionScreen, sizeScreen);
            }

            DrawNodeContent(renderer, node, style, textBounds);

            guiState.Restore();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\SnapEditor\Widgets\GraphEditors\NodeRenderers\GrammarTaskNodeRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Grammar;
using DungeonArchitect.Graphs;
using UnityEngine;
using DMathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Editors.SnapFlow
{
    public class GrammarTaskNodeRenderer : GrammarNodeRendererBase
    {
        protected override Color GetPinColor(GraphNode node)
        {
            var taskNode = node as GrammarTaskNode;

            var nodeColor = (taskNode != null && taskNode.NodeType != null)
                ? taskNode.NodeType.nodeColor : new Color(0.2f, 0.3f, 0.3f);
            return nodeColor;
        }

        protected override Color GetBodyColor(GraphNode node)
        {
            var taskNode = node as GrammarTaskNode;
            var nodeType = (taskNode != null) ? taskNode.NodeType : null;
            return (nodeType != null) ? new Color(0.1f, 0.1f, 0.1f, 1) : Color.red;
        }

        protected override string GetCaption(GraphNode node)
        {
            var taskNode = node as GrammarTaskNode;
            var nodeType = (taskNode != null) ? taskNode.NodeType : null;

            if (nodeType == null)
            {
                return "[DELETED]";
            }

            var nodeMessage = nodeType.nodeName;
            if (taskNode.DisplayExecutionIndex)
            {
                nodeMessage = string.Format("{0}:{1}", nodeMessage, taskNode.executionIndex);
            }
            return nodeMessage;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\Implementations\BSPThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
 using DungeonArchitect.Builders.BSP;
 using DungeonArchitect.Themeing;
 using UnityEngine;
 
 namespace DungeonArchitect.Editors.Visualization.Implementation
 {
     public class BSPThemeMarkerVisualizationBuilder : ThemeMarkerVisualizationBuilderBase, IThemeMarkerVisualizationBuilder
     {
         public bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
         {
             localGeometry = null;
             material = null;
             if (dungeon == null)
             {
                 return false;
             }
 
             var builder = dungeon.GetComponent<BSPDungeonBuilder>();
             var config = dungeon.GetComponent<BSPDungeonConfig>();
             var model = dungeon.GetComponent<BSPDungeonModel>();
             
             if (builder == null || config == null || model == null)
             {
                 return false;
             }
             
             var gridSize = config.gridSize;
             
             if (markerName == BSPDungeonMarkerNames.GroundRoom || markerName == BSPDungeonMarkerNames.GroundCorridor) 
             {
                 CreateGroundGeometry(gridSize.x, gridSize.y, out localGeometry, out material);
                 return true;
             }
             
             if (markerName == BSPDungeonMarkerNames.Door ||
                 markerName == BSPDungeonMarkerNames.WallRoom ||
                 markerName == BSPDungeonMarkerNames.WallCorridor) 
             {
                 var size = gridSize.x;
                 CreateWallGeometry(size, size, out localGeometry, out material);
                 return true;
             }
             
             if (markerName == BSPDungeonMarkerNames.WallSeparator)
             {
                 var radius = gridSize.x * 0.1f;
                 CreatePillarGeometry(radius, out localGeometry, out material);
                 return true;
             }

 
             return false;
         }
     }
 }
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\Implementations\FloorPlanThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.FloorPlan;
using DungeonArchitect.Themeing;
using UnityEngine;

namespace DungeonArchitect.Editors.Visualization.Implementation
{
    public class FloorPlanThemeMarkerVisualizationBuilder : ThemeMarkerVisualizationBuilderBase, IThemeMarkerVisualizationBuilder
    {
        public bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
        {
            localGeometry = null;
            material = null;
            if (dungeon == null)
            {
                return false;
            }

            var builder = dungeon.GetComponent<FloorPlanBuilder>();
            var config = dungeon.GetComponent<FloorPlanConfig>();
            var model = dungeon.GetComponent<FloorPlanModel>();
            
            if (builder == null || config == null || model == null)
            {
                return false;
            }
            
            var gridSize = config.GridSize;
            
            if (markerName == FloorPlanMarkerNames.Ground || markerName == FloorPlanMarkerNames.Ceiling) 
            {
                CreateGroundGeometry(gridSize.x, gridSize.z, out localGeometry, out material);
                return true;
            }
            
            if (markerName == FloorPlanMarkerNames.Wall ||
                markerName == FloorPlanMarkerNames.Door ||
                markerName == FloorPlanMarkerNames.BuildingWall) 
            {
                CreateWallGeometry(gridSize.x, 4, out localGeometry, out material);
                return true;
            }

            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\Implementations\GridFlowThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.GridFlow;
using DungeonArchitect.Themeing;
using UnityEngine;

namespace DungeonArchitect.Editors.Visualization.Implementation
{
    public class GridFlowThemeMarkerVisualizationBuilder : ThemeMarkerVisualizationBuilderBase, IThemeMarkerVisualizationBuilder
    {
        public bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
        {
            localGeometry = null;
            material = null;
            if (dungeon == null)
            {
                return false;
            }

            var builder = dungeon.GetComponent<GridFlowDungeonBuilder>();
            var config = dungeon.GetComponent<GridFlowDungeonConfig>();
            var model = dungeon.GetComponent<GridFlowDungeonModel>();
            
            if (builder == null || config == null || model == null)
            {
                return false;
            }
            
            var gridSize = config.gridSize;
            var wallsAsEdges = model.wallsAsEdges;
            
            if (markerName == GridFlowDungeonMarkerNames.Ground) 
            {
                CreateGroundGeometry(gridSize.x, gridSize.z, out localGeometry, out material);
                return true;
            }
            
            if (markerName == GridFlowDungeonMarkerNames.Wall || 
                markerName == GridFlowDungeonMarkerNames.Door || 
                markerName == GridFlowDungeonMarkerNames.DoorOneWay) 
            {
                if (wallsAsEdges)
                {
                    CreateWallGeometry(gridSize.x, 4, out localGeometry, out material);
                }
                else
                {
                    CreateGroundGeometry(gridSize.x, gridSize.z, out localGeometry, out material);
                }
                return true;
            }

            if (markerName == GridFlowDungeonMarkerNames.Fence) 
            {
                CreateWallGeometry(gridSize.x, 2, out localGeometry, out material);
                return true;
            }
            
            if (markerName == GridFlowDungeonMarkerNames.WallSeparator || 
                markerName == GridFlowDungeonMarkerNames.FenceSeparator)
            {
                var radius = gridSize.x * 0.1f;
                CreatePillarGeometry(radius, out localGeometry, out material);
                return true;
            }

            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\Implementations\GridThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.Grid;
using DungeonArchitect.Themeing;
using UnityEngine;

namespace DungeonArchitect.Editors.Visualization.Implementation
{
    public class GridThemeMarkerVisualizationBuilder : ThemeMarkerVisualizationBuilderBase, IThemeMarkerVisualizationBuilder
    {
        public bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material) 
        {
            localGeometry = null;
            material = null;
            if (dungeon == null)
            {
                return false;
            }

            var builder = dungeon.GetComponent<GridDungeonBuilder>();
            var config = dungeon.GetComponent<GridDungeonConfig>();
            if (builder == null || config == null)
            {
                return false;
            }
            
            var gridSize = config.GridCellSize;

            if (markerName == GridDungeonMarkerNames.Ground) 
            {
                CreateGroundGeometry(gridSize.x, gridSize.z, out localGeometry, out material);
                return true;
            }
            
            if (markerName == GridDungeonMarkerNames.Wall || markerName == GridDungeonMarkerNames.Door) 
            {
                CreateWallGeometry(gridSize.x, 4, out localGeometry, out material);
                return true;
            }

            if (markerName == GridDungeonMarkerNames.Fence) 
            {
                CreateWallGeometry(gridSize.x, 2, out localGeometry, out material);
                return true;
            }
            
            if (markerName == GridDungeonMarkerNames.WallHalf) 
            {
                CreateWallGeometry(gridSize.x, gridSize.y, out localGeometry, out material);
                ApplyOffset(new Vector3(0, -gridSize.y, 0), localGeometry);
                return true;
            }
            
            if (markerName == GridDungeonMarkerNames.Stair) 
            {
                CreateGroundGeometry(gridSize.x, gridSize.z, out localGeometry, out material);
                localGeometry.Vertices[1].y = gridSize.y;
                localGeometry.Vertices[2].y = gridSize.y;
                return true;
            }

            if (markerName == GridDungeonMarkerNames.Stair2X) 
            {
                CreateGroundGeometry(gridSize.x, gridSize.z, out localGeometry, out material);
                localGeometry.Vertices[1].y = gridSize.y * 2;
                localGeometry.Vertices[2].y = gridSize.y * 2;
                return true;
            }

            if (markerName == GridDungeonMarkerNames.WallSeparator || 
                markerName == GridDungeonMarkerNames.FenceSeparator || 
                markerName == GridDungeonMarkerNames.RoomWallSeparator)
            {
                var radius = gridSize.x * 0.1f;
                CreatePillarGeometry(radius, out localGeometry, out material);
                return true;
            }
            
            if (markerName == GridDungeonMarkerNames.WallHalfSeparator) 
            {
                var radius = gridSize.x * 0.1f;
                CreatePillarGeometry(radius, out localGeometry, out material);
                ApplyOffset(new Vector3(0, -gridSize.y, 0), localGeometry);
                return true;
            }

            return false;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\Implementations\IsaacThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.Isaac;
using DungeonArchitect.Themeing;
using UnityEngine;
 
 namespace DungeonArchitect.Editors.Visualization.Implementation
 {
     public class IsaacThemeMarkerVisualizationBuilder : ThemeMarkerVisualizationBuilderBase, IThemeMarkerVisualizationBuilder
     {
         public bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
         {
             localGeometry = null;
             material = null;
             if (dungeon == null)
             {
                 return false;
             }
 
             var builder = dungeon.GetComponent<IsaacDungeonBuilder>();
             var config = dungeon.GetComponent<IsaacDungeonConfig>();
             var model = dungeon.GetComponent<IsaacDungeonModel>();
             
             if (builder == null || config == null || model == null)
             {
                 return false;
             }
             
             var gridSize = config.tileSize;
             
             if (markerName == IsaacDungeonMarkerNames.Ground ||
                 markerName == IsaacDungeonMarkerNames.Door ||
                 markerName == IsaacDungeonMarkerNames.Wall) 
             {
                 CreateGroundGeometry(gridSize.x, gridSize.y, out localGeometry, out material);
                 return true;
             }
             
             return false;
         }
     }
 }
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\Implementations\MarioThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.Mario;
using DungeonArchitect.Themeing;
using UnityEngine;

namespace DungeonArchitect.Editors.Visualization.Implementation
{
    public class MarioThemeMarkerVisualizationBuilder : ThemeMarkerVisualizationBuilderBase, IThemeMarkerVisualizationBuilder
    {
        public bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
        {
            localGeometry = null;
            material = null;
            if (dungeon == null)
            {
                return false;
            }

            var builder = dungeon.GetComponent<MarioDungeonBuilder>();
            var config = dungeon.GetComponent<MarioDungeonConfig>();
            var model = dungeon.GetComponent<MarioDungeonModel>();

            if (builder == null || config == null || model == null)
            {
                return false;
            }

            var gridSize = config.gridSize;

            if (markerName == MarioDungeonMarkerNames.Ground ||
                markerName == MarioDungeonMarkerNames.BackgroundGround ||
                markerName == MarioDungeonMarkerNames.BackgroundCeiling ||
                markerName == MarioDungeonMarkerNames.Corridor)
            {
                CreateGroundGeometry(gridSize.x, gridSize.z, out localGeometry, out material);
                return true;
            }

            if (markerName == MarioDungeonMarkerNames.WallFront ||
                markerName == MarioDungeonMarkerNames.WallBack ||
                markerName == MarioDungeonMarkerNames.WallSide ||
                markerName == MarioDungeonMarkerNames.BackgroundWall)
            {
                CreateWallGeometry(gridSize.x, gridSize.y, out localGeometry, out material);
                return true;
            }

            if (markerName == MarioDungeonMarkerNames.Stair)
            {
                CreateGroundGeometry(gridSize.x, gridSize.z, out localGeometry, out material);
                localGeometry.Vertices[1].y = gridSize.y;
                localGeometry.Vertices[2].y = gridSize.y;
                return true;
                
            }
            return false;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\Implementations\MazeThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
 using DungeonArchitect.Builders.Maze;
 using DungeonArchitect.Themeing;
 using UnityEngine;
 
 namespace DungeonArchitect.Editors.Visualization.Implementation
 {
     public class MazeThemeMarkerVisualizationBuilder : ThemeMarkerVisualizationBuilderBase, IThemeMarkerVisualizationBuilder
     {
         public bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
         {
             localGeometry = null;
             material = null;
             if (dungeon == null)
             {
                 return false;
             }
 
             var builder = dungeon.GetComponent<MazeDungeonBuilder>();
             var config = dungeon.GetComponent<MazeDungeonConfig>();
             var model = dungeon.GetComponent<MazeDungeonModel>();
             
             if (builder == null || config == null || model == null)
             {
                 return false;
             }
             
             var gridSize = config.gridSize;
             
             if (markerName == MazeDungeonMarkerNames.GroundBlock || markerName == MazeDungeonMarkerNames.WallBlock) 
             {
                 CreateGroundGeometry(gridSize.x, gridSize.y, out localGeometry, out material);
                 return true;
             }
             
             return false;
         }
     }
 }
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\ThemeEditor\Visualization\MarkerVisualizers\Implementations\SimpleCityThemeMarkerVisualizationBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Builders.SimpleCity;
using DungeonArchitect.Themeing;
using UnityEngine;

namespace DungeonArchitect.Editors.Visualization.Implementation
{
    public class SimpleCityThemeMarkerVisualizationBuilder : ThemeMarkerVisualizationBuilderBase, IThemeMarkerVisualizationBuilder
    {
        public bool Build(Dungeon dungeon, string markerName, out ThemeEditorVisMarkerGeometry localGeometry, out Material material)
        {
            localGeometry = null;
            material = null;
            if (dungeon == null)
            {
                return false;
            }
            
            var builder = dungeon.GetComponent<SimpleCityDungeonBuilder>();
            var config = dungeon.GetComponent<SimpleCityDungeonConfig>();
            
            if (builder == null || config == null)
            {
                return false;
            }
            
            var gridSize = config.CellSize;
            
            if (markerName == SimpleCityDungeonMarkerNames.House ||
                markerName == SimpleCityDungeonMarkerNames.Park ||
                markerName == SimpleCityDungeonMarkerNames.Road_X ||
                markerName == SimpleCityDungeonMarkerNames.Road_T ||
                markerName == SimpleCityDungeonMarkerNames.Road_Corner ||
                markerName == SimpleCityDungeonMarkerNames.Road_S ||
                markerName == SimpleCityDungeonMarkerNames.Road_E ||
                markerName == SimpleCityDungeonMarkerNames.Road ||
                markerName == SimpleCityDungeonMarkerNames.CityWall ||
                markerName == SimpleCityDungeonMarkerNames.CityDoor ||
                markerName == SimpleCityDungeonMarkerNames.CityGround ||
                markerName == SimpleCityDungeonMarkerNames.CornerTower ||
                markerName == SimpleCityDungeonMarkerNames.CityWallPadding) 
            {
                CreateGroundGeometry(gridSize.x, gridSize.y, out localGeometry, out material);
                return true;
            }
            

            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\MarkerGenRuleGraphNodeActionBase.cs:
 using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator.Nodes.Actions.Info;
using DungeonArchitect.MarkerGenerator.Pins;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Nodes
{
    public abstract class MarkerGenRuleGraphNodeActionBase : MarkerGenRuleGraphNode
    {
        public override Color BodyColor => new Color(0.1f, 0.1f, 0.2f);
        public override Color TitleColor => new Color(0.1f, 0.2f, 0.3f);
        
        protected override void CreateDefaultPins()
        {
            CreateInputPin("");
            CreateOutputPin("");
        }

        protected void CreateInputPin(string pinName)
        {
            var pin = CreatePinOfType<MarkerGenRuleGraphPinExec>(GraphPinType.Input);
            pin.text = pinName;
        }
        
        protected void CreateOutputPin(string pinName)
        {
            var pin = CreatePinOfType<MarkerGenRuleGraphPinExec>(GraphPinType.Output);
            pin.text = pinName;
        }

        public virtual MarkerGenRuleActionInfo CreateActionInfo()
        {
            return null;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\MarkerGenRuleGraphNodeConditionBase.cs:
 using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator.Pins;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Nodes
{
    public abstract class MarkerGenRuleGraphNodeConditionBase : MarkerGenRuleGraphNode
    {
        public override Color BodyColor => new Color(0.15f, 0.1f, 0.1f);
        public override Color TitleColor => new Color(0.3f, 0.1f, 0.1f);

        protected void CreateInputPin(string pinName)
        {
            var pin = CreatePinOfType<MarkerGenRuleGraphPinBool>(GraphPinType.Input);
            pin.text = pinName;
        }
        
        protected void CreateOutputPin(string pinName)
        {
            var pin = CreatePinOfType<MarkerGenRuleGraphPinBool>(GraphPinType.Output);
            pin.text = pinName;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Pins\MarkerGenRuleGraphPin.cs:
 using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Pins
{
    public abstract class MarkerGenRuleGraphPin : GraphPin
    {
        public string text = "";
        
        public virtual Color GetPinColor()
        {
            return Color.white;
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Pins\MarkerGenRuleGraphPinBool.cs:
 using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Pins
{
    public class MarkerGenRuleGraphPinBool : MarkerGenRuleGraphPin
    {
        public bool defaultValue = true;

        public override Color GetPinColor()
        {
            if (ClickState == GraphPinMouseState.Hover)
            {
                return new Color(1.0f, 0.5f, 0.1f);
            }
            else if (ClickState == GraphPinMouseState.Clicked)
            {
                return new Color(0.9f, 0.1f, 0.1f);
            }
            
            return Color.red;
        }
    } 
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Pins\MarkerGenRuleGraphPinExec.cs:
 using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Pins
{
    public class MarkerGenRuleGraphPinExec : MarkerGenRuleGraphPin
    {

        public override Color GetPinColor()
        {
            if (ClickState == GraphPinMouseState.Hover)
            {
                return new Color(0.5f, 1.0f, 1.0f);
            }
            else if (ClickState == GraphPinMouseState.Clicked)
            {
                return new Color(1.0f, 1.0f, 1.0f);
            }
            
            return Color.white;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Impl\Grid\GridAssenblies.cs:
 using System.Collections.Generic;
using DungeonArchitect.MarkerGenerator.Grid;
using DungeonArchitect.MarkerGenerator.Nodes.Actions.Info;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Rule.Grid.Assemblies
{
    public class GridMarkerGenRuleAssembly
    {
        public Vector2Int Coord;
        public GridMarkerGenRuleType RuleType;
        public GridMarkerGenRule Rule;
        public bool HintWillInsertAssetHere;


        public GridMarkerGenRuleAssembly Clone()
        {
            return new GridMarkerGenRuleAssembly()
            {
                Coord = Coord,
                RuleType = RuleType,
                Rule = Rule,
                HintWillInsertAssetHere = HintWillInsertAssetHere,
            };
        }
    }
    
    public class GridMarkerGenPatternAssembly
    {
        public GridMarkerGenRuleAssembly[] Rules = System.Array.Empty<GridMarkerGenRuleAssembly>();
        public Vector2Int BoundsMin = Vector2Int.zero;
        public Vector2Int BoundsMax = Vector2Int.zero;
        public float RotationAngleRad = 0;
        public int Rotation90Index = 0;

        public GridMarkerGenPatternAssembly()
        {
        }
        
        public GridMarkerGenPatternAssembly(GridMarkerGenPatternAssembly other)
        {
            BoundsMin = other.BoundsMin;
            BoundsMax = other.BoundsMax;
            RotationAngleRad = other.RotationAngleRad;
            Rotation90Index = other.Rotation90Index;
            Rules = new GridMarkerGenRuleAssembly[other.Rules.Length];
            for (int i = 0; i < Rules.Length; i++)
            {
                Rules[i] = other.Rules[i].Clone();
            }
        }
    }

    public class GridMarkerGenPatternAssemblyBuilder
    {
        public static GridMarkerGenPatternAssembly GenerateAssembly(GridMarkerGenPattern pattern)
        {
            var asm = new GridMarkerGenPatternAssembly();
            var asmRules = new List<GridMarkerGenRuleAssembly>();
            foreach (var rule in pattern.rules)
            {
                if (rule is GridMarkerGenRule gridRule)
                {
                    var asmRule = new GridMarkerGenRuleAssembly
                    {
                        Coord = gridRule.coord,
                        RuleType = gridRule.ruleType,
                        HintWillInsertAssetHere = gridRule.hintWillInsertAssetHere,
                        Rule = gridRule
                    };

                    if (!asmRule.HintWillInsertAssetHere)
                    {
                        // Check if we have a "Add Marker" action node in the rule graph
                        foreach (var actionInfo in rule.actions.actionList)
                        {
                            if (actionInfo is MarkerGenRuleActionInfoAddMarker)
                            {
                                asmRule.HintWillInsertAssetHere = true;
                            }
                        }
                    }

                    asmRules.Add(asmRule);
                }
            }

            asm.Rules = asmRules.ToArray();
            UpdateBounds(ref asm);

            return asm;
        }

        public static GridMarkerGenPatternAssembly RotateAssembly90(GridMarkerGenPatternAssembly assembly)
        {
            var rotatedAssembly = new GridMarkerGenPatternAssembly(assembly);
            rotatedAssembly.RotationAngleRad += 90;
            rotatedAssembly.Rotation90Index++;

            var rotation = Quaternion.AngleAxis(90, Vector3.up);
            foreach (var rotatedRule in rotatedAssembly.Rules)
            {
                if (rotatedRule.RuleType == GridMarkerGenRuleType.Corner) {
                    Vector3 offset = new Vector3(0.5f, 0.0f, 0.5f);
                    Vector3 oldLocation = new Vector3(rotatedRule.Coord.x, 0, rotatedRule.Coord.y) - offset;
                    Vector3 newLocation = rotation * oldLocation + offset;
                    rotatedRule.Coord = new Vector2Int(
                        Mathf.RoundToInt(newLocation.x),
                        Mathf.RoundToInt(newLocation.z));
                }
                else if (rotatedRule.RuleType == GridMarkerGenRuleType.Ground) {
                    Vector3 oldLocation = new Vector3(rotatedRule.Coord.x, 0, rotatedRule.Coord.y);
                    Vector3 newLocation = rotation * oldLocation;
                    rotatedRule.Coord = new Vector2Int(
                        Mathf.RoundToInt(newLocation.x),
                        Mathf.RoundToInt(newLocation.z));
                }
                else if (rotatedRule.RuleType == GridMarkerGenRuleType.EdgeX) {
                    Vector3 oldLocation = new Vector3(rotatedRule.Coord.x, 0, rotatedRule.Coord.y - 0.5f);
                    Vector3 newLocation = rotation * oldLocation + new Vector3(0.5f, 0, 0);;
                    rotatedRule.RuleType = GridMarkerGenRuleType.EdgeZ;
                    rotatedRule.Coord = new Vector2Int(
                        Mathf.RoundToInt(newLocation.x),
                        Mathf.RoundToInt(newLocation.z));
                }
                else if (rotatedRule.RuleType == GridMarkerGenRuleType.EdgeZ) {
                    Vector3 oldLocation = new Vector3(rotatedRule.Coord.x - 0.5f, 0, rotatedRule.Coord.y);
                    Vector3 newLocation = rotation * oldLocation + new Vector3(0, 0, 0.5f);;
                    rotatedRule.RuleType = GridMarkerGenRuleType.EdgeX;
                    rotatedRule.Coord = new Vector2Int(
                        Mathf.RoundToInt(newLocation.x),
                        Mathf.RoundToInt(newLocation.z));
                }
                else {
                    // Not supported
                    Debug.Assert(false, "Invalid state");
                }
            }

            return rotatedAssembly;
        }

        public static void UpdateBounds(ref GridMarkerGenPatternAssembly assembly)
        {
            if (assembly.Rules.Length == 0)
            {
                assembly.BoundsMin = Vector2Int.zero;
                assembly.BoundsMax = Vector2Int.zero;
                return;
            }

            assembly.BoundsMin = assembly.Rules[0].Coord;
            assembly.BoundsMax = assembly.Rules[0].Coord;
            foreach (var rule in assembly.Rules)
            {
                assembly.BoundsMin.x = Mathf.Min(assembly.BoundsMin.x, rule.Coord.x);
                assembly.BoundsMin.y = Mathf.Min(assembly.BoundsMin.y, rule.Coord.y);
                assembly.BoundsMax.x = Mathf.Max(assembly.BoundsMax.x, rule.Coord.x);
                assembly.BoundsMax.y = Mathf.Max(assembly.BoundsMax.y, rule.Coord.y);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Impl\Grid\GridMarkerGenPattern.cs:
 using System;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Grid
{
    public class GridMarkerGenPattern : MarkerGenPattern
    {
        [Tooltip(@"List of marker names that should be on the same level while testing for the pattern
* E.g. 1: If you add 'Ground' to the list, and if that marker exist at the location of any of the pattern rule blocks, they'll have to be on the same height, or the pattern won't match. This might be useful if you're inserting a larger ground tile (2x2) and don't want it to match with a adjacent ground tile of a different height
* E.g. 2: You're trying to turn a (Door-Wall) edge into a larger 2x Door. We don't want to match the pattern if the Wall and Door adjacent edges are on different heights, so you'd specify both 'Wall' and 'Door' in this list")]
        public string[] sameHeightMarkers = Array.Empty<string>();

        public bool expandMarkerDomain = false;
        public int expandMarkerDomainAmount = 0;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Impl\Grid\GridMarkerGenProcessor.cs:
 using System;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.MarkerGenerator.Grid;
using DungeonArchitect.MarkerGenerator.Nodes.Actions.Info;
using DungeonArchitect.MarkerGenerator.Rule.Grid;
using DungeonArchitect.MarkerGenerator.Rule.Grid.Assemblies;
using DungeonArchitect.MarkerGenerator.VM;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Processor.Grid
{
    public class GridMarkerGenProcessor : IMarkerGenProcessor
    {
        private Matrix4x4 dungeonTransform;
        private Vector3 gridSize;
        private ScriptInstanceCache<GridMarkerGenRuleUserScript> scriptCache;
        private DungeonBuilder dungeonBuilder;
        private DungeonModel dungeonModel;
        private DungeonConfig dungeonConfig;
        private DungeonQuery dungeonQuery;
        
        public GridMarkerGenProcessor(Matrix4x4 dungeonTransform, Vector3 gridSize, DungeonBuilder dungeonBuilder, DungeonModel dungeonModel, DungeonConfig dungeonConfig, DungeonQuery dungeonQuery)
        {
            this.dungeonTransform = dungeonTransform;
            this.gridSize = gridSize;
            scriptCache = new ScriptInstanceCache<GridMarkerGenRuleUserScript>();
            this.dungeonBuilder = dungeonBuilder;
            this.dungeonModel = dungeonModel;
            this.dungeonConfig = dungeonConfig;
            this.dungeonQuery = dungeonQuery;
        }

        public void Release()
        {
            if (scriptCache != null)
            {
                scriptCache.Release();
            }
        }
        
        struct PatternMatchCoord {
            public int X;
            public int Y;
            public int AsmIdx;
            public override string ToString()
            {
                return string.Format("({0}, {1}) - [{2}]", X, Y, AsmIdx);
            }
        }

        public bool Process(MarkerGenPattern pattern, PropSocket[] oldMarkers, System.Random random, out PropSocket[] newMarkers)
        {
            var gridPattern = pattern as GridMarkerGenPattern;
            if (gridPattern == null || !ShouldProcessAssembly(gridPattern))
            {
                newMarkers = Array.Empty<PropSocket>();
                return false;
            }

            var assemblies = new List<GridMarkerGenPatternAssembly>
            {
                GridMarkerGenPatternAssemblyBuilder.GenerateAssembly(gridPattern)
            };
            
            if (gridPattern.rotateToFit)
            {
                for (int i = 0; i < 3; i++)
                {
                    var asm = assemblies.Last();
                    var rotatedAsm = GridMarkerGenPatternAssemblyBuilder.RotateAssembly90(asm);
                    assemblies.Add(rotatedAsm);
                }
            }

            // Bring the markers to origin (by inverse multiplying it from the dungeon marker position
            TransformMarkers(dungeonTransform.inverse, oldMarkers);

            var boundsExpansion = gridPattern.expandMarkerDomain ? gridPattern.expandMarkerDomainAmount : 0;
            var markerList = new GridSceneMarkerList(gridSize, oldMarkers, boundsExpansion);
            var cellHeights = new GridSceneCellHeights(markerList, markerList.WorldOffset, markerList.WorldSize);

            var worldOffset = markerList.WorldOffset;
            var worldSize = markerList.WorldSize;

            var occupancyList = new GridSceneCellsBool(worldOffset, worldSize);

            var patternMatchCommands = new List<PatternMatchCoord>();
            for (int asmIdx = 0; asmIdx < assemblies.Count; asmIdx++) {
                var patternAsm = assemblies[asmIdx];
                GeneratePatternMatchCommands(patternAsm, asmIdx, worldOffset, worldSize, patternMatchCommands);
            }

            if (gridPattern.randomizeFittingOrder) {
                MathUtils.Shuffle(patternMatchCommands, random);
            }

            var matchedCommands = new List<PatternMatchCoord>();
            foreach (var cmd in patternMatchCommands) {
                if (gridPattern.probability > 0)
                {
                    var patternSettings = new ExecutePatternSettings()
                    {
                        SameHeightMarkers = gridPattern.sameHeightMarkers,
                        AllowInsertionOverlaps = gridPattern.allowInsertionOverlaps
                    };

                    if (ShouldExecutePattern(cmd.X, cmd.Y, assemblies[cmd.AsmIdx], patternSettings, occupancyList, markerList, cellHeights))
                    {
                        matchedCommands.Add(cmd);
                        
                        // Mark the occupied cells
                        MarkPatternOccupancy(cmd.X, cmd.Y, assemblies[cmd.AsmIdx], occupancyList);
                    }
                }
            }

            foreach (var cmd in matchedCommands)
            {
                if (random.NextFloat() <= gridPattern.probability)
                {
                    ExecutePattern(cmd.X, cmd.Y, assemblies[cmd.AsmIdx], markerList, cellHeights);
                }
            }

            newMarkers = markerList.GenerateMarkerList();
            TransformMarkers(dungeonTransform, newMarkers);
            return true;
        }

        struct ExecutePatternSettings
        {
            public bool AllowInsertionOverlaps;
            public string[] SameHeightMarkers;

        }

        private bool ShouldExecutePattern(int baseX, int baseY, GridMarkerGenPatternAssembly asm, ExecutePatternSettings patternSettings,
            GridSceneCellsBool occupancyList,
            GridSceneMarkerList markerList, GridSceneCellHeights cellHeights)
        {
            bool shouldExecutePattern = true;

            // We'll insert a geometry here.  Make sure it wasn't inserted already in this layer
            if (!patternSettings.AllowInsertionOverlaps)
            {
                foreach (var asmRule in asm.Rules)
                {
                    if (asmRule.Rule.IsAssetInsertedHere())
                    {
                        var worldCoord = new Vector2Int(baseX, baseY) + asmRule.Coord;
                        var cellOccupancy = occupancyList.GetValue(worldCoord);
                        if (cellOccupancy != null && cellOccupancy.IsOccupied(asmRule.RuleType))
                        {
                            // This insertion will overlap with a previous geometry we inserted in this layer
                            shouldExecutePattern = false;
                            break;
                        }
                    }
                }
            }

            // Check if the SameHeight constraint passes
            if (shouldExecutePattern && patternSettings.SameHeightMarkers.Length > 0)
            {
                var markersToCheck = new HashSet<string>(patternSettings.SameHeightMarkers);
                var markerHeights = new Dictionary<string, int>();
                foreach (var rule in asm.Rules)
                {
                    var worldCoord = new Vector2Int(baseX, baseY) + rule.Coord;
                    var cell = markerList.GetValue(worldCoord);
                    if (cell != null)
                    {
                        var cellMarkers = cell.GetMarkerList(rule.RuleType);
                        if (cellMarkers != null)
                        {
                            foreach (var markerInfo in cellMarkers)
                            {
                                if (markersToCheck.Contains(markerInfo.SocketType))
                                {
                                    var position = Matrix.GetTranslation(ref markerInfo.Transform);
                                    int markerCoordY = Mathf.RoundToInt(position.y / gridSize.y);
                                    if (markerHeights.ContainsKey(markerInfo.SocketType))
                                    {
                                        int existingCoordY = markerHeights[markerInfo.SocketType];
                                        if (markerCoordY != existingCoordY)
                                        {
                                            shouldExecutePattern = false;
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        markerHeights.Add(markerInfo.SocketType, markerCoordY);
                                    }
                                }
                            }
                        }
                    }

                    if (!shouldExecutePattern)
                    {
                        break;
                    }
                }
            }

            if (shouldExecutePattern)
            {
                foreach (var ruleAsm in asm.Rules)
                {
                    var coord = new Vector2Int(baseX, baseY) + ruleAsm.Coord;
                    var coordType = ruleAsm.RuleType;
                    var apiSettings = new GridMarkerGenVmAPISettings()
                    {
                        Coord = coord,
                        CoordType = coordType,
                        MarkerList = markerList,
                        DungeonTransform = dungeonTransform,
                        GridSize = gridSize,
                        Builder = dungeonBuilder,
                        Model = dungeonModel,
                        Config = dungeonConfig,
                        Query = dungeonQuery,
                        CellHeights = cellHeights,
                        ScriptInstanceCache = scriptCache
                    };
                    var api = new GridMarkerGenVmAPI(apiSettings);

                    var vm = new MarkerGenVM(api);

                    // Run the condition rule program
                    if (!vm.Run(ruleAsm.Rule.program, out var ruleGraphResult))
                    {
                        // The program didn't run successfully (i.e. didn't execute properly in the vm for some reason).  set the graph result to false
                        ruleGraphResult = false;
                    }

                    if (!ruleGraphResult)
                    {
                        // The rule graph did not pass. do not execute the actions on this pattern
                        shouldExecutePattern = false;
                        break;
                    }
                }
            }

            return shouldExecutePattern;
        }
        
        private void ExecutePattern(int baseX, int baseY, GridMarkerGenPatternAssembly asm, GridSceneMarkerList markerList, GridSceneCellHeights cellHeights)
        {
            var actionApi = new GridMarkerGenActionAPI(markerList, cellHeights);
            
            foreach (var ruleAsm in asm.Rules)
            {
                if (ruleAsm != null && ruleAsm.Rule != null && ruleAsm.Rule.actions != null && ruleAsm.Rule.actions.actionList != null)
                {
                    actionApi.State = new GridRuleActionAPIState
                    {
                        Coord = new Vector2Int(baseX, baseY) + ruleAsm.Coord,
                        CoordType = ruleAsm.RuleType,
                        BaseAngleRad = asm.RotationAngleRad,
                        Rotation90Index = asm.Rotation90Index
                    };
                    
                    foreach (var actionInfo in ruleAsm.Rule.actions.actionList)
                    {
                        if (actionInfo is MarkerGenRuleActionInfoAddMarker addMarkerAction)
                        {
                            actionApi.AddMarker(addMarkerAction);
                        }
                        else if (actionInfo is MarkerGenRuleActionInfoRemoveMarker removeMarkerAction)
                        {
                            actionApi.RemoveMarker(removeMarkerAction);
                        }
                    }
                }
            }
        }

        private void MarkPatternOccupancy(int baseX, int baseY, GridMarkerGenPatternAssembly asm, GridSceneCellsBool occupancyList)
        {
            foreach (var asmRule in asm.Rules) {
                if (asmRule.Rule.IsAssetInsertedHere())
                {
                    var worldCoord = new Vector2Int(baseX, baseY) + asmRule.Coord;
                    var cellOccupancy = occupancyList.GetValue(worldCoord);
                    cellOccupancy?.SetOccupied(asmRule.RuleType, true);
                }
            }
        }
        
        private class GridCellHeightCoords
        {
            public int GroundCoordY = 0;
            public int CornerCoordY = 0;
            public int EdgeXCoordY = 0;
            public int EdgeZCoordY = 0;
	
            public int GetHeight(GridMarkerGenRuleType coordType) {
                if (coordType == GridMarkerGenRuleType.Ground) {
                    return GroundCoordY;
                }
                else if (coordType == GridMarkerGenRuleType.Corner) {
                    return CornerCoordY;
                }
                else if (coordType == GridMarkerGenRuleType.EdgeX) {
                    return EdgeXCoordY;
                }
                else if (coordType == GridMarkerGenRuleType.EdgeZ) {
                    return EdgeZCoordY;
                }
                else {
                    Debug.LogError("Unsupported rule type"); // Not implemented
                    return 0;
                }
            }
        };
        
        private struct GridRuleActionAPIState {
            public Vector2Int Coord;
            public GridMarkerGenRuleType CoordType;
            public float BaseAngleRad;
            public int Rotation90Index;
        };

        class GridSceneCellHeights : GridSceneCells<GridCellHeightCoords>
        {
            struct QueueItem {
                public Vector2Int Coord;
                public int CoordY;
            };
            
            public GridSceneCellHeights(GridSceneMarkerList markerList, Vector2Int worldOffset, Vector2Int worldSize)
                : base(worldOffset, worldSize)
            {
                var cellHeight = Mathf.Max(1.0f, markerList.CellHeight);
                
                var visited = new HashSet<Vector2Int>();
                var queue = new Queue<QueueItem>();

                var coordStart = markerList.WorldOffset;
                var coordEnd = markerList.WorldOffset + markerList.WorldSize;
                
                // Run through the initial ground tiles and fill up the queue
                {
                
                    for (int z = coordStart.y; z < coordEnd.y; z++) {
                        for (int x = coordStart.x; x < coordEnd.x; x++) {
                            var cellCoord = new Vector2Int(x, z);
                            
                            var cell = markerList.GetValue(cellCoord);
                            if (cell == null || cell.TileMarkers.Count == 0) continue;
					
                            var groundLocation = Matrix.GetTranslation(ref cell.TileMarkers[0].Transform);
                            var coordY = Mathf.RoundToInt(groundLocation.y / cellHeight);
                            visited.Add(cellCoord);
                            queue.Enqueue(new QueueItem()
                            {
                                Coord = cellCoord,
                                CoordY = coordY
                            });
                        }
                    }
                }
                
                // Run a flood fill algorithm on the initial ground tiles
                {
                    var neighborDeltas = new Vector2Int[] {
                        new Vector2Int(-1, 0),
                        new Vector2Int(1, 0),
                        new Vector2Int(0, -1),
                        new Vector2Int(0, 1)
                    };
                    
                    while (queue.Count > 0)
                    {
                        var front = queue.Dequeue();
                        var cellCoordsZ = GetValue(front.Coord);
                        if (cellCoordsZ != null)
                        {
                            cellCoordsZ.GroundCoordY = front.CoordY;

                            // Add the neighbors
                            for (int d = 0; d < 4; d++)
                            {
                                var neighborCoord = front.Coord + neighborDeltas[d];
                                if (IsCoordValid(neighborCoord) && !visited.Contains(neighborCoord))
                                {
                                    visited.Add(neighborCoord);
                                    queue.Enqueue(new QueueItem()
                                    {
                                        Coord = neighborCoord,
                                        CoordY = front.CoordY
                                    });
                                }
                            }
                        }
                    }
                }

                // Fill up the rest of the coords (edges, corners) based on the ground tiles
                {
                    for (int z = coordStart.y; z < coordEnd.y; z++) {
                        for (int x = coordStart.x; x < coordEnd.x; x++) {
                            var baseCoord = new Vector2Int(x, z);
                            var c00 = GetValue(baseCoord + new Vector2Int(0, 0));
                            var c10 = GetValue(baseCoord + new Vector2Int(-1, 0));
                            var c01 = GetValue(baseCoord + new Vector2Int(0, -1));
                            var c11 = GetValue(baseCoord + new Vector2Int(-1, -1));
					
                            var xEdgeY = c00.GroundCoordY;
                            if (c01 != null)
                            {
                                xEdgeY = Mathf.Max(xEdgeY, c01.GroundCoordY);
                            }

                            var zEdgeY = c00.GroundCoordY;
                            if (c10 != null)
                            {
                                zEdgeY = Mathf.Max(xEdgeY, c10.GroundCoordY);
                            }

                            var cornerY = Mathf.Max(xEdgeY, zEdgeY);
                            if (c11 != null)
                            {
                                cornerY = Mathf.Max(cornerY, c11.GroundCoordY);
                            }

                            c00.EdgeXCoordY = xEdgeY;
                            c00.EdgeZCoordY = zEdgeY;
                            c00.CornerCoordY = cornerY;
                        }
                    }
                }
            }
        }
        
        private class GridMarkerGenActionAPI
        {
            public GridRuleActionAPIState State { get; set; }
            private GridSceneMarkerList markerList;
            private GridSceneCellHeights cellHeights;

            public GridMarkerGenActionAPI(GridSceneMarkerList markerList, GridSceneCellHeights cellHeights)
            {
                this.markerList = markerList;
                this.cellHeights = cellHeights;
            }

            public void AddMarker(MarkerGenRuleActionInfoAddMarker action)
            {
                if (markerList == null || action == null)
                {
                    return;
                }

                var cell = markerList.GetValue(State.Coord);
                if (cell == null)
                {
                    return;
                }

                if (cell.Contains(action.markerName, State.CoordType))
                {
                    // Already contains a marker
                    return;
                }
                
                var heights = cellHeights.GetValue(State.Coord);
                Debug.Assert(heights != null);
                
                var coordY = heights.GetHeight(State.CoordType);

                bool useRotationOverride = false;
                var rotationOverride = Quaternion.identity;
                if (action.copyRotationFromMarkers.Length > 0) {
                    var copyRotMarkerSet = new HashSet<string>(action.copyRotationFromMarkers);
                    var cellMarkerList = cell.GetMarkerList(State.CoordType);
                    if (cellMarkerList != null) {
                        foreach (var markerInfo in cellMarkerList) {
                            if (copyRotMarkerSet.Contains(markerInfo.SocketType)) {
                                rotationOverride = Matrix.GetRotation(ref markerInfo.Transform);
                                useRotationOverride = true;
                                break;
                            }
                        }
                    }
                }

                var markerRotation = useRotationOverride ? rotationOverride : GetWorldRotation();
				
                // Calculate the transform
                Matrix4x4 transform;
                {
                    markerList.GetCellToWorldCoords(State.Coord, coordY, State.CoordType, out var worldLocation);

                    if (action.copyHeightFromMarkers.Length > 0) {
                        var copyHeightMarkerSet = new HashSet<string>(action.copyHeightFromMarkers);
                        var cellMarkerList = cell.GetMarkerList(State.CoordType);
                        if (cellMarkerList != null) {
                            foreach (var markerInfo in cellMarkerList) {
                                if (copyHeightMarkerSet.Contains(markerInfo.SocketType)) {
                                    worldLocation.y = Matrix.GetTranslation(ref markerInfo.Transform).y;
                                    break;
                                }
                            }
                        }
                    }
					
                    transform = Matrix4x4.TRS(worldLocation, markerRotation, Vector3.one);
                }
				
                var mewMarker = new PropSocket
                {
                    Id = markerList.GenerateNextMarkerId(),
                    SocketType = action.markerName,
                    Transform = transform
                };

                cell.Add(mewMarker, State.CoordType);
            }

            public void RemoveMarker(MarkerGenRuleActionInfoRemoveMarker action)
            {
                if (markerList != null)
                {
                    var cell = markerList.GetValue(State.Coord);
                    if (cell != null)
                    {
                        cell.Remove(action.markerName, State.CoordType);
                    }
                }
            }
            
            Quaternion GetWorldRotation() {
                float angle = State.BaseAngleRad;
                if (State.Rotation90Index == 0 && State.CoordType == GridMarkerGenRuleType.EdgeZ)
                {
                    angle += 90; //Mathf.PI * 0.5f;
                }
                else if (State.Rotation90Index == 2 && State.CoordType == GridMarkerGenRuleType.EdgeZ)
                {
                    angle += 270; //Mathf.PI * 1.5f;
                }
                else if (State.Rotation90Index == 1 && State.CoordType == GridMarkerGenRuleType.EdgeX)
                {
                    angle += 90; //Mathf.PI * 0.5f;
                }
                else if (State.Rotation90Index == 3 && State.CoordType == GridMarkerGenRuleType.EdgeX)
                {
                    angle += 270; //Mathf.PI * 1.5f;
                }

                return Quaternion.AngleAxis(angle, Vector3.up);
            }

        }


        struct GridMarkerGenVmAPISettings
        {
            public Vector2Int Coord;
            public GridMarkerGenRuleType CoordType;
            public GridSceneMarkerList MarkerList;
            public Matrix4x4 DungeonTransform;
            public Vector3 GridSize;
            public DungeonBuilder Builder;
            public DungeonModel Model;
            public DungeonConfig Config;
            public DungeonQuery Query;
            public GridSceneCellHeights CellHeights;
            public ScriptInstanceCache<GridMarkerGenRuleUserScript> ScriptInstanceCache;
        }
        
        private class GridMarkerGenVmAPI : IMarkerGenVmAPI
        {
            private GridMarkerGenVmAPISettings settings;
            public GridMarkerGenVmAPI(GridMarkerGenVmAPISettings settings)
            {
                this.settings = settings;
            }

            public bool MarkerExists(string markerName)
            {
                if (settings.MarkerList != null)
                {
                    var cell = settings.MarkerList.GetValue(settings.Coord);
                    if (cell != null)
                    {
                        return cell.Contains(markerName, settings.CoordType);
                    }
                }

                return false;
            }

            Vector3 GetWorldPosition()
            {
                var heights = settings.CellHeights.GetValue(settings.Coord);
                var heightY = heights?.GetHeight(settings.CoordType) ?? 0;
                var coordF = new Vector3(settings.Coord.x, heightY, settings.Coord.y);
                var worldPos = Vector3.Scale(coordF, settings.GridSize);
                return settings.DungeonTransform * worldPos;
            }
            
            public bool ConditionScript(string scriptPath)
            {
                var script = settings.ScriptInstanceCache.GetScript(scriptPath);
                if (script == null)
                {
                    return false;
                }

                var validateParams = new GridMarkerGenRuleUserScript.ValidateSettings()
                {
                    Position = GetWorldPosition(),
                    Coord = settings.Coord,
                    CoordType = settings.CoordType,
                    DungeonTransform = settings.DungeonTransform,
                    Builder = settings.Builder,
                    Config = settings.Config,
                    Model = settings.Model,
                    Query = settings.Query
                };
                
                return script.Validate(validateParams);
            }
        }
        
        private void GeneratePatternMatchCommands(GridMarkerGenPatternAssembly asm, int asmIdx, Vector2Int worldOffset, Vector2Int worldSize, List<PatternMatchCoord> commands)
        {
            if (asm.Rules.Length == 0) {
                return;
            }

            var patternSize = asm.BoundsMax - asm.BoundsMin + new Vector2Int(1, 1);
            var startCoord = worldOffset - patternSize;
            var endCoord = worldOffset + worldSize;
	
            for (int y = startCoord.y; y <= endCoord.y; y++) {
                for (int x = startCoord.x; x <= endCoord.x; x++) {
                    commands.Add(new PatternMatchCoord
                    {
                        X = x, 
                        Y = y, 
                        AsmIdx = asmIdx
                    });
                }
            }
        }

        private bool ShouldProcessAssembly(GridMarkerGenPattern pattern)
        {
            if (pattern == null || pattern.rules.Length == 0)
            {
                return false;
            }

            foreach (var rule in pattern.rules)
            {
                if (rule == null || rule.program == null || !rule.program.compiled)
                {
                    continue;
                }

                if (rule.actions != null && rule.actions.actionList != null && rule.actions.actionList.Length > 0)
                {
                    // We have actions defined for this rule.  We need to process this pattern
                    return true;
                }
            }

            return false;
        }

        private void TransformMarkers(Matrix4x4 transform, PropSocket[] markers)
        {
            foreach (var marker in markers)
            {
                marker.Transform = transform * marker.Transform;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Impl\Grid\GridMarkerGenRule.cs:
 using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Rule.Grid
{
    public enum GridMarkerGenRuleType
    {
        Ground,
        EdgeX,
        EdgeZ,
        Corner
    }
    
    public class GridMarkerGenRule : MarkerGenRule
    {
        [HideInInspector]
        public Vector2Int coord;
        
        [HideInInspector]
        public GridMarkerGenRuleType ruleType;
        
        [Tooltip(@"Tell the system that you'll be inserting an art asset at this location.  By default, if the rule graph emits a marker (EmitMarker action node), it would know that this position would be occupied by an art asset and you can ignore this flag.    In cases where you'd insert a larger asset, e.g. a 2x2 tile, you'd use the EmitMarker node in one of the 2x2 position and the system needs to know that the nearby 3 tiles would also be occupied. Go to each one and set this hint so your final result does not have overlaps")]
        public bool hintWillInsertAssetHere = false;

        public override bool IsAssetInsertedHere()
        {
            return hintWillInsertAssetHere || base.IsAssetInsertedHere();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Impl\Grid\GridSceneMarkers.cs:
 
using System.Collections.Generic;
using DungeonArchitect.MarkerGenerator.Rule.Grid;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Grid
{
    class GridSceneCell
    {
        public readonly List<PropSocket> TileMarkers = new List<PropSocket>();
        public readonly List<PropSocket> CornerMarkers = new List<PropSocket>();
        public readonly List<PropSocket> EdgeXMarkers = new List<PropSocket>();
        public readonly List<PropSocket> EdgeZMarkers = new List<PropSocket>();

        public void Add(PropSocket marker, GridMarkerGenRuleType type)
        {
            var markerList = GetMarkerList(type);
            if (markerList != null)
            {
                var markerPosition = Matrix.GetTranslation(ref marker.Transform);
                var duplicate = false;
                foreach (var existingMarker in markerList)
                {
                    var existingPosition = Matrix.GetTranslation(ref existingMarker.Transform);
                    if (existingMarker.SocketType == marker.SocketType && markerPosition.Equals(existingPosition ))
                    {
                        duplicate = true;
                        break;
                    }
                }

                if (!duplicate)
                {
                    markerList.Add(marker);
                }
            }
        }

        public void Remove(string markerName, GridMarkerGenRuleType type)
        {
            var markerList = GetMarkerList(type);
            if (markerList != null)
            {
                PropSocket markerToRemove = null;
                foreach (var marker in markerList)
                {
                    if (marker.SocketType == markerName)
                    {
                        markerToRemove = marker;
                        break;
                    }
                }

                if (markerToRemove != null)
                {
                    markerList.Remove(markerToRemove);
                }
            }
        }
        
        public bool Contains(string markerName, GridMarkerGenRuleType type)
        {
            var markerList = GetMarkerList(type);
            if (markerList != null)
            {
                foreach (var marker in markerList)
                {
                    if (marker.SocketType == markerName)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
        

        public List<PropSocket> GetMarkerList(GridMarkerGenRuleType type)
        {
            switch (type)
            {
                case GridMarkerGenRuleType.Ground:
                    return TileMarkers;
                
                case GridMarkerGenRuleType.Corner:
                    return CornerMarkers;
                
                case GridMarkerGenRuleType.EdgeX:
                    return EdgeXMarkers;
                
                case GridMarkerGenRuleType.EdgeZ:
                    return EdgeZMarkers;
                
                default:
                    return null;
            }
        }
    }
    
    class GridSceneCells<T> where T : new()
    {
        public GridSceneCells()
        {
        }

        public GridSceneCells(Vector2Int worldOffset, Vector2Int worldSize)
        {
            Init(worldOffset, worldSize);
        }

        protected void Init(Vector2Int worldOffset, Vector2Int worldSize)
        {
            this.WorldOffset = worldOffset;
            this.WorldSize = worldSize;

            Cells.Clear();
            int numItems = worldSize.x * worldSize.y;
            for (int i = 0; i < numItems; i++)
            {
                Cells.Add(new T());
            }
        }

        public T GetValue(Vector2Int coord)
        {
            if (!IsCoordValid(coord))
            {
                return default;
            }

            return Cells[GetIndex(coord)];
        }
        
        
        public bool IsCoordValid(Vector2Int coord) {
            return coord.x >= WorldOffset.x && coord.x < WorldOffset.x + WorldSize.x
                                                  && coord.y >= WorldOffset.y && coord.y < WorldOffset.y + WorldSize.y;
        }

        protected int GetIndex(Vector2Int coord)
        {
            var localCoord = coord - WorldOffset;
            return WorldSize.x * localCoord.y + localCoord.x;
        }
        
        public Vector2Int WorldOffset { get; protected set; }
        public Vector2Int WorldSize { get; protected set; }
        
        protected readonly List<T> Cells = new List<T>();
    }

    class GridCellOccupancyInfo
    {
        public bool GroundOccupied { get; private set; } = false;
        public bool EdgeXOccupied { get; private set; } = false;
        public bool EdgeZOccupied { get; private set; } = false;
        public bool CornerOccupied { get; private set; } = false;

        public void SetOccupied(GridMarkerGenRuleType type, bool value)
        {
            if (type == GridMarkerGenRuleType.Ground)
            {
                GroundOccupied = value;
            }
            else if (type == GridMarkerGenRuleType.EdgeX)
            {
                EdgeXOccupied = value;
            } 
            else if (type == GridMarkerGenRuleType.EdgeZ)
            {
                EdgeZOccupied = value;
            } 
            else if (type == GridMarkerGenRuleType.Corner)
            {
                CornerOccupied = value;
            } 
        }

        public bool IsOccupied(GridMarkerGenRuleType type)
        {
            if (type == GridMarkerGenRuleType.Ground) return GroundOccupied;
            if (type == GridMarkerGenRuleType.EdgeX) return EdgeXOccupied;
            if (type == GridMarkerGenRuleType.EdgeZ) return EdgeZOccupied;
            if (type == GridMarkerGenRuleType.Corner) return CornerOccupied;
            return false;
        }
    }

    class GridSceneCellsBool : GridSceneCells<GridCellOccupancyInfo>
    {
        public GridSceneCellsBool(Vector2Int worldOffset, Vector2Int worldSize) : base(worldOffset, worldSize)
        {
        }
    }


    class GridSceneMarkerList : GridSceneCells<GridSceneCell>
    {
        public GridSceneMarkerList(Vector3 cellSize3D, PropSocket[] markers, int boundsExpansion)
        {
            CellSize = new Vector2(cellSize3D.x, cellSize3D.z);
            CellHeight = cellSize3D.y;
            nextMarkerId = markers.Length;

            Vector2 boundsMin, boundsMax;
            
            if (markers.Length > 0)
            {
                var position3D = Matrix.GetTranslation(ref markers[0].Transform);
                boundsMin = boundsMax = new Vector2(position3D.x, position3D.z);
                foreach (var marker in markers) {
                    var location = Matrix.GetTranslation(ref marker.Transform);
                    boundsMin.x = Mathf.Min(boundsMin.x, location.x);
                    boundsMin.y = Mathf.Min(boundsMin.y, location.z);
                    boundsMax.x = Mathf.Max(boundsMax.x, location.x);
                    boundsMax.y = Mathf.Max(boundsMax.y, location.z);
                }
            }
            else
            {
                boundsMin = boundsMax = Vector2.zero;
            }

            if (CellSize.x > 0 && CellSize.y > 0) {
                boundsMin /= CellSize;
                boundsMax /= CellSize;
            }
            else {
                boundsMin = boundsMax = Vector2.zero;
            }

            int startX = Mathf.FloorToInt(boundsMin.x);
            int startY = Mathf.FloorToInt(boundsMin.y);
            int endX = Mathf.FloorToInt(boundsMax.x);
            int endY = Mathf.FloorToInt(boundsMax.y);

            WorldOffset = new Vector2Int(startX, startY);
            WorldSize = new Vector2Int(endX - startX + 1, endY - startY + 1);

            // Expand the bounds
            WorldOffset -= new Vector2Int(boundsExpansion, boundsExpansion);
            WorldSize += new Vector2Int(boundsExpansion, boundsExpansion) * 2;

            Init(WorldOffset, WorldSize);

            // Register the markers
            foreach (var marker in markers)
            {
                var position = Matrix.GetTranslation(ref marker.Transform);
                GetWorldToCellCoords(position, out var coord, out var coordType);
                var cell = GetValue(coord);
                if (cell != null) {
                    cell.Add(marker, coordType);
                }
            } 
        }
        
        public void GetWorldToCellCoords(Vector3 worldLocation, out Vector2Int coord, out GridMarkerGenRuleType coordType) {
            var coordF = new Vector2(worldLocation.x, worldLocation.z) / CellSize;

            coord = new Vector2Int(
                Mathf.FloorToInt(coordF.x),
                Mathf.FloorToInt(coordF.y));

            float dx = coordF.x - coord.x;
            float dz = coordF.y - coord.y;

            System.Func<float, float, bool> Equals = (float a, float b) => Mathf.Abs(a - b) < 1e-2f;
            if (Equals(dx, 0.0f) && Equals(dz, 0.0f)) {
                coordType = GridMarkerGenRuleType.Corner;
            }
            else if (Equals(dx, 0.5f) && Equals(dz, 0.0f)) {
                coordType = GridMarkerGenRuleType.EdgeX;
            }
            else if (Equals(dx, 0.0f) && Equals(dz, 0.5f)) {
                coordType = GridMarkerGenRuleType.EdgeZ;
            }
            else {
                coordType = GridMarkerGenRuleType.Ground;
            }
        }
            
        
        public void GetCellToWorldCoords(Vector2Int coord, int coordY, GridMarkerGenRuleType coordType, out Vector3 outWorldLocation) {
            var coordF = new Vector2(coord.x, coord.y);
            if (coordType == GridMarkerGenRuleType.Ground) {
                coordF += new Vector2(0.5f, 0.5f);
            }
            else if (coordType == GridMarkerGenRuleType.EdgeX) {
                coordF += new Vector2(0.5f, 0.0f);
            }
            else if (coordType == GridMarkerGenRuleType.EdgeZ) {
                coordF += new Vector2(0.0f, 0.5f);
            }

            var pos2D = Vector2.Scale(coordF, CellSize);
            outWorldLocation = new Vector3(pos2D.x, coordY * CellHeight, pos2D.y);
        }

        public PropSocket[] GenerateMarkerList()
        {
            var result = new List<PropSocket>();
            foreach (var cell in Cells)
            {
                result.AddRange(cell.TileMarkers);
                result.AddRange(cell.CornerMarkers);
                result.AddRange(cell.EdgeXMarkers);
                result.AddRange(cell.EdgeZMarkers);
            }

            // Reset their ids
            int indexCounter = 0;
            foreach (var marker in result)
            {
                marker.Id = indexCounter++;
            }

            return result.ToArray();
        }
        
        public int GenerateNextMarkerId()
        {
            return nextMarkerId++;
        }
            
        public Vector2 CellSize { get; private set; }
        public float CellHeight { get; private set; }
        private int nextMarkerId = 0;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\Graph\Nodes\SCBaseDomainNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Graphs.SpatialConstraints
{
    public class SCBaseDomainNode : GraphNode
    {
        public static readonly float TileSize = 200;

        [SerializeField]
        protected SCRuleNodeDomain ruleDomain = SCRuleNodeDomain.Invalid;
        public SCRuleNodeDomain RuleDomain
        {
            get { return ruleDomain; }
        }

        [SerializeField]
        protected bool isSnapped = false;
        public bool IsSnapped
        {
            get { return isSnapped; }
            set { isSnapped = value; }
        }

        public virtual Color GetColor()
        {
            return Color.black;
        }

        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);

            float nodeSize = TileSize / 10.0f;
            bounds.size = new Vector2(nodeSize, nodeSize);
        }

        public static Vector2 GetSnapPosition(Vector2 position)
        {
            var tileSize = SCBaseDomainNode.TileSize / 2.0f;
            position.x = Mathf.RoundToInt(position.x / tileSize) * tileSize;
            position.y = Mathf.RoundToInt(position.y / tileSize) * tileSize;
            return position;
        }

        public bool ContainsOtherNodeAt(Vector2 snappedPosition)
        {
            foreach (var node in graph.Nodes)
            {
                if (node.Bounds.center == snappedPosition && node != this)
                {
                    return true;
                }
            }
            return false;
        }

        public IntVector2 GetHalfGridLogicalCoords()
        {
            var halfTileSize = SCBaseDomainNode.TileSize / 2.0f;
            var center = bounds.center;
            var coords = new IntVector2();
            coords.x = Mathf.Abs(Mathf.RoundToInt(center.x / halfTileSize) % 2);
            coords.y = Mathf.Abs(Mathf.RoundToInt(center.y / halfTileSize) % 2);
            return coords;
        }

        void UpdateRuleDomain()
        {
            if (isSnapped)
            {
                var coords = GetHalfGridLogicalCoords();

                if (coords.x == 0 && coords.y == 0)
                {
                    ruleDomain = SCRuleNodeDomain.Corner;
                }
                else if (coords.x == 1 && coords.y == 1)
                {
                    ruleDomain = SCRuleNodeDomain.Tile;
                }
                else
                {
                    ruleDomain = SCRuleNodeDomain.Edge;
                }
            }
            else
            {
                ruleDomain = SCRuleNodeDomain.Invalid;
            }
        }

        public virtual bool SnapNode()
        {
            var snappedCenter = GetSnapPosition(bounds.center);
            if (ContainsOtherNodeAt(snappedCenter))
            {
                isSnapped = false;
            }
            else
            {
                bounds.center = snappedCenter;
                isSnapped = true;
            }

            UpdateRuleDomain();

            return isSnapped;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\Graph\Nodes\SCReferenceNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Graphs.SpatialConstraints
{
    public class SCReferenceNode : SCRuleNode
    {
        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            
            canBeDeleted = false;
        }

        public override Color GetColor()
        {
            return new Color(0.3f, 0, 1);
        }

    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\SpatialConstraints\Graph\Nodes\SCRuleNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.SpatialConstraints;

namespace DungeonArchitect.Graphs.SpatialConstraints
{
    public enum SCRuleNodeDomain
    {
        Tile,
        Edge,
        Corner,
        Invalid,
    }

    public enum SCRuleNodeEvaluationMode
    {
        AllRulesMustPass,
        AtleastOneRuleShouldPass
    }

    public class SCRuleNode : SCBaseDomainNode
    {
        [SerializeField]
        public ConstraintRule[] constraints = new ConstraintRule[0];

        [SerializeField]
        public SCRuleNodeEvaluationMode constraintEvaluationMode = SCRuleNodeEvaluationMode.AllRulesMustPass;

        [SerializeField]
        public float exclusionRuleSearchRadius = 0.1f;

        [SerializeField]
        public string[] exclusionRuleMarkersToRemove = new string[0];
        
        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            
        }

        public override Color GetColor()
        {
            return Color.black;
        }


        public override void CopyFrom(GraphNode node)
        {
            base.CopyFrom(node);

            if (node is SCRuleNode)
            {
                var otherNode = node as SCRuleNode;
                var constraintList = new List<ConstraintRule>();

                foreach (var otherConstraint in otherNode.constraints)
                {
                    var constraint = Object.Instantiate(otherConstraint) as ConstraintRule;
                    constraintList.Add(constraint);
                }

                constraints = constraintList.ToArray();
                constraintEvaluationMode = otherNode.constraintEvaluationMode;
                exclusionRuleSearchRadius = otherNode.exclusionRuleSearchRadius;
                System.Array.Copy(otherNode.exclusionRuleMarkersToRemove, exclusionRuleMarkersToRemove, otherNode.exclusionRuleMarkersToRemove.Length);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\SceneProvider\Impl\DungeonItemSpawnListener.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect
{
    /// <summary>
    /// Subclass this on your script and drop it on your dungeon game object to 
    /// start inserting your own custom data into the spawned dungeon items
    /// </summary>
    public class DungeonItemSpawnListener : MonoBehaviour
    {
        public virtual void SetMetadata(GameObject dungeonItem, DungeonNodeSpawnData spawnData) { }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\SceneProvider\Impl\NonPooledDungeonSceneProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect
{
    public class NonPooledDungeonSceneProvider : PooledDungeonSceneProvider
    {
        public override void OnDungeonBuildStart()
        {
            // Disable pooling by not collecting or destroying pooled objects
            Initialize();
        }

        public override void OnDungeonBuildStop()
        {
            
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\ThemeEngine\SceneProvider\Impl\PooledDungeonSceneProvider.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Utils;
using DungeonArchitect.Themeing;

namespace DungeonArchitect
{
    /// <summary>
    /// Implementation of the Scene provider that adds object pooling over the existing functionality.
    /// This is useful for quick rebuilding and better performance, as object in the scene are reused
    /// while rebuilding, instead of destroying everything and rebuilding
    /// </summary>
	public class PooledDungeonSceneProvider : DungeonSceneProvider {
		// Pools list of game objects by their node ids
		Dictionary<string, Queue<GameObject>> pooledObjects = new Dictionary<string, Queue<GameObject>>();

		public override void OnDungeonBuildStart() {
            base.OnDungeonBuildStart();
			pooledObjects.Clear ();
			var items = GameObject.FindObjectsOfType<DungeonSceneProviderData>();
			foreach (var item in items) {
                if (item == null || item.externallyManaged) continue;
                if (item.dungeon != this.dungeon) continue;
                if (item.NodeId == null) continue;

				if (!pooledObjects.ContainsKey(item.NodeId)) {
					pooledObjects.Add(item.NodeId, new Queue<GameObject>());
				}
				pooledObjects[item.NodeId].Enqueue(item.gameObject);
			}
		}

		public override void OnDungeonBuildStop() {
			// Destroy all unused objects from the pool
			foreach (var objects in pooledObjects.Values) {
				foreach (var obj in objects) {
					if (Application.isPlaying) {
						Destroy(obj);
					} else {
						DestroyImmediate(obj);
					}
				}
			}

			pooledObjects.Clear ();
		}

		public override GameObject AddSprite(SpriteDungeonThemeItem spriteProp, Matrix4x4 transform, IDungeonSceneObjectInstantiator objectInstantiator) {
			if (spriteProp == null) return null;
			string NodeId = spriteProp.NodeId;
			
			if (spriteProp.sprite == null) {
				return null;
			}

			FlipSpriteTransform(ref transform, spriteProp.sprite);

			GameObject item = null;
			// Try to reuse an object from the pool
			if (pooledObjects.ContainsKey (NodeId) && pooledObjects [NodeId].Count > 0) {
				item = pooledObjects [NodeId].Dequeue ();
				SetTransform (item.transform, transform);
			} else {
				// Pool is exhausted for this object
				item = BuildSpriteObject(spriteProp, transform, NodeId);
			}
			
			SetStaticState(item, spriteProp.StaticState);

            return item;
		}
        
        public override void InvalidateNodeCache(string NodeId) {
            if (pooledObjects.ContainsKey(NodeId))
            {
                foreach (var obj in pooledObjects[NodeId])
                {
                    if (Application.isPlaying)
                    {
                        Destroy(obj);
                    }
                    else
                    {
                        DestroyImmediate(obj);
                    }
                }
                pooledObjects[NodeId].Clear();
            }
        }
		
        public override GameObject AddGameObject(GameObjectDungeonThemeItem gameObjectProp, Matrix4x4 transform, IDungeonSceneObjectInstantiator objectInstantiator)
        {
			if (gameObjectProp == null) return null;
			var MeshTemplate = gameObjectProp.Template;
			string NodeId = gameObjectProp.NodeId;

			if (MeshTemplate == null) {
                return null;
			}
			
			// If we are in 2D mode, then flip the YZ axis
			{
				var mode2D = false;
				if (config != null) {
					mode2D = config.IsMode2D();
				}
				if (mode2D) {
					var position = Matrix.GetTranslation(ref transform);
					FlipSpritePosition(ref position);
					Matrix.SetTranslation(ref transform, position);
				}
			}

			GameObject item = null;
			// Try to reuse an object from the pool
			if (pooledObjects.ContainsKey (NodeId) && pooledObjects [NodeId].Count > 0) {
				item = pooledObjects [NodeId].Dequeue ();
                if (item != null)
                {
                    SetTransform(item.transform, transform);
                }
            } 

            if (item == null) { 
				// Pool is exhausted for this object
				item = BuildGameObject(gameObjectProp, transform, objectInstantiator);
            }
            
            SetStaticState(item, gameObjectProp.StaticState);

            return item;
		}

        void SetStaticState(GameObject item, DungeonThemeItemStaticMode staticState)
        {
	        if (Application.isPlaying)
	        {
		        // Changing static state at runtime has no affect
		        return;
	        }
	        if (staticState == DungeonThemeItemStaticMode.Unchanged) return;
	        if (item == null) return;

	        var isStatic = staticState == DungeonThemeItemStaticMode.ForceStatic;
	        
	        item.isStatic = isStatic;
	        if (isStatic)
	        {
		        RecursivelySetStatic(item.transform);
	        }
        }

		public override GameObject AddGameObjectFromArray(GameObjectArrayDungeonThemeItem gameObjectArrayProp, int index, Matrix4x4 transform, IDungeonSceneObjectInstantiator objectInstantiator)
		{
			if (gameObjectArrayProp == null) return null;
			string NodeId = gameObjectArrayProp.NodeId + "_" + index.ToString();

			// If we are in 2D mode, then flip the YZ axis
			{
				var mode2D = false;
				if (config != null) {
					mode2D = config.IsMode2D();
				}
				if (mode2D) {
					var position = Matrix.GetTranslation(ref transform);
					FlipSpritePosition(ref position);
					Matrix.SetTranslation(ref transform, position);
				}
			}

			GameObject item = null;
			// Try to reuse an object from the pool
			if (pooledObjects.ContainsKey (NodeId) && pooledObjects [NodeId].Count > 0) {
				item = pooledObjects [NodeId].Dequeue ();
				SetTransform (item.transform, transform);
			} else {
				// Pool is exhausted for this object
				item = BuildGameObjectFromArray(gameObjectArrayProp, index, transform, objectInstantiator);
			}

			SetStaticState(item, gameObjectArrayProp.StaticState);
			
			return item;
		}


        void RecursivelySetStatic(Transform trans)
        {
            var obj = trans.gameObject;
            obj.isStatic = true;
            for (int i = 0; i < trans.childCount; i++)
            {
                var child = trans.GetChild(i);
                RecursivelySetStatic(child);
            }
        }

	}
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\ExecGraph\Nodes\FlowExecGraphNodeBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Flow.Exec
{
    public class FlowExecGraphNodeBase : GraphNode
    {
        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            Size = new Vector2(120, 120);

            // Create an input pin on the top
            CreatePinOfType<FlowExecGraphNodePin>(GraphPinType.Input,
                        Vector2.zero,
                        Rect.zero,
                        new Vector2(0, -1));

            // Create an output pin at the bottom
            CreatePinOfType<FlowExecGraphNodePin>(GraphPinType.Output,
                        Vector2.zero,
                        Rect.zero,
                        new Vector2(0, -1));

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\ExecGraph\Nodes\FlowExecGraphNodePin.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Flow.Exec
{
    [System.Serializable]
    public class FlowExecGraphNodePin : GraphPin
    {
        public Vector2 Padding = new Vector2(10, 10);

        public override bool ContainsPoint(Vector2 worldPoint)
        {
            if (PinType == GraphPinType.Input)
            {
                // We don't want the user to touch this pin.  Our logic will connect output-output pins correctly
                return false;
            }

            if (base.ContainsPoint(worldPoint))
            {
                // Make sure it is not inside the body
                var bodyBounds = Node.Bounds;
                bodyBounds.position += Padding;
                bodyBounds.size -= Padding * 2;

                // make sure it is not inside the body
                return !bodyBounds.Contains(worldPoint);
            }
            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\ExecGraph\Nodes\FlowExecResultGraphNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using DungeonArchitect.Graphs;

namespace DungeonArchitect.Flow.Exec
{
    public class FlowExecResultGraphNode : FlowExecRuleGraphNode
    {
        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            canBeDeleted = false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\ExecGraph\Nodes\FlowExecRuleGraphNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine.Serialization;

namespace DungeonArchitect.Flow.Exec
{
    public enum GridFlowGraphNodeExecutionStage
    {
        NotExecuted,
        WaitingToExecute,       // Dependent nodes are being processed
        Executed                // The node has been executed
    }
    public class GridFlowGraphNodeExecutionStatus
    {
        public GridFlowGraphNodeExecutionStage ExecutionStage { get; set; }
        public FlowTaskExecutionResult Success { get; set; }
        public string ErrorMessage { get; set; }

        public GridFlowGraphNodeExecutionStatus()
        {
            ExecutionStage = GridFlowGraphNodeExecutionStage.NotExecuted;
            Success = FlowTaskExecutionResult.FailHalt;
            ErrorMessage = "";
        }
    }

    public class FlowExecRuleGraphNode : FlowExecGraphNodeBase
    {
        [FormerlySerializedAs("nodeHandler")] 
        public FlowExecTask task;
        
        public GridFlowGraphNodeExecutionStatus executionStatus;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\ExecGraph\Tasks\FlowExecTask.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Domains;
using UnityEngine;

namespace DungeonArchitect.Flow.Exec
{
    public enum FlowTaskExecutionResult
    {
        Success,
        FailRetry,
        FailHalt
    }

    public enum FlowTaskExecutionFailureReason
    {
        Unknown,
        Timeout
    }

    public class FlowTaskExecContext
    {
        public System.Random Random;
        public FlowDomainExtensions DomainExtensions { get; set; }
    }
    
    public class FlowTaskExecInput
    {
        public FlowTaskExecOutput[] IncomingTaskOutputs;

        public FlowExecTaskState CloneInputState()
        {
            if (IncomingTaskOutputs.Length == 0) return null;
            if (IncomingTaskOutputs[0].State == null) return null;
            return IncomingTaskOutputs[0].State.Clone();
        }
    }

    public class FlowTaskExecOutput
    {
        public FlowExecTaskState State = new FlowExecTaskState();
        public FlowTaskExecutionResult ExecutionResult = FlowTaskExecutionResult.FailHalt;
        public FlowTaskExecutionFailureReason FailureReason = FlowTaskExecutionFailureReason.Unknown;
        public string ErrorMessage = "";
    }
    
    public abstract class FlowExecTask : ScriptableObject
    {
        public abstract FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input);
        public string description = "";
    }

    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class FlowExecNodeInfoAttribute : System.Attribute
    {
        public string Title { get; private set; }
        public string MenuPrefix { get; private set; }
        public float Weight { get; private set; }

        public FlowExecNodeInfoAttribute(string title)
            : this(title, "", 0)
        {
        }

        public FlowExecNodeInfoAttribute(string title, string menuPrefix)
            : this(title, menuPrefix, 0)
        {
        }

        public FlowExecNodeInfoAttribute(string title, string menuPrefix, float weight)
        {
            this.Title = title;
            this.MenuPrefix = menuPrefix;
            this.Weight = weight;
        }

        public static FlowExecNodeInfoAttribute GetHandlerAttribute(System.Type type)
        {
            if (type == null) return null;
            return type.GetCustomAttributes(typeof(FlowExecNodeInfoAttribute), true).FirstOrDefault() as FlowExecNodeInfoAttribute;
        }
    }

    public class FlowExecNodeOutputRegistry
    {
        public void Clear()
        {
            stateByNodeId.Clear();
        }

        public void Register(string nodeId, FlowTaskExecOutput state)
        {
            if (state != null)
            {
                stateByNodeId[nodeId] = state;
            }
        }

        public FlowTaskExecOutput Get(string nodeId)
        {
            if (stateByNodeId.ContainsKey(nodeId))
            {
                return stateByNodeId[nodeId];
            }
            return null;
        }

        private Dictionary<string, FlowTaskExecOutput> stateByNodeId = new Dictionary<string, FlowTaskExecOutput>();
    }

    public class FlowExecTaskState
    {
        public ICloneable GetState(System.Type type)
        {
            return states.ContainsKey(type) ? states[type] : null;
        }
        
        public T GetState<T>() where T : ICloneable
        {
            if (states.ContainsKey(typeof(T)))
            {
                return (T) states[typeof(T)];
            }

            // Not found, return default value (null)
            return default;
        }

        public void SetState(System.Type type, ICloneable state)
        {
            if (state != null)
            {
                Debug.Assert(state.GetType() == type || state.GetType().IsSubclassOf(type));
                states[type] = state;
            }
        }

        public FlowExecTaskState Clone()
        {
            var clone = new FlowExecTaskState();
            foreach (var entry in states)
            {
                var type = entry.Key;
                var obj = entry.Value;
                var clonedObj = obj.Clone() as ICloneable;
                clone.SetState(type, clonedObj);
            }

            return clone;
        }

        public System.Type[] GetRegisteredStateTypes()
        {
            return states.Keys.ToArray();
        }
        
        protected Dictionary<System.Type, ICloneable> states = new Dictionary<Type, ICloneable>();
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\ExecGraph\Tasks\FlowExecTaskResult.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Flow.Exec
{
    [FlowExecNodeInfo("Result", "", 3000)]
    public class FlowExecTaskResult : FlowExecTask
    {
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            output.State = input.CloneInputState();
            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\ExecGraph\Tasks\FlowExecTaskUtils.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;

namespace DungeonArchitect.Flow.Exec
{
    public class FlowExecTaskUtils 
    {
        public static FlowExecTaskState[] GetIncomingStates(FlowExecRuleGraphNode currentNode, FlowExecNodeOutputRegistry nodeOutputRegistry)
        {
            var incomingStates = new List<FlowExecTaskState>();
            var incomingNodes = FlowExecGraphUtils.GetIncomingNodes(currentNode);
            foreach (var incomingNode in incomingNodes)
            {
                var incomingExecState = nodeOutputRegistry.Get(incomingNode.Id);
                if (incomingExecState != null)
                {
                    incomingStates.Add(incomingExecState.State);
                }
            }
            return incomingStates.ToArray();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\Items\Components\FlowDoorKeyComponent.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Flow.Items
{
    public class FlowDoorKeyComponent : MonoBehaviour
    {
        public string keyId;
        public string[] validLockIds = new string[0];

        public FlowDoorLockComponent[] lockRefs;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\Items\Components\FlowDoorLockComponent.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Flow.Items
{
    public class FlowDoorLockComponent : MonoBehaviour
    {
        public string lockId;
        public string[] validKeyIds = new string[0];
        public FlowDoorKeyComponent[] validKeyRefs = new FlowDoorKeyComponent[0];
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\Items\Metadata\FlowItemMetadataComponent.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Flow.Items
{
    public class FlowItemMetadataComponent : MonoBehaviour
    {
        public FlowGraphItemType itemType;

        public string itemId;

        public string[] referencedItemIds = new string[0];
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\Items\Metadata\FlowItemMetadataHandler.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Items
{
    [SerializeField]
    public class FlowItemMetadata
    {
        public FlowGraphItemType itemType;
        public DungeonUID itemId = DungeonUID.Empty;
        public DungeonUID[] referencedItems = new DungeonUID[0];
        public Transform parentTransform = null;
    }

    public class FlowItemMetadataHandler : DungeonItemSpawnListener
    {
        T FindOrAddComponent<T>(GameObject gameObject) where T : Component
        {
            if (gameObject == null)
            {
                return null;
            }
            
            var component = gameObject.GetComponent<T>();
            if (component == null)
            {
                component = gameObject.AddComponent<T>();
            }
            return component;
        }

        public override void SetMetadata(GameObject dungeonItem, DungeonNodeSpawnData spawnData)
        {
            if (dungeonItem != null)
            {
                var marker = spawnData.socket;
                if (marker.metadata is FlowItemMetadata)
                {
                    var itemData = marker.metadata as FlowItemMetadata;
                    if (itemData != null)
                    {
                        var component = FindOrAddComponent<FlowItemMetadataComponent>(dungeonItem);
                        if (component != null)
                        {
                            component.itemType = itemData.itemType;
                            component.itemId = itemData.itemId.ToString();

                            var referencedIds = new List<string>();
                            foreach (var referencedGuidId in itemData.referencedItems)
                            {
                                referencedIds.Add(referencedGuidId.ToString());
                            }

                            component.referencedItemIds = referencedIds.ToArray();
                        }
                    }

                    if (itemData.parentTransform != null)
                    {
                        dungeonItem.transform.SetParent(itemData.parentTransform, true); 
                    }
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Core\Items\Metadata\FlowItemMetadataResolver.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using UnityEngine;

namespace DungeonArchitect.Flow.Items
{
    public class FlowItemMetadataResolver : DungeonEventListener
    {
        T[] GetDungeonOwnedComponents<T>(Dungeon dungeon) where T : Component
        {
            var result = new List<T>();
            var allItems = GameObject.FindObjectsOfType<T>();
            foreach (var item in allItems)
            {
                if (item == null) continue;
                var dungeonData = item.gameObject.GetComponent<DungeonSceneProviderData>();
                if (dungeonData == null) continue;
                if (dungeonData.dungeon == dungeon)
                {
                    result.Add(item);
                }
            }

            return result.ToArray();
        }

        T FindOrAddComponent<T>(GameObject gameObject) where T : Component
        {
            var component = gameObject.GetComponent<T>();
            if (component == null)
            {
                component = gameObject.AddComponent<T>();
            }

            return component;
        }

        public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model)
        {
            var items = GetDungeonOwnedComponents<FlowItemMetadataComponent>(dungeon);
            var itemMap = new Dictionary<string, FlowItemMetadataComponent>();
            foreach (var item in items)
            {
                if (item.itemId == null || item.itemId.Length == 0) continue;

                if (itemMap.ContainsKey(item.itemId))
                {
                    //Debug.LogError("Duplicate id: " + item.itemId);
                }

                itemMap[item.itemId] = item;
            }

            // clear out the key locks
            {
                var oldKeys = GetDungeonOwnedComponents<FlowDoorKeyComponent>(dungeon);
                foreach (var key in oldKeys)
                {
                    key.lockRefs = new FlowDoorLockComponent[0];
                }

                var oldLocks = GetDungeonOwnedComponents<FlowDoorLockComponent>(dungeon);
                foreach (var lockComponent in oldLocks)
                {
                    lockComponent.validKeyRefs = new FlowDoorKeyComponent[0];
                    lockComponent.validKeyIds = new string[0];
                }
            }

            foreach (var item in items)
            {
                if (item.itemType == FlowGraphItemType.Key)
                {
                    var keyComponent = FindOrAddComponent<FlowDoorKeyComponent>(item.gameObject);
                    keyComponent.keyId = item.itemId;

                    var lockComponents = new List<FlowDoorLockComponent>();
                    for (int i = 0; i < item.referencedItemIds.Length; i++)
                    {
                        var refItemId = item.referencedItemIds[i];
                        if (!itemMap.ContainsKey(refItemId)) continue;

                        var refItem = itemMap[refItemId];
                        if (refItem.itemType == FlowGraphItemType.Lock)
                        {
                            var lockComponent = FindOrAddComponent<FlowDoorLockComponent>(refItem.gameObject);
                            lockComponents.Add(lockComponent);

                            var keyRefs = new List<FlowDoorKeyComponent>(lockComponent.validKeyRefs);
                            keyRefs.Add(keyComponent);
                            lockComponent.validKeyRefs = keyRefs.ToArray();

                            var keyIds = new List<string>(lockComponent.validKeyIds);
                            keyIds.Add(keyComponent.keyId);
                            lockComponent.validKeyIds = keyIds.ToArray();
                        }
                    }

                    keyComponent.lockRefs = lockComponents.ToArray();
                    keyComponent.keyId = item.itemId;
                    keyComponent.validLockIds = item.referencedItemIds;
                }
                else if (item.itemType == FlowGraphItemType.Lock)
                {
                    var lockComponent = FindOrAddComponent<FlowDoorLockComponent>(item.gameObject);
                    lockComponent.lockId = item.itemId;
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\LayoutBaseFlowTaskCreateKeyLock.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tasks
{
    public class LayoutBaseFlowTaskCreateKeyLock : FlowExecTask
    {
        public string keyBranch = "main";
        public string lockBranch = "main";
        public string keyMarkerName = "Key";
        public string lockMarkerName = "Lock";


        protected virtual bool Validate(FlowTaskExecContext context, FlowTaskExecInput input, ref string errorMessage, ref FlowTaskExecutionResult executionResult)
        {
            return true;
        }

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output.State = input.CloneInputState();
            if (!Validate(context, input, ref output.ErrorMessage, ref output.ExecutionResult))
            {
                return output;
            }

            var graph = output.State.GetState<FlowLayoutGraph>();

            FlowLayoutGraphNode keyNode;
            FlowLayoutGraphLink lockLink;
            
            var graphQuery = new FlowLayoutGraphQuery(graph);
            if (FindKeyLockSetup(graphQuery, context.Random, out keyNode, out lockLink, out output.ErrorMessage))
            {
                var keyItem = new FlowItem();
                keyItem.type = FlowGraphItemType.Key;
                keyItem.markerName = keyMarkerName;
                keyNode.AddItem(keyItem);
                
                ProcessKeyItem(keyItem, keyNode, lockLink);

                var lockItem = new FlowItem();
                lockItem.type = FlowGraphItemType.Lock;
                lockItem.markerName = lockMarkerName;
                lockLink.state.AddItem(lockItem);
                
                keyItem.referencedItemIds.Add(lockItem.itemId);
                lockItem.referencedItemIds.Add(keyItem.itemId);

                output.ExecutionResult = FlowTaskExecutionResult.Success;
                return output;
            }

            output.ExecutionResult = FlowTaskExecutionResult.FailRetry;
            return output;
        }

        protected virtual void ProcessKeyItem(FlowItem keyItem, FlowLayoutGraphNode keyNode, FlowLayoutGraphLink lockLink)
        {
        }

        DungeonUID[] GetLockedNodesInPath(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphLink lockLink)
        {
            var sourceNode = graphQuery.GetNode(lockLink.source);
            var destNode = graphQuery.GetNode(lockLink.destination);
            
            var disallowedNodes = new List<DungeonUID>();
            disallowedNodes.Add(destNode.nodeId);
            
            // If the link belongs to the main path, we want to disallow all the nodes in the main path after this link
            bool mainPathLink = (sourceNode != null && destNode != null && sourceNode.mainPath && destNode.mainPath);
            if (mainPathLink)
            {
                var graph = graphQuery.Graph;
                // Grab all the main path nodes after this link
                var mainPathNodeId = destNode.nodeId;
                var visited = new HashSet<DungeonUID>() {mainPathNodeId};

                while (true)
                {
                    FlowLayoutGraphLink nextLink = null;
                    foreach (var link in graph.Links)
                    {
                        if (link.state.type == FlowLayoutGraphLinkType.Unconnected) continue;
                        if (link.source == mainPathNodeId)
                        {
                            // make sure the destination node is also a main path node
                            var dest = graphQuery.GetNode(link.destination);
                            if (dest.mainPath)
                            {
                                nextLink = link;
                                break;
                            }
                        }
                    }

                    if (nextLink == null)
                    {
                        break;
                    }

                    mainPathNodeId = nextLink.destination;
                    if (visited.Contains(mainPathNodeId))
                    {
                        break;
                    }

                    visited.Add(mainPathNodeId);
                    disallowedNodes.Add(mainPathNodeId);
                }
            }

            return disallowedNodes.ToArray();
        }
        
        private bool FindKeyLockSetup(FlowLayoutGraphQuery graphQuery, System.Random random, out FlowLayoutGraphNode outKeyNode,
                out FlowLayoutGraphLink outLockLink, out string errorMessage)
        {
            var graph = graphQuery.Graph;
            var entranceNode = FlowLayoutGraphUtils.FindNodeWithItemType(graph, FlowGraphItemType.Entrance);
            if (entranceNode == null)
            {
                errorMessage = "Missing Entrance Node";
                outKeyNode = null;
                outLockLink = null;
                return false;
            }

            var keyNodes = FlowLayoutGraphUtils.FindNodesOnPath(graph, keyBranch);
            var lockNodes = FlowLayoutGraphUtils.FindNodesOnPath(graph, lockBranch);

            MathUtils.Shuffle(keyNodes, random);
            MathUtils.Shuffle(lockNodes, random);

            var traversal = graphQuery.Traversal;
            
            foreach (var keyNode in keyNodes)
            {
                foreach (var lockNode in lockNodes)
                {
                    
                    // Lock link list creation criteria
                    //     1. Get all lock node links that connect to other nodes in the same lock path
                    //     2. grab the rest of the links connected to the lock node
                    //     3. Filter out the ones that already have a lock on them
                    // Lock link selection criteria 
                    //     1. Make sure the key node is accessible from the entrance, after blocking off the selected lock link
                    //     2. Make sure lock node is not accessible from the entrance after blocking off the selected lock link

                    // Generate the lock link array
                    var lockNodeLinks = new List<FlowLayoutGraphTraversal.FNodeInfo>();
                    {
                        var allLockLinks = traversal.GetConnectedNodes(lockNode.nodeId);

                        var resultPrimary = new List<FlowLayoutGraphTraversal.FNodeInfo>();
                        var resultSecondary = new List<FlowLayoutGraphTraversal.FNodeInfo>();
                        
                        foreach (var connectionInfo in allLockLinks)
                        {
                            // Make sure this link doesn't already have a lock
                            var lockLink = graphQuery.GetLink(connectionInfo.LinkId);
                            if (lockLink == null || FlowLayoutGraphUtils.ContainsItem(lockLink.state.items, FlowGraphItemType.Lock))
                            {
                                continue;
                            }

                            var connectedNode = graphQuery.GetNode(connectionInfo.NodeId);
                            if (connectedNode != null)
                            {
                                if (connectedNode.pathName == lockBranch)
                                {
                                    resultPrimary.Add(connectionInfo);
                                }
                                else
                                {
                                    resultSecondary.Add(connectionInfo);
                                }
                            }
                        }
                        
                        MathUtils.Shuffle(resultPrimary, random);
                        lockNodeLinks.AddRange(resultPrimary);

                        MathUtils.Shuffle(resultSecondary, random);
                        lockNodeLinks.AddRange(resultSecondary);
                    }
                    
                    
                    // Select the first valid link from the list
                    foreach (var lockConnection in lockNodeLinks)
                    {
                        var lockLinkId = lockConnection.LinkId;
                        var lockLink = graphQuery.GetLink(lockLinkId);
                        if (lockLink == null)
                        {
                            continue;
                        }

                        // Check if this link belongs to the main path
                        //var lockedNodeIds = GetLockedNodesInPath(graphQuery, lockLink);
                        var lockedNodeIds = new DungeonUID[]{ lockLink.destination };

                        Func<FlowLayoutGraphTraversal.FNodeInfo, bool> canTraverse = 
                                (traverseInfo) => traverseInfo.LinkId != lockLinkId;
                        
                        // 1. Make sure the key node is accessible from the entrance, after blocking off the selected lock link
                        bool canReachKey = FlowLayoutGraphUtils.CanReachNode(graphQuery, entranceNode.nodeId, keyNode.nodeId, 
                            false, false, true, canTraverse);
                        if (canReachKey) {
                            // 2. Make sure lock node is not accessible from the entrance after blocking off the selected lock link
                            bool canReachLockedNode = false;
                            foreach (var lockedNodeId in lockedNodeIds)
                            {
                                bool reachable = FlowLayoutGraphUtils.CanReachNode(graphQuery, entranceNode.nodeId, lockedNodeId,
                                    false, false, true, canTraverse);
                                
                                if (reachable)
                                {
                                    canReachLockedNode = true;
                                    break;
                                }
                            }
                            
                            if (!canReachLockedNode) {
                                // Validate the entire graph's key-lock setup by walking through it like a player would
                                if (ValidateFullKeyLockSetup(graphQuery, keyNode, lockLink))
                                {
                                    outKeyNode = keyNode;
                                    outLockLink = lockLink;
                                    errorMessage = "";
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            
            outKeyNode = null;
            outLockLink = null;
            errorMessage = "Cannot find key-lock";
            return false;
        }


        struct NodeConnectionInfo
        {
            public FlowLayoutGraphNode ConnectedNode;
            public bool ContainsLock;
            public DungeonUID LockId;

            public NodeConnectionInfo(FlowLayoutGraphNode connectedNode)
            {
                this.ConnectedNode = connectedNode;
                this.ContainsLock = false;
                this.LockId = DungeonUID.Empty;
            }
            public NodeConnectionInfo(FlowLayoutGraphNode connectedNode, DungeonUID lockId)
            {
                this.ConnectedNode = connectedNode;
                this.ContainsLock = true;
                this.LockId = lockId;
            }
        }
        
        private bool ValidateFullKeyLockSetup(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode inputKeyNode, FlowLayoutGraphLink inputLockLink)
        {
            // We'll walk through the entire graph like how a player would and make sure it is a playable level
            // Step1:
            //      - Flood fill from the start node till we can't reach any more nodes.
            //      - Record all the keys we've encountered till now.
            //      - Do not pass through any locks we cannot open yet (based on the keys we've encountered)
            //      - Do not pass through one-way doors
            //
            // Step2: 
            //      - If all nodes were visited in the last flood fill, Return true
            //
            // Step3:
            //      - Did we visit at-least one new node since the last flood fill?
            //           + if not, return fail
            //
            // Step4:
            //      - Repeat Step1

            var graph = graphQuery.Graph;
            
            FlowLayoutGraphNode startNode = null;
            FlowLayoutGraphNode goalNode = null;
            var connectedNodes = new Dictionary<FlowLayoutGraphNode, List<NodeConnectionInfo>>();
            var keyToLockMap = new Dictionary<DungeonUID, HashSet<DungeonUID>>();
            var lockToKeyMap = new Dictionary<DungeonUID, HashSet<DungeonUID>>();
            int numActiveNodes = 0;
            
            // Create a new temp id for the key-lock pair that is being tested and add it to the list (this pair has not been added to the graph yet)
            var inputKeyID = DungeonUID.NewUID();
            var inputLockID = DungeonUID.NewUID();
            keyToLockMap.Add(inputKeyID, new HashSet<DungeonUID>(){ inputLockID });
            lockToKeyMap.Add(inputLockID, new HashSet<DungeonUID>(){ inputKeyID });
            
            #region Build Lookups
            {
                foreach (var node in graph.Nodes)
                {
                    if (node == null || !node.active) continue;
                    numActiveNodes++;
                    
                    foreach (var item in node.items)
                    {
                        if (item == null) continue;
                        if (item.type == FlowGraphItemType.Entrance)
                        {
                            startNode = node;
                        }
                        else if (item.type == FlowGraphItemType.Exit)
                        {
                            goalNode = node;
                        }
                        else if (item.type == FlowGraphItemType.Key)
                        {
                            var keyId = item.itemId;
                            var lockIds = item.referencedItemIds;
                            if (!keyToLockMap.ContainsKey(keyId))
                            {
                                keyToLockMap.Add(keyId, new HashSet<DungeonUID>());
                            }

                            foreach (var lockId in lockIds)
                            {
                                keyToLockMap[keyId].Add(lockId);

                                if (!lockToKeyMap.ContainsKey(lockId))
                                {
                                    lockToKeyMap.Add(lockId, new HashSet<DungeonUID>());
                                }

                                lockToKeyMap[lockId].Add(keyId);
                            }
                        }
                    }
                }

                if (startNode == null || goalNode == null)
                {
                    return false;
                }

                
                // build the connected node list
                foreach (var link in graph.Links)
                {
                    if (link == null || link.state.type == FlowLayoutGraphLinkType.Unconnected) continue;
                    var sourceNode = graphQuery.GetNode(link.source);
                    var destNode = graphQuery.GetNode(link.destination);
                    if (sourceNode == null || destNode == null) continue;

                    if (!connectedNodes.ContainsKey(sourceNode))
                    {
                        connectedNodes.Add(sourceNode, new List<NodeConnectionInfo>());
                    }

                    if (!connectedNodes.ContainsKey(destNode))
                    {
                        connectedNodes.Add(destNode, new List<NodeConnectionInfo>());
                    }

                    var connectionInfo = new NodeConnectionInfo(destNode);
                    foreach (var item in link.state.items)
                    {
                        if (item.type == FlowGraphItemType.Lock)
                        {
                            connectionInfo.ContainsLock = true;
                            connectionInfo.LockId = item.itemId;
                            break;
                        }
                    }

                    if (link == inputLockLink)
                    {
                        connectionInfo.ContainsLock = true;
                        connectionInfo.LockId = inputLockID;
                    }

                    connectedNodes[sourceNode].Add(connectionInfo);
                    if (link.state.type == FlowLayoutGraphLinkType.Connected && !connectionInfo.ContainsLock)
                    {
                        connectedNodes[destNode].Add(new NodeConnectionInfo(sourceNode));
                    }
                }
            }
            #endregion

            int lastVisitedNodes = 0;
            var visitedKeys = new HashSet<DungeonUID>();
            while (lastVisitedNodes < numActiveNodes)
            {
                // Step1: Flood fill from the start node
                var queue = new Queue<FlowLayoutGraphNode>();
                var visited = new HashSet<FlowLayoutGraphNode>();
                queue.Enqueue(startNode);
                visited.Add(startNode);
                while (queue.Count > 0)
                {
                    var node = queue.Dequeue();
                    Debug.Assert(node != null && node.active);
                    
                    // Save visited keys
                    foreach (var item in node.items)
                    {
                        if (item.type == FlowGraphItemType.Key)
                        {
                            visitedKeys.Add(item.itemId);
                        }
                    }

                    if (node == inputKeyNode)
                    {
                        visitedKeys.Add(inputKeyID);
                    }
                    
                    // Visit unexplored connected nodes
                    if (connectedNodes.ContainsKey(node))
                    {
                        var connections = connectedNodes[node];
                        foreach (var connection in connections)
                        {
                            if (visited.Contains(connection.ConnectedNode)) continue;
                            bool canTraverseDoor = true;
                            if (connection.ContainsLock)
                            {
                                // Make sure we have a key to pass through it
                                canTraverseDoor = false;
                                foreach (var keyId in visitedKeys)
                                {
                                    if (keyToLockMap.ContainsKey(keyId))
                                    {
                                        if (keyToLockMap[keyId].Contains(connection.LockId))
                                        {
                                            // We have a key that can open this lock
                                            canTraverseDoor = true;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (canTraverseDoor)
                            {
                                queue.Enqueue(connection.ConnectedNode);
                                visited.Add(connection.ConnectedNode);
                            }
                        }
                    }
                }
                
                var numVisited = visited.Count;
                if (numVisited <= lastVisitedNodes)
                {
                    // No change since last time
                    Debug.Assert(numVisited < numActiveNodes);
                    return false;
                }
                lastVisitedNodes = numVisited;
            }

            return true;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\LayoutBaseFlowTaskCreateMainPath.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tasks
{
    public class LayoutBaseFlowTaskCreateMainPath : LayoutBaseFlowTaskPathBuilderBase
    {
        public int pathSize = 12;
        public string pathName = "main";
        public Color nodeColor = Color.green;
        public string startMarkerName = "SpawnPoint";
        public string goalMarkerName = "LevelGoal";
        public string startNodePathName = "main_start";
        public string goalNodePathName = "main_goal";
        public bool drawDebug = false;

        // Number of searches to perform at once.  This helps converge to a solution faster if we are stuck on a single search path.
        // However, this might increase the overall search time by a little bit. 
        public int numParallelSearches = 1;
        public long maxFramesToProcess = 1000;

        protected virtual bool Validate(FlowTaskExecContext context, FlowTaskExecInput input, ref string errorMessage, ref FlowTaskExecutionResult executionResult)
        {
            return true;
        }

        protected virtual void ProcessEntranceItem(FlowItem entranceItem, FlowLayoutGraphNode entranceNode)
        {
        }

        public virtual void ProcessGoalItem(FlowItem goalItem, FlowLayoutGraphNode goalNode)
        {
            
        }

        protected override void FinalizePath(FlowLayoutStaticGrowthState staticState, FlowLayoutSharedGrowthState sharedState, FlowLayoutGrowthState state)
        {
            base.FinalizePath(staticState, sharedState, state);
            
            var graphQuery = staticState.GraphQuery;
            
            // Add an entry item to the first node
            {
                var entranceNode = graphQuery.GetNode(state.Path[0].NodeId);
                // Override the entrance node path name
                entranceNode.pathName = startNodePathName;
                    
                // Add a spawn point item
                var item = entranceNode.CreateItem<FlowItem>();
                item.type = FlowGraphItemType.Entrance;
                item.markerName = startMarkerName;
                ProcessEntranceItem(item, entranceNode);
            }
                
            // Add a goal item to the last node
            {
                var goalNodeId = state.Path[state.Path.Count - 1].NodeId;
                var goalNode = graphQuery.GetNode(goalNodeId);
                    
                // Override the goal node path name
                goalNode.pathName = goalNodePathName;
                    
                // Add a goal item
                var item = goalNode.CreateItem<FlowItem>();
                item.type = FlowGraphItemType.Exit;
                item.markerName = goalMarkerName;
                ProcessGoalItem(item, goalNode);
            }
        }

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (pathSize <= 0)
            {
                output.ErrorMessage = "Invalid path size";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            output.State = input.CloneInputState();
            var graph = output.State.GetState<FlowLayoutGraph>();

            if (graph == null || graph.Nodes.Count == 0)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (!Validate(context, input, ref output.ErrorMessage, ref output.ExecutionResult))
            {
                return output;
            }
            
            var graphQuery = new FlowLayoutGraphQuery(graph);
            var staticState = new FlowLayoutStaticGrowthState();
            staticState.Graph = graph;
            staticState.GraphQuery = graphQuery;
            staticState.Random = context.Random;
            staticState.MinPathSize = pathSize;
            staticState.MaxPathSize = pathSize;
            staticState.NodeColor = nodeColor;
            staticState.PathName = pathName;
            staticState.NodeGroupGenerator = CreateNodeGroupGenerator(context.DomainExtensions, graph, context.Random);
            staticState.GraphConstraint = CreateGraphConstraint(context.DomainExtensions, graph, context.Random);
            staticState.NodeCreationConstraint = CreateNodeCreationConstraint(context.DomainExtensions, graph, context.Random);

            int[] shuffledEntranceIndices = MathUtils.GetShuffledIndices(graph.Nodes.Count, context.Random);
            var pathingSystem = new FFlowAgPathingSystem(maxFramesToProcess);
            foreach (var nodeIndex in shuffledEntranceIndices)
            {
                var startNode = graph.Nodes[nodeIndex];
                if (startNode == null || startNode.active)
                {
                    // Cannot use this node
                    continue;
                }
                
                pathingSystem.RegisterGrowthSystem(startNode, staticState);
            }
            
            pathingSystem.Execute(numParallelSearches);
            if (pathingSystem.FoundResult)
            {
                var pathResult = pathingSystem.Result;
                FinalizePath(pathResult.StaticState, pathResult.SharedState, pathResult.State);

                output.ExecutionResult = FlowTaskExecutionResult.Success;
                return output;
            }

            EFlowLayoutGrowthErrorType pathingError = pathingSystem.GetLastError();
            if (pathingError == EFlowLayoutGrowthErrorType.CannotMerge)
            {
                output.ErrorMessage = "Cannot Merge back";
            }
            else if (pathingError == EFlowLayoutGrowthErrorType.NodeConstraint)
            {
                output.ErrorMessage = "Error: Check Constraints";
            }
            else if (pathingError == EFlowLayoutGrowthErrorType.GraphConstraint)
            {
                output.ErrorMessage = "Error: Check Module Constraints";
            }
            else
            {
                output.ErrorMessage = "Cannot find path";
            }

            output.ExecutionResult = FlowTaskExecutionResult.FailRetry;
            return output;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\LayoutBaseFlowTaskCreatePath.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tasks
{
    public class LayoutBaseFlowTaskCreatePath : LayoutBaseFlowTaskPathBuilderBase
    {
        public int minPathSize = 3;
        public int maxPathSize = 3;
        public string pathName = "branch";
        public Color nodeColor = new Color(1, 0.5f, 0);

        public string startFromPath = "main";
        public string endOnPath = "";

        // Override the path name of the first node in the path.  Useful for connecting other paths to it
        public string startNodePathNameOverride = "";
    
        // Override the path name of the first node in the path.  Useful for connecting other paths to it
        public string endNodePathNameOverride = "";

        // Number of searches to perform at once.  This helps converge to a solution faster if we are stuck on a single search path.
        // However, this might increase the overall search time by a little bit. 
        public int numParallelSearches = 1;
        public long maxFramesToProcess = 2000;
        
        public bool drawDebug = false;
        
        
        class StartNodeCandidate
        {
            public DungeonUID StartNodeId;
            public FlowLayoutGraphNode OriginatingHeadNode;
        }
        
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (minPathSize <= 0)
            {
                output.ErrorMessage = "Invalid path size";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output.State = input.CloneInputState();
            var graph = output.State.GetState<FlowLayoutGraph>();
            maxPathSize = Mathf.Max(maxPathSize, minPathSize);

            if (graph == null || graph.Nodes.Count == 0)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            var graphQuery = new FlowLayoutGraphQuery(graph);
            var possibleStartNodes = new List<StartNodeCandidate>();

            // Find the start node candidates
            {
                var sourceNodes = FlowLayoutGraphUtils.FindNodesOnPath(graph, startFromPath);
                if (sourceNodes.Length == 0)
                {
                    output.ErrorMessage = string.Format("Start path '{0}' not found", startFromPath);
                    output.ExecutionResult = FlowTaskExecutionResult.FailRetry;
                    return output;
                }
                

                foreach (var headNode in sourceNodes)
                {
                    if (headNode == null) continue;

                    var startNodeIds = graphQuery.GetConnectedNodes(headNode.nodeId);
                    foreach (var startNodeId in startNodeIds)
                    {
                        var startNode = graphQuery.GetNode(startNodeId);
                        if (startNode == null || startNode.active)
                        {
                            continue;
                        }
                        var startNodeInfo = new StartNodeCandidate();
                        startNodeInfo.StartNodeId = startNodeId;
                        startNodeInfo.OriginatingHeadNode = headNode;
                        possibleStartNodes.Add(startNodeInfo);
                    }
                }
                
                if (possibleStartNodes.Count == 0)
                {
                    output.ErrorMessage = string.Format("Not enough space to grow out of '{0}'", startFromPath);
                    output.ExecutionResult = FlowTaskExecutionResult.FailRetry;
                    return output;
                }
            }

            
            
            // Find the sink node candidates
            var sinkNodes = FlowLayoutGraphUtils.FindNodesOnPath(graph, endOnPath);
            if (endOnPath.Length > 0 && sinkNodes.Length == 0)
            {
                output.ErrorMessage = string.Format("End path '{0}' not found", endOnPath);
                output.ExecutionResult = FlowTaskExecutionResult.FailRetry;
                return output;
            }

            var pathingSystem = new FFlowAgPathingSystem(maxFramesToProcess);
            {
                var visitedStartNodes = new HashSet<DungeonUID>();
                var startNodeIndices = MathUtils.GetShuffledIndices(possibleStartNodes.Count, context.Random);
                foreach (var startNodeIdx in startNodeIndices)
                {
                    var startNodeInfo = possibleStartNodes[startNodeIdx];
                    var startNodeId = startNodeInfo.StartNodeId;
                    if (visitedStartNodes.Contains(startNodeId)) continue;
                    visitedStartNodes.Add(startNodeId);

                    var startNode = graphQuery.GetNode(startNodeId);
                    if (startNode == null || startNode.active) continue;

                    var staticState = new FlowLayoutStaticGrowthState();
                    staticState.Graph = graph;
                    staticState.GraphQuery = graphQuery;
                    staticState.HeadNode = startNodeInfo.OriginatingHeadNode;
                    staticState.SinkNodes = new List<FlowLayoutGraphNode>(sinkNodes);
                    staticState.Random = context.Random;
                    staticState.MinPathSize = minPathSize;
                    staticState.MaxPathSize = maxPathSize;
                    staticState.NodeColor = nodeColor;
                    staticState.PathName = pathName;
                    staticState.StartNodePathNameOverride = startNodePathNameOverride;
                    staticState.EndNodePathNameOverride = endNodePathNameOverride;
                    staticState.NodeGroupGenerator = CreateNodeGroupGenerator(context.DomainExtensions, graph, context.Random);
                    staticState.GraphConstraint = CreateGraphConstraint(context.DomainExtensions, graph, context.Random);
                    staticState.NodeCreationConstraint = CreateNodeCreationConstraint(context.DomainExtensions, graph, context.Random);
                    
                    pathingSystem.RegisterGrowthSystem(startNode, staticState);
                }
            }

            pathingSystem.Execute(numParallelSearches);
            if (pathingSystem.FoundResult)
            {
                var result = pathingSystem.Result;
                FinalizePath(result.StaticState, result.SharedState, result.State);

                output.ExecutionResult = FlowTaskExecutionResult.Success;
                return output;
            }

            EFlowLayoutGrowthErrorType pathingError = pathingSystem.GetLastError();
            if (pathingError == EFlowLayoutGrowthErrorType.CannotMerge)
            {
                output.ErrorMessage = "Cannot Merge back";
            }
            else if (pathingError == EFlowLayoutGrowthErrorType.NodeConstraint)
            {
                output.ErrorMessage = "Error: Check Constraints";
            }
            else if (pathingError == EFlowLayoutGrowthErrorType.GraphConstraint)
            {
                output.ErrorMessage = "Error: Check Module Constraints";
            }
            else
            {
                output.ErrorMessage = "Cannot find path";
            }
            output.ExecutionResult = FlowTaskExecutionResult.FailRetry;
            return output;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\LayoutBaseFlowTaskFinalizeGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Items;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tasks
{
    public class LayoutBaseFlowTaskFinalizeGraph : FlowExecTask
    {
        public bool debugDraw = false;
        public int oneWayDoorPromotionWeight = 0;


        struct ItemInfo
        {
            public ItemInfo(FlowItem item, FlowLayoutGraphNode node, FlowLayoutGraphLink link)
            {
                this.item = item;
                this.node = node;
                this.link = link;
            }

            public object GetParent()
            {
                if (node == null) return link;
                return node;
            }

            public FlowItem item;
            public FlowLayoutGraphNode node;
            public FlowLayoutGraphLink link;
        }

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output.State = input.CloneInputState();
            var graph = output.State.GetState<FlowLayoutGraph>();

            if (graph == null)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            var weights = FlowLayoutGraphUtils.CalculateWeights(graph, 10);
            if (debugDraw)
            {
                EmitDebugInfo(graph, weights);
            }

            // Make the links one directional if the difference in the source/dest nodes is too much
            foreach (var link in graph.Links)
            {
                if (link.state.type == FlowLayoutGraphLinkType.Unconnected) continue;
                var source = graph.GetNode(link.source);
                var dest = graph.GetNode(link.destination);
                if (source == null || dest == null) continue;
                if (!source.active || !dest.active) continue;

                int weightDiff = (weights[source] + 1) - weights[dest];
                if (weightDiff > oneWayDoorPromotionWeight)
                {
                    link.state.type = FlowLayoutGraphLinkType.OneWay;
                }
            }

            // Remove undirected links
            var links = graph.Links.ToArray();
            foreach (var link in links)
            {
                if (link.state.type == FlowLayoutGraphLinkType.Unconnected)
                {
                    graph.RemoveLink(link);
                }
            }

            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }

        protected IntVector2 GetNodeCoord(FlowLayoutGraphNode node)
        {
            var coordF = node.coord;
            return new IntVector2(Mathf.RoundToInt(coordF.x), Mathf.RoundToInt(coordF.y));
        }



        private void EmitDebugInfo(FlowLayoutGraph graph, Dictionary<FlowLayoutGraphNode, int> weights)
        {
            foreach (var entry in weights)
            {
                var node = entry.Key;
                var weight = entry.Value;

                var debugItem = new FlowItem();
                debugItem.type = FlowGraphItemType.Custom;
                debugItem.customInfo.itemType = "debug";
                debugItem.customInfo.text = weight.ToString();
                debugItem.customInfo.backgroundColor = new Color(0, 0, 0.3f);
                node.AddItem(debugItem);
            }
        }

        /*
        private bool ResolveKeyLocks(FlowLayoutGraph graph, ItemInfo keyInfo, ItemInfo lockInfo)
        {
            var keyItem = keyInfo.item;
            var lockItem = lockInfo.item;
            var lockNode = lockInfo.node;
            if (lockNode == null) return false;


            var incomingLinks = (from link in graph.GetIncomingLinks(lockNode)
                                where link.state.Type != FlowLayoutGraphLinkType.Unconnected
                                select link).ToArray();

            var outgoingLinks = (from link in graph.GetOutgoingLinks(lockNode)
                                 where link.state.Type != FlowLayoutGraphLinkType.Unconnected
                                 select link).ToArray();

            bool canLockIncoming = true;
            bool canLockOutgoing = true;
            if (incomingLinks.Length == 0)
            {
                canLockIncoming = false;
            }

            if (outgoingLinks.Length == 0)
            {
                canLockOutgoing = false;
            }

            var lockParent = lockInfo.GetParent();
            var keyParent = keyInfo.GetParent();
            if (lockParent == keyParent && lockParent != null)
            {
                canLockIncoming = false;
            }

            if (!canLockIncoming && !canLockOutgoing)
            {
                return false;
            }

            keyItem.referencedItemIds.Remove(lockItem.itemId);
            lockNode.Items.Remove(lockItem);

            FlowLayoutGraphLink[] linksToLock;
            if (canLockIncoming && canLockOutgoing)
            {
                // We can lock either the incoming or outgoing.  Choose the one that requires less links to be locked
                if (incomingLinks.Length == outgoingLinks.Length)
                {
                    linksToLock = incomingLinks;
                }
                else
                {
                    linksToLock = outgoingLinks.Length < incomingLinks.Length ? outgoingLinks : incomingLinks;
                }
            }
            else
            {
                linksToLock = canLockOutgoing ? outgoingLinks : incomingLinks;
            }
            foreach (var link in linksToLock)
            {
                var linkLock = lockItem.Clone();
                linkLock.itemId = System.Guid.NewGuid();
                link.state.AddItem(linkLock);
                keyItem.referencedItemIds.Add(linkLock.itemId);
            }

            return true;
        }
        */
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\LayoutBaseFlowTaskMirrorGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tasks
{
    public abstract class LayoutBaseFlowTaskMirrorGraph : FlowExecTask
    {
        public LayoutBaseFlowTaskMirrorDirectionX mirrorX = LayoutBaseFlowTaskMirrorDirectionX.None;
        public LayoutBaseFlowTaskMirrorDirectionY mirrorY = LayoutBaseFlowTaskMirrorDirectionY.None;
        public LayoutBaseFlowTaskMirrorDirectionZ mirrorZ = LayoutBaseFlowTaskMirrorDirectionZ.None;
        
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output.State = input.CloneInputState();
            var graph = output.State.GetState<FlowLayoutGraph>();
            
            if (graph == null)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (mirrorX == LayoutBaseFlowTaskMirrorDirectionX.Left)
            {
                Vector3 graphCoordMin, graphCoordMax;
                GetGraphBounds(graph, out graphCoordMin, out graphCoordMax);
                
                System.Func<Vector3, bool> funcShouldMirror = (coord) => !Mathf.Approximately(coord.x, graphCoordMin.x);
                System.Func<Vector3, Vector3> funcGetMirrorCoord = (coord) => new Vector3(graphCoordMin.x - (coord.x - graphCoordMin.x), coord.y, coord.z);
                MirrorGraph(graph, funcGetMirrorCoord, funcShouldMirror, graphCoordMin, graphCoordMax);
            }
            else if (mirrorX == LayoutBaseFlowTaskMirrorDirectionX.Right)
            {
                Vector3 graphCoordMin, graphCoordMax;
                GetGraphBounds(graph, out graphCoordMin, out graphCoordMax);
                
                System.Func<Vector3, bool> funcShouldMirror = (coord) => !Mathf.Approximately(coord.x, graphCoordMax.x);
                System.Func<Vector3, Vector3> funcGetMirrorCoord = (coord) => new Vector3(graphCoordMax.x + (graphCoordMax.x - coord.x), coord.y, coord.z);
                MirrorGraph(graph, funcGetMirrorCoord, funcShouldMirror, graphCoordMin, graphCoordMax);
            }
            
            if (mirrorY == LayoutBaseFlowTaskMirrorDirectionY.Down)
            {
                Vector3 graphCoordMin, graphCoordMax;
                GetGraphBounds(graph, out graphCoordMin, out graphCoordMax);

                System.Func<Vector3, bool> funcShouldMirror = (coord) => !Mathf.Approximately(coord.y, graphCoordMin.y);
                System.Func<Vector3, Vector3> funcGetMirrorCoord = (coord) => new Vector3(coord.x, graphCoordMin.y - (coord.y - graphCoordMin.y), coord.z);
                MirrorGraph(graph, funcGetMirrorCoord, funcShouldMirror, graphCoordMin, graphCoordMax);
            }
            else if (mirrorY == LayoutBaseFlowTaskMirrorDirectionY.Up)
            {
                Vector3 graphCoordMin, graphCoordMax;
                GetGraphBounds(graph, out graphCoordMin, out graphCoordMax);

                System.Func<Vector3, bool> funcShouldMirror = (coord) => !Mathf.Approximately(coord.y, graphCoordMax.y);
                System.Func<Vector3, Vector3> funcGetMirrorCoord = (coord) => new Vector3(coord.x, graphCoordMax.y + (graphCoordMax.y - coord.y), coord.z);
                MirrorGraph(graph, funcGetMirrorCoord, funcShouldMirror, graphCoordMin, graphCoordMax);
            }

            if (mirrorZ == LayoutBaseFlowTaskMirrorDirectionZ.Back)
            {
                Vector3 graphCoordMin, graphCoordMax;
                GetGraphBounds(graph, out graphCoordMin, out graphCoordMax);

                System.Func<Vector3, bool> funcShouldMirror = (coord) => !Mathf.Approximately(coord.z, graphCoordMin.z);
                System.Func<Vector3, Vector3> funcGetMirrorCoord = (coord) => new Vector3(coord.x, coord.y, graphCoordMin.z - (coord.z - graphCoordMin.z));
                MirrorGraph(graph, funcGetMirrorCoord, funcShouldMirror, graphCoordMin, graphCoordMax);
            }
            else if (mirrorZ == LayoutBaseFlowTaskMirrorDirectionZ.Front)
            {
                Vector3 graphCoordMin, graphCoordMax;
                GetGraphBounds(graph, out graphCoordMin, out graphCoordMax);

                System.Func<Vector3, bool> funcShouldMirror = (coord) => !Mathf.Approximately(coord.z, graphCoordMax.z);
                System.Func<Vector3, Vector3> funcGetMirrorCoord = (coord) => new Vector3(coord.x, coord.y, graphCoordMax.z + (graphCoordMax.z - coord.z));
                MirrorGraph(graph, funcGetMirrorCoord, funcShouldMirror, graphCoordMin, graphCoordMax);
            }

            // Fix the coords so they start with 0,0,0
            FixNodeCoords(graph);
            
            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }

        void FixNodeCoords(FlowLayoutGraph graph)
        {
            Vector3 graphCoordMin, graphCoordMax;
            GetGraphBounds(graph, out graphCoordMin, out graphCoordMax);
            var offset = -graphCoordMin;
            foreach (var node in graph.Nodes)
            {
                node.coord += offset;
                node.position = GetNodePosition(node.coord, graphCoordMin, graphCoordMax);
            }
        }
        

        protected abstract Vector3 GetNodePosition(Vector3 coord, Vector3 coordMin, Vector3 coordMax);
        
        void MirrorGraph(FlowLayoutGraph graph, System.Func<Vector3, Vector3> funcGetMirrorCoord, System.Func<Vector3, bool> funcShouldMirror,
            Vector3 graphCoordMin, Vector3 graphCoordMax)
        {
            var sourceToMirrorNodes = new Dictionary<FlowLayoutGraphNode, FlowLayoutGraphNode>();
            var sourceToMirrorSubNodes = new Dictionary<DungeonUID, DungeonUID>();
            var nodesCopy = graph.Nodes.ToArray();
            foreach (var sourceNode in nodesCopy)
            {
                FlowLayoutGraphNode mirroredNode;
                if (funcShouldMirror(sourceNode.coord))
                {
                    mirroredNode = sourceNode.Clone();
                    mirroredNode.nodeId = DungeonUID.NewUID();
                    mirroredNode.coord = funcGetMirrorCoord(sourceNode.coord);
                    mirroredNode.position = GetNodePosition(mirroredNode.coord, graphCoordMin, graphCoordMax);
                    graph.AddNode(mirroredNode);
                }
                else
                {
                    mirroredNode = sourceNode;
                }

                for (int i = 0; i < sourceNode.MergedCompositeNodes.Count; i++)
                {
                    if (mirroredNode != sourceNode)
                    {
                        mirroredNode.MergedCompositeNodes[i].nodeId = DungeonUID.NewUID();
                    }
                    
                    var sourceSubNodeID = sourceNode.MergedCompositeNodes[i].nodeId;
                    var mirrorSubNodeID = mirroredNode.MergedCompositeNodes[i].nodeId;
                    sourceToMirrorSubNodes[sourceSubNodeID] = mirrorSubNodeID;
                }
                
                sourceToMirrorNodes[sourceNode] = mirroredNode;
            }
            
            var graphQuery = new FlowLayoutGraphQuery(graph);   // Note: Will query only with the source links since we haven't added the mirrored links yet
            var linksCopy = graph.Links.ToArray();
            foreach (var sourceLink in linksCopy)
            {
                // clone only if the start or end nodes have been mirrored
                var sourceLinkSrc = graphQuery.GetNode(sourceLink.source);
                var sourceLinkDst = graphQuery.GetNode(sourceLink.destination);

                if (funcShouldMirror(sourceLinkSrc.coord) || funcShouldMirror(sourceLinkDst.coord))
                {
                    if (sourceToMirrorNodes.ContainsKey(sourceLinkSrc) && sourceToMirrorNodes.ContainsKey(sourceLinkDst))
                    {
                        var mirrorLinkSrc = sourceToMirrorNodes[sourceLinkSrc];
                        var mirrorLinkDst = sourceToMirrorNodes[sourceLinkDst];
                        var mirrorLink = graph.MakeLink(mirrorLinkSrc, mirrorLinkDst);
                        mirrorLink.state = sourceLink.state.Clone();
                        if (sourceToMirrorSubNodes.ContainsKey(sourceLink.sourceSubNode) && sourceToMirrorSubNodes.ContainsKey(sourceLink.destinationSubNode))
                        {
                            mirrorLink.sourceSubNode = sourceToMirrorSubNodes[sourceLink.sourceSubNode];
                            mirrorLink.destinationSubNode = sourceToMirrorSubNodes[sourceLink.destinationSubNode];
                        }
                    }
                }
            }
        }
        
        
        bool GetGraphBounds(FlowLayoutGraph graph, out Vector3 graphCoordMin, out Vector3 graphCoordMax)
        {
            if (graph == null || graph.Nodes.Count == 0)
            {
                graphCoordMin = Vector3.zero;
                graphCoordMax = Vector3.zero;
                return false;
            }
            
            graphCoordMin = graphCoordMax = graph.Nodes[0].coord;

            foreach (var node in graph.Nodes)
            {
                graphCoordMin = MathUtils.ComponentMin(graphCoordMin, node.coord);
                graphCoordMax = MathUtils.ComponentMax(graphCoordMax, node.coord);
            }
            
            return true;
        }

    }
    
    
    public enum LayoutBaseFlowTaskMirrorDirectionX
    { 
        None,
        Left, 
        Right
    }
    
    public enum LayoutBaseFlowTaskMirrorDirectionY
    {
        None, 
        Up, 
        Down
    }
    
    public enum LayoutBaseFlowTaskMirrorDirectionZ
    { 
        None,
        Front, 
        Back
    }


} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\LayoutBaseFlowTaskPathBuilderBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Domains.Layout.Tasks
{
    public abstract class LayoutBaseFlowTaskPathBuilderBase : FlowExecTask
    {
        protected virtual void FinalizePath(FlowLayoutStaticGrowthState staticState, FlowLayoutSharedGrowthState sharedState, FlowLayoutGrowthState state)
        {
            FlowLayoutGraphPathUtils.FinalizePath(staticState, sharedState, state);
        }


        protected virtual FlowLayoutNodeGroupGenerator CreateNodeGroupGenerator(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            return new NullFlowLayoutNodeGroupGenerator();
        }

        protected virtual IFlowLayoutGraphConstraints CreateGraphConstraint(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            return new NullFlowLayoutGraphConstraints();
        }

        protected virtual IFlowLayoutNodeCreationConstraint CreateNodeCreationConstraint(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            return new NullFlowLayoutNodeCreationConstraint();
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\LayoutBaseFlowTaskSpawnItems.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Items;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tasks
{
    [System.Serializable]
    public enum LayoutFlowNodeHandler_SpawnItemMethod
    {
        RandomRange,
        LinearDifficulty,
        CurveDifficulty
    }
    
    public class LayoutBaseFlowTaskSpawnItems : FlowExecTask
    {
        public string[] paths = new string[] { "main" };

        public FlowGraphItemType itemType = FlowGraphItemType.Enemy;
        public string markerName = "";
        public FlowGraphItemCustomInfo customItemInfo = FlowGraphItemCustomInfo.Default;
        public int minCount = 1;
        public int maxCount = 4;
        public LayoutFlowNodeHandler_SpawnItemMethod spawnMethod = LayoutFlowNodeHandler_SpawnItemMethod.LinearDifficulty;
        public AnimationCurve spawnDistributionCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float spawnDistributionVariance = 0.2f;
        public float minSpawnDifficulty = 0.0f;
        public float spawnProbability = 1.0f;

        public bool showDifficulty = false;
        public Color difficultyInfoColor = new Color(0, 0, 0.5f);

        class NodeInfo
        {
            public NodeInfo(FlowLayoutGraphNode node, float weight)
            {
                this.node = node;
                this.weight = weight;
            }

            public FlowLayoutGraphNode node;
            public float weight;
        }

        protected virtual bool Validate(FlowTaskExecContext context, FlowTaskExecInput input, ref string errorMessage, ref FlowTaskExecutionResult executionResult)
        {
            return true;
        }
        
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output.State = input.CloneInputState();
            if (!Validate(context, input, ref output.ErrorMessage, ref output.ExecutionResult))
            {
                return output;
            }
            
            var graph = output.State.GetState<FlowLayoutGraph>();

            var nodesByPath = new Dictionary<string, NodeInfo[]>();
            {
                var weights = FlowLayoutGraphUtils.CalculateWeights(graph, 1);
                var nodesByPathList = new Dictionary<string, List<NodeInfo>>();
                foreach (var entry in weights)
                {
                    var node = entry.Key;
                    var weight = entry.Value;

                    var pathName = node.pathName;
                    if (paths.Contains(pathName))
                    {
                        if (!nodesByPathList.ContainsKey(pathName))
                        {
                            nodesByPathList.Add(pathName, new List<NodeInfo>());
                        }
                        nodesByPathList[pathName].Add(new NodeInfo(node, weight));
                    }

                }

                // Sort the path list
                foreach (var entry in nodesByPathList)
                {
                    var pathName = entry.Key;
                    var pathList = entry.Value;
                    var sortedPath = pathList.OrderBy(info => info.weight).ToArray();
                    nodesByPath.Add(pathName, sortedPath);
                }
            }

            // Normalize the weights
            foreach (var entry in nodesByPath)
            {
                var pathName = entry.Key;
                var pathNodes = entry.Value;
                if (pathName.Length == 0) continue;

                float minWeight = float.MaxValue;
                float maxWeight = -float.MaxValue;
                foreach(var pathNode in pathNodes)
                {
                    minWeight = Mathf.Min(minWeight, pathNode.weight);
                    maxWeight = Mathf.Max(maxWeight, pathNode.weight);
                }

                foreach (var pathNode in pathNodes)
                {
                    if (Mathf.Abs(maxWeight - minWeight) > 1e-6f)
                    {
                        pathNode.weight = (pathNode.weight - minWeight) / (maxWeight - minWeight);
                    }
                    else
                    {
                        pathNode.weight = 1;
                    }
                }
            }

            foreach (var pathName in paths)
            {
                if (!nodesByPath.ContainsKey(pathName)) continue;
                NodeInfo[] pathNodes = nodesByPath[pathName];

                foreach (var pathNode in pathNodes)
                {
                    if (pathNode.weight < minSpawnDifficulty) continue;
                    int spawnCount = GetSpawnCount(context.Random, pathNode.weight);

                    for (int i = 0; i < spawnCount; i++)
                    {
                        var item = new FlowItem();
                        item.type = itemType;
                        item.markerName = markerName;
                        item.customInfo = customItemInfo;
                        pathNode.node.AddItem(item);
                        HandleItemSpawn(pathNode.node, item);
                    }
                }

                if (showDifficulty)
                {
                    EmitDebugInfo(pathNodes);
                }
            }

            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }

        protected virtual void HandleItemSpawn(FlowLayoutGraphNode node, FlowItem item)
        {
        }

        int GetSpawnCount(System.Random random, float weight)
        {
            weight = Mathf.Clamp01(weight);
            
            if (spawnMethod == LayoutFlowNodeHandler_SpawnItemMethod.CurveDifficulty && spawnDistributionCurve == null)
            {
                spawnMethod = LayoutFlowNodeHandler_SpawnItemMethod.LinearDifficulty;
            }

            int spawnCount = 0;
            if (spawnMethod == LayoutFlowNodeHandler_SpawnItemMethod.RandomRange)
            {
                spawnCount = random.Range(minCount, maxCount);
            }
            else if (spawnMethod == LayoutFlowNodeHandler_SpawnItemMethod.LinearDifficulty)
            {
                var v = random.Range(-spawnDistributionVariance, spawnDistributionVariance);
                var w = Mathf.Clamp01(weight + v);
                spawnCount = Mathf.RoundToInt(minCount + (maxCount - minCount) * w);
            }
            else if (spawnMethod == LayoutFlowNodeHandler_SpawnItemMethod.CurveDifficulty)
            {
                var v = random.Range(-spawnDistributionVariance, spawnDistributionVariance);
                var w = Mathf.Clamp01(weight + v);
                float t = spawnDistributionCurve.Evaluate(w);
                spawnCount = Mathf.RoundToInt(minCount + (maxCount - minCount) * t);
            }

            spawnProbability = Mathf.Clamp01(spawnProbability);
            if (random.NextFloat() > spawnProbability)
            {
                spawnCount = 0;
            }
            return spawnCount;
        }

        void EmitDebugInfo(NodeInfo[] nodes)
        {
            foreach (var nodeInfo in nodes)
            {
                var node = nodeInfo.node;
                var weight = nodeInfo.weight;

                var debugItem = new FlowItem();
                debugItem.type = FlowGraphItemType.Custom;
                debugItem.customInfo.text = weight.ToString("0.0");
                debugItem.customInfo.backgroundColor = difficultyInfoColor;
                node.AddItem(debugItem);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tasks\TilemapBaseFlowTaskCreateElevations.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Utils.Noise;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tasks
{
    public class TilemapBaseFlowTaskCreateElevations : FlowExecTask
    {
        public string markerName = "Rock";

        public int noiseOctaves = 4;
        public float noiseFrequency = 0.01f;
        public float noiseValuePower = 0;
        public int numSteps = 4;

        public float minHeight = -20;
        public float maxHeight = -5;
        public float seaLevel = -10;

        public Color landColor = new Color(0.4f, 0.2f, 0);
        public Color seaColor = new Color(0, 0, 0.4f);
        public float minColorMultiplier = 0.1f;

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            var incomingTilemap = input.IncomingTaskOutputs[0].State.GetState<FlowTilemap>();
            if (incomingTilemap == null)
            {
                output.ErrorMessage = "Missing tilemap input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            var incomingGraph = input.IncomingTaskOutputs[0].State.GetState<FlowLayoutGraph>();
            if (incomingGraph == null)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            var tilemap = new FlowTilemap(incomingTilemap.Width, incomingTilemap.Height);
            var graph = incomingGraph.Clone() as FlowLayoutGraph;

            output.State.SetState(typeof(FlowTilemap), tilemap);
            output.State.SetState(typeof(FlowLayoutGraph), graph);
            
            var random = context.Random;
            var noiseTable = new GradientNoiseTable();
            noiseTable.Init(128, random);

            // Assign the valid traversable paths 
            for (int y = 0; y < tilemap.Height; y++)
            {
                for (int x = 0; x < tilemap.Width; x++)
                {
                    var incomingCell = incomingTilemap.Cells[x, y];
                    var cell = tilemap.Cells[x, y];
                    float cellHeight = 0;
                    if (incomingCell.CellType == FlowTilemapCellType.Empty)
                    {
                        var position = new Vector2(x, y) * noiseFrequency;
                        var n = noiseTable.GetNoiseFBM(position, noiseOctaves);
                        if (noiseValuePower > 1e-6f)
                        {
                            n = Mathf.Pow(n, noiseValuePower);
                        }
                        n = Mathf.Floor(n * numSteps) / numSteps;
                        cellHeight = minHeight + n * (maxHeight - minHeight);
                    }

                    cell.CellType = FlowTilemapCellType.Custom;
                    cell.CustomCellInfo = new FlowTilemapCustomCellInfo();
                    cell.CustomCellInfo.name = markerName;
                    cell.Height = cellHeight;
                    var color = (cell.Height <= seaLevel) ? seaColor : landColor;
                    var minColor = color * minColorMultiplier;
                    var colorBrightness = 1.0f;
                    if (Mathf.Abs(maxHeight - minHeight) > 1e-6f)
                    {
                        colorBrightness = (cell.Height - minHeight) / (maxHeight - minHeight);
                    }
                    cell.CustomCellInfo.defaultColor = Color.Lerp(minColor, color, colorBrightness);
                }
            }

            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tasks\TilemapBaseFlowTaskCreateOverlay.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Utils.Noise;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tasks
{
    public enum TilemapFlowNodeHandler_CreateTilemapOverlayGenMethod
    {
        Noise,
        Script
    }

    [System.Serializable]
    public class TilemapFlowNodeOverlayNoiseSettings
    {
        public int noiseOctaves = 4;
        public float noiseFrequency = 0.15f;
        public float noiseValuePower = 0;
        public float noiseMinValue = 0;
        public float noiseMaxValue = 1.0f;
        public float noiseThreshold = 0.5f;
        public int minDistFromMainPath = 2;
    }

    public interface ITilemapFlowOverlayGenerator
    {
        void Init(System.Random random);
        bool Generate(FlowTilemapCell cell, FlowTilemapCell incomingCell, System.Random random, ref float overlayValue);
    }

    public class NoiseTilemapFlowOverlayGenerator : ITilemapFlowOverlayGenerator
    {
        GradientNoiseTable noiseTable;
        TilemapFlowNodeOverlayNoiseSettings noiseSettings;
        public NoiseTilemapFlowOverlayGenerator(TilemapFlowNodeOverlayNoiseSettings noiseSettings)
        {
            this.noiseSettings = noiseSettings;
        }

        public void Init(System.Random random)
        {
            noiseTable = new GradientNoiseTable();
            noiseTable.Init(128, random);

            noiseSettings.minDistFromMainPath = Mathf.Max(1, noiseSettings.minDistFromMainPath);
        }

        public bool Generate(FlowTilemapCell cell, FlowTilemapCell incomingCell, System.Random random, ref float overlayValue)
        {
            var cellCoord = incomingCell.TileCoord;
            var position = cellCoord.ToVector2() * noiseSettings.noiseFrequency;
            var n = noiseTable.GetNoiseFBM(position, noiseSettings.noiseOctaves);
            if (noiseSettings.noiseValuePower > 0.0f)
            {
                n = Mathf.Pow(n, noiseSettings.noiseValuePower);
            }

            n = noiseSettings.noiseMinValue + (noiseSettings.noiseMaxValue - noiseSettings.noiseMinValue) * n;

            if (n > noiseSettings.noiseThreshold)
            {
                var distanceFromMainPath = incomingCell.DistanceFromMainPath;
                float noiseFactor = (n - noiseSettings.noiseThreshold) / (1.0f - noiseSettings.noiseThreshold);
                bool insertOverlay = (noiseFactor * distanceFromMainPath > noiseSettings.minDistFromMainPath);

                if (insertOverlay)
                {
                    overlayValue = n;
                    return true;
                }
            }
            return false;
        }
    }
    
    public class TilemapBaseFlowTaskCreateOverlay : FlowExecTask
    {
        public string markerName = "Tree";
        public Color color = Color.green;
        public bool overlayBlocksTile = true;
        public TilemapFlowNodeHandler_CreateTilemapOverlayGenMethod generationMethod = TilemapFlowNodeHandler_CreateTilemapOverlayGenMethod.Noise;
        public TilemapFlowNodeOverlayNoiseSettings noiseSettings = new TilemapFlowNodeOverlayNoiseSettings();
        public FlowTilemapCellOverlayMergeConfig mergeConfig = new FlowTilemapCellOverlayMergeConfig();
        public string generatorScriptClass;

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            var incomingTilemap = input.IncomingTaskOutputs[0].State.GetState<FlowTilemap>();
            if (incomingTilemap == null)
            {
                output.ErrorMessage = "Missing tilemap input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            var incomingGraph = input.IncomingTaskOutputs[0].State.GetState<FlowLayoutGraph>();
            if (incomingGraph == null)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            var tilemap = new FlowTilemap(incomingTilemap.Width, incomingTilemap.Height);
            var graph = incomingGraph.Clone() as FlowLayoutGraph;

            output.State.SetState(typeof(FlowTilemap), tilemap);
            output.State.SetState(typeof(FlowLayoutGraph), graph);
            
            var random = context.Random;
            var generator = createGeneratorInstance();
            if (generator == null)
            {
                output.ErrorMessage = "Invalid script reference";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            generator.Init(random);

            // Create overlays
            for (int y = 0; y < tilemap.Height; y++)
            {
                for (int x = 0; x < tilemap.Width; x++)
                {
                    var incomingCell = incomingTilemap.Cells[x, y];
                    var cell = tilemap.Cells[x, y];

                    float overlayValue = 0;
                    if (generator.Generate(cell, incomingCell, random, ref overlayValue))
                    {
                        var overlay = new FlowTilemapCellOverlay();
                        overlay.markerName = markerName;
                        overlay.color = color;
                        overlay.noiseValue = overlayValue;
                        overlay.mergeConfig = mergeConfig;
                        overlay.tileBlockingOverlay = overlayBlocksTile;

                        cell.Overlay = overlay;
                    }
                }
            }

            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }

        ITilemapFlowOverlayGenerator createGeneratorInstance()
        {
            ITilemapFlowOverlayGenerator generator = null;
            if (generationMethod == TilemapFlowNodeHandler_CreateTilemapOverlayGenMethod.Noise)
            {
                generator = new NoiseTilemapFlowOverlayGenerator(noiseSettings);
            }
            else if (generationMethod == TilemapFlowNodeHandler_CreateTilemapOverlayGenMethod.Script)
            {
                if (generatorScriptClass != null)
                {
                    var type = System.Type.GetType(generatorScriptClass);
                    if (type != null)
                    {
                        generator = ScriptableObject.CreateInstance(type) as ITilemapFlowOverlayGenerator;
                    }
                }
            }
            return generator;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tasks\TilemapBaseFlowTaskFinalize.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tasks
{
    public class TilemapBaseFlowTaskFinalize : FlowExecTask
    {
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output.State = input.CloneInputState();
            var tilemap = output.State.GetState<FlowTilemap>();
            if (tilemap == null)
            {
                output.ErrorMessage = "Missing tilemap input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            var graph = output.State.GetState<FlowLayoutGraph>();

            if (!AssignItems(tilemap, graph, context.Random, ref output.ErrorMessage))
            {
                output.ExecutionResult = FlowTaskExecutionResult.FailRetry;
                return output;
            }
            
            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }

        protected virtual bool AssignItems(FlowTilemap tilemap, FlowLayoutGraph graph, System.Random random, ref string errorMessage)
        {
            return true;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tasks\TilemapBaseFlowTaskInitialize.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tasks
{
    [System.Serializable]
    public enum TilemapFlowNodeWallGenerationMethod
    {
        WallAsTiles,
        WallAsEdges,
    }

    public abstract class TilemapBaseFlowTaskInitialize : FlowExecTask
    {
        protected virtual bool Validate(FlowTaskExecContext context, FlowTaskExecInput input, FlowTaskExecOutput output)
        {
            return true;
        }

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            output.State = input.CloneInputState();
            if (!Validate(context, input, output))
            {
                // Failed
                return output;
            }
            
            var graph = output.State.GetState<FlowLayoutGraph>();  // TODO: Remove the need to cast
            if (graph == null)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            var tilemap = BuildTilemap(graph, context.Random);
            if (tilemap == null)
            {
                output.ErrorMessage = "Failed to generate tilemap";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            output.State.SetState(typeof(FlowTilemap), tilemap);
            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }

        protected abstract FlowTilemap BuildTilemap(FlowLayoutGraph graph, System.Random random);

    }
    
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tasks\TilemapBaseFlowTaskMerge.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tasks
{
    public class TilemapBaseFlowTaskMerge : FlowExecTask
    {   
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            FlowLayoutGraph incomingGraph = null;
            var incomingTilemaps = new List<FlowTilemap>();
            foreach (var incomingOutput in input.IncomingTaskOutputs)
            {
                var incomingTilemap = incomingOutput.State.GetState<FlowTilemap>();
                if (incomingTilemap != null)
                {
                    incomingTilemaps.Add(incomingTilemap);
                }

                if (incomingGraph == null)
                {
                    incomingGraph = incomingOutput.State.GetState<FlowLayoutGraph>();
                }
            }
            
            if (incomingTilemaps.Count == 0)
            {
                output.ErrorMessage = "Missing tilemap input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            if (incomingGraph == null)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            var tilemap = new FlowTilemap(incomingTilemaps[0].Width, incomingTilemaps[0].Height);
            var graph = incomingGraph.Clone() as FlowLayoutGraph;

            output.State.SetState(typeof(FlowTilemap), tilemap);
            output.State.SetState(typeof(FlowLayoutGraph), graph);

            var registeredStateTypes = new HashSet<System.Type>();
            registeredStateTypes.Add(typeof(FlowTilemap));
            registeredStateTypes.Add(typeof(FlowLayoutGraph));
            
            // Clone all the missing states from the incoming nodes
            foreach (var incomingOutput in input.IncomingTaskOutputs)
            {
                foreach (var incomingOutputStateType in incomingOutput.State.GetRegisteredStateTypes())
                {
                    if (!registeredStateTypes.Contains(incomingOutputStateType))
                    {
                        var incomingState = incomingOutput.State.GetState(incomingOutputStateType);
                        if (incomingState != null)
                        {
                            var clonedState = incomingState.Clone() as ICloneable;
                            if (clonedState != null)
                            {
                                output.State.SetState(incomingOutputStateType, clonedState);
                                registeredStateTypes.Add(incomingOutputStateType);
                            }
                        }
                    }
                }
            }

            // merge the cells
            for (int y = 0; y < tilemap.Height; y++)
            {
                for (int x = 0; x < tilemap.Width; x++)
                {
                    int bestWeight = 0;
                    FlowTilemapCell bestCell = null;
                    var incomingOverlays = new List<FlowTilemapCellOverlay>();
                    foreach (var incomingTilemap in incomingTilemaps)
                    {
                        var weight = 0;
                        var incomingCell = incomingTilemap.Cells[x, y];
                        if (incomingCell.CellType == FlowTilemapCellType.Empty)
                        {
                            weight = 1;
                        }
                        else if (incomingCell.CellType == FlowTilemapCellType.Custom)
                        {
                            weight = 2;
                        }
                        else
                        {
                            weight = 3;
                        }

                        if (incomingCell.Overlay != null)
                        {
                            incomingOverlays.Add(incomingCell.Overlay);
                        }

                        bool useResult = false;
                        if (weight > bestWeight)
                        {
                            useResult = true;
                        }
                        else if (weight == bestWeight)
                        {
                            if (bestCell != null && incomingCell.Height > bestCell.Height)
                            {
                                useResult = true;
                            }
                        }

                        if (useResult)
                        {
                            bestCell = incomingCell;
                            bestWeight = weight;
                        }
                    }
                    
                    tilemap.Cells[x, y] = bestCell.Clone();
                    var resultCell = tilemap.Cells[x, y];
                    FlowTilemapCellOverlay bestOverlay = null;
                    float bestOverlayWeight = 0;
                    foreach (var incomingOverlay in incomingOverlays)
                    {
                        var valid = resultCell.Height >= incomingOverlay.mergeConfig.minHeight
                                   && resultCell.Height <= incomingOverlay.mergeConfig.maxHeight;

                        if (valid)
                        {
                            if (bestOverlay == null || incomingOverlay.noiseValue > bestOverlayWeight)
                            {
                                bestOverlay = incomingOverlay;
                                bestOverlayWeight = incomingOverlay.noiseValue;
                            }
                        }
                    }
                    if (bestOverlay != null)
                    {
                        resultCell.Overlay = bestOverlay.Clone();
                    }
                }
            }

            // Merge the edges
            for (int y = 0; y <= tilemap.Height; y++)
            {
                for (int x = 0; x <= tilemap.Width; x++)
                {
                    FlowTilemapEdge bestEdgeH = null;
                    FlowTilemapEdge bestEdgeV = null;
                    foreach (var incomingTilemap in incomingTilemaps)
                    {
                        var incomingEdgeH = incomingTilemap.Edges.GetHorizontal(x, y);
                        var incomingEdgeV = incomingTilemap.Edges.GetVertical(x, y);
                        if (incomingEdgeH.EdgeType != FlowTilemapEdgeType.Empty)
                        {
                            bestEdgeH = incomingEdgeH;
                        }
                        if (incomingEdgeV.EdgeType != FlowTilemapEdgeType.Empty)
                        {
                            bestEdgeV = incomingEdgeV;
                        }
                    }

                    if (bestEdgeH != null)
                    {
                        tilemap.Edges.SetHorizontal(x, y, bestEdgeH.Clone());
                    }
                    if (bestEdgeV != null)
                    {
                        tilemap.Edges.SetVertical(x, y, bestEdgeV.Clone());
                    }
                }
            }


            foreach (var cell in tilemap.Cells)
            {
                if (cell.CellType == FlowTilemapCellType.Wall && cell.Overlay != null)
                {
                    if (cell.Overlay.mergeConfig != null)
                    {
                        var wallOverlayRule = cell.Overlay.mergeConfig.wallOverlayRule;
                        if (wallOverlayRule == FlowTilemapCellOverlayMergeWallOverlayRule.KeepOverlayRemoveWall)
                        {
                            cell.CellType = FlowTilemapCellType.Floor;
                            cell.UseCustomColor = true;
                        }
                        else if (wallOverlayRule == FlowTilemapCellOverlayMergeWallOverlayRule.KeepWallRemoveOverlay)
                        {
                            cell.Overlay = null;
                        }
                    }
                }
            }

            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tasks\TilemapBaseFlowTaskOptimize.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Exec;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tasks
{
    public class TilemapBaseFlowTaskOptimize : FlowExecTask
    {
        public int discardDistanceFromLayout= 3;
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = new FlowTaskExecOutput();
            if (input.IncomingTaskOutputs.Length == 0)
            {
                output.ErrorMessage = "Missing Input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }

            if (input.IncomingTaskOutputs.Length > 1)
            {
                output.ErrorMessage = "Only one input allowed";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            output.State = input.CloneInputState();
            var tilemap = output.State.GetState<FlowTilemap>();
            if (tilemap == null)
            {
                output.ErrorMessage = "Missing tilemap input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return output;
            }
            
            DiscardDistantTiles(tilemap);

            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }

        void DiscardDistantTiles(FlowTilemap tilemap)
        {
            var width = tilemap.Width;
            var height = tilemap.Height;
            var queue = new Queue<FlowTilemapCell>();


            var childOffsets = new int[]
            {
                -1, 0,
                1, 0,
                0, -1,
                0, 1
            };

            var distanceFromLayout = new Dictionary<FlowTilemapCell, int>();
            foreach (var cell in tilemap.Cells)
            {
                if (cell.LayoutCell)
                {
                    queue.Enqueue(cell);
                    distanceFromLayout[cell] = 0;
                }
            }
            while (queue.Count > 0)
            {
                var cell = queue.Dequeue();

                // Traverse the children
                var childDistance = distanceFromLayout[cell] + 1;
                for (int i = 0; i < 4; i++)
                {
                    int nx = cell.TileCoord.x + childOffsets[i * 2 + 0];
                    int ny = cell.TileCoord.y + childOffsets[i * 2 + 1];
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height)
                    {
                        var ncell = tilemap.Cells[nx, ny];
                        if (ncell.LayoutCell) continue;
                        if (!distanceFromLayout.ContainsKey(ncell) || childDistance < distanceFromLayout[ncell])
                        {
                            distanceFromLayout[ncell] = childDistance;
                            queue.Enqueue(ncell);
                        }
                    }
                }
            }
            discardDistanceFromLayout = Mathf.Max(0, discardDistanceFromLayout);
            foreach (var cell in tilemap.Cells)
            {
                if (!distanceFromLayout.ContainsKey(cell)) continue;
                if (cell.LayoutCell) continue;
                if (distanceFromLayout[cell] > discardDistanceFromLayout)
                {
                    cell.Clear();
                }
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tooling\FlowTilemapToolGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tooling
{
    public class FlowTilemapToolGraph : Graph
    {
        public override void OnEnable()
        {
            base.OnEnable();

            hideFlags = HideFlags.HideInHierarchy;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tooling\FlowTilemapToolGraphBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tooling
{
    public class FlowTilemapToolBuildContext
    {
        public FlowTilemap tilemap;
        public FlowLayoutGraph LayoutGraph;
        public GraphBuilder graphBuilder;

        public FlowLayoutGraphNode selectedNode;
        public FlowItem selectedItem;
    }

    public class FlowTilemapToolGraphBuilder
    {
        public static void Build(FlowTilemapToolBuildContext context)
        {
            if (context.graphBuilder == null)
            {
                return;
            }

            context.graphBuilder.DestroyAllNodes();

            if (context.tilemap == null)
            {
                return;
            }

            var previewNode = context.graphBuilder.CreateNode<FlowTilemapToolGraphNode>();
            if (previewNode != null)
            {
                previewNode.SetTilemap(context.tilemap);
                previewNode.LayoutGraph = context.LayoutGraph;
                previewNode.SelectedNode = context.selectedNode;
                previewNode.SelectedItem = context.selectedItem;
            }

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\Tilemap\Tooling\FlowTilemapToolGraphNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Tilemap.Tooling
{
    public class FlowTilemapToolGraphNode : GraphNode
    {
        public int tileRenderSize = 12;
        public FlowTilemap Tilemap { get; private set; }
        public FlowLayoutGraph LayoutGraph { get; set; }
        public FlowLayoutGraphNode SelectedNode { get; set; }
        public FlowItem SelectedItem { get; set; }
        public bool RequestRecreatePreview { get; set; }

        public FlowTilemapToolGraphNode()
        {
            RequestRecreatePreview = false;
        }

        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
        }

        public void SetTilemap(FlowTilemap tilemap)
        {
            this.Tilemap = tilemap;

            // Update the bounds
            var size = new Vector2(tilemap.Width, tilemap.Height) * tileRenderSize;
            bounds = new Rect(Vector2.zero, size);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\Custom\GridFlowCustomTaskAttribute.cs:
 using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class GridFlowCustomTaskAttribute : FlowExecNodeInfoAttribute
    {
        public GridFlowCustomTaskAttribute(string title) : base(title)
        {
        }

        public GridFlowCustomTaskAttribute(string title, string menuPrefix) : base(title, menuPrefix)
        {
        }

        public GridFlowCustomTaskAttribute(string title, string menuPrefix, float weight) : base(title, menuPrefix, weight)
        {
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\LayoutGraph\GridFlowLayoutTaskCreateGrid.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Exec;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Create Grid", "Layout Graph/", 1000)]
    public class GridFlowLayoutTaskCreateGrid : FlowExecTask
    {
        public Vector2Int resolution = new Vector2Int(6, 5);

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var graph = new FlowLayoutGraph();

            int width = resolution.x;
            int height = resolution.y;
            var nodes = new FlowLayoutGraphNode[width, height];
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    var node = new FlowLayoutGraphNode();
                    node.position = new Vector2(x, height - y - 1) * GridFlowConstants.LayoutNodeEditorSpacing;
                    node.coord = new Vector3(x, y, 0);
                    nodes[x, y] = node;

                    if (x > 0)
                    {
                        var srcNode = nodes[x - 1, y];
                        var dstNode = nodes[x, y];
                        graph.MakeLinkFastUnsafe(srcNode, dstNode);
                    }
                    if (y > 0)
                    {
                        var srcNode = nodes[x, y - 1];
                        var dstNode = nodes[x, y];
                        graph.MakeLinkFastUnsafe(srcNode, dstNode);
                    }

                    graph.AddNode(node);
                }
            }
            
            var output = new FlowTaskExecOutput();
            output.State.SetState(typeof(FlowLayoutGraph), graph);
            output.ExecutionResult = FlowTaskExecutionResult.Success;
            return output;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\LayoutGraph\GridFlowLayoutTaskCreateKeyLock.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Items;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Create Key Lock", "Layout Graph/", 1040)]
    public class GridFlowLayoutTaskCreateKeyLock : LayoutBaseFlowTaskCreateKeyLock
    {
        public TilemapItemPlacementSettings placementSettings = new TilemapItemPlacementSettings();

        protected override bool Validate(FlowTaskExecContext context, FlowTaskExecInput input, ref string errorMessage, ref FlowTaskExecutionResult executionResult)
        {
            if (!TilemapItemPlacementStrategyUtils.Validate(placementSettings, ref errorMessage))
            {
                executionResult = FlowTaskExecutionResult.FailHalt;
                return false;
            }

            return true;
        }

        protected override void ProcessKeyItem(FlowItem keyItem, FlowLayoutGraphNode keyNode, FlowLayoutGraphLink lockLink)
        {
            keyItem.SetDomainData(placementSettings.Clone() as TilemapItemPlacementSettings);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\LayoutGraph\GridFlowLayoutTaskCreateMainPath.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Impl.GridFlow.Constraints;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Create Main Path", "Layout Graph/", 1010)]
    public class GridFlowLayoutTaskCreateMainPath : LayoutBaseFlowTaskCreateMainPath
    {
        [System.Serializable]
        public enum NodeConstraintType
        {
            None,
            StartEndNode,
            Script
        }
        
        public TilemapItemPlacementSettings startPlacementSettings = new TilemapItemPlacementSettings();        // TODO: Move this to grid flow impl
        public TilemapItemPlacementSettings goalPlacementSettings = new TilemapItemPlacementSettings();         // TODO: Move this to grid flow impl

        // Node position constraints
        public NodeConstraintType positionConstraintMode;
        public Vector2Int[] startNodePositionConstraints;
        public Vector2Int[] endNodePositionConstraints;
        // A ScriptableObject that implements IGridFlowLayoutNodePositionConstraint
        public string nodePositionConstraintScriptClassName;

        public bool fixedStartRoomSize = false;
        public bool fixedEndRoomSize = false;
        
        private readonly InstanceCache instanceCache = new InstanceCache();
        
        protected override bool Validate(FlowTaskExecContext context, FlowTaskExecInput input, ref string errorMessage, ref FlowTaskExecutionResult executionResult)
        {
            string placementErrorMessage = "";
            if (!TilemapItemPlacementStrategyUtils.Validate(startPlacementSettings, ref placementErrorMessage))
            {
                errorMessage = "Start Item: " + placementErrorMessage;
                executionResult = FlowTaskExecutionResult.FailHalt;
                return false;
            }

            if (!TilemapItemPlacementStrategyUtils.Validate(goalPlacementSettings, ref placementErrorMessage))
            {
                errorMessage = "Goal Item: " + placementErrorMessage;
                executionResult = FlowTaskExecutionResult.FailHalt;
                return false;
            }

            return true;
        }

        protected override void ProcessEntranceItem(FlowItem entranceItem, FlowLayoutGraphNode entranceNode)
        {
            if (startPlacementSettings != null)
            {
                entranceItem.SetDomainData(startPlacementSettings.Clone() as TilemapItemPlacementSettings);
            }
        }

        public override void ProcessGoalItem(FlowItem goalItem, FlowLayoutGraphNode goalNode)
        {
            if (goalPlacementSettings != null)
            {
                goalItem.SetDomainData(goalPlacementSettings.Clone() as TilemapItemPlacementSettings);
            }
        }

        protected override void FinalizePath(FlowLayoutStaticGrowthState staticState, FlowLayoutSharedGrowthState sharedState, FlowLayoutGrowthState state)
        {
            base.FinalizePath(staticState, sharedState, state);
            
            // Tag the nodes as main path
            int size = state.Path.Count;
            for (var i = 0; i < size; i++)
            {
                var pathItem = state.Path[i];
                var pathNode = staticState.GraphQuery.GetNode(pathItem.NodeId);
                if (pathNode != null)
                {
                    pathNode.mainPath = true;

                    var nodeState = pathNode.GetDomainData<GridFlowLayoutNodeState>();
                    nodeState.CanPerturb = true;

                    if (i == 0 && fixedStartRoomSize)
                    {
                        nodeState.CanPerturb = false;
                    }
                    
                    if (i == size - 1 && fixedEndRoomSize)
                    {
                        nodeState.CanPerturb = false;
                    }
                }
            }
        }
        
        private Vector2Int FindGridSize(FlowLayoutGraph graph)
        {
            var gridSize = Vector2Int.zero;
            foreach (var node in graph.Nodes)
            {
                if (node != null)
                {
                    var coord = MathUtils.RoundToVector3Int(node.coord);
                    gridSize.x = Mathf.Max(gridSize.x, coord.x + 1);
                    gridSize.y = Mathf.Max(gridSize.y, coord.y + 1);
                }
            }
            return gridSize;
        }
        
        protected override IFlowLayoutNodeCreationConstraint CreateNodeCreationConstraint(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            if (graph != null)
            {
                if (positionConstraintMode == NodeConstraintType.Script)
                {
                    // Try to instantiate the script
                    var scriptInstance = instanceCache.GetInstance(nodePositionConstraintScriptClassName) as IGridFlowLayoutNodePositionConstraint;
                    if (scriptInstance != null)
                    {
                        var gridSize = FindGridSize(graph);
                        return new GridFlowLayoutNodeConstraintProcessorScript(scriptInstance, gridSize, random);
                    }
                }
                else if (positionConstraintMode == NodeConstraintType.StartEndNode)
                {
                    return new GridFlowLayoutNodeConstraintProcessorStartEnd(startNodePositionConstraints, endNodePositionConstraints);
                }
            }
            return new NullFlowLayoutNodeCreationConstraint();
        }
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\LayoutGraph\GridFlowLayoutTaskCreatePath.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Pathing;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Impl.GridFlow.Constraints;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Create Path", "Layout Graph/", 1020)]
    public class GridFlowLayoutTaskCreatePath : LayoutBaseFlowTaskCreatePath
    {
        [System.Serializable]
        public enum NodeConstraintType
        {
            None,
            Script
        }
        
        // Node position constraints
        public NodeConstraintType positionConstraintMode;
        // A ScriptableObject that implements ISGFLayoutNodePositionConstraint
        public string nodePositionConstraintScriptClassName;
        
        private readonly InstanceCache instanceCache = new InstanceCache();
        
        private Vector2Int FindGridSize(FlowLayoutGraph graph)
        {
            var gridSize = Vector2Int.zero;
            foreach (var node in graph.Nodes)
            {
                if (node != null)
                {
                    var coord = MathUtils.RoundToVector3Int(node.coord);
                    gridSize.x = Mathf.Max(gridSize.x, coord.x + 1);
                    gridSize.y = Mathf.Max(gridSize.y, coord.y + 1);
                }
            }
            return gridSize;
        }

        protected override IFlowLayoutNodeCreationConstraint CreateNodeCreationConstraint(FlowDomainExtensions domainExtensions, FlowLayoutGraph graph, System.Random random)
        {
            if (graph != null)
            {
                if (positionConstraintMode == NodeConstraintType.Script)
                {
                    // Try to instantiate the script
                    var scriptInstance = instanceCache.GetInstance(nodePositionConstraintScriptClassName) as IGridFlowLayoutNodePositionConstraint;
                    if (scriptInstance != null)
                    {
                        var gridSize = FindGridSize(graph);
                        return new GridFlowLayoutNodeConstraintProcessorScript(scriptInstance, gridSize, random);
                    }
                }
            }
            return new NullFlowLayoutNodeCreationConstraint();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\LayoutGraph\GridFlowLayoutTaskFinalizeGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Linq;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Items;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{

    [FlowExecNodeInfo("Finalize Graph", "Layout Graph/", 1050)]
    public class GridFlowLayoutTaskFinalizeGraph : LayoutBaseFlowTaskFinalizeGraph
    {
        public bool generateCaves = true;
        public bool generateCorridors = true;
        public int maxEnemiesPerCaveNode = 3;

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var result = base.Execute(context, input);
            if (result.ExecutionResult == FlowTaskExecutionResult.Success)
            {
                var graph = result.State.GetState<FlowLayoutGraph>();
                AssignRoomTypes(graph, context.Random);
            }

            return result;
        }

        void AssignRoomTypes(FlowLayoutGraph graph, System.Random random)
        {
            foreach (var node in graph.Nodes)
            {
                var tilemapDomain = node.GetDomainData<GridFlowTilemapDomainData>();
                tilemapDomain.RoomType = GetNodeRoomType(graph, node);
            }

            // Make another pass and force assign rooms where a link requires a door
            foreach (var link in graph.Links)
            {
                bool containsLock = link.state.items.Count(i => i.type == FlowGraphItemType.Lock) > 0;
                if (containsLock || link.state.type == FlowLayoutGraphLinkType.OneWay)
                {
                    // We need atleast one room type that supports doors (rooms and corridors)
                    var nodeA = graph.GetNode(link.source);
                    var nodeB = graph.GetNode(link.destination);

                    var domainDataA = nodeA.GetDomainData<GridFlowTilemapDomainData>();
                    var domainDataB = nodeB.GetDomainData<GridFlowTilemapDomainData>();
                    
                    var containsDoorA = (domainDataA.RoomType == GridFlowLayoutNodeRoomType.Room || domainDataA.RoomType == GridFlowLayoutNodeRoomType.Corridor);
                    var containsDoorB = (domainDataB.RoomType == GridFlowLayoutNodeRoomType.Room || domainDataB.RoomType == GridFlowLayoutNodeRoomType.Corridor);
                    if (!containsDoorA && !containsDoorB)
                    {
                        // promote one of them to a room
                        var nodeToPromote = (random.NextFloat() < 0.5f) ? domainDataA : domainDataB;
                        nodeToPromote.RoomType = GridFlowLayoutNodeRoomType.Room;
                    }
                }
            }
        }

        GridFlowLayoutNodeRoomType GetNodeRoomType(FlowLayoutGraph graph, FlowLayoutGraphNode node)
        {
            var incoming = graph.GetIncomingLinks(node).ToArray();
            var outgoing = graph.GetOutgoingLinks(node).ToArray();
            int numEnemies = node.items.Count(i => i.type == FlowGraphItemType.Enemy);
            
            {
                int numKeys = node.items.Count(i => i.type == FlowGraphItemType.Key);
                int numBonus = node.items.Count(i => i.type == FlowGraphItemType.Bonus);
                bool hasEntrance = node.items.Count(i => i.type == FlowGraphItemType.Entrance) > 0;
                bool hasExit = node.items.Count(i => i.type == FlowGraphItemType.Exit) > 0;

                if (hasEntrance || hasExit || numKeys > 0 || numBonus > 0)
                {
                    return GridFlowLayoutNodeRoomType.Room;
                }
            }

            var roomType = CalculateRoomType(graph, incoming, outgoing, numEnemies);
            if (roomType == GridFlowLayoutNodeRoomType.Corridor && !generateCorridors)
            {
                roomType = GridFlowLayoutNodeRoomType.Cave;
            }
            if (roomType == GridFlowLayoutNodeRoomType.Cave && !generateCaves)
            {
                roomType = GridFlowLayoutNodeRoomType.Room;
            }

            return roomType;
        }

        GridFlowLayoutNodeRoomType CalculateRoomType(FlowLayoutGraph graph, FlowLayoutGraphLink[] incoming,
            FlowLayoutGraphLink[] outgoing, int numEnemies)
        {
            if (incoming.Length == 1 && outgoing.Length == 1 && numEnemies == 0) 
            {
                // make sure the incoming and outgoing are in the same line
                var incomingNode = graph.GetNode(incoming[0].source);
                var outgoingNode = graph.GetNode(outgoing[0].destination);
                var coordIn = GetNodeCoord(incomingNode);
                var coordOut = GetNodeCoord(outgoingNode);

                var sameLine = (coordIn.x == coordOut.x || coordIn.y == coordOut.y);
                if (sameLine)
                {
                    return GridFlowLayoutNodeRoomType.Corridor;
                }
            }

            return numEnemies <= maxEnemiesPerCaveNode
                ? GridFlowLayoutNodeRoomType.Cave
                : GridFlowLayoutNodeRoomType.Room;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\LayoutGraph\GridFlowLayoutTaskMirrorGraph.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Mirror Graph", "Layout Graph/", 1050)]
    public class GridFlowLayoutTaskMirrorGraph  : LayoutBaseFlowTaskMirrorGraph
    {
        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            return base.Execute(context, input);
        }

        protected override Vector3 GetNodePosition(Vector3 coord, Vector3 coordMin, Vector3 coordMax)
        {
            var height = coordMax.y - coordMin.y;
            var position = new Vector2(coord.x, height - coord.y) * GridFlowConstants.LayoutNodeEditorSpacing;
            return position;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\LayoutGraph\GridFlowLayoutTaskSpawnItems.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tasks;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Items;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Spawn Items", "Layout Graph/", 1030)]
    public class GridFlowLayoutTaskSpawnItems : LayoutBaseFlowTaskSpawnItems
    {
        public TilemapItemPlacementSettings placementSettings = new TilemapItemPlacementSettings();

        protected override bool Validate(FlowTaskExecContext context, FlowTaskExecInput input, ref string errorMessage,
            ref FlowTaskExecutionResult executionResult)
        {
            if (!TilemapItemPlacementStrategyUtils.Validate(placementSettings, ref errorMessage))
            {
                executionResult = FlowTaskExecutionResult.FailHalt;
                return false;
            }

            return true;
        }

        protected override void HandleItemSpawn(FlowLayoutGraphNode node, FlowItem item)
        {
            item.SetDomainData(placementSettings.Clone() as TilemapItemPlacementSettings);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\Tilemap\GridFlowTilemapTaskCreateElevations.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{

    [FlowExecNodeInfo("Create Tilemap Elevations", "Tilemap/", 2100)]
    public class GridFlowTilemapTaskCreateElevations : TilemapBaseFlowTaskCreateElevations
    {
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\Tilemap\GridFlowTilemapTaskCreateOverlay.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Create Tilemap Overlay", "Tilemap/", 2200)]
    public class GridFlowTilemapTaskCreateOverlay : TilemapBaseFlowTaskCreateOverlay
    {
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\Tilemap\GridFlowTilemapTaskFinalize.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//

using System;
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{

    [FlowExecNodeInfo("Finalize Tilemap", "Tilemap/", 2500)]
    public class GridFlowTilemapTaskFinalize : TilemapBaseFlowTaskFinalize
    {
        public bool debugUnwalkableCells = false;
        
        protected override bool AssignItems(FlowTilemap tilemap, FlowLayoutGraph graph, System.Random random, ref string errorMessage)
        {   
            var nodesByCoord = new Dictionary<IntVector2, FlowLayoutGraphNode>();
            var freeTilesByNode = new Dictionary<IntVector2, List<FlowTilemapCell>>();
            var tilesByNode = new Dictionary<IntVector2, List<FlowTilemapCell>>();

            foreach (var node in graph.Nodes)
            {
                var coord = GetNodeCoord(node);
                nodesByCoord[coord] = node;
            }

            foreach (var cell in tilemap.Cells)
            {
                if (cell.CellType == FlowTilemapCellType.Floor)
                {
                    var nodeCoord = cell.NodeCoord;
                    if (!freeTilesByNode.ContainsKey(nodeCoord))
                    {
                        freeTilesByNode.Add(nodeCoord, new List<FlowTilemapCell>());
                    }
                    if (cell.Item == DungeonUID.Empty)
                    {
                        freeTilesByNode[nodeCoord].Add(cell);
                    }
                    
                    if (!tilesByNode.ContainsKey(nodeCoord))
                    {
                        tilesByNode.Add(nodeCoord, new List<FlowTilemapCell>());
                    }
                    tilesByNode[nodeCoord].Add(cell);
                }
            }

            // Filter walkable paths on the free tiles (some free tile patches may be blocked by overlays like tree lines)
            var nodeKeys = new List<IntVector2>(freeTilesByNode.Keys);
            foreach (var nodeCoord in nodeKeys)
            {
                freeTilesByNode[nodeCoord] = FilterWalkablePath(freeTilesByNode[nodeCoord]);
            }

            var distanceField = new FlowTilemapDistanceField(tilemap);
            // Add node items
            foreach (var node in graph.Nodes)
            {
                var coord = GetNodeCoord(node);
                if (freeTilesByNode.ContainsKey(coord))
                {
                    var freeTiles = freeTilesByNode[coord];
                    foreach (var item in node.items)
                    {
                        if (freeTiles.Count == 0)
                        {
                            errorMessage = "Item Placement failed. Insufficient free tiles";
                            return false;
                        }

                        var freeTileIndex = -1;
                        var context = new TilemapItemPlacementStrategyContext();
                        context.tilemap = tilemap;
                        context.distanceField = distanceField;
                        context.random = random;
                        context.node = node;
                        context.chunkTiles = tilesByNode.ContainsKey(coord) ? tilesByNode[coord].ToArray() : Array.Empty<FlowTilemapCell>();

                        string placementErrorMessage = "";
                        var placementSettings = item.GetDomainData<TilemapItemPlacementSettings>();
                        if (placementSettings != null)
                        {
                            var placementStrategy = TilemapItemPlacementStrategyFactory.Create(placementSettings.placementMethod);
                            var placementSuccess = false;
                            if (placementStrategy != null)
                            {
                                placementSuccess = placementStrategy.PlaceItems(item, freeTiles.ToArray(), placementSettings, context, ref freeTileIndex, ref placementErrorMessage);

                                // If we failed, try to fall back to random tile placement, if specified
                                if (!placementSuccess && placementSettings.fallbackToRandomPlacement)
                                {
                                    var randomPlacement = TilemapItemPlacementStrategyFactory.Create(TilemapItemPlacementMethod.RandomTile);
                                    placementSuccess = randomPlacement.PlaceItems(item, freeTiles.ToArray(), placementSettings, context, ref freeTileIndex, ref placementErrorMessage);
                                }
                            }

                            if (!placementSuccess)
                            {
                                errorMessage = "Item Placement failed. " + placementErrorMessage;
                                return false;
                            }
                            if (freeTileIndex < 0 || freeTileIndex >= freeTiles.Count)
                            {
                                errorMessage = "Item Placement failed. Invalid tile index";
                                return false;
                            }
                        }
                        else
                        {
                            freeTileIndex = random.Next(freeTiles.Count - 1);
                        }


                        var freeTile = freeTiles[freeTileIndex];
                        freeTile.Item = item.itemId;
                        freeTiles.Remove(freeTile);
                    }
                }
            }

            return true;
        }
        
        
        List<FlowTilemapCell> FilterWalkablePath(List<FlowTilemapCell> cells)
        {
            var unreachable = new HashSet<IntVector2>();
            var cellsByCoord = new Dictionary<IntVector2, FlowTilemapCell>();

            foreach(var cell in cells)
            {
                unreachable.Add(cell.TileCoord);
                cellsByCoord[cell.TileCoord] = cell;
            }

            var queue = new Queue<FlowTilemapCell>();
            foreach (var cell in cells)
            {
                if (cell.MainPath)
                {
                    unreachable.Remove(cell.TileCoord);
                    queue.Enqueue(cell);
                }
            }

            var childOffsets = new int[]
            {
                -1, 0,
                1, 0,
                0, -1,
                0, 1
            };

            while (queue.Count > 0)
            {
                var cell = queue.Dequeue();
                var coord = cell.TileCoord;
                for (int i = 0; i < 4; i++)
                {
                    var cx = coord.x + childOffsets[i * 2 + 0];
                    var cy = coord.y + childOffsets[i * 2 + 1];
                    var childCoord = new IntVector2(cx, cy);
                    if (unreachable.Contains(childCoord))
                    {
                        var canTraverse = true;
                        var childCell = cellsByCoord[childCoord];
                        if (childCell.Overlay != null && childCell.Overlay.tileBlockingOverlay)
                        {
                            canTraverse = false;
                        }
                        if (canTraverse)
                        {
                            unreachable.Remove(childCoord);
                            queue.Enqueue(cellsByCoord[childCoord]);
                        }
                    }
                }
            }

            if (debugUnwalkableCells)
            {
                foreach (var unreachableCoord in unreachable)
                {
                    var invalidCell = cellsByCoord[unreachableCoord];
                    invalidCell.CustomColor = Color.red;
                    invalidCell.UseCustomColor = true;
                }
            }

            // Grab all the cells that are not in the unreachable list
            var result = new List<FlowTilemapCell>();

            foreach (var cell in cells)
            {
                if (!unreachable.Contains(cell.TileCoord))
                {
                    result.Add(cell);
                }
            }

            return result;
        }

        IntVector2 GetNodeCoord(FlowLayoutGraphNode node)
        {
            var coordF = node.coord;
            return new IntVector2(Mathf.RoundToInt(coordF.x), Mathf.RoundToInt(coordF.y));
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\Tilemap\GridFlowTilemapTaskInitialize.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Initialize Tilemap", "Tilemap/", 2000)]
    public class GridFlowTilemapTaskInitialize : TilemapBaseFlowTaskInitialize
    {
        public Vector2Int tilemapSizePerNode = new Vector2Int(10, 10);
        public Vector2 perturbAmount = new Vector2(3, 3);
        public float corridorLaneWidth = 2;
        public int layoutPadding = 0;
        public bool cropTilemap = true;
        public TilemapFlowNodeWallGenerationMethod wallGenerationMethod = TilemapFlowNodeWallGenerationMethod.WallAsTiles;

        public int caveAutomataNeighbors = 5;
        public int caveAutomataIterations = 4;
        public float caveThickness = 2.25f;

        public float roomColorSaturation = 0.3f;
        public float roomColorBrightness = 1.5f;

        private int nodeWidth;
        private int nodeHeight;
        
        protected override bool Validate(FlowTaskExecContext context, FlowTaskExecInput input, FlowTaskExecOutput output)
        {
            var graph = output.State.GetState<FlowLayoutGraph>();
            if (graph == null)
            {
                output.ErrorMessage = "Missing graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return false;
            }

            if (graph.Nodes.Count == 0)
            {
                output.ErrorMessage = "Invalid graph input";
                output.ExecutionResult = FlowTaskExecutionResult.FailHalt;
                return false;
            }

            return true;
        }

        public override FlowTaskExecOutput Execute(FlowTaskExecContext context, FlowTaskExecInput input)
        {
            var output = base.Execute(context, input);

            var tilemapState = new GridFlowTilemapState();
            tilemapState.WallGenerationMethod = wallGenerationMethod;
            output.State.SetState(typeof(GridFlowTilemapState), tilemapState);
            
            return output;
        }
        protected override FlowTilemap BuildTilemap(FlowLayoutGraph graph, System.Random random)
        {
            IntVector2 abstractGridSize;
            if (!GetGraphSize(graph, out abstractGridSize))
            {
                return null;
            }

            nodeWidth = abstractGridSize.x;
            nodeHeight = abstractGridSize.y;
            var tilemapWidth = nodeWidth * tilemapSizePerNode.x;
            var tilemapHeight = nodeHeight * tilemapSizePerNode.y;
            var tilemap = new FlowTilemap(tilemapWidth, tilemapHeight);
            
            var tileNodes = new TilemapFlowNodeInfo[nodeWidth, nodeHeight];
            for (int ny = 0; ny < nodeHeight; ny++)
            {
                for (int nx = 0; nx <nodeWidth; nx++)
                {
                    var x0 = nx * tilemapSizePerNode.x;
                    var y0 = ny * tilemapSizePerNode.y;
                    var x1 = x0 + tilemapSizePerNode.x;
                    var y1 = y0 + tilemapSizePerNode.y;
                    var node = new TilemapFlowNodeInfo(x0, y0, x1, y1);
                    tileNodes[nx, ny] = node;
                }
            }
            foreach (var node in graph.Nodes)
            {
                var coord = GetNodeCoord(node);
                var tileNode = tileNodes[coord.x, coord.y];
                tileNode.node = node;
            }

            var graphQuery = new FlowLayoutGraphQuery(graph);
            PerturbRoomSizes(graphQuery, tileNodes, random);
            FixCorridorSizes(tileNodes, graphQuery);

            RasterizeRoomCorridors(tileNodes, tilemap);
            RasterizeBaseCaveBlocks(tileNodes, tilemap, graphQuery);

            GenerateMainPath(tileNodes, tilemap, graphQuery);
            BuildCaves(tileNodes, tilemap, graphQuery, random);
            BuildDoors(tileNodes, tilemap, graphQuery);

            tilemap = CropTilemap(tilemap);

            CalculateDistanceFromMainPath(tileNodes, tilemap, new GridFlowLayoutNodeRoomType[] { GridFlowLayoutNodeRoomType.Cave });
            CalculateDistanceFromMainPath(tileNodes, tilemap, new GridFlowLayoutNodeRoomType[] {
                GridFlowLayoutNodeRoomType.Room,
                GridFlowLayoutNodeRoomType.Corridor
            });
            CalculateDistanceFromMainPathOnEmptyArea(tilemap);

            DebugPostProcess(tileNodes, tilemap, graph);

            return tilemap;
        }


        FlowTilemap CropTilemap(FlowTilemap oldTilemap)
        {
            if (oldTilemap.Width == 0 || oldTilemap.Height == 0)
            {
                return oldTilemap;
            }

            int x0 = 0;
            int x1 = 0;
            int y0 = 0;
            int y1 = 0;
            if (cropTilemap)
            {
                bool foundFirstCell = false;
                foreach (var cell in oldTilemap.Cells)
                {
                    bool layoutTile = cell.CellType == FlowTilemapCellType.Floor
                                      || cell.CellType == FlowTilemapCellType.Wall
                                      || cell.CellType == FlowTilemapCellType.Door;

                    if (layoutTile)
                    {
                        var x = cell.TileCoord.x;
                        var y = cell.TileCoord.y;
                        if (!foundFirstCell)
                        {
                            foundFirstCell = true;
                            x0 = x1 = x;
                            y0 = y1 = y;
                        }
                        else
                        {
                            x0 = Mathf.Min(x0, x);
                            x1 = Mathf.Max(x1, x);
                            y0 = Mathf.Min(y0, y);
                            y1 = Mathf.Max(y1, y);
                        }
                    }
                }
            }
            else
            {
                x1 = oldTilemap.Width - 1;
                y1 = oldTilemap.Height - 1;
            }

            var p = layoutPadding;
            var layoutWidth = x1 - x0 + 1;
            var layoutHeight = y1 - y0 + 1;
            var tilemap = new FlowTilemap(
                    layoutWidth + p * 2,
                    layoutHeight + p * 2);

            // clone the cells
            for (int y = 0; y < layoutHeight; y++)
            {
                for (int x = 0; x < layoutWidth; x++)
                {
                    var ix = x + p;
                    var iy = y + p;

                    tilemap.Cells[ix, iy] = oldTilemap.Cells[x + x0, y + y0].Clone();
                    tilemap.Cells[ix, iy].TileCoord = new IntVector2(ix, iy);
                }
            }
            // clone the edges
            for (int y = 0; y <= layoutHeight; y++)
            {
                for (int x = 0; x <= layoutWidth; x++)
                {
                    var ix = x + p;
                    var iy = y + p;

                    tilemap.Edges.SetHorizontal(ix, iy, oldTilemap.Edges.GetHorizontal(x + x0, y + y0).Clone());
                    tilemap.Edges.SetVertical(ix, iy, oldTilemap.Edges.GetVertical(x + x0, y + y0).Clone());

                    var edgeH = tilemap.Edges.GetHorizontal(ix, iy);
                    edgeH.EdgeCoord = new IntVector2(ix, iy);

                    var edgeV = tilemap.Edges.GetVertical(ix, iy);
                    edgeV.EdgeCoord = new IntVector2(ix, iy);
                }
            }

            return tilemap;
        }

        #region Room / Corridor Generation Functions
        void PerturbRoomSizes(FlowLayoutGraphQuery graphQuery, TilemapFlowNodeInfo[,] tileNodes, System.Random random)
        {
            // Perturb horizontally
            {
                //perturbAmount = Mathf.Min(perturbAmount, tilemapSizePerNode * 0.5f - corridorLaneWidth);
                //perturbAmount = Mathf.Max(0, perturbAmount);

                var maxPerturbAmount = Mathf.FloorToInt((tilemapSizePerNode.x - 2 - corridorLaneWidth) * 0.5f);
                maxPerturbAmount = Mathf.Max(0, maxPerturbAmount);

                var perturbX = Mathf.Min(perturbAmount.x, maxPerturbAmount);
                perturbX = Mathf.Max(0, perturbX);

                for (int ny = 0; ny < nodeHeight; ny++)
                {
                    for (int nx = -1; nx < nodeWidth; nx++)
                    {
                        var nodeA = (nx >= 0) ? tileNodes[nx, ny] : null;
                        var nodeB = (nx + 1 < nodeWidth) ? tileNodes[nx + 1, ny] : null;
                        
                        bool perturbA = true;
                        bool perturbB = true;

                        if (nodeA != null && nodeA.node != null)
                        {
                            var nodeStateA = nodeA.node.GetDomainData<GridFlowLayoutNodeState>();
                            perturbA = nodeStateA.CanPerturb;
                        }
                        
                        if (nodeB != null && nodeB.node != null)
                        {
                            var nodeStateB = nodeB.node.GetDomainData<GridFlowLayoutNodeState>();
                            perturbB = nodeStateB.CanPerturb;
                        }
                        
                        bool connected = false;
                        if (nodeA != null && nodeB != null && nodeA.node != null && nodeB.node != null)
                        {
                            var link = graphQuery.GetConnectedLink(nodeA.node.nodeId, nodeB.node.nodeId, true);
                            connected = (link != null && link.state.type != FlowLayoutGraphLinkType.Unconnected);
                        }

                        if (connected)
                        {
                            if (perturbA && perturbB)
                            {
                                float amount = random.Range(-perturbX, perturbX);
                                nodeA.x1 += amount;
                                nodeB.x0 += amount;
                            }
                        }
                        else
                        {
                            
                            if (nodeA != null && perturbA)
                            {
                                var amount = perturbX * random.NextFloat();
                                nodeA.x1 -= amount;
                            }

                            if (nodeB != null && perturbB)
                            {
                                var amount = perturbX * random.NextFloat();
                                nodeB.x0 += amount;
                            }
                        }
                    }
                }
            }

            // Perturb vertically
            {
                var maxPerturbAmount = Mathf.FloorToInt((tilemapSizePerNode.y - 2 - corridorLaneWidth) * 0.5f);
                maxPerturbAmount = Mathf.Max(0, maxPerturbAmount);

                var perturbY = Mathf.Min(perturbAmount.y, maxPerturbAmount);
                perturbY = Mathf.Max(0, perturbY);

                for (int nx = 0; nx < nodeWidth; nx++)
                {
                    for (int ny = -1; ny < nodeHeight; ny++)
                    {
                        var nodeA = (ny >= 0) ? tileNodes[nx, ny] : null;
                        var nodeB = (ny + 1 < nodeHeight) ? tileNodes[nx, ny + 1] : null;

                        bool perturbA = true;
                        bool perturbB = true;

                        if (nodeA != null && nodeA.node != null)
                        {
                            var nodeStateA = nodeA.node.GetDomainData<GridFlowLayoutNodeState>();
                            perturbA = nodeStateA.CanPerturb;
                        }
                        
                        if (nodeB != null && nodeB.node != null)
                        {
                            var nodeStateB = nodeB.node.GetDomainData<GridFlowLayoutNodeState>();
                            perturbB = nodeStateB.CanPerturb;
                        }
                        
                        bool connected = false;
                        if (nodeA != null && nodeB != null && nodeA.node != null && nodeB.node != null)
                        {
                            var link = graphQuery.GetConnectedLink(nodeA.node.nodeId, nodeB.node.nodeId, true);
                            connected = (link != null && link.state.type != FlowLayoutGraphLinkType.Unconnected);
                        }

                        if (connected)
                        {
                            if (perturbA && perturbB)
                            {
                                bool canMoveDown = (nodeA.x0 >= nodeB.x0 && nodeA.x1 <= nodeB.x1);
                                bool canMoveUp = (nodeB.x0 >= nodeA.x0 && nodeB.x1 <= nodeA.x1);

                                if (!canMoveUp && !canMoveDown) continue;

                                if (canMoveUp && canMoveDown)
                                {
                                    // Move randomly on either one direction
                                    if (random.NextFloat() < 0.5f)
                                    {
                                        canMoveUp = false;
                                    }
                                    else
                                    {
                                        canMoveDown = false;
                                    }
                                }

                                float perturbDirection = (canMoveUp ? -1 : 1);
                                float perturb = random.NextFloat() * perturbY * perturbDirection;
                                nodeA.y1 += perturb;
                                nodeB.y0 += perturb;
                            }
                        }
                        else
                        {
                            if (nodeA != null && perturbA)
                            {
                                float amountA = perturbY * random.NextFloat();
                                nodeA.y1 -= amountA;
                            }

                            if (nodeB != null && perturbB)
                            {
                                float amountB = perturbY * random.NextFloat();
                                nodeB.y0 += amountB;
                            }
                        }
                    }
                }
            }
        }

        GridFlowLayoutNodeRoomType GetRoomType(FlowLayoutGraphNode node)
        {
            var domainData = node.GetDomainData<GridFlowTilemapDomainData>();
            return domainData.RoomType;
        }
        
        void FixCorridorSizes(TilemapFlowNodeInfo[,] tileNodes, FlowLayoutGraphQuery graphQuery)
        {
            foreach (var tileNode in tileNodes)
            {
                var node = tileNode.node;
                if (GetRoomType(node) == GridFlowLayoutNodeRoomType.Corridor)
                {
                    var incomingNodes = graphQuery.GetIncomingNodes(node.nodeId);
                    var outgoingNodes = graphQuery.GetOutgoingNodes(node.nodeId);
                    if (incomingNodes.Length == 0 || outgoingNodes.Length == 0) continue;

                    var incomingNode = incomingNodes[0];
                    var outgoingNode = outgoingNodes[0];
                    var inCoord = GetNodeCoord(graphQuery.GetNode(incomingNode));
                    var outCoord = GetNodeCoord(graphQuery.GetNode(outgoingNode));
                    var vertical = inCoord.x == outCoord.x;
                    if (vertical)
                    {
                        tileNode.x0 = Mathf.Max(tileNode.x0, tileNode.midX - corridorLaneWidth);
                        tileNode.x1 = Mathf.Min(tileNode.x1, tileNode.midX + corridorLaneWidth);
                    }
                    else
                    {
                        tileNode.y0 = Mathf.Max(tileNode.y0, tileNode.midY - corridorLaneWidth);
                        tileNode.y1 = Mathf.Min(tileNode.y1, tileNode.midY + corridorLaneWidth);
                    }
                }
            }
        }
        void RasterizeRoomCorridors(TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap)
        {
            foreach (var tileNode in tileNodes)
            {
                if (!tileNode.node.active) continue;
                bool wallsAsTiles = wallGenerationMethod == TilemapFlowNodeWallGenerationMethod.WallAsTiles;
                var b = NodeTilemapBounds.Build(tileNode, tilemap.Width, tilemap.Height, wallsAsTiles);
                if (!wallsAsTiles)
                {
                    b.x1--;
                    b.y1--;
                }
                
                if (GetRoomType(tileNode.node) == GridFlowLayoutNodeRoomType.Cave)
                {
                    // Render the caves in another pass
                    continue;
                }

                var nodeCoord = GetNodeCoord(tileNode.node);
                // Rasterize the tiles
                for (int y = b.y0; y <= b.y1; y++)
                {
                    for (int x = b.x0; x <= b.x1; x++)
                    {
                        var cell = tilemap.Cells.GetCell(x, y);
                        if (cell == null) continue;
                        cell.LayoutCell = true;

                        cell.NodeCoord = nodeCoord;
                        if (wallsAsTiles)
                        {
                            cell.CellType = (x == b.x0 || x == b.x1 || y == b.y0 || y == b.y1)
                            ? FlowTilemapCellType.Wall
                            : FlowTilemapCellType.Floor;
                        }
                        else
                        {
                            if (x <= b.x1 && y <= b.y1)
                            {
                                cell.CellType = FlowTilemapCellType.Floor;
                            }
                        }

                        var nodeColor = tileNode.node.color;
                        cell.CustomColor = ColorUtils.BrightenColor(nodeColor, roomColorSaturation, roomColorBrightness);

                        if (cell.CellType == FlowTilemapCellType.Floor)
                        {
                            cell.UseCustomColor = true;
                        }

                        else if (cell.CellType == FlowTilemapCellType.Wall)
                        {
                            FlowTilemapCellWallInfo wallInfo = cell.Userdata as FlowTilemapCellWallInfo;
                            if (wallInfo == null)
                            {
                                wallInfo = new FlowTilemapCellWallInfo();
                                cell.Userdata = wallInfo;
                            }

                            wallInfo.owningNodes.Add(nodeCoord);
                        }
                    }
                }

                // Rasterize the edges
                if (!wallsAsTiles)
                {
                    for (int y = b.y0; y <= b.y1; y++)
                    {
                        var edge1 = tilemap.Edges.GetVertical(b.x0, y);
                        var edge2 = tilemap.Edges.GetVertical(b.x1 + 1, y);
                        edge1.EdgeType = FlowTilemapEdgeType.Wall;
                        edge2.EdgeType = FlowTilemapEdgeType.Wall;
                    }
                    for (int x = b.x0; x <= b.x1; x++)
                    {
                        var edge1 = tilemap.Edges.GetHorizontal(x, b.y0);
                        var edge2 = tilemap.Edges.GetHorizontal(x, b.y1 + 1);
                        edge1.EdgeType = FlowTilemapEdgeType.Wall;
                        edge2.EdgeType = FlowTilemapEdgeType.Wall;
                    }
                }
            }
        }
        #endregion

        #region Cave Generation Functions
        private void RasterizeBaseCaveBlocks(TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap, FlowLayoutGraphQuery graphQuery)
        {
            foreach (var tileNode in tileNodes)
            {
                if (!tileNode.node.active) continue;
                bool wallsAsTiles = wallGenerationMethod == TilemapFlowNodeWallGenerationMethod.WallAsTiles;
                var b = NodeTilemapBounds.Build(tileNode, tilemap.Width, tilemap.Height, wallsAsTiles);
                if (!wallsAsTiles)
                {
                    b.x1--;
                    b.y1--;
                }

                if (GetRoomType(tileNode.node) != GridFlowLayoutNodeRoomType.Cave)
                {
                    // Only build the caves in this pass
                    continue;
                }

                
                var nodeCoord = GetNodeCoord(tileNode.node);
                var caveNode = tileNode.node;
                var blockLeft = ShouldBlockCaveBoundary(graphQuery, caveNode, -1, 0);
                var blockRight = ShouldBlockCaveBoundary(graphQuery, caveNode, 1, 0);
                var blockTop = ShouldBlockCaveBoundary(graphQuery, caveNode, 0, -1);
                var blockBottom = ShouldBlockCaveBoundary(graphQuery, caveNode, 0, 1);
                for (int y = b.y0; y <= b.y1; y++)
                {
                    for (int x = b.x0; x <= b.x1; x++)
                    {
                        var cell = tilemap.Cells.GetCell(x, y);
                        if (cell == null) continue;

                        if (cell.CellType == FlowTilemapCellType.Empty)
                        {
                            var makeFloor = true;
                            if (wallsAsTiles)
                            {
                                if (blockLeft && x == b.x0) makeFloor = false;
                                if (blockTop && y == b.y0) makeFloor = false;
                                if (blockRight && x == b.x1) makeFloor = false;
                                if (blockBottom && y == b.y1) makeFloor = false;
                            }
                            else
                            {   
                                if (blockLeft && x == b.x0) makeFloor = false;
                                if (blockTop && y == b.y0) makeFloor = false;
                            }

                            if (makeFloor)
                            {
                                cell.NodeCoord = nodeCoord;
                                cell.CellType = FlowTilemapCellType.Floor;
                                cell.UseCustomColor = true;
                                var nodeColor = tileNode.node.color;
                                cell.CustomColor = ColorUtils.BrightenColor(nodeColor, roomColorSaturation, roomColorBrightness);
                            }
                        }
                    }
                }
                
                
                // Discard tiles adjacent to non-connected cave chunks
                {
                    var tileNodeCoord = GetNodeCoord(tileNode.node);
                    var tilesToDiscard = new List<FlowTilemapCell>();
                    
                    System.Action<int, int, int, int> fnDiscard = (x, y, dx, dy) =>
                    {
                        var cell = tilemap.Cells.GetCell(x, y);
                        if (cell != null && cell.CellType == FlowTilemapCellType.Floor)
                        {
                            var ncell = tilemap.Cells.GetCell(x + dx, y + dy);
                            var tileNodeNeighborCoord = tileNodeCoord + new IntVector2(dx, dy);
                            if (ncell != null && ncell.CellType == FlowTilemapCellType.Floor && ncell.NodeCoord != tileNodeNeighborCoord)
                            {
                                bool neighborIsCave = false;
                                {
                                    var neighborNodeCoord = new Vector3(ncell.NodeCoord.x, ncell.NodeCoord.y, 0);
                                    var neighborNodeId = graphQuery.GetNodeAtCoord(neighborNodeCoord);
                                    var neighborNode = graphQuery.GetNode(neighborNodeId);
                                    neighborIsCave = (neighborNode != null && GetRoomType(neighborNode) == GridFlowLayoutNodeRoomType.Cave);
                                }
                                
                                if (neighborIsCave)
                                {
                                    tilesToDiscard.Add(cell);
                                }
                            }
                        }
                    };
                    
                    for (int y = b.y0; y <= b.y1; y++)
                    {
                        fnDiscard(b.x0, y, -1, 0);
                        fnDiscard(b.x1, y, 1, 0);
                    }
                    for (int x = b.x0; x <= b.x1; x++)
                    {
                        fnDiscard(x, b.y0, 0, -1);
                        fnDiscard(x, b.y1, 0, 1);
                    }
                    
                    foreach (var tileToDiscard in tilesToDiscard)
                    {
                        tileToDiscard.Clear();
                    }
                }
            }
        }
        private void BuildCaves(TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap, FlowLayoutGraphQuery graphQuery, System.Random random)
        {
            CalculateDistanceFromMainPath(tileNodes, tilemap, new GridFlowLayoutNodeRoomType[] { GridFlowLayoutNodeRoomType.Cave });
            var caveMap = GenerateCaveBuildMap(tileNodes, tilemap);
            BuildCaveStep_BuildRocks(caveMap, tilemap, random);
            BuildCaveStep_SimulateGrowth(caveMap, tilemap, random);
            BuildCaveStep_Cleanup(caveMap, tileNodes, tilemap);
            BuildCaveStep_UpdateEdges(caveMap, tileNodes, tilemap);
        }
        private CaveCellBuildTile[,] GenerateCaveBuildMap(TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap)
        {
            var caveMap = new CaveCellBuildTile[tilemap.Width, tilemap.Height];

            foreach (var cell in tilemap.Cells)
            {
                var caveTile = new CaveCellBuildTile();
                caveTile.tileCoord = cell.TileCoord;
                var tileNode = tileNodes[cell.NodeCoord.x, cell.NodeCoord.y];
                caveTile.valid = (GetRoomType(tileNode.node) == GridFlowLayoutNodeRoomType.Cave && tileNode.node.active && cell.CellType == FlowTilemapCellType.Floor);
                caveMap[cell.TileCoord.x, cell.TileCoord.y] = caveTile;
            }

            return caveMap;
        }
        private void BuildCaveStep_BuildRocks(CaveCellBuildTile[,] caveMap, FlowTilemap tilemap, System.Random random)
        {
            foreach (var caveCell in caveMap)
            {
                var tileCell = tilemap.Cells[caveCell.tileCoord.x, caveCell.tileCoord.y];
                if (caveThickness > 0)
                {
                    var rockProbability = Mathf.Exp(-tileCell.DistanceFromMainPath / caveThickness);
                    caveCell.rockTile = random.NextFloat() < rockProbability;
                }
                else
                {
                    caveCell.rockTile = (tileCell.DistanceFromMainPath == 0);
                }
            }
        }
        private void BuildCaveStep_SimulateGrowth(CaveCellBuildTile[,] caveMap, FlowTilemap tilemap, System.Random random)
        {
            var width = caveMap.GetLength(0);
            var height = caveMap.GetLength(1);

            for (int i = 0; i < caveAutomataIterations; i++)
            {
                CaveCellBuildTile[,] oldMap = new CaveCellBuildTile[width, height];
                for (int y = 0; y < height; y++)
                {
                    for (int x = 0; x < width; x++)
                    {
                        oldMap[x, y] = caveMap[x, y].Clone();
                    }
                }

                for (int y = 0; y < height; y++)
                {
                    for (int x = 0; x < width; x++)
                    {
                        int nrocks = 0;
                        for (int dy = -1; dy <= 1; dy++)
                        {
                            for (int dx = -1; dx <= 1; dx++)
                            {
                                if (dx == 0 && dy == 0) continue;
                                int nx = x + dx;
                                int ny = y + dy;
                                if (nx < 0 || ny < 0 || nx >= width || ny >= height) continue;
                                if (oldMap[nx, ny].rockTile)
                                {
                                    nrocks++;
                                }
                            }
                        }


                        if (nrocks >= caveAutomataNeighbors)
                        {
                            caveMap[x, y].rockTile = true;
                        }
                    }
                }

            }

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    if (caveMap[x, y].valid && !caveMap[x, y].rockTile)
                    {
                        tilemap.Cells[x, y].CellType = FlowTilemapCellType.Empty;
                        tilemap.Cells[x, y].UseCustomColor = false;
                        caveMap[x, y].valid = false;
                    }
                }
            }
        }
        private void BuildCaveStep_Cleanup(CaveCellBuildTile[,] caveMap, TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap)
        {
            var width = tilemap.Width;
            var height = tilemap.Height;
            var traversibleCaveTiles = new bool[width, height];

            var childOffsets = new int[]
            {
                -1, 0,
                1, 0,
                0, -1,
                0, 1
            };

            foreach (var tileNode in tileNodes)
            {
                if (GetRoomType(tileNode.node) != GridFlowLayoutNodeRoomType.Cave)
                {
                    // Only process the caves
                    continue;
                }

                if (!tileNode.node.active)
                {
                    // Do not process inactive nodes
                    continue;
                }

                var nodeCoord = GetNodeCoord(tileNode.node);
                var tileCenter = NodeCoordToTileCoord(nodeCoord);

                if (traversibleCaveTiles[tileCenter.x, tileCenter.y])
                {
                    // Already processed from another adjacent node
                    continue;
                }

                // Flood fill from the center of this node
                var queue = new Queue<IntVector2>();
                queue.Enqueue(tileCenter);
                while (queue.Count > 0)
                {
                    var front = queue.Dequeue();
                    if (traversibleCaveTiles[front.x, front.y])
                    {
                        // Already processed
                        continue;
                    }

                    traversibleCaveTiles[front.x, front.y] = true;

                    // Traverse the children
                    for (int i = 0; i < 4; i++)
                    {
                        var childCoord = new IntVector2(
                            front.x + childOffsets[i * 2 + 0],
                            front.y + childOffsets[i * 2 + 1]);

                        if (childCoord.x >= 0 && childCoord.y >= 0 && childCoord.x < width && childCoord.y < height)
                        {
                            if (caveMap[childCoord.x, childCoord.y].valid)
                            {
                                var visited = traversibleCaveTiles[childCoord.x, childCoord.y];
                                if (!visited)
                                {
                                    queue.Enqueue(childCoord);
                                }
                            }
                        }
                    }
                }
            }

            // Assign the valid traversable paths 
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    var cell = tilemap.Cells[x, y];
                    var nodeCoord = cell.NodeCoord;
                    var tileNode = tileNodes[nodeCoord.x, nodeCoord.y];
                    if (GetRoomType(tileNode.node) == GridFlowLayoutNodeRoomType.Cave)
                    {
                        var valid = traversibleCaveTiles[x, y];
                        caveMap[x, y].valid = valid;
                        if (!valid)
                        {
                            tilemap.Cells[x, y].CellType = FlowTilemapCellType.Empty;
                            tilemap.Cells[x, y].UseCustomColor = false;
                        }
                        else
                        {
                            tilemap.Cells[x, y].LayoutCell = true;
                        }
                    }
                }
            }
        }

        private bool CanCreateEdgeToAdjacentCaveTile(FlowTilemap tilemap, CaveCellBuildTile[,] caveMap, int x, int y)
        {
            if (x < 0 || x >= tilemap.Width || y < 0 || y >= tilemap.Height) return true;   // this is an empty tile

            if (tilemap.Cells[x, y].CellType == FlowTilemapCellType.Empty
                || tilemap.Cells[x, y].CellType == FlowTilemapCellType.Custom)
            {
                return true;
            }

            bool caveTile = caveMap[x, y].valid && caveMap[x, y].rockTile;
            if (caveTile)
            {
                // no need for an edge between two cave tiles
                return false;
            }

            // This tile is not empty and is not a cave tile
            return false;
        }

        private void BuildCaveStep_UpdateEdges(CaveCellBuildTile[,] caveMap, TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap)
        {
            var width = tilemap.Width;
            var height = tilemap.Height;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    bool caveTile = x < width && y < height && caveMap[x, y].valid && caveMap[x, y].rockTile;
                    if (!caveTile) continue;

                    bool createEdgeLeft = CanCreateEdgeToAdjacentCaveTile(tilemap, caveMap, x - 1, y);
                    bool createEdgeRight = CanCreateEdgeToAdjacentCaveTile(tilemap, caveMap, x + 1, y);

                    bool createEdgeBottom = CanCreateEdgeToAdjacentCaveTile(tilemap, caveMap, x, y - 1);
                    bool createEdgeTop = CanCreateEdgeToAdjacentCaveTile(tilemap, caveMap, x, y + 1);

                    if (createEdgeLeft)
                    {
                        var edgeV = tilemap.Edges.GetVertical(x, y);
                        if (edgeV.EdgeType == FlowTilemapEdgeType.Empty)
                        {
                            edgeV.EdgeType = FlowTilemapEdgeType.Fence;
                        }
                    }

                    if (createEdgeRight)
                    {
                        var edgeV = tilemap.Edges.GetVertical(x + 1, y);
                        if (edgeV.EdgeType == FlowTilemapEdgeType.Empty)
                        {
                            edgeV.EdgeType = FlowTilemapEdgeType.Fence;
                        }
                    }

                    if (createEdgeBottom)
                    {
                        var edgeH = tilemap.Edges.GetHorizontal(x, y);
                        if (edgeH.EdgeType == FlowTilemapEdgeType.Empty)
                        {
                            edgeH.EdgeType = FlowTilemapEdgeType.Fence;
                        }
                    }

                    if (createEdgeTop)
                    {
                        var edgeH = tilemap.Edges.GetHorizontal(x, y + 1);
                        if (edgeH.EdgeType == FlowTilemapEdgeType.Empty)
                        {
                            edgeH.EdgeType = FlowTilemapEdgeType.Fence;
                        }
                    }
                }
            }

        }
        
        private void DebugPostProcess(TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap, FlowLayoutGraph graph)
        {
            bool debugMainPathDistance = false;
            var width = tilemap.Width;
            var height = tilemap.Height;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    var tileCell = tilemap.Cells[x, y];
                    var tileNode = tileNodes[tileCell.NodeCoord.x, tileCell.NodeCoord.y];
                    var roomType = GetRoomType(tileNode.node);

                    if (debugMainPathDistance)
                    {
                        var startColor = new Color(1.0f, 0.4f, 0.4f);
                        var endColor = new Color(0.25f, 0.1f, 0.1f);
                        if (tileCell.CellType != FlowTilemapCellType.Empty)
                        {
                            if (roomType == GridFlowLayoutNodeRoomType.Cave)
                            {
                                startColor = new Color(0.4f, 0.4f, 1.0f);
                                endColor = new Color(0.1f, 0.1f, 0.25f);
                            }
                            else if (roomType == GridFlowLayoutNodeRoomType.Room || roomType == GridFlowLayoutNodeRoomType.Corridor)
                            {
                                startColor = new Color(0.4f, 1.0f, 0.4f);
                                endColor = new Color(0.1f, 0.25f, 0.1f);
                            }
                        }

                        var distanceFactor = Mathf.Exp(-tileCell.DistanceFromMainPath / 5.0f);
                        var debugColor = Color.Lerp(endColor, startColor, distanceFactor);
                        tileCell.CustomColor = debugColor;
                        tileCell.UseCustomColor = true;
                    }
                }
            }
        }
        bool ShouldBlockCaveBoundary(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode caveNode, int dx, int dy)
        {
            /*
            var coord = GetNodeCoord(caveNode);
            var otherCoord = coord + new IntVector2(dx, dy);
            FlowLayoutGraphNode otherNode = null;
            foreach (var node in graph.Nodes)
            {
                var nodeCoord = GetNodeCoord(node);
                if (nodeCoord.Equals(otherCoord))
                {
                    otherNode = node;
                    break;
                }
            }
            */

            var otherNodeId = graphQuery.GetNodeAtCoord(caveNode.coord + new Vector3(dx, dy, 0));
            var otherNode = graphQuery.GetNode(otherNodeId);
            
            if (otherNode == null || !otherNode.active)
            {
                // a node in this location doesn't exist
                return false;
            }

            // Check if we have a link between these nodes. If we don't, then block it
            var link = graphQuery.GetConnectedLink(caveNode.nodeId, otherNode.nodeId, true);
            if (link == null)
            {
                // No link exists. we should block this
                return true;
            }

            // We have a link to the other node.   block only if they it is a non-cave nodes
            return false; //GetRoomType(otherNode) != GridFlowLayoutNodeRoomType.Cave;
        }
        #endregion

        #region Common Functions
        private void GenerateMainPath(TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap, FlowLayoutGraphQuery graphQuery)
        {
            var graph = graphQuery.Graph;
            foreach (var link in graph.Links)
            {
                var nodeA = graphQuery.GetNode(link.source);
                var nodeB = graphQuery.GetNode(link.destination);

                var tileCenterA = NodeCoordToTileCoord(GetNodeCoord(nodeA));
                var tileCenterB = NodeCoordToTileCoord(GetNodeCoord(nodeB));
                if (tileCenterA.x == tileCenterB.x)
                {
                    var x = tileCenterA.x;
                    int y0 = Mathf.Min(tileCenterA.y, tileCenterB.y);
                    int y1 = Mathf.Max(tileCenterA.y, tileCenterB.y);
                    for (int y = y0; y <= y1; y++)
                    {
                        var cell = tilemap.Cells[x, y];
                        cell.MainPath = true;
                        cell.DistanceFromMainPath = 0;
                    }
                }
                else if (tileCenterA.y == tileCenterB.y)
                {
                    var y = tileCenterA.y;
                    int x0 = Mathf.Min(tileCenterA.x, tileCenterB.x);
                    int x1 = Mathf.Max(tileCenterA.x, tileCenterB.x);
                    for (int x = x0; x <= x1; x++)
                    {
                        var cell = tilemap.Cells[x, y];
                        cell.MainPath = true;
                        cell.DistanceFromMainPath = 0;
                    }
                }
                else
                {
                    Debug.Log("invalid input");
                }
            }

            if (graph.Links.Count == 0 && graph.Nodes.Count == 1)
            {
                var node = graph.Nodes[0];
                var tc = NodeCoordToTileCoord(GetNodeCoord(node));
                tilemap.Cells[tc.x, tc.y].MainPath = true;
                tilemap.Cells[tc.x, tc.y].DistanceFromMainPath = 0;

            }
        }
        private void CalculateDistanceFromMainPathOnEmptyArea(FlowTilemap tilemap)
        {
            var width = tilemap.Width;
            var height = tilemap.Height;
            var queue = new Queue<FlowTilemapCell>();

            var childOffsets = new int[]
            {
                -1, 0,
                1, 0,
                0, -1,
                0, 1
            };

            foreach (var cell in tilemap.Cells)
            {
                if (cell.CellType != FlowTilemapCellType.Empty)
                {
                    continue;
                }

                var validStartNode = false;

                for (int i = 0; i < 4; i++)
                {
                    int nx = cell.TileCoord.x + childOffsets[i * 2 + 0];
                    int ny = cell.TileCoord.y + childOffsets[i * 2 + 1];
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height)
                    {
                        var ncell = tilemap.Cells[nx, ny];
                        if (ncell.CellType != FlowTilemapCellType.Empty)
                        {
                            validStartNode = true;
                            cell.DistanceFromMainPath = Mathf.Min(cell.DistanceFromMainPath, ncell.DistanceFromMainPath);
                        }
                    }
                }

                if (validStartNode)
                {
                    queue.Enqueue(cell);
                }
            }


            while (queue.Count > 0)
            {
                var cell = queue.Dequeue();
                var ndist = cell.DistanceFromMainPath + 1;

                for (int i = 0; i < 4; i++)
                {
                    int nx = cell.TileCoord.x + childOffsets[i * 2 + 0];
                    int ny = cell.TileCoord.y + childOffsets[i * 2 + 1];
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height)
                    {
                        var ncell = tilemap.Cells[nx, ny];

                        if (ncell.CellType == FlowTilemapCellType.Empty)
                        {
                            if (ndist < ncell.DistanceFromMainPath)
                            {
                                ncell.DistanceFromMainPath = ndist;
                                queue.Enqueue(ncell);
                                
                            }
                        }
                    }
                }
            }
        }
        private void CalculateDistanceFromMainPath(TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap, GridFlowLayoutNodeRoomType[] allowedRoomTypes)
        {
            var width = tilemap.Width;
            var height = tilemap.Height;
            var queue = new Queue<FlowTilemapCell>();

            foreach (var cell in tilemap.Cells)
            {
                var tileNode = tileNodes[cell.NodeCoord.x, cell.NodeCoord.y];
                var roomType = GetRoomType(tileNode.node);
                if (!allowedRoomTypes.Contains(roomType))
                {
                    continue;
                }

                if (cell.MainPath)
                {
                    queue.Enqueue(cell);
                }
            }

            var childOffsets = new int[]
            {
                -1, 0,
                1, 0,
                0, -1,
                0, 1
            };

            while (queue.Count > 0)
            {
                var tile = queue.Dequeue();

                // Traverse the children
                var childDistance = tile.DistanceFromMainPath + 1;
                for (int i = 0; i < 4; i++)
                {
                    int nx = tile.TileCoord.x + childOffsets[i * 2 + 0];
                    int ny = tile.TileCoord.y + childOffsets[i * 2 + 1];
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height)
                    {
                        var ncell = tilemap.Cells[nx, ny];
                        var ntileNode = tileNodes[ncell.NodeCoord.x, ncell.NodeCoord.y];
                        var nroomType = GetRoomType(ntileNode.node);
                        if (!allowedRoomTypes.Contains(nroomType))
                        {
                            continue;
                        }

                        if (childDistance < ncell.DistanceFromMainPath)
                        {
                            ncell.DistanceFromMainPath = childDistance;
                            queue.Enqueue(ncell);
                        }
                    }
                }
            }
        }

        struct DoorInfo
        {
            public FlowLayoutGraphLink Link { get; set; }
            public IntVector2 CellCoord { get; set; }
            public bool HorizontalDoorEdge { get; set; }
        }

        void BuildDoors(TilemapFlowNodeInfo[,] tileNodes, FlowTilemap tilemap, FlowLayoutGraphQuery graphQuery)
        {
            bool wallsAsTiles = (wallGenerationMethod == TilemapFlowNodeWallGenerationMethod.WallAsTiles);

            // Build the doors
            var doorList = new List<DoorInfo>();
            foreach (var tileNode in tileNodes)
            {
                if (tileNode == null || tileNode.node == null) continue;
                if (!tileNode.node.active) continue;
                var b = NodeTilemapBounds.Build(tileNode, tilemap.Width, tilemap.Height, wallsAsTiles);

                var node = tileNode.node;
                var nodeCoord = GetNodeCoord(node);
                var connectedLinks = graphQuery.GetConnectedLinks(tileNode.node.nodeId);
                foreach (var link in connectedLinks)
                {
                    if (link.source != tileNode.node.nodeId)
                    {
                        // Not an outgoing link
                        continue;
                    }
                    
                    if (link.state.type == FlowLayoutGraphLinkType.Unconnected) continue;

                    var otherNode = graphQuery.GetNode(link.destination);
                    if (GetRoomType(node) == GridFlowLayoutNodeRoomType.Cave && GetRoomType(otherNode) == GridFlowLayoutNodeRoomType.Cave)
                    {
                        // We don't need a door between two cave nodes
                        continue;
                    }

                    bool foundDoor = false;
                    var doorCoord = new IntVector2(0, 0);
                    bool horizontalEdge = true;

                    var otherCoord = GetNodeCoord(otherNode);
                    if (nodeCoord.x == otherCoord.x)
                    {
                        // Vertical link
                        var y = (nodeCoord.y < otherCoord.y) ? b.y1 : b.y0;
                        foundDoor = true;
                        doorCoord = new IntVector2(b.mx, y);
                        horizontalEdge = true;
                    }
                    else if (nodeCoord.y == otherCoord.y)
                    {
                        // Horizontal link
                        var x = (nodeCoord.x < otherCoord.x) ? b.x1 : b.x0;
                        foundDoor = true;
                        doorCoord = new IntVector2(x, b.my);
                        horizontalEdge = false;
                    }

                    if (foundDoor)
                    {
                        var doorMeta = new FlowTilemapCellDoorInfo();
                        {
                            var sourceNode = graphQuery.GetNode(link.source);
                            var destNode = graphQuery.GetNode(link.destination);
                            doorMeta.oneWay = (link.state.type == FlowLayoutGraphLinkType.OneWay);
                            doorMeta.nodeA = GetNodeCoord(sourceNode);
                            doorMeta.nodeB = GetNodeCoord(destNode);
                            int numLockedItems = link.state.items.Count(i => i.type == FlowGraphItemType.Lock);
                            doorMeta.locked = numLockedItems > 0;
                        }

                        if (wallsAsTiles)
                        {
                            FlowTilemapCell doorCell = tilemap.Cells.GetCell(doorCoord.x, doorCoord.y);
                            doorCell.Userdata = doorMeta;
                            doorCell.CellType = FlowTilemapCellType.Door;
                        }
                        else
                        {
                            FlowTilemapEdge doorEdge = horizontalEdge
                                ? tilemap.Edges.GetHorizontal(doorCoord.x, doorCoord.y)
                                : tilemap.Edges.GetVertical(doorCoord.x, doorCoord.y);
                            doorEdge.Userdata = doorMeta;
                            doorEdge.EdgeType = FlowTilemapEdgeType.Door;
                        }

                        var doorInfo = new DoorInfo();
                        doorInfo.Link = link;
                        doorInfo.CellCoord = doorCoord;
                        doorInfo.HorizontalDoorEdge = horizontalEdge;
                        doorList.Add(doorInfo);
                    }
                }
            }

            // Add door items
            foreach (var door in doorList)
            {
                var items = door.Link.state.items;
                var doorItem = items.Count > 0 ? items[0] : null;
                if (doorItem == null) continue;

                if (wallsAsTiles)
                {
                    var cellCoord = door.CellCoord;
                    var cell = tilemap.Cells[cellCoord.x, cellCoord.y];
                    cell.Item = doorItem.itemId;
                }
                else
                {
                    var doorCoord = door.CellCoord;
                    FlowTilemapEdge doorEdge = door.HorizontalDoorEdge
                        ? tilemap.Edges.GetHorizontal(doorCoord.x, doorCoord.y)
                        : tilemap.Edges.GetVertical(doorCoord.x, doorCoord.y);
                    if (doorEdge != null)
                    {
                        doorEdge.Item = doorItem.itemId;
                    }
                }
            }
        }
        #endregion

        #region Utility Functions

        IntVector2 GetNodeCoord(FlowLayoutGraphNode node)
        {
            var coordF = node.coord;
            return new IntVector2(Mathf.RoundToInt(coordF.x), Mathf.RoundToInt(coordF.y));
        }
        
        private IntVector2 NodeCoordToTileCoord(IntVector2 nodeCoord)
        {
            var itilemapSizePerNode = new IntVector2(tilemapSizePerNode.x, tilemapSizePerNode.y);
            var tileCoord = nodeCoord * itilemapSizePerNode;
            tileCoord += itilemapSizePerNode / 2;
            return tileCoord;
        }
        bool GetGraphSize(FlowLayoutGraph graph, out IntVector2 size)
        {
            if (graph.Nodes.Count == 0)
            {
                size = IntVector2.Zero;
                return false;
            }

            int width = -int.MaxValue;
            int height = -int.MaxValue;

            foreach (var node in graph.Nodes)
            {
                var coord = GetNodeCoord(node);
                width = Mathf.Max(width, coord.x);
                height = Mathf.Max(height, coord.y);
            }

            size = new IntVector2(width + 1, height + 1);
            return true;
        }
        FlowTilemapCellType GetCellType(FlowTilemap tilemap, int x, int y)
        {
            if (x < 0 || y < 0 || x >= tilemap.Width || y >= tilemap.Height)
            {
                return FlowTilemapCellType.Empty;
            }
            return tilemap.Cells[x, y].CellType;
        }
        #endregion
    }
    
    
    #region Data structures

    struct NodeTilemapBounds
    {
        public int x0, y0, x1, y1, mx, my;
        public static NodeTilemapBounds Build(TilemapFlowNodeInfo tileNode, int tilemapWidth, int tilemapHeight, bool clampToBoundary)
        {
            var b = new NodeTilemapBounds();
            b.x0 = Mathf.FloorToInt(tileNode.x0);
            b.y0 = Mathf.FloorToInt(tileNode.y0);
            b.x1 = Mathf.FloorToInt(tileNode.x1);
            b.y1 = Mathf.FloorToInt(tileNode.y1);
            b.mx = Mathf.FloorToInt(tileNode.midX);
            b.my = Mathf.FloorToInt(tileNode.midY);

            if (clampToBoundary)
            {
                b.x0 = Mathf.Clamp(b.x0, 0, tilemapWidth - 1);
                b.x1 = Mathf.Clamp(b.x1, 0, tilemapWidth - 1);
                b.y0 = Mathf.Clamp(b.y0, 0, tilemapHeight - 1);
                b.y1 = Mathf.Clamp(b.y1, 0, tilemapHeight - 1);
                b.mx = Mathf.Clamp(b.mx, 0, tilemapWidth - 1);
                b.my = Mathf.Clamp(b.my, 0, tilemapHeight - 1);
            }

            return b;
        }
    }

    class CaveCellBuildTile
    {
        public IntVector2 tileCoord;
        public bool valid = false;
        public bool rockTile = false;

        public CaveCellBuildTile Clone()
        {
            var tile = new CaveCellBuildTile();
            tile.tileCoord = tileCoord;
            tile.valid = valid;
            tile.rockTile = rockTile;
            return tile;
        }
    }

    public class TilemapFlowNodeInfo
    {
        public TilemapFlowNodeInfo(float x0, float y0, float x1, float y1)
        {
            this.x0 = x0;
            this.y0 = y0;
            this.x1 = x1;
            this.y1 = y1;

            midX = (x0 + x1) * 0.5f;
            midY = (y0 + y1) * 0.5f;
        }

        public float x0;
        public float x1;
        public float y0;
        public float y1;

        public float midX;
        public float midY;
        public FlowLayoutGraphNode node;
    }
    #endregion
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\Tilemap\GridFlowTilemapTaskMerge.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{

    [FlowExecNodeInfo("Merge Tilemaps", "Tilemap/", 2300)]
    public class GridFlowTilemapTaskMerge : TilemapBaseFlowTaskMerge
    {
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\Tasks\Tilemap\GridFlowTilemapTaskOptimize.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Tilemap.Tasks;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Flow.Impl.GridFlow.Tasks
{
    [FlowExecNodeInfo("Optimize Tilemap", "Tilemap/", 2400)]
    public class GridFlowTilemapTaskOptimize : TilemapBaseFlowTaskOptimize
    {
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\TilemapPlacement\Impl\TilemapItemPlacementStrategy_NearEdge.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Items;

namespace DungeonArchitect.Flow.Impl.GridFlow
{
    public class TilemapItemPlacementStrategyNearEdge : ITilemapItemPlacementStrategy
    {
        public bool PlaceItems(FlowItem item, FlowTilemapCell[] freeCells, TilemapItemPlacementSettings settings, TilemapItemPlacementStrategyContext context, ref int outFreeTileIndex, ref string errorMessage)
        {
            if (freeCells.Length == 0)
            {
                // Not enough free cells for placing the items
                errorMessage = "Insufficient free tiles";
                return false;
            }

            var bestCells = new List<int>();
            var bestDistance = int.MaxValue;
            for (int i = 0; i < freeCells.Length; i++) 
            {
                var freeCell = freeCells[i];
                var x = freeCell.TileCoord.x;
                var y = freeCell.TileCoord.y;
                var distanceCell = context.distanceField.distanceCells[x, y];
                var distance = distanceCell.DistanceFromEdge;
                if (settings.avoidPlacingNextToDoors && distanceCell.DistanceFromDoor == 1)
                {
                    continue;
                }
                if (distance == bestDistance)
                {
                    bestCells.Add(i);
                }
                else if (distance < bestDistance)
                {
                    bestDistance = distance;
                    bestCells.Clear();
                    bestCells.Add(i);
                }
            }

            if (bestCells.Count == 0)
            {
                // Not enough free cells for placing the items
                errorMessage = "Insufficient free tiles";
                return false;
            }

            var bestCellIndex = context.random.Next(bestCells.Count - 1);
            outFreeTileIndex = bestCells[bestCellIndex];
            return true;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\TilemapPlacement\Impl\TilemapItemPlacementStrategy_Random.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Items;

namespace DungeonArchitect.Flow.Impl.GridFlow
{
    public class TilemapItemPlacementStrategyRandom : ITilemapItemPlacementStrategy
    {
        public bool PlaceItems(FlowItem item, FlowTilemapCell[] freeCells, TilemapItemPlacementSettings settings, TilemapItemPlacementStrategyContext context, ref int outFreeTileIndex, ref string errorMessage)
        {
            var freeCellIndexRef = new List<int>();
            for (int i = 0; i < freeCells.Length; i++) 
            {
                var freeCell = freeCells[i];
                var x = freeCell.TileCoord.x;
                var y = freeCell.TileCoord.y;
                var distanceCell = context.distanceField.distanceCells[x, y];
                if (!settings.avoidPlacingNextToDoors || distanceCell.DistanceFromDoor > 1)
                {
                    freeCellIndexRef.Add(i);
                }
            }

            if (freeCellIndexRef.Count == 0)
            {
                // Not enough free cells for placing the items
                errorMessage = "Insufficient free tiles";
                return false;
            }

            var freeCellTableIndex = context.random.Next(freeCellIndexRef.Count - 1);
            outFreeTileIndex = freeCellIndexRef[freeCellTableIndex];
            return true;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\FlowImpl\GridFlow\TilemapPlacement\Impl\TilemapItemPlacementStrategy_Script.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Domains.Tilemap;
using DungeonArchitect.Flow.Items;
using UnityEngine;

namespace DungeonArchitect.Flow.Impl.GridFlow
{
    public class TilemapItemPlacementStrategyScript : ITilemapItemPlacementStrategy
    {
        public bool PlaceItems(FlowItem item, FlowTilemapCell[] freeCells, TilemapItemPlacementSettings settings,
                TilemapItemPlacementStrategyContext context, ref int outFreeTileIndex, ref string errorMessage)
        {
            if (settings.placementScriptClass != null && settings.placementScriptClass.Length > 0)
            {
                var type = System.Type.GetType(settings.placementScriptClass);
                if (type != null)
                {
                    var script = ScriptableObject.CreateInstance(type) as ITilemapItemPlacementStrategy;
                    if (script != null)
                    {
                        return script.PlaceItems(item, freeCells, settings, context, ref outFreeTileIndex, ref errorMessage);
                    }
                }
            }

            errorMessage = "Invalid script reference";
            return false;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Execution\Nodes\GrammarExecEntryNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;


namespace DungeonArchitect.Grammar
{
    public class GrammarExecEntryNode : GrammarExecNodeBase
    {
        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            canBeDeleted = false;
            caption = "Entry";
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Execution\Nodes\GrammarExecNodeBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;


namespace DungeonArchitect.Grammar
{
    public class GrammarExecNodeBase : GraphNode
    {
        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            Size = new Vector2(120, 120);

            // Create an input pin on the top
            CreatePinOfType<GrammarNodePin>(GraphPinType.Input,
                        Vector2.zero,
                        Rect.zero,
                        new Vector2(0, -1));

            // Create an output pin at the bottom
            CreatePinOfType<GrammarNodePin>(GraphPinType.Output,
                        Vector2.zero,
                        Rect.zero,
                        new Vector2(0, -1));

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Execution\Nodes\GrammarExecRuleNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;


namespace DungeonArchitect.Grammar
{
    [System.Serializable]
    public enum GrammarExecRuleRunMode
    {
        RunOnce,
        RunWithProbability,
        Iterate,
        IterateRange
    }

    public class GrammarExecRuleNode : GrammarExecNodeBase
    {
        [SerializeField]
        [HideInInspector]
        public GrammarProductionRule rule;

        [SerializeField]
        public GrammarExecRuleRunMode runMode;

        public float runProbability = 1.0f;

        public int iterateCount = 3;

        public int minIterateCount = 3;

        public int maxIterateCount = 5;

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Grammar\GraphBuillder\GrammarGraphBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Grammar
{
    public interface IGrammarGraphBuilder 
    {
        int CreateNode(string nodeName, int executionIndex);
        bool LinkNodes(int nodeAId, int nodeBId);
    }

    public class GrammarGraphBuilder : IGrammarGraphBuilder
    {
        GrammarNodeType[] nodeTypes;
        GraphBuilder graphBuilder;
        int nodeIdCounter = 0;
        GrammarGraph grammarGraph;
        Dictionary<int, GraphNode> generatedNodes = new Dictionary<int, GraphNode>();

        public GrammarGraphBuilder(GrammarGraph grammarGraph, GrammarNodeType[] nodeTypes, GraphBuilder graphBuilder)
        {
            this.grammarGraph = grammarGraph;
            this.nodeTypes = nodeTypes;
            this.graphBuilder = graphBuilder;
        }

        public int CreateNode(string nodeName, int executionIndex)
        {
            // Find the node type that has this name
            GrammarNodeType targetNodeType = null;
            foreach (var nodeType in nodeTypes)
            {
                if (nodeType.nodeName == nodeName)
                {
                    targetNodeType = nodeType;
                    break;
                }
            }

            if (targetNodeType == null)
            {
                return -1;
            }

            var node = graphBuilder.CreateNode(typeof(GrammarTaskNode)) as GrammarTaskNode;
            node.NodeType = targetNodeType;
            node.executionIndex = executionIndex;

            int nodeId = ++nodeIdCounter;
            generatedNodes.Add(nodeId, node);
            return nodeId;
        }

        public bool LinkNodes(int nodeAId, int nodeBId)
        {
            if (nodeAId == nodeBId)
            {
                // Cannot link to the same node
                return false;
            }

            if (!generatedNodes.ContainsKey(nodeAId) || !generatedNodes.ContainsKey(nodeBId))
            {
                return false;
            }

            GraphNode nodeA = generatedNodes[nodeAId];
            GraphNode nodeB = generatedNodes[nodeBId];

            // Assumes that we link to the first pin of both the nodes
            if (nodeA.OutputPin == null || nodeB.InputPin == null)
            {
                return false;
            }

            var link = graphBuilder.LinkNodes<GraphLink>(nodeA.OutputPin, nodeB.InputPin);
            return (link != null);
        }

        public void ClearGraph()
        {
            var nodes = grammarGraph.Nodes.ToArray();
            foreach (var node in nodes)
            {
                if (node is CommentNode) continue;

                graphBuilder.DestroyNode(node);
            }
        }
    }

}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Grammar\GraphBuillder\GrammarGraphBuildScript.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Grammar
{
    public interface IGrammarGraphBuildScript
    {
        void Generate(IGrammarGraphBuilder grammarBuilder);
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Grammar\Nodes\GrammarNodeBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Grammar
{
    public class GrammarNodeBase : GraphNode
    {
    }
}

 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Grammar\Nodes\GrammarNodePin.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Grammar
{
    [System.Serializable]
    public class GrammarNodePin : GraphPin
    {
        public Vector2 Padding = new Vector2(10, 10);

        public override bool ContainsPoint(Vector2 worldPoint)
        {
            if (PinType == GraphPinType.Input)
            {
                // We don't want the user to touch this pin.  Our logic will connect output-output pins correctly
                return false;
            }

            if (base.ContainsPoint(worldPoint))
            {
                // Make sure it is not inside the body
                var bodyBounds = Node.Bounds;
                bodyBounds.position += Padding;
                bodyBounds.size -= Padding * 2;

                // make sure it is not inside the body
                return !bodyBounds.Contains(worldPoint);
            }
            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Grammar\Nodes\GrammarRuleNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
namespace DungeonArchitect.Grammar
{
    public class GrammarRuleNode : GrammarNodeBase
    {
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Grammar\Graphs\Grammar\Nodes\GrammarTaskNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;
using DMathUtils = DungeonArchitect.Utils.MathUtils;

namespace DungeonArchitect.Grammar
{
    public class GrammarTaskNode : GrammarNodeBase
    {
        public GrammarNodeType NodeType;
        public int executionIndex = 0;
        public bool DisplayExecutionIndex = true;

        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            Size = new Vector2(80, 45);

            // Create an input pin on the top
            CreatePinOfType<GrammarNodePin>(GraphPinType.Input,
                        Vector2.zero,
                        Rect.zero,
                        new Vector2(0, -1));

            // Create an output pin at the bottom
            CreatePinOfType<GrammarNodePin>(GraphPinType.Output,
                        Vector2.zero,
                        Rect.zero,
                        new Vector2(0, -1));

        }

        public override void CopyFrom(GraphNode otherNode) {
            base.CopyFrom(otherNode);

            if (otherNode is GrammarTaskNode)
            {
                var otherTaskNode = otherNode as GrammarTaskNode;
                NodeType = otherTaskNode.NodeType;
                executionIndex = otherTaskNode.executionIndex;
                DisplayExecutionIndex = otherTaskNode.DisplayExecutionIndex;
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\GraphEditor\Renderers\GraphLinkRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{
    public interface IGraphLinkRenderer
    {
        void DrawGraphLink(UIRenderer renderer, GraphRendererContext rendererContext, GraphLink link, GraphCamera camera);
    }

    /// <summary>
    /// Spline based Graph Link renderer
    /// </summary>
    public class SplineGraphLinkRenderer : IGraphLinkRenderer
    {
        public void DrawGraphLink(UIRenderer renderer, GraphRendererContext rendererContext, GraphLink link, GraphCamera camera)
        {
            if (link.Input == null || link.Output == null)
            {
                // Link not initialized yet. nothing to draw
                return;
            }

            float lineThickness = 3;

            Vector2 startPos = camera.WorldToScreen(link.Output.WorldPosition);
            Vector2 endPos = camera.WorldToScreen(link.Input.WorldPosition);
            var tangentStrength = link.GetTangentStrength() / camera.ZoomLevel;
            Vector3 startTan = startPos + link.Output.Tangent * tangentStrength;
            Vector3 endTan = endPos + link.Input.Tangent * tangentStrength;
            var lineColor = new Color(1, 1, 1, 0.75f);
            renderer.DrawBezier(startPos, endPos, startTan, endTan, lineColor, null, lineThickness);

            // Draw the arrow cap
            var rotation = Quaternion.FromToRotation(new Vector3(1, 0, 0), link.Input.Tangent.normalized);
            float arrowSize = 10.0f / camera.ZoomLevel;
            float arrowWidth = 0.5f / camera.ZoomLevel;
            var arrowTails = new Vector2[] {
                rotation * new Vector3(1, arrowWidth) * arrowSize,
                rotation * new Vector3(1, -arrowWidth) * arrowSize,
            };

            //renderer.DrawPolyLine(lineColor, arrowTails);
            renderer.DrawLine(lineColor, endPos, endPos + arrowTails[0]);
            renderer.DrawLine(lineColor, endPos, endPos + arrowTails[1]);
            renderer.DrawLine(lineColor, endPos + arrowTails[0], endPos + arrowTails[1]);
        }
    }


    public class StraightLineGraphLinkRenderer : IGraphLinkRenderer
    {
        private Vector2 GetPointOnNodeBounds(Vector2 position, GraphPin pin, float distanceBias)
        {
            var nodeRect = (pin.Node != null) ? pin.Node.Bounds : new Rect(pin.WorldPosition, Vector2.one);
            var center = nodeRect.position + nodeRect.size * 0.5f;
            var b = new Bounds(center, nodeRect.size);
            var direction = (center - position).normalized;
            var r = new Ray(position, direction);
            float intersectDistance;
            if (b.IntersectRay(r, out intersectDistance))
            {
                return position + direction * (intersectDistance + distanceBias);
            }

            return pin.WorldPosition;
        }

        public void DrawGraphLink(UIRenderer renderer, GraphRendererContext rendererContext, GraphLink link, GraphCamera camera)
        {
            if (link.Input == null || link.Output == null)
            {
                // Link not initialized yet. nothing to draw
                return;
            }


            Vector2 startPos, endPos;
            {
                float bias = -5;
                startPos = GetPointOnNodeBounds(link.Input.WorldPosition, link.Output, bias);
                endPos = GetPointOnNodeBounds(link.Output.WorldPosition, link.Input, bias);

                startPos = camera.WorldToScreen(startPos);
                endPos = camera.WorldToScreen(endPos);
            }

            var lineColor = new Color(1, 1, 1, 1);
            float lineThickness = 3;

            DrawLine(renderer, startPos, endPos, camera, lineColor, lineThickness);
        }

        public static void DrawLine(UIRenderer renderer, Vector2 startPos, Vector2 endPos, GraphCamera camera, Color lineColor, float lineThickness)
        {
            renderer.DrawAAPolyLine(lineThickness, lineColor, startPos, endPos);

            //renderer.ArrowHandleCap(lineColor, 0, endPos, Quaternion.identity, 30, EventType.Used);

            var rotation = Quaternion.FromToRotation(new Vector3(1, 0, 0), (startPos - endPos).normalized);
            float arrowSize = 10.0f / camera.ZoomLevel;
            float arrowWidth = 0.5f / camera.ZoomLevel;
            var arrowTails = new Vector2[] {
                rotation * new Vector3(1, arrowWidth) * arrowSize,
                rotation * new Vector3(1, -arrowWidth) * arrowSize,
            };

            var p0 = endPos;
            var p1 = endPos + arrowTails[0];
            var p2 = endPos + arrowTails[1];

            renderer.DrawAAConvexPolygon(lineColor, p0, p1, p2, p0);
            
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\GraphEditor\Renderers\GraphNodeRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System;
using UnityEngine;
using System.Collections.Generic;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{
    /// <summary>
    /// Renders the graph node in the graph editor
    /// </summary>
    public class GraphNodeRenderer
    {

        public bool GraphStateChanged { get; set; }
        
        protected virtual Color getBackgroundColor(GraphNode node)
        {
            return node.Selected ? GraphEditorConstants.NODE_COLOR_SELECTED : GraphEditorConstants.NODE_COLOR;
        }

        public virtual void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            // Draw the pins
            if (node.InputPins != null)
            {
                foreach (var pin in node.InputPins)
                {
                    GraphPinRenderer.Draw(renderer, rendererContext, pin, camera);
                }
            }
            if (node.OutputPin != null)
            {
                foreach (var pin in node.OutputPins)
                {
                    GraphPinRenderer.Draw(renderer, rendererContext, pin, camera);
                }
            }
        }

        public virtual void BeginFrame(Graph graph)
        {
        }

        public virtual void EndFrame()
        {
        }
        
        public virtual void Release() { }

		protected virtual void DrawTextCentered(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera, string text) {
			DrawTextCentered (renderer, rendererContext, node, camera, text, Vector2.zero);
		}

		protected virtual void DrawTextCentered(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera, string text, Vector2 offset) {
			var style = new GUIStyle(GUI.skin.GetStyle("Label"));
			style.alignment = TextAnchor.MiddleCenter;

			var positionScreen = camera.WorldToScreen(node.Position + offset);
			var labelSize = new Vector2 (node.Bounds.width, node.Bounds.height) / camera.ZoomLevel;
			var labelBounds = new Rect(positionScreen.x, positionScreen.y, labelSize.x, labelSize.y);
			style.normal.textColor = node.Selected ? GraphEditorConstants.TEXT_COLOR_SELECTED : GraphEditorConstants.TEXT_COLOR;

			var originalFont = style.font;
			var originalFontSize = style.fontSize;
			var miniFontBaseSize = 20;

			if (camera.ZoomLevel >= 2) {

				float scaledFontSize = originalFontSize;
				if (scaledFontSize == 0) {
					scaledFontSize = miniFontBaseSize;
				}
				scaledFontSize = Mathf.Max(1.0f, scaledFontSize / camera.ZoomLevel);

				style.fontSize = Mathf.RoundToInt(scaledFontSize);
                style.font = renderer.StyleManager.GetFontMini();
			}

            renderer.Label(labelBounds, text, style);

			style.font = originalFont;
			style.fontSize = originalFontSize;
		}

        protected void DrawNodeTexture(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera, string textureName)
        {
            var nodeTexture = renderer.GetResource<Texture2D>(textureName) as Texture2D;
			var textureSize = new Vector2 (nodeTexture.width, nodeTexture.height);
			if (nodeTexture != null)
            {
                var center = camera.WorldToScreen(node.Bounds.center);

				var size = textureSize / camera.ZoomLevel;
				var position = center - size / 2.0f;

                var rect = new Rect(position.x, position.y, size.x, size.y);
				renderer.DrawTexture(rect, nodeTexture);
            }
        }
    }

    public class GraphNodeRendererFactory
    {
        GraphNodeRenderer defaultRenderer = new GraphNodeRenderer();
        Dictionary<Type, GraphNodeRenderer> renderers = new Dictionary<Type, GraphNodeRenderer>();


        public void RegisterNodeRenderer(Type nodeType, GraphNodeRenderer renderer)
        {
            if (!renderers.ContainsKey(nodeType))
            {
                renderers.Add(nodeType, renderer);
            }
        }

        public GraphNodeRenderer GetRenderer(Type nodeType)
        {
            if (renderers.ContainsKey(nodeType))
            {
                return renderers[nodeType];
            }
            
            // Try to get a base class renderer
            foreach (var entry in renderers)
            {
                var rendererType = entry.Key;
                if (nodeType.IsSubclassOf(rendererType))
                {
                    return entry.Value;
                }
            }
            
            return defaultRenderer;
        }

        public void Release()
        {
            foreach (var renderer in renderers.Values)
            {
                renderer.Release();
            }

            renderers.Clear();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\GraphEditor\Renderers\GraphPinRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{
    /// <summary>
    /// Renders a graph pin hosted inside a node
    /// </summary>
    public class GraphPinRenderer
    {

        public static void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphPin pin, GraphCamera camera)
        {
            var pinBounds = new Rect(pin.GetBounds());
			var positionWorld = pin.Node.Position + pinBounds.position;
            var positionScreen = camera.WorldToScreen(positionWorld);
			pinBounds.position = positionScreen;
			pinBounds.size /= camera.ZoomLevel;

            var guiState = new GUIState(renderer);
            renderer.DrawRect(pinBounds, GetPinColor(pin));
            guiState.Restore();

            // Draw the pin texture
            var pinTexture = renderer.GetResource<Texture2D>(UIResourceLookup.TEXTURE_PIN_GLOW) as Texture2D;
			if (pinTexture != null)
            {
                renderer.DrawTexture(pinBounds, pinTexture);
            }
        }

        static Color GetPinColor(GraphPin pin)
        {
            Color color;
            if (pin.ClickState == GraphPinMouseState.Clicked)
            {
                color = GraphEditorConstants.PIN_COLOR_CLICK;
            }
            else if (pin.ClickState == GraphPinMouseState.Hover)
            {
                color = GraphEditorConstants.PIN_COLOR_HOVER;
            }
            else
            {
                color = GraphEditorConstants.PIN_COLOR;
            }
            return color;
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\UI\Widgets\GraphEditor\Renderers\TooltipRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.UI.Widgets.GraphEditors
{
    /// <summary>
    /// Graph tooltip singleton
    /// </summary>
    public class GraphTooltip
    {
        /// <summary>
        /// Set this to display a tooltip in the graph editor
        /// </summary>
        public static string message = "";
        public static void Clear()
        {
            message = "";
        }
    }

    /// <summary>
    /// Renders a tooltip in the graph editor. The tooltip message is defined in GraphTooltip.message
    /// </summary>
    public class GraphTooltipRenderer
    {
        public static void Draw(UIRenderer renderer, GraphRendererContext rendererContext, Vector2 mousePosition)
        {
            if (GraphTooltip.message == null || GraphTooltip.message.Trim().Length == 0) return;

            var tooltipPadding = new Vector2(4, 4);

            var drawPosition = mousePosition + new Vector2(15, 5);

            var tooltipString = GraphTooltip.message;
            var style = new GUIStyle(GUI.skin.GetStyle("label"));
            var contentSize = style.CalcSize(new GUIContent(tooltipString));
            drawPosition -= tooltipPadding;
            contentSize += tooltipPadding * 2;
            var bounds = new Rect(drawPosition.x, drawPosition.y, contentSize.x, contentSize.y);

            var guiState = new GUIState(renderer);
            renderer.backgroundColor = new Color(.15f, .15f, .15f);
            renderer.DrawRect(bounds, new Color(.15f, .15f, .15f));

            var innerGlow = renderer.GetResource<Texture2D>(UIResourceLookup.TEXTURE_PIN_GLOW) as Texture2D;
            renderer.DrawTexture(bounds, innerGlow);

            style.alignment = TextAnchor.MiddleCenter;
            style.normal.textColor = Color.white;
            renderer.Label(bounds, tooltipString, style);
            guiState.Restore();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\ExecGraphEditor\NodeRenderers\FlowExecNodeRendererBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;
using UnityEditor;
using DMathUtils = DungeonArchitect.Utils.MathUtils;
using DungeonArchitect.Flow.Exec;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.Flow
{
    public abstract class FlowExecNodeRendererBase : GraphNodeRenderer
    {
        protected abstract string GetCaption(GraphNode node);
        protected abstract Color GetPinColor(GraphNode node);
        protected virtual Color GetBodyColor(GraphNode node)
        {
            return new Color(0.1f, 0.1f, 0.1f, 1);
        }

        protected FlowExecTask GetHandler(GraphNode node)
        {
            var execNode = node as FlowExecRuleGraphNode;
            return (execNode != null) ? execNode.task : null;
        }

        protected GridFlowGraphNodeExecutionStatus GetNodeExecutionState(GraphNode node)
        {
            var execNode = node as FlowExecRuleGraphNode;
            return (execNode != null) ? execNode.executionStatus : null;
        }

        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            var pinColor = GetPinColor(node);

            // Update the node bounds
            NodeBoundLayoutData layoutData;
            {
                var style = GetNodeStyle(node, camera.ZoomLevel);
                var contentScreenSize = GetContentScreenSize(node, style);
                UpdateNodeBounds(node, camera.ZoomLevel, contentScreenSize, style, out layoutData);
            }

            // Draw the pins
            DrawPins(renderer, rendererContext, node, camera, pinColor);

            // Draw the node body
            DrawNodeBody(renderer, layoutData, node, camera);
        }

        void DrawPins(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera, Color nodeColor)
        {
            var outputPin = node.OutputPin;
            var nodeSize = node.Bounds.size;
            var offset = nodeSize / 2.0f;
            outputPin.Position = offset;
            outputPin.BoundsOffset = new Rect(-offset, nodeSize);

            var inputPin = node.InputPin;
            inputPin.Position = offset;
            inputPin.BoundsOffset = outputPin.BoundsOffset;

            DrawPin(renderer, rendererContext, outputPin, camera, nodeColor);
        }

        class GridFlowExecEditorConstants
        {
            public static readonly Color PIN_COLOR_HOVER = new Color(1, 0.6f, 0.0f);
            public static readonly Color PIN_COLOR_CLICK = new Color(1, 0.9f, 0.0f);
            public static readonly Color FOCUS_HIGHLITE_COLOR = new Color(1, 0.5f, 0, 1);
            public static readonly Vector2 BASE_PADDING = new Vector2(16, 16);
        }

        static Color GetPinColor(GraphPin pin, Color nodeColor)
        {
            Color color;
            if (pin.ClickState == GraphPinMouseState.Clicked)
            {
                color = GridFlowExecEditorConstants.PIN_COLOR_CLICK;
            }
            else if (pin.ClickState == GraphPinMouseState.Hover)
            {
                color = GridFlowExecEditorConstants.PIN_COLOR_HOVER;
            }
            else
            {
                color = nodeColor;
            }
            return color;
        }

        void DrawPin(UIRenderer renderer, GraphRendererContext rendererContext, GraphPin pin, GraphCamera camera, Color nodeColor)
        {
            if (pin.Node == null)
            {
                Debug.Log("pin node null. skipping");
                return;

            }
            var guiState = new GUIState(renderer);

            var pinBounds = new Rect(pin.GetBounds());
            var positionWorld = pin.Node.Position + pinBounds.position;
            var positionScreen = camera.WorldToScreen(positionWorld);
            pinBounds.position = positionScreen;
            pinBounds.size /= camera.ZoomLevel;

            if (pin.Node != null && pin.Node.Selected)
            {
                var focusboundsScreen = DMathUtils.ExpandRect(pinBounds, 2);
                renderer.DrawRect(focusboundsScreen, GridFlowExecEditorConstants.FOCUS_HIGHLITE_COLOR);
            }

            renderer.DrawRect(pinBounds, GetPinColor(pin, nodeColor));

            guiState.Restore();

        }

        public void UpdateNodeBounds(GraphNode node, float zoomLevel)
        {
            var style = GetNodeStyle(node, zoomLevel);
            var contentScreenSize = GetContentScreenSize(node, style);
            NodeBoundLayoutData layoutData;
            UpdateNodeBounds(node, zoomLevel, contentScreenSize, style, out layoutData);
        }

        struct NodeBoundLayoutData
        {
            public Vector2 screenTextSize;
            public Vector2 screenNodeSize;
        }
        static void UpdateNodeBounds(GraphNode node, float zoomLevel, Vector2 contentScreenSize, GUIStyle style, out NodeBoundLayoutData outLayoutData)
        {
            var screenPadding = GridFlowExecEditorConstants.BASE_PADDING / zoomLevel;
            var screenTextSize = contentScreenSize;
            var screenNodeSize = screenTextSize + screenPadding * 2;
            var updateWorldSize = screenNodeSize * zoomLevel;
            var nodeBounds = node.Bounds;
            nodeBounds.size = updateWorldSize;
            node.Bounds = nodeBounds;

            outLayoutData = new NodeBoundLayoutData();
            outLayoutData.screenTextSize = screenTextSize;
            outLayoutData.screenNodeSize = screenNodeSize;
        }

        public static GUIStyle GetNodeStyle(GraphNode node, float zoomLevel)
        {
            var style = new GUIStyle(EditorStyles.boldLabel);
            style.alignment = TextAnchor.UpperLeft;

            style.normal.textColor = node.Selected ? GraphEditorConstants.TEXT_COLOR_SELECTED : GraphEditorConstants.TEXT_COLOR;

            {
                style.font = EditorStyles.boldFont;
                float scaledFontSize = style.fontSize == 0 ? style.font.fontSize : style.fontSize;
                scaledFontSize = Mathf.Max(1.0f, scaledFontSize / zoomLevel);
                style.fontSize = Mathf.RoundToInt(scaledFontSize);
            }
            return style;
        }

        protected virtual Vector2 GetContentScreenSize(GraphNode node, GUIStyle style)
        {
            var layout = CalcLayoutInfo(node, style);

            var size = layout.messageSize;
            size.x = Mathf.Max(size.x, layout.descSize.x);
            size.x = Mathf.Max(size.x, layout.errorSize.x);

            if (layout.drawDescription)
            {
                size.y += layout.descSize.y;
            }

            if (layout.drawErrorMessage)
            {
                size.y += layout.errorSize.y;
            }

            return size;
        }

        void DrawNodeExecStatus(UIRenderer renderer, GraphNode node, GraphCamera camera, Rect boxBounds, ExecRuleNodeLayoutInfo layout)
        {
            // Draw the execution status bar
            var execState = GetNodeExecutionState(node);
            if (execState != null && execState.ExecutionStage != GridFlowGraphNodeExecutionStage.NotExecuted)
            {
                bool drawErrorBar = false;
                Color barColor = Color.grey;
                if (execState.ExecutionStage == GridFlowGraphNodeExecutionStage.WaitingToExecute)
                {
                    barColor = new Color(1, 0.5f, 0);
                }
                else if (execState.ExecutionStage == GridFlowGraphNodeExecutionStage.Executed)
                {
                    if (execState.Success == FlowTaskExecutionResult.Success)
                    {
                        barColor = Color.green;
                    }
                    else
                    {
                        barColor = Color.red;
                        drawErrorBar = true;
                    }
                }

                if (drawErrorBar && layout.drawErrorMessage)
                {
                    var execHighlightBounds = boxBounds;
                    execHighlightBounds.y += boxBounds.height - layout.errorSize.y;
                    execHighlightBounds.height = layout.errorSize.y;
                    renderer.DrawRect(execHighlightBounds, barColor);
                    renderer.Box(execHighlightBounds, layout.errorContent, layout.errorStyle);
                }
                else
                {
                    var barHeight = 4.0f / camera.ZoomLevel;
                    var execHighlightBounds = boxBounds;
                    execHighlightBounds.y += execHighlightBounds.height - barHeight;
                    execHighlightBounds.height = Mathf.Max(barHeight, 2);
                    renderer.DrawRect(execHighlightBounds, barColor);
                }
            }
        }

        protected struct ExecRuleNodeLayoutInfo
        {
            public GUIContent messageContent;
            public Vector2 messageSize;
            public GUIStyle messageStyle;

            public bool drawDescription;
            public GUIContent descContent;
            public Vector2 descSize;
            public GUIStyle descStyle;

            public bool drawErrorMessage;
            public GUIContent errorContent;
            public Vector2 errorSize;
            public GUIStyle errorStyle;

        }

        protected virtual string GetDescText(GraphNode node) { return ""; }

        GUIStyle GetDescStyle(GUIStyle style)
        {
            var descStyle = new GUIStyle(style);
            descStyle.fontSize = 12;
            return descStyle;
        }

        GUIStyle GetErrorStyle(GUIStyle style)
        {
            var errorStyle = new GUIStyle(style);
            errorStyle.fontSize = 12;
            errorStyle.alignment = TextAnchor.MiddleCenter;
            return errorStyle;
        }

        ExecRuleNodeLayoutInfo CalcLayoutInfo(GraphNode node, GUIStyle style)
        {
            var layout = new ExecRuleNodeLayoutInfo();

            // Calculate the message size
            {
                string nodeMessage = GetCaption(node);

                layout.messageContent = new GUIContent(nodeMessage);
                layout.messageSize = style.CalcSize(layout.messageContent);
                layout.messageStyle = style;
            }

            // Calculate the desc size
            {
                string description = GetDescText(node);
                layout.drawDescription = description.Length > 0;
                var descStyle = GetDescStyle(style);
                descStyle.font = EditorStyles.standardFont;
                descStyle.fontSize = Mathf.RoundToInt(style.fontSize * 0.8f);

                layout.descContent = new GUIContent(description);
                layout.descSize = description.Length > 0
                    ? descStyle.CalcSize(layout.descContent)
                    : Vector2.zero;
                layout.descStyle = descStyle;
            }

            // Calculate the error size
            {
                layout.drawErrorMessage = false;

                var ruleNode = node as FlowExecRuleGraphNode;
                string errorMessage;

                if (ruleNode != null && ruleNode.executionStatus != null)
                {
                    layout.drawErrorMessage =
                        (ruleNode.executionStatus.Success != FlowTaskExecutionResult.Success)
                        && (ruleNode.executionStatus.ExecutionStage == GridFlowGraphNodeExecutionStage.Executed)
                        && (ruleNode.executionStatus.ErrorMessage.Length > 0);
                    errorMessage = ruleNode.executionStatus.ErrorMessage;
                }
                else
                {
                    layout.drawErrorMessage = false;
                    errorMessage = "";
                }

                var errorStyle = GetErrorStyle(style);
                errorStyle.font = EditorStyles.standardFont;
                errorStyle.fontSize = Mathf.RoundToInt(style.fontSize * 0.8f);

                layout.errorContent = new GUIContent(errorMessage);
                layout.errorSize = layout.drawErrorMessage
                    ? errorStyle.CalcSize(layout.errorContent)
                    : Vector2.zero;
                layout.errorStyle = errorStyle;
            }
            return layout;
        }

        void DrawNodeBody(UIRenderer renderer, NodeBoundLayoutData layoutData, GraphNode node, GraphCamera camera)
        {
            var style = GetNodeStyle(node, camera.ZoomLevel);

            var guiState = new GUIState(renderer);
            Color nodeColor = GetBodyColor(node);

            var outputPin = node.OutputPin as FlowExecGraphNodePin;
            var pinPadding = new Vector2(12, 12);
            var screenPinPadding = pinPadding / camera.ZoomLevel;
            if (outputPin != null)
            {
                outputPin.Padding = pinPadding;
            }

            // Draw the node pin
            Rect boxBounds;
            {
                var positionScreen = camera.WorldToScreen(node.Position + pinPadding);
                var sizeScreen = layoutData.screenNodeSize - screenPinPadding * 2;
                boxBounds = new Rect(positionScreen, sizeScreen);
            }
            renderer.DrawRect(boxBounds, nodeColor);


            var layout = CalcLayoutInfo(node, style);

            // Draw the node content
            {
                Rect contentBounds;
                {
                    var positionScreen = camera.WorldToScreen(node.Position + GridFlowExecEditorConstants.BASE_PADDING);
                    var sizeScreen = layoutData.screenTextSize;
                    contentBounds = new Rect(positionScreen, sizeScreen);
                }

                layout.messageStyle.normal.textColor = Color.white;
                layout.descStyle.normal.textColor = Color.white;

                var messageOffsetX = Mathf.Max(0, (contentBounds.width - layout.messageSize.x) * 0.5f);

                var messageBounds = new Rect(contentBounds.position + new Vector2(messageOffsetX, 0), layout.messageSize);
                renderer.Label(messageBounds, layout.messageContent, layout.messageStyle);
                if (layout.drawDescription)
                {
                    var modeOffsetX = Mathf.Max(0, (contentBounds.width - layout.descSize.x) * 0.5f);
                    var descBounds = new Rect(contentBounds.position + new Vector2(modeOffsetX, layout.messageSize.y), layout.descSize);

                    renderer.Label(descBounds, layout.descContent, layout.descStyle);
                }
            }

            DrawNodeExecStatus(renderer, node, camera, boxBounds, layout);

            guiState.Restore();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\ExecGraphEditor\NodeRenderers\FlowExecResultNodeRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Editors.Flow
{
    public class FlowExecResultNodeRenderer : FlowExecNodeRendererBase
    {
        protected override string GetCaption(GraphNode node)
        {
            return "Result";
        }

        protected override Color GetPinColor(GraphNode node)
        {
            return new Color(0.1f, 0.4f, 0.2f);
        }

        protected override Color GetBodyColor(GraphNode node)
        {
            return new Color(0.1f, 0.1f, 0.1f, 1);
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\ExecGraphEditor\NodeRenderers\FlowExecRuleNodeRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;
using DungeonArchitect.Graphs;
using DungeonArchitect.Flow.Exec;

namespace DungeonArchitect.Editors.Flow
{
    public class FlowExecRuleNodeRenderer : FlowExecNodeRendererBase
    {
        protected override string GetDescText(GraphNode node)
        {
            var handler = GetHandler(node);
            return (handler != null) ? handler.description : "";
        }

        protected override string GetCaption(GraphNode node)
        {
            var handler = GetHandler(node);
            var menuAttribute = handler != null ? FlowExecNodeInfoAttribute.GetHandlerAttribute(handler.GetType()) : null;
            return (menuAttribute != null) ? menuAttribute.Title : "[INVALID]";
        }

        protected override Color GetPinColor(GraphNode node)
        {
            var handler = GetHandler(node);
            return (handler != null) ? new Color(0.3f, 0.3f, 0.5f) : Color.red;
        }

        protected override Color GetBodyColor(GraphNode node)
        {
            var handler = GetHandler(node);
            return (handler != null) ? new Color(0.1f, 0.1f, 0.1f, 1) : Color.red;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\PreviewLayoutGraphEditor\Renderers\FlowPreviewLayoutItemRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;
using UnityEditor;
using UnityEngine;

namespace DungeonArchitect.Editors.Flow.Layout
{
    public delegate void OnFlowLayoutGraphItemRendered(FlowItem item, Rect screenBounds);
    public class FlowPreviewLayoutItemRenderer 
    {
        public static float ItemRadiusFactor { get; private set; }
        public static float ItemHoverScaleFactor { get; private set; }

        static FlowPreviewLayoutItemRenderer()
        {
            ItemRadiusFactor = 0.35f;
            ItemHoverScaleFactor = 1.25f;
        }

        public static float GetItemScaleFactor(Vector2 mousePosition, Rect itemBounds)
        {
            var radius = itemBounds.size.x * 0.5f;
            var itemCenter = itemBounds.center;
            var distance = (mousePosition - itemCenter).magnitude - radius;
            distance = 1 - Mathf.Clamp01(distance / (itemBounds.size.x * 0.25f));
            distance = distance * distance;

            var scaleFactor = Mathf.Lerp(1.0f, ItemHoverScaleFactor, distance);
            return scaleFactor;
        }

        public static void DrawItem(UIRenderer renderer, GraphRendererContext rendererContext, GraphCamera camera, FlowItem item, Rect itemBounds, float textScaleFactor)
        {
            // Draw the item background circle
            Color colorBackground, colorForeground;
            FlowItemUtils.GetFlowItemColor(item, out colorBackground, out colorForeground);
            var borderColor = item.editorSelected ? Color.red : Color.black;
            var thickness = item.editorSelected ? 3 : 1;
            FlowPreviewLayoutNodeRendererBase.DrawCircle(renderer, itemBounds, colorBackground, borderColor, thickness);

            // Draw the item text
            {
                var text = FlowItemUtils.GetFlowItemText(item);
                var style = new GUIStyle(EditorStyles.boldLabel);
                style.normal.textColor = colorForeground;
                style.alignment = TextAnchor.MiddleCenter;
                style.font = EditorStyles.boldFont;
                float scaledFontSize = (style.fontSize == 0) ? style.font.fontSize : style.fontSize;
                scaledFontSize *= textScaleFactor;
                scaledFontSize = Mathf.Max(1.0f, scaledFontSize / camera.ZoomLevel);
                style.fontSize = Mathf.RoundToInt(scaledFontSize);
                renderer.Label(itemBounds, text, style);
            }
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\PreviewLayoutGraphEditor\Renderers\FlowPreviewLayoutLinkRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D;
using UnityEngine;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.Flow.Layout
{
    public class FlowPreviewLayoutLinkRenderer : IGraphLinkRenderer
    {
        public float padding = 4;
        public Color lineColorDirected = new Color(1, 1, 1, 1);
        public Color lineColorUndirected = new Color(1, 1, 1, 0.25f);
        public Color lineColorOneWay = new Color(1, 0.5f, 0, 1);
        public float lineThickness = 3;

        public event OnFlowLayoutGraphItemRendered GridFlowLayoutGraphItemRendered;

        public void DrawGraphLink(UIRenderer renderer, GraphRendererContext rendererContext, GraphLink link, GraphCamera camera)
        {
            if (link.Input == null || link.Output == null)
            {
                // Link not initialized yet. nothing to draw
                return;
            }

            var nodeA = link.Output.Node;
            var nodeB = link.Input.Node;
            if (nodeA == null || nodeB == null)
            {
                // invalid state
                return;
            }

            if (nodeA == nodeB)
            {
                return;
            }

            var positionA = nodeA.Bounds.center;
            var radiusA = nodeA.Bounds.width * 0.5f;

            var positionB = nodeB.Bounds.center;
            var radiusB = nodeB.Bounds.width * 0.5f;

            var vecAToB = (positionB - positionA);
            var length = vecAToB.magnitude;
            var direction = vecAToB / length;

            var worldStartPos = positionA + direction * (radiusA + padding);
            var worldEndPos = positionA + direction * (length - radiusB - padding);

            var startPos = camera.WorldToScreen(worldStartPos);
            var endPos = camera.WorldToScreen(worldEndPos);


            var previewLink = link as FlowLayoutToolGraph2DLink;
            if (previewLink != null)
            {
                bool directional = previewLink.layoutLinkState.type != FlowLayoutGraphLinkType.Unconnected;

                var color = directional ? lineColorDirected : lineColorUndirected;
                if (previewLink.layoutLinkState.type == FlowLayoutGraphLinkType.OneWay)
                {
                    color = lineColorOneWay;
                }
                renderer.DrawAAPolyLine(lineThickness, color, startPos, endPos);

                // Draw the arrow head if directional
                if (directional)
                {
                    var rotation = Quaternion.FromToRotation(new Vector3(1, 0, 0), (startPos - endPos).normalized);
                    float arrowSize = 10.0f / camera.ZoomLevel;
                    float arrowWidth = 0.5f / camera.ZoomLevel;
                    var arrowTails = new Vector2[] {
                        rotation * new Vector3(1, arrowWidth) * arrowSize,
                        rotation * new Vector3(1, -arrowWidth) * arrowSize,
                    };

                    var p0 = endPos;
                    var p1 = endPos + arrowTails[0];
                    var p2 = endPos + arrowTails[1];

                    renderer.DrawAAConvexPolygon(color, p0, p1, p2, p0);

                    if (previewLink.layoutLinkState.type == FlowLayoutGraphLinkType.OneWay)
                    {
                        // Draw another arrow head
                        var dirToTail = (startPos - endPos).normalized;
                        var offset = dirToTail * 10.0f / camera.ZoomLevel;

                        p0 += offset;
                        p1 += offset;
                        p2 += offset;
                        renderer.DrawAAConvexPolygon(color, p0, p1, p2, p0);
                    }

                    // Draw the items
                    {
                        float itemPadding = 2;
                        var items = previewLink.layoutLinkState.items;
                        for (int i = 0; i < items.Count; i++)
                        {
                            var item = items[i];

                            var sourceNode = link.Output.Node;
                            var destNode = link.Input.Node;

                            var hostSizeScreen = sourceNode.Bounds.size / camera.ZoomLevel;
                            var hostRadiusScreen = Mathf.Min(hostSizeScreen.x, hostSizeScreen.y) * 0.5f;

                            var itemRadiusScreen = hostRadiusScreen * FlowPreviewLayoutItemRenderer.ItemRadiusFactor;

                            var numLaneItems2 = items.Count / 2;
                            var numLaneItems1 = items.Count - numLaneItems2;

                            bool firstLane = i < numLaneItems1;
                            var laneIndex = i;
                            var laneItemCount = numLaneItems1;

                            var offsetY = itemRadiusScreen + itemPadding;
                            if (items.Count == 1)
                            {
                                offsetY = 0;
                            }

                            if (!firstLane)
                            {
                                laneIndex -= numLaneItems1;
                                laneItemCount = numLaneItems2;
                                offsetY = -offsetY;
                            }

                            var indexOffsetF = laneIndex - (laneItemCount - 1) * 0.5f;
                            var offsetX = (itemRadiusScreen + itemPadding) * indexOffsetF * 2;
                            Vector2 offset;
                            var linkDirection = (endPos - startPos).normalized;
                            float dot = Vector2.Dot(linkDirection, new Vector2(1, 0));
                            if (dot < 0.9999f)
                            {
                                offset = rotation * new Vector3(offsetX, offsetY);
                            }
                            else
                            {
                                offset = new Vector2(offsetX, -offsetY);
                            }


                            var centerScreen = (startPos + endPos) * 0.5f + offset;
                            var extentScreen = new Vector2(itemRadiusScreen, itemRadiusScreen);
                            var itemBounds = new Rect(centerScreen - extentScreen, extentScreen * 2);

                            float scaleFactor = FlowPreviewLayoutItemRenderer.GetItemScaleFactor(rendererContext.GraphEditor.LastMousePosition, itemBounds);
                            var scaledSize = itemBounds.size * scaleFactor;
                            itemBounds = new Rect(itemBounds.center - scaledSize * 0.5f, scaledSize);

                            FlowPreviewLayoutItemRenderer.DrawItem(renderer, rendererContext, camera, item, itemBounds, scaleFactor);
                            if (GridFlowLayoutGraphItemRendered != null)
                            {
                                GridFlowLayoutGraphItemRendered.Invoke(item, itemBounds);
                            }
                        }
                    }
                }
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\PreviewLayoutGraphEditor\Renderers\FlowPreviewLayoutNodeRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.UI;
using DungeonArchitect.Graphs;
using DungeonArchitect.Flow.Domains.Layout;
using DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D;
using DungeonArchitect.Flow.Impl.GridFlow;
using UnityEngine;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.Flow.Layout
{
    public class FlowPreviewLayoutNodeRenderer : FlowPreviewLayoutNodeRendererBase
    {
        public event OnFlowLayoutGraphItemRendered FlowLayoutGraphItemRendered;
        protected override string GetCaption(GraphNode node)
        {
            var caption = "";
            var previewNode = node as FlowLayoutToolGraph2DNode;
            if (previewNode != null && previewNode.LayoutNode.active)
            {
                var roomType = GetRoomType(previewNode.LayoutNode);
                switch (roomType)
                {
                    case GridFlowLayoutNodeRoomType.Room:
                        caption = "R";
                        break;

                    case GridFlowLayoutNodeRoomType.Corridor:
                        caption = "Co";
                        break;

                    case GridFlowLayoutNodeRoomType.Cave:
                        caption = "Ca";
                        break;
                }
            }

            return caption;
        }

        FlowLayoutGraphNode GetLayoutNode(GraphNode node)
        {
            var previewNode = node as FlowLayoutToolGraph2DNode;
            if (previewNode != null)
            {
                return previewNode.LayoutNode;
            }
            return null;
        }

        protected override Color GetBodyColor(GraphNode node)
        {
            var bodyColor = base.GetBodyColor(node);
            
            var nodeState = GetLayoutNode(node);
            if (nodeState != null && nodeState.active)
            {
                bodyColor = nodeState.color;
            }
            return bodyColor;
        }



        protected override void DrawNodeBody(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            base.DrawNodeBody(renderer, rendererContext, node, camera);

            var layoutNode = GetLayoutNode(node);
            if (layoutNode != null)
            {
                int numItems = layoutNode.items.Count;
                if (numItems > 0)
                {
                    var hostPosScreen = camera.WorldToScreen(node.Position);
                    var hostSizeScreen = node.Bounds.size / camera.ZoomLevel;
                    var hostCenterScreen = hostPosScreen + hostSizeScreen * 0.5f;
                    var hostRadiusScreen = Mathf.Min(hostSizeScreen.x, hostSizeScreen.y) * 0.5f;

                    var itemRadiusScreen = hostRadiusScreen * FlowPreviewLayoutItemRenderer.ItemRadiusFactor;
                    var itemCenterDistance = hostRadiusScreen - itemRadiusScreen;

                    for (int i = 0; i < numItems; i++)
                    {
                        var item = layoutNode.items[i];
                        if (item == null) continue;
                        var angle = Mathf.PI * 2 * i / numItems - Mathf.PI * 0.5f;
                        var direction = new Vector2(Mathf.Cos(angle), Mathf.Sin(angle));
                        var itemCenterScreen = hostCenterScreen + direction * itemCenterDistance;
                        var itemBoundsSize = new Vector2(itemRadiusScreen, itemRadiusScreen) * 2;
                        var itemBounds = new Rect(itemCenterScreen - itemBoundsSize * 0.5f, itemBoundsSize);
                        
                        float scaleFactor = FlowPreviewLayoutItemRenderer.GetItemScaleFactor(rendererContext.GraphEditor.LastMousePosition, itemBounds);
                        var scaledSize = itemBounds.size * scaleFactor;
                        itemBounds = new Rect(itemBounds.center - scaledSize * 0.5f, scaledSize);

                        FlowPreviewLayoutItemRenderer.DrawItem(renderer, rendererContext, camera, item, itemBounds, scaleFactor);
                        if (FlowLayoutGraphItemRendered != null)
                        {
                            FlowLayoutGraphItemRendered.Invoke(item, itemBounds);
                        }
                    }
                }
            }
        }

        private GridFlowLayoutNodeRoomType GetRoomType(FlowLayoutGraphNode node)
        {
            var domainData = node.GetDomainData<GridFlowTilemapDomainData>();
            return domainData.RoomType;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Editor\Editors\FlowEditor\Widgets\GraphEditors\PreviewLayoutGraphEditor\Renderers\FlowPreviewLayoutNodeRendererBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEditor;
using UnityEngine;
using DMathUtils = DungeonArchitect.Utils.MathUtils;
using DungeonArchitect.Graphs;
using DungeonArchitect.UI;
using DungeonArchitect.UI.Widgets.GraphEditors;

namespace DungeonArchitect.Editors.Flow.Layout
{
    public abstract class FlowPreviewLayoutNodeRendererBase : GraphNodeRenderer
    {
        protected abstract string GetCaption(GraphNode node);
        protected virtual Color GetBodyColor(GraphNode node)
        {
            return new Color(0.2f, 0.3f, 0.2f, 1);
        }

        public override void Draw(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            // Draw the node body
            DrawNodeBody(renderer, rendererContext, node, camera);
        }

        class GridFlowPreviewEditorConstants
        {
            public static readonly Color NODE_BORDER_COLOR = new Color(0.1f, 0.1f, 0.1f);
            public static readonly Color NODE_BORDER_COLOR_SELECTED = new Color(1, .5f, 0, 1);
            public static readonly Vector2 BASE_PADDING = new Vector2(24, 24);
        }

        public static GUIStyle GetNodeStyle(GraphNode node, float zoomLevel)
        {
            var style = new GUIStyle(EditorStyles.boldLabel);
            style.alignment = TextAnchor.UpperLeft;

            style.normal.textColor = node.Selected ? GraphEditorConstants.TEXT_COLOR_SELECTED : GraphEditorConstants.TEXT_COLOR;
            style.alignment = TextAnchor.MiddleCenter;
            {
                style.font = EditorStyles.boldFont;
                float scaledFontSize = style.fontSize == 0 ? style.font.fontSize : style.fontSize;
                scaledFontSize = Mathf.Max(1.0f, scaledFontSize / zoomLevel);
                style.fontSize = Mathf.RoundToInt(scaledFontSize);
            }
            return style;
        }

        protected virtual Vector2 GetContentScreenSize(GraphNode node, GUIStyle style)
        {
            string nodeMessage = GetCaption(node);
            var content = new GUIContent(nodeMessage);
            return style.CalcSize(content);
        }

        protected virtual void DrawNodeContent(UIRenderer renderer, GraphNode node, GUIStyle style, Rect bounds, Color textColor)
        {
            string nodeMessage = GetCaption(node);
            var content = new GUIContent(nodeMessage);

            style.normal.textColor = textColor;
            renderer.Label(bounds, content, style);
        }

        public static void DrawCircle(UIRenderer renderer, Rect bounds, Color bodyColor, Color borderColor, float border)
        {
            var bodyTexture = renderer.GetResource<Texture2D>(UIResourceLookup.TEXTURE_CURSOR_RING_SOLID) as Texture2D;
            if (border > 0)
            {
                var borderBounds = bounds;
                borderBounds.position -= new Vector2(border, border);
                borderBounds.size += new Vector2(border, border) * 2;
                renderer.DrawTexture(borderBounds, bodyTexture, ScaleMode.StretchToFill, true, borderColor);
            }
            renderer.DrawTexture(bounds, bodyTexture, ScaleMode.StretchToFill, true, bodyColor);
        }

        protected virtual void DrawNodeBody(UIRenderer renderer, GraphRendererContext rendererContext, GraphNode node, GraphCamera camera)
        {
            var guiState = new GUIState(renderer);

            // Draw the node pin
            Rect boxBounds;
            {
                var positionScreen = camera.WorldToScreen(node.Position);
                var sizeScreen = node.Bounds.size / camera.ZoomLevel;
                boxBounds = new Rect(positionScreen, sizeScreen);
            }

            Color bodyColor = GetBodyColor(node);
            var borderColor = node.Selected
                ? GridFlowPreviewEditorConstants.NODE_BORDER_COLOR_SELECTED 
                : GridFlowPreviewEditorConstants.NODE_BORDER_COLOR;

            DrawCircle(renderer, boxBounds, bodyColor, borderColor, 2);


            var style = GetNodeStyle(node, camera.ZoomLevel);
            DrawNodeContent(renderer, node, style, boxBounds, Color.black);

            guiState.Restore();
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Actions\MarkerGenRuleNodeAddMarker.cs:
 using System;
using System.Collections.Generic;
using DungeonArchitect.MarkerGenerator.Nodes.Actions.Info;
using UnityEngine;
using UnityEngine.Jobs;

namespace DungeonArchitect.MarkerGenerator.Nodes.Actions
{
    public class MarkerGenRuleNodeAddMarker: MarkerGenRuleGraphNodeActionBase
    {
        public string markerName = "";
        
        [Tooltip(@"Copy the rotation from one of the markers found in this list")]
        public string[] copyRotationFromMarkers = Array.Empty<string>();
	
        [Tooltip(@"Copy the height from one of the markers found in this list")]
        public string[] copyHeightFromMarkers = Array.Empty<string>();
        
        public override string Title => "Add Marker: " + (string.IsNullOrEmpty(markerName) ? "<NONE>" : markerName);
        
        public override MarkerGenRuleActionInfo CreateActionInfo()
        {
            var actionInfo = CreateInstance<MarkerGenRuleActionInfoAddMarker>();
            actionInfo.markerName = markerName;
            actionInfo.copyRotationFromMarkers = new List<string>(copyRotationFromMarkers).ToArray();
            actionInfo.copyHeightFromMarkers = new List<string>(copyHeightFromMarkers).ToArray();
            return actionInfo;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Actions\MarkerGenRuleNodeOnPass.cs:
 using DungeonArchitect.Graphs;
using UnityEngine;
using UnityEngine.PlayerLoop;

namespace DungeonArchitect.MarkerGenerator.Nodes.Actions
{
    public class MarkerGenRuleNodeOnPass : MarkerGenRuleGraphNodeActionBase
    {
        public override Color BodyColor => new Color(0.1f, 0.1f, 0.3f);
        public override Color TitleColor => new Color(0.1f, 0.2f, 0.4f);
        
        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);

            canBeDeleted = false;
        }

        public override string Title => "On Selected";

        protected override void CreateDefaultPins()
        {
            CreateOutputPin("Exec");
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Actions\MarkerGenRuleNodeRemoveMarker.cs:
 using DungeonArchitect.MarkerGenerator.Nodes.Actions.Info;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Nodes.Actions
{
    public class MarkerGenRuleNodeRemoveMarker: MarkerGenRuleGraphNodeActionBase
    {
        public string markerName = "";
        public override string Title => "Remove Marker: " + (string.IsNullOrEmpty(markerName) ? "<NONE>" : markerName);

        public override MarkerGenRuleActionInfo CreateActionInfo()
        {
            var actionInfo = CreateInstance<MarkerGenRuleActionInfoRemoveMarker>();
            actionInfo.markerName = markerName;
            return actionInfo;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Condition\MarkerGenRuleNodeAnd.cs:
 using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator.Pins;

namespace DungeonArchitect.MarkerGenerator.Nodes.Condition
{
    public class MarkerGenRuleNodeAnd : MarkerGenRuleGraphNodeConditionBase
    {
        public override string Title => "AND";

        protected override void CreateDefaultPins()
        {   
            CreateInputPin("A");
            CreateInputPin("B");
            
            CreateOutputPin("");
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Condition\MarkerGenRuleNodeConditionScript.cs:
 using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Nodes.Condition
{
    public class MarkerGenRuleNodeConditionScript : MarkerGenRuleGraphNodeConditionBase
    {
        public string scriptClassName;

        public override string Title
        {
            get
            {
                string displayName = GetDisplayName();
                if (string.IsNullOrEmpty(displayName))
                {
                    displayName = "<NONE>";
                }
                return "Script: " + displayName;
            }
        }
        protected override void CreateDefaultPins()
        {
            CreateOutputPin("");
        }

        private System.Type cachedType = null;
        private string cachedTypeText = null;
        
        private string GetDisplayName()
        {
            if (string.IsNullOrEmpty(scriptClassName))
            {
                return "";
            }

            if (cachedType == null || cachedTypeText != scriptClassName)
            {
                cachedTypeText = scriptClassName;
                cachedType = System.Type.GetType(scriptClassName);
            }

            return cachedType == null ? "" : cachedType.Name;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Condition\MarkerGenRuleNodeMarkerExists.cs:
 using DungeonArchitect.Graphs;

namespace DungeonArchitect.MarkerGenerator.Nodes.Condition
{
    public class MarkerGenRuleNodeMarkerExists : MarkerGenRuleGraphNodeConditionBase
    {
        public string markerName = "";
        public override string Title => "Marker Exists: " + (string.IsNullOrEmpty(markerName) ? "<NONE>" : markerName);
        protected override void CreateDefaultPins()
        {
            CreateOutputPin("");
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Condition\MarkerGenRuleNodeNot.cs:
 using DungeonArchitect.Graphs;

namespace DungeonArchitect.MarkerGenerator.Nodes.Condition
{
    public class MarkerGenRuleNodeNot : MarkerGenRuleGraphNodeConditionBase
    {
        public override string Title => "NOT";

        protected override void CreateDefaultPins()
        {
            CreateInputPin("");
            CreateOutputPin("");
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Condition\MarkerGenRuleNodeOr.cs:
 using DungeonArchitect.Graphs;

namespace DungeonArchitect.MarkerGenerator.Nodes.Condition
{
    public class MarkerGenRuleNodeOr : MarkerGenRuleGraphNodeConditionBase
    {
        public override string Title => "OR";

        protected override void CreateDefaultPins()
        {
            CreateInputPin("A");
            CreateInputPin("B");
            
            CreateOutputPin("");
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Condition\MarkerGenRuleNodeResult.cs:
 using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator.Pins;
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Nodes.Condition
{
    public class MarkerGenRuleNodeResult : MarkerGenRuleGraphNodeConditionBase
    {
        public override Color BodyColor => new Color(0.3f, 0.1f, 0.1f);
        public override Color TitleColor => new Color(0.4f, 0.1f, 0.1f);
        
        public override string Title => "Should Select?";

        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);

            canBeDeleted = false;
        }

        protected override void CreateDefaultPins()
        {
            CreateInputPin("Result");
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\Lib\FlowLayoutPathing.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Pathing
{
    public interface IFlowLayoutNodeCreationConstraint
    {
        bool CanCreateNodeAt(FlowLayoutGraphNode node, int totalPathLength, int currentPathPosition);
    }

    public class NullFlowLayoutNodeCreationConstraint : IFlowLayoutNodeCreationConstraint
    {
        public bool CanCreateNodeAt(FlowLayoutGraphNode node, int totalPathLength, int currentPathPosition)
        {
            return true;
        }
    }
    
    public class FlowLayoutStaticGrowthState {
        public FlowLayoutGraph Graph;
        public FlowLayoutGraphQuery GraphQuery;
        public FlowLayoutGraphNode HeadNode = null;
        public List<FlowLayoutGraphNode> SinkNodes = new List<FlowLayoutGraphNode>();
        public System.Random Random;
        public int MinPathSize;
        public int MaxPathSize;
        public Color NodeColor;
        public string PathName;
        public string StartNodePathNameOverride = "";
        public string EndNodePathNameOverride = "";
        public IFlowLayoutGraphConstraints GraphConstraint;
        public FlowLayoutNodeGroupGenerator NodeGroupGenerator;
        public IFlowLayoutNodeCreationConstraint NodeCreationConstraint;
    };

    public class FlowLayoutGrowthStatePathItem {
        public DungeonUID NodeId;
        public DungeonUID PreviousNodeId;
        public object userdata;

        public FlowLayoutGrowthStatePathItem Clone()
        {
            var clone = new FlowLayoutGrowthStatePathItem();
            clone.NodeId = NodeId;
            clone.PreviousNodeId = PreviousNodeId;
            clone.userdata = userdata;  // TODO: clone?
            return clone;
        }
    };

    public enum EFlowLayoutGrowthErrorType
    {
        None,
        GraphConstraint,
        NodeConstraint,
        EmptyNodeGroup,
        CannotMerge,
    }
    
    public class FlowLayoutGrowthState {
        public List<FlowLayoutGrowthStatePathItem> Path = new List<FlowLayoutGrowthStatePathItem>();
        public HashSet<DungeonUID> Visited = new HashSet<DungeonUID>();
        public List<FlowLayoutGraphNodeGroup> NodeGroups = new List<FlowLayoutGraphNodeGroup>();
        public FlowLayoutGraphNode TailNode = null;

        public FlowLayoutGrowthState Clone()
        {
            var clone = new FlowLayoutGrowthState();
            clone.Visited = new HashSet<DungeonUID>(Visited);
            clone.TailNode = TailNode;
            
            foreach (var path in Path)
            {
                clone.Path.Add(path.Clone());
            }
            
            foreach (var group in NodeGroups)
            {
                clone.NodeGroups.Add(group.Clone());
            }
            
            return clone;
        }
    };

    public class FlowLayoutSharedGrowthState
    {
        public FFAGConstraintsLink LinkFromHead;
        public FFAGConstraintsLink LinkToTail;
        public EFlowLayoutGrowthErrorType LastError = EFlowLayoutGrowthErrorType.None;
    }

    class FlowLayoutGraphPathUtils {
    
        //static bool GrowPath(const UFlowAbstractNode* CurrentNode, const FFlowAGStaticGrowthState& StaticState, FFlowAGGrowthState& OutState);
        public static void FinalizePath(FlowLayoutStaticGrowthState staticState, FlowLayoutSharedGrowthState sharedState, FlowLayoutGrowthState state)
        {
            var path = state.Path;

            if (path.Count == 0) {
                return;
            }
            
            // Create merged node groups
            foreach (var groupInfo in state.NodeGroups) {
                CreateMergedCompositeNode(staticState.Graph, staticState.GraphQuery, groupInfo);
            }
            staticState.GraphQuery.Rebuild();
            
            FlowLayoutGraph graph = staticState.GraphQuery.GetGraph();
            var childToParentMap = new Dictionary<DungeonUID, DungeonUID>(); // [ChildNodeId -> ParentNodeId]
            foreach (var parentNode in graph.Nodes) {
                if (parentNode.MergedCompositeNodes.Count > 1) {
                    foreach (var childNode in parentNode.MergedCompositeNodes) {
                        childToParentMap[childNode.nodeId] = parentNode.nodeId;
                    }
                }
            }

            var pathLength = path.Count;
            for (int i = 0; i < pathLength; i++) {
                var pathItem = path[i];
                var origNodeId = pathItem.NodeId;
                var origPrevNodeId = pathItem.PreviousNodeId;
                if (childToParentMap.ContainsKey(pathItem.NodeId))
                {
                    pathItem.NodeId = childToParentMap[pathItem.NodeId];
                }

                if (childToParentMap.ContainsKey(pathItem.PreviousNodeId))
                {
                    pathItem.PreviousNodeId = childToParentMap[pathItem.PreviousNodeId];
                }
                
                FlowLayoutGraphNode pathNode = staticState.GraphQuery.GetNode(pathItem.NodeId);
                if (pathNode == null) continue;
                pathNode.active = true;
                pathNode.color = staticState.NodeColor;
                pathNode.pathIndex = i;
                pathNode.pathLength = pathLength;

                string pathName;
                if (i == 0 && staticState.StartNodePathNameOverride.Length > 0) {
                    pathName = staticState.StartNodePathNameOverride;
                }
                else if (i == path.Count - 1 && staticState.EndNodePathNameOverride.Length > 0) {
                    pathName = staticState.EndNodePathNameOverride;
                }
                else {
                    pathName = staticState.PathName;
                }
                pathNode.pathName = pathName;
                

                // Link the path nodes
                if (i > 0) {
                    var linkSrc = pathItem.PreviousNodeId;
                    var linkDst = pathItem.NodeId;
                    var linkSrcSub = origPrevNodeId;
                    var linkDstSub = origNodeId;
                    
                    var possibleLinks = staticState.Graph.GetLinks(linkSrc, linkDst, true);
                    foreach (var possibleLink in possibleLinks) {
                        if (possibleLink == null) continue;
                        if (possibleLink.source == linkSrc && possibleLink.destination == linkDst) {
                            bool bValid = (!possibleLink.sourceSubNode.IsValid() || possibleLink.sourceSubNode == linkSrcSub);
                            bValid &= (!possibleLink.destinationSubNode.IsValid() || possibleLink.destinationSubNode == linkDstSub);

                            // Found the correct link
                            if (bValid) {
                                possibleLink.state.type = FlowLayoutGraphLinkType.Connected;
                                break;
                            }
                        }
                        else if (possibleLink.source == linkDst && possibleLink.destination == linkSrc) {
                            bool bValid = (!possibleLink.sourceSubNode.IsValid() || possibleLink.sourceSubNode == linkDstSub);
                            bValid &= (!possibleLink.destinationSubNode.IsValid() || possibleLink.destinationSubNode == linkSrcSub);

                            // Found the correct link
                            if (bValid) {
                                possibleLink.state.type = FlowLayoutGraphLinkType.Connected;
                                possibleLink.ReverseDirection();
                                break;
                            }
                        }
                    }
                }
            }

            // Setup the start / end links
            if (staticState.HeadNode != null)
            {
                Debug.Assert(sharedState.LinkFromHead != null);
                var linkSrc = sharedState.LinkFromHead.IncomingNode.nodeId;
                var linkDst = sharedState.LinkFromHead.Node.nodeId;
                
                FlowLayoutGraphLink headLink = null;
                bool reverse = false;
                foreach (var link in staticState.Graph.Links)
                {
                    if ((link.source == linkSrc || link.sourceSubNode == linkSrc) &&
                        (link.destination == linkDst || link.destinationSubNode == linkDst))
                    {
                        headLink = link;
                        break;
                    }
                    
                    if ((link.source == linkDst || link.sourceSubNode == linkDst) &&
                        (link.destination == linkSrc || link.destinationSubNode == linkSrc))
                    {
                        headLink = link;
                        reverse = true;
                        break;
                    }

                }

                if (headLink != null)
                {
                    headLink.state.type = FlowLayoutGraphLinkType.Connected;
                    if (reverse)
                    {
                        headLink.ReverseDirection();
                    }
                }
            }

            // Find the end node, if any so that it can merge back to the specified branch (specified in variable EndOnPath)
            if (state.TailNode != null) {
                Debug.Assert(sharedState.LinkToTail != null);
                var linkSrc = sharedState.LinkToTail.IncomingNode.nodeId;
                var linkDst = sharedState.LinkToTail.Node.nodeId;
                
                FlowLayoutGraphLink tailLink = null;
                bool reverse = false;
                foreach (var link in staticState.Graph.Links)
                {
                    if ((link.source == linkSrc || link.sourceSubNode == linkSrc) &&
                        (link.destination == linkDst || link.destinationSubNode == linkDst))
                    {
                        tailLink = link;
                        break;
                    }
                    
                    if ((link.source == linkDst || link.sourceSubNode == linkDst) &&
                        (link.destination == linkSrc || link.destinationSubNode == linkSrc))
                    {
                        tailLink = link;
                        reverse = true;
                        break;
                    }

                }

                if (tailLink != null)
                {
                    tailLink.state.type = FlowLayoutGraphLinkType.Connected;
                    if (reverse)
                    {
                        tailLink.ReverseDirection();
                    }
                }
            }
        }
        
        static FlowLayoutGraphNode CreateMergedCompositeNode(FlowLayoutGraph graph, FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNodeGroup nodeGroup)
        {
            if (nodeGroup.GroupNodes.Count <= 1) {
                return null;
            }
    
            var subNodes = new HashSet<FlowLayoutGraphNode>();
            var subNodeIds = new HashSet<DungeonUID>();
            var subItems = new HashSet<FlowItem>();

            var previewLocation = Vector3.zero;
            var coord = Vector3.zero;
            foreach (var subNodeId in nodeGroup.GroupNodes) {
                FlowLayoutGraphNode subNode = graphQuery.GetNode(subNodeId);
                if (subNode == null) continue;
                subNodes.Add(subNode);
                subNodeIds.Add(subNodeId);
                foreach (var item in subNode.items)
                {
                    subItems.Add(item);
                }
                coord += subNode.coord;
                previewLocation += subNode.position;
            }
            var numSubNodes = subNodes.Count;
            if (numSubNodes > 0) {
                coord /= numSubNodes;
                previewLocation /= numSubNodes;

                FlowLayoutGraphNode newNode = graph.CreateNode();
                newNode.active = true;
                newNode.items = new List<FlowItem>(subItems);
                newNode.coord = coord;
                newNode.position = previewLocation;
                newNode.MergedCompositeNodes = new List<FlowLayoutGraphNode>(subNodes);

                // Remove all the sub nodes from the graph 
                foreach (FlowLayoutGraphNode subNode in subNodes) {
                    graph.Nodes.Remove(subNode);
                }

                foreach (FlowLayoutGraphLink link in graph.Links) {
                    if (subNodeIds.Contains(link.source)) {
                        link.sourceSubNode = link.source;
                        link.source = newNode.nodeId;
                    }
                    if (subNodeIds.Contains(link.destination)) {
                        link.destinationSubNode = link.destination;
                        link.destination = newNode.nodeId;
                    }
                }

                var filteredLinks = new List<FlowLayoutGraphLink>();
                foreach (var link in graph.Links)
                {
                    if (link.source != link.destination)
                    {
                        filteredLinks.Add(link);
                    }
                }

                graph.Links = filteredLinks;
                return newNode;
            }

            return null;
        }
    };

    public class FlowLayoutPathNodeGroup 
    {
        public bool IsGroup = false;
        public float Weight = 1.0f;
        public List<DungeonUID> GroupNodes = new List<DungeonUID>();        // The list of nodes that belong to this node
        public List<DungeonUID> GroupEdgeNodes = new List<DungeonUID>();     // The list of nodes on the edge of the group (so they can connect to other nodes)

        public object userdata;
    };


    public abstract class FlowLayoutNodeGroupGenerator
    {
        public abstract FlowLayoutPathNodeGroup[] Generate(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode currentNode, int pathIndex, int pathLength, System.Random random, HashSet<DungeonUID> visited);
        
        public virtual int GetMinNodeGroupSize() { return 1; }
    }

    public class NullFlowLayoutNodeGroupGenerator : FlowLayoutNodeGroupGenerator
    {
        public override FlowLayoutPathNodeGroup[] Generate(FlowLayoutGraphQuery graphQuery, FlowLayoutGraphNode currentNode, int pathIndex, int pathLength, System.Random random, HashSet<DungeonUID> visited)
        {
            if (currentNode == null)
            {
                return new FlowLayoutPathNodeGroup[0];
            }

            var group = new FlowLayoutPathNodeGroup();
            group.IsGroup = false;
            group.GroupNodes.Add(currentNode.nodeId);
            group.GroupEdgeNodes.Add(currentNode.nodeId);
            return new FlowLayoutPathNodeGroup[] { group };
        }
    }
    
    class FlowLayoutPathStackFrame {
        public FlowLayoutGraphNode CurrentNode;
        public FlowLayoutGraphNode IncomingNode;
        public FlowLayoutGraphLink IncomingLink;
        public FlowLayoutGrowthState State = new FlowLayoutGrowthState();
    };

    class FFlowLayoutPathingSystemResult
    {
        public FFlowLayoutPathingSystemResult()
        {
        }

        public FFlowLayoutPathingSystemResult(FlowLayoutGrowthState state, FlowLayoutStaticGrowthState staticState, FlowLayoutSharedGrowthState sharedState)
        {
            this.State = state;
            this.StaticState = staticState;
            this.SharedState = sharedState;
        }

        public FlowLayoutGrowthState State;
        public FlowLayoutStaticGrowthState StaticState;
        public FlowLayoutSharedGrowthState SharedState;
    }
    
    class FlowPathGrowthSystem : StackSystem<FlowLayoutPathStackFrame, FlowLayoutStaticGrowthState, FlowLayoutSharedGrowthState, FFlowLayoutPathingSystemResult>
    {
        public FlowPathGrowthSystem(FlowLayoutStaticGrowthState staticState) : base(staticState)
        {
        }
    }

    /**
     * Maintains a list of growth systems and runs them in parallel till the first solution is found.
     * This also avoids a single solution from getting stuck and taking a very long time,
     * as multiple paths are being explored at the same time
    */
    class FFlowAgPathingSystem
    {
        public bool FoundResult
        {
            get => foundResult;
        }

        public bool Timeout
        {
            get => timeout;
        }

        public FFlowLayoutPathingSystemResult Result
        {
            get => result;
        }

        public FFlowAgPathingSystem(long maxFramesToProcess)
        {
            this.maxFramesToProcess = maxFramesToProcess;
        }

        public void RegisterGrowthSystem(FlowLayoutGraphNode startNode, FlowLayoutStaticGrowthState staticState, int count = 1)
        {
            Debug.Assert(count > 0);

            for (int i = 0; i < count; i++)
            {
                var initFrame = new FlowLayoutPathStackFrame();
                initFrame.CurrentNode = startNode;
                initFrame.IncomingNode = null;
                var growthSystem = new FlowPathGrowthSystem(staticState);
                growthSystem.Initialize(initFrame);
                growthSystems.Add(growthSystem);
            }
        }

        public void Execute(int numParallelSearches)
        {
            numParallelSearches = Mathf.Max(numParallelSearches, 1);

            frameCounter = 0;
            for (int i = 0; i < growthSystems.Count; i += numParallelSearches)
            {
                var startIdx = i;
                var endIdx = Mathf.Min(i + numParallelSearches - 1, growthSystems.Count - 1);
                ExecuteImpl(startIdx, endIdx);

                if (foundResult || timeout)
                {
                    break;
                }
            }
        }

        public EFlowLayoutGrowthErrorType GetLastError()
        {
            foreach (var growthSystem in growthSystems)
            {
                if (growthSystem != null && growthSystem.SharedState.LastError != EFlowLayoutGrowthErrorType.None)
                {
                    return growthSystem.SharedState.LastError;
                }
            }

            return EFlowLayoutGrowthErrorType.None;
        }
        
        private void ExecuteImpl(int startIdx, int endIdx)
        {
            bool running = true;
            while (running && !timeout && !foundResult)
            {
                running = false;
                for (int i = startIdx; i <= endIdx; i++)
                {
                    var growthSystem = growthSystems[i];
                    if (growthSystem.Running)
                    {
                        growthSystem.ExecuteStep(FlowLayoutPathStackGrowthTask.Execute);

                        running |= growthSystem.Running;
                        if (growthSystem.FoundResult)
                        {
                            foundResult = true;
                            result = growthSystem.Result;
                            break;
                        }

                        frameCounter++;
                        if (frameCounter >= maxFramesToProcess)
                        {
                            timeout = true;
                            break;
                        }
                    }
                }
            }
        }


        private List<FlowPathGrowthSystem> growthSystems = new List<FlowPathGrowthSystem>();
        private bool foundResult = false;
        private bool timeout = false;
        private long frameCounter = 0;
        private long maxFramesToProcess = 0;
        private FFlowLayoutPathingSystemResult result;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tasks\Lib\FlowLayoutPathTask.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Pathing
{
    class FlowLayoutPathStackGrowthTask
    {
        public static void Execute(FlowLayoutPathStackFrame frameState, FlowLayoutStaticGrowthState staticState, FlowLayoutSharedGrowthState sharedState,
                StackSystem<FlowLayoutPathStackFrame, FlowLayoutStaticGrowthState, FlowLayoutSharedGrowthState, FFlowLayoutPathingSystemResult> stackSystem)
        {
            Debug.Assert(staticState.MinPathSize > 0 && staticState.MaxPathSize > 0);
            Debug.Assert(staticState.GraphQuery != null);

            var state = frameState.State;
            var currentNode = frameState.CurrentNode;
            var incomingNode = frameState.IncomingNode;

            var pathIndex = state.Path.Count;
            var pathLength = Mathf.Clamp(pathIndex + 1, staticState.MinPathSize, staticState.MaxPathSize);
            if (pathIndex == 0 && staticState.HeadNode != null) {
                // Check if we can connect from the head node to this node
                if (!staticState.GraphConstraint.IsValid(staticState.GraphQuery, staticState.HeadNode, new FlowLayoutGraphNode[]{currentNode}))
                {
                    stackSystem.SharedState.LastError = EFlowLayoutGrowthErrorType.GraphConstraint;
                    return;
                }
            }

            if (staticState.NodeCreationConstraint != null) {
                if (!staticState.NodeCreationConstraint.CanCreateNodeAt(currentNode, pathLength, pathIndex)) {
                    stackSystem.SharedState.LastError = EFlowLayoutGrowthErrorType.NodeConstraint;
                    return;
                }
            }

            bool bFirstNodeInPath = (pathIndex == 0);

            var baseIncomingConstraintLinks = new List<FFAGConstraintsLink>();
            if (bFirstNodeInPath && staticState.HeadNode != null) {
                var headSubNode = staticState.HeadNode;
                if (staticState.HeadNode.MergedCompositeNodes.Count > 1) {
                    foreach (var graphLink in staticState.Graph.Links) {
                        if (graphLink.state.type != FlowLayoutGraphLinkType.Unconnected) continue;
                        if (graphLink.source == currentNode.nodeId && graphLink.destination == staticState.HeadNode.nodeId) {
                            headSubNode = staticState.GraphQuery.GetSubNode(graphLink.destinationSubNode);
                            Debug.Assert(headSubNode != null);
                            break;
                        }
                        else if (graphLink.source == staticState.HeadNode.nodeId && graphLink.destination == currentNode.nodeId) {
                            headSubNode = staticState.GraphQuery.GetSubNode(graphLink.sourceSubNode);
                            Debug.Assert(headSubNode != null);
                            break;
                        }
                    }
                }

                var headConnectedLink = staticState.GraphQuery.GetConnectedLink(currentNode.nodeId, headSubNode.nodeId);
                Debug.Assert(headConnectedLink != null, "Cannot find link to head node");
                
                sharedState.LinkFromHead = new FFAGConstraintsLink(currentNode, headSubNode, headConnectedLink);
                baseIncomingConstraintLinks.Add(sharedState.LinkFromHead);
            }
            if (incomingNode != null) {
                baseIncomingConstraintLinks.Add(new FFAGConstraintsLink(currentNode, incomingNode, frameState.IncomingLink));
            }

            Debug.Assert(staticState.NodeGroupGenerator != null);
            
            var sortedNodeGroups = new List<FlowLayoutPathNodeGroup>();
            {
                FlowLayoutPathNodeGroup[] possibleNodeGroupsArray = staticState.NodeGroupGenerator.Generate(staticState.GraphQuery, currentNode, pathIndex,
                    pathLength, staticState.Random, state.Visited);
                if (possibleNodeGroupsArray.Length == 0)
                {
                    stackSystem.SharedState.LastError = EFlowLayoutGrowthErrorType.EmptyNodeGroup;
                }

                var possibleNodeGroups = new List<FlowLayoutPathNodeGroup>(possibleNodeGroupsArray);
                MathUtils.Shuffle(possibleNodeGroups, staticState.Random);

                while (possibleNodeGroups.Count > 0)
                {
                    int indexToProcess = 0;
                    {
                        float maxWeight = 0;
                        foreach (var group in possibleNodeGroups)
                        {
                            maxWeight = Mathf.Max(maxWeight, group.Weight);
                        }

                        float frameSelectionWeight = staticState.Random.NextFloat() * maxWeight;
                        for (int i = 0; i < possibleNodeGroups.Count; i++)
                        {
                            if (frameSelectionWeight <= possibleNodeGroups[i].Weight)
                            {
                                indexToProcess = i;
                                break;
                            }
                        }
                    }
                    sortedNodeGroups.Add(possibleNodeGroups[indexToProcess]);
                    possibleNodeGroups.RemoveAt(indexToProcess);
                }
            }

            var framesToPush = new List<FlowLayoutPathStackFrame>();
            foreach (var growthNodeGroup in sortedNodeGroups)
            {   
                // Check if we can use this newly created group node by connecting in to it
                if (!staticState.GraphConstraint.IsValid(staticState.GraphQuery, growthNodeGroup, pathIndex, pathLength, baseIncomingConstraintLinks.ToArray()))
                {
                    stackSystem.SharedState.LastError = EFlowLayoutGrowthErrorType.GraphConstraint;
                    continue;
                }

                FlowLayoutGrowthState nextState = state.Clone();

                // Update the frame path and visited state
                foreach (var groupNode in growthNodeGroup.GroupNodes)
                {
                    nextState.Visited.Add(groupNode);
                }
                
                var pathFrame = new FlowLayoutGrowthStatePathItem();
                pathFrame.NodeId = currentNode.nodeId;
                pathFrame.PreviousNodeId = incomingNode != null ? incomingNode.nodeId : DungeonUID.Empty;
                pathFrame.userdata = growthNodeGroup.userdata;
                nextState.Path.Add(pathFrame);

                // Add path node group info
                if (growthNodeGroup.IsGroup) {
                    var nodeGroup = new FlowLayoutGraphNodeGroup();
                    nodeGroup.GroupId = DungeonUID.NewUID();
                    nodeGroup.GroupNodes = growthNodeGroup.GroupNodes;
                    nextState.NodeGroups.Add(nodeGroup);
                }

                // Check if we reached the desired path size
                if (nextState.Path.Count >= staticState.MinPathSize) {
                    // Check if we are near the sink node, if any
                    if (staticState.SinkNodes.Count == 0) {
                        // No sink nodes defined.
                        var result = new FFlowLayoutPathingSystemResult(nextState, staticState, sharedState);
                        stackSystem.FinalizeResult(result);
                        return;
                    }

                    {
                        var sinkNodeIndices = MathUtils.GetShuffledIndices(staticState.SinkNodes.Count, staticState.Random);
                        var groupEdgeNodeIndices = MathUtils.GetShuffledIndices(growthNodeGroup.GroupEdgeNodes.Count, staticState.Random);
                        foreach (var groupEdgeNodeIndex in groupEdgeNodeIndices) {
                            var groupEdgeNodeId = growthNodeGroup.GroupEdgeNodes[groupEdgeNodeIndex];
                            DungeonUID[] connectedNodeIds;
                            FlowLayoutGraphLink[] connectedLinks;
                            staticState.GraphQuery.GetConnectedNodes(groupEdgeNodeId, out connectedNodeIds, out connectedLinks);
                            
                            var connectedNodeIndices = MathUtils.GetShuffledIndices(connectedNodeIds.Length, staticState.Random);
                            foreach (var connectedNodeIndex in connectedNodeIndices) {
                                var connectedNodeId = connectedNodeIds[connectedNodeIndex];
                                var connectedLink = connectedLinks[connectedNodeIndex];
                                var connectedNode = staticState.GraphQuery.GetNode(connectedNodeId);
                                foreach (var sinkNodeIndex in sinkNodeIndices) {
                                    var sinkNode = staticState.SinkNodes[sinkNodeIndex];
                                    if (sinkNode == null) continue;

                                    if (nextState.Path.Count == 1 && sinkNode == staticState.HeadNode) {
                                        // If the path node size is 1, we don't want to connect back to the head node
                                        continue;
                                    }
                                    
                                    if (connectedNode == sinkNode) {
                                        var groupEdgeNode = staticState.GraphQuery.GetNode(groupEdgeNodeId);
                                        // TODO: Iterate through the edge nodes and check if we can connect to the tail node
                                        var incomingConstraintLinks = new List<FFAGConstraintsLink>(baseIncomingConstraintLinks);
                                        var connectedSubNode = connectedNode;
                                        if (connectedNode.MergedCompositeNodes.Count > 1) {
                                            foreach (var graphLink in staticState.Graph.Links) {
                                                if (graphLink.state.type != FlowLayoutGraphLinkType.Unconnected) continue;
                                                if (graphLink.source == groupEdgeNodeId && graphLink.destination == connectedNodeId) {
                                                    connectedSubNode = staticState.GraphQuery.GetSubNode(graphLink.destinationSubNode);
                                                    Debug.Assert(connectedSubNode != null);
                                                    break;
                                                }
                                                else if (graphLink.source == connectedNodeId && graphLink.destination == groupEdgeNodeId) {
                                                    connectedSubNode = staticState.GraphQuery.GetSubNode(graphLink.sourceSubNode);
                                                    Debug.Assert(connectedSubNode != null);
                                                    break;
                                                }
                                            }
                                        }
                                        
                                        sharedState.LinkToTail = new FFAGConstraintsLink(connectedSubNode, groupEdgeNode, connectedLink);
                                        incomingConstraintLinks.Add(sharedState.LinkToTail);
                                        if (!staticState.GraphConstraint.IsValid(
                                            staticState.GraphQuery, growthNodeGroup, pathIndex, pathLength, incomingConstraintLinks.ToArray()))
                                        {
                                            continue;
                                        }

                                        var sinkIncomingNodes = new List<FlowLayoutGraphNode>() { groupEdgeNode };
                                        if (sinkNode == staticState.HeadNode) {
                                            // The sink and the head are the same. Add the first node to the connected list
                                            var firstNodeInPath = staticState.GraphQuery.GetNode(nextState.Path[0].NodeId);
                                            if (firstNodeInPath != null) {
                                                sinkIncomingNodes.Add(firstNodeInPath);
                                            }
                                        }

                                        if (!staticState.GraphConstraint.IsValid(staticState.GraphQuery, sinkNode, sinkIncomingNodes.ToArray()))
                                            continue;

                                        nextState.TailNode = sinkNode;
                                        stackSystem.FinalizeResult(new FFlowLayoutPathingSystemResult(nextState, staticState, sharedState));
                                        return;
                                    }
                                }
                            }
                        }
                    }

                    if (nextState.Path.Count == staticState.MaxPathSize) {
                        // no sink nodes nearby and we've reached the max path size
                        stackSystem.SharedState.LastError = EFlowLayoutGrowthErrorType.CannotMerge;
                        return;
                    }
                }


                // Try to grow from each outgoing node
                {
                    var groupEdgeNodeIndices = MathUtils.GetShuffledIndices(growthNodeGroup.GroupEdgeNodes.Count, staticState.Random);
                    foreach (var groupEdgeNodeIndex in groupEdgeNodeIndices) {
                        var groupEdgeNodeId = growthNodeGroup.GroupEdgeNodes[groupEdgeNodeIndex];
                        DungeonUID[] connectedNodeIds;
                        FlowLayoutGraphLink[] connectedLinks;
                        staticState.GraphQuery.GetConnectedNodes(groupEdgeNodeId, out connectedNodeIds, out connectedLinks);
                        var connectedNodeIndices = MathUtils.GetShuffledIndices(connectedNodeIds.Length, staticState.Random);
                        foreach (var connectedNodeIndex in connectedNodeIndices) {
                            var connectedNodeId = connectedNodeIds[connectedNodeIndex];
                            if (nextState.Visited.Contains(connectedNodeId)) continue;

                            var connectedNode = staticState.GraphQuery.GetNode(connectedNodeId);
                            if (connectedNode == null) continue;
                            if (connectedNode.active) continue;
                            
                            var connectedLink = connectedLinks[connectedNodeIndex];
                            var groupEdgeNode = staticState.GraphQuery.GetNode(groupEdgeNodeId);
                            var incomingConstraintLinks = new List<FFAGConstraintsLink>(baseIncomingConstraintLinks);
                            incomingConstraintLinks.Add(new FFAGConstraintsLink(groupEdgeNode, connectedNode, connectedLink));
                            if (!staticState.GraphConstraint.IsValid(staticState.GraphQuery, growthNodeGroup, pathIndex, pathLength, incomingConstraintLinks.ToArray())) {
                                continue;
                            }

                            var nextFrame = new FlowLayoutPathStackFrame();
                            nextFrame.State = nextState;
                            nextFrame.CurrentNode = connectedNode;
                            nextFrame.IncomingNode = groupEdgeNode;
                            nextFrame.IncomingLink = connectedLink;
                            framesToPush.Add(nextFrame);
                        }
                    }
                }
            }
            
            // Push in reverse order since this is a stack, so that our sort order works correctly
            framesToPush.Reverse();
            foreach (var frame in framesToPush)
            {
                stackSystem.PushFrame(frame);
            }
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid2D\FlowLayoutToolGraph2D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D
{
    public class FlowLayoutToolGraph2D : Graph
    {
        public override void OnEnable()
        {
            base.OnEnable();

            hideFlags = HideFlags.HideInHierarchy;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid2D\FlowLayoutToolGraph2DBuilder.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.Graphs;
using DungeonArchitect.Utils;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D
{
    public class FlowLayoutToolGraph2DBuilder
    {
        public static void Build(FlowLayoutGraph layoutGraph, GraphBuilder graphBuilder)
        {
            if (graphBuilder == null)
            {
                return;
            }

            graphBuilder.DestroyAllNodes();

            if (layoutGraph == null)
            {
                return;
            }

            // Create the nodes
            var runtimeToPreviewMap = new Dictionary<DungeonUID, FlowLayoutToolGraph2DNode>();
            foreach (var runtimeNode in layoutGraph.Nodes)
            {
                var previewNode = graphBuilder.CreateNode<FlowLayoutToolGraph2DNode>();
                if (previewNode != null)
                {
                    previewNode.LayoutNode = runtimeNode;
                    previewNode.Position = runtimeNode.position;
                    runtimeToPreviewMap.Add(runtimeNode.nodeId, previewNode);
                }
            }

            foreach (var link in layoutGraph.Links)
            {
                var startNode = runtimeToPreviewMap[link.source];
                var endNode = runtimeToPreviewMap[link.destination];

                if (startNode != null && endNode != null)
                {
                    var outputPin = startNode.OutputPin;
                    var inputPin = endNode.InputPin;

                    if (outputPin != null && inputPin != null)
                    {
                        var previewLink = graphBuilder.LinkNodes<FlowLayoutToolGraph2DLink>(startNode.OutputPin, endNode.OutputPin);
                        previewLink.layoutLinkState = link.state;
                    }
                }

            }
        }
    }


    public class FlowLayoutToolGraph2DUtils
    {
        public static FlowItem[] GetAllItems(FlowLayoutToolGraph2D graph)
        {
            var items = new List<FlowItem>();
            foreach (var node in graph.Nodes)
            {
                var previewNode = node as FlowLayoutToolGraph2DNode;
                if (previewNode != null)
                {
                    foreach (var item in previewNode.LayoutNode.items)
                    {
                        if (item != null)
                        {
                            items.Add(item);
                        }
                    }
                }
            }

            foreach (var link in graph.Links)
            {
                var previewLink = link as FlowLayoutToolGraph2DLink;
                if (previewLink != null)
                {
                    foreach (var item in previewLink.layoutLinkState.items)
                    {
                        if (item != null)
                        {
                            items.Add(item);
                        }
                    }
                }
            }

            return items.ToArray();
        }

    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid2D\FlowLayoutToolGraph2DLink.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D
{
    public class FlowLayoutToolGraph2DLink : GraphLink
    {
        public FlowLayoutGraphLinkState layoutLinkState;
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid2D\FlowLayoutToolGraph2DNode.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D
{
    public class FlowLayoutToolGraph2DNode : GraphNode
    {
        public FlowLayoutGraphNode LayoutNode { get; set; }

        public override void Initialize(string id, Graph graph)
        {
            base.Initialize(id, graph);
            Size = new Vector2(54, 54);

            var pinPosition = Size * 0.5f;
            // Create an input pin on the top
            CreatePinOfType<FlowLayoutToolGraph2DNodePin>(GraphPinType.Input,
                        pinPosition,
                        Rect.zero,
                        new Vector2(0, -1));

            // Create an output pin at the bottom
            CreatePinOfType<FlowLayoutToolGraph2DNodePin>(GraphPinType.Output,
                        pinPosition,
                        Rect.zero,
                        new Vector2(0, -1));

        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid2D\FlowLayoutToolGraph2DNodePin.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Graphs;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph2D
{
    public class FlowLayoutToolGraph2DNodePin : GraphPin
    {
        public Vector2 Padding = new Vector2(0, 0);

        public override bool ContainsPoint(Vector2 worldPoint)
        {
            if (PinType == GraphPinType.Input)
            {
                // We don't want the user to touch this pin.  Our logic will connect output-output pins correctly
                return false;
            }

            if (base.ContainsPoint(worldPoint))
            {
                // Make sure it is not inside the body
                var bodyBounds = Node.Bounds;
                bodyBounds.position += Padding;
                bodyBounds.size -= Padding * 2;

                // make sure it is not inside the body
                return !bodyBounds.Contains(worldPoint);
            }
            return false;
        }
    }
}
 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid3D\FlowLayoutToolGraph3D.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.UI.Widgets;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D
{
    public class FlowLayout3DRenderSettings
    {
        public FlowLayout3DRenderSettings(float nodeRadius)
        { 
            NodeRadius = nodeRadius;
            InactiveNodeRadius = NodeRadius * 0.2f;
            ItemRadius = NodeRadius * 0.4f;
            LinkThickness = NodeRadius * 0.2f;
            
        }
        public float NodeRadius { get; private set; } = 0.5f;
        public float InactiveNodeRadius { get; private set; } = 0.1f;
        public float ItemRadius { get; private set; }  = 0.2f;
        public float LinkThickness { get; private set; }  = 0.10f;
    }
    
    class FlowLayout3DConstants
    {
        public static readonly Color InactiveNodeColor = new Color(0, 0, 0, 0.05f);
        public static readonly Color LinkColor = new Color(0, 0, 0, 0.9f);
        public static readonly Color LinkOneWayColor = new Color(1, 0.2f, 0, 0.9f);
        public static readonly Color LinkItemRefColor = new Color(1, 0, 0, 0.9f);
        public static readonly float LinkHeadThicknessMultiplier = 4.0f;
        public static readonly float ItemNodeScaleMultiplier = 0.3f;   
    }

    public class FlowLayoutToolGraph3D : SxViewportWidget
    {
        private FlowLayout3DRenderSettings renderSettings = new FlowLayout3DRenderSettings(0.5f); 
        
        public void RecenterView()
        {   
            var activePoints = new List<Vector3>();
            var inactivePoints = new List<Vector3>();

            var nodeActors = World.GetActorsOfType<SxLayoutNodeActor>();
            foreach (var nodeActor in nodeActors)
            {
                if (nodeActor == null) continue;
                if (nodeActor.LayoutNode.active)
                {
                    activePoints.Add(nodeActor.Position);
                    foreach (var subNode in nodeActor.LayoutNode.MergedCompositeNodes)
                    {
                        activePoints.Add(subNode.position);
                    }
                }
                else
                {
                    inactivePoints.Add(nodeActor.Position);
                }
            }

            if (activePoints.Count > 0)
            {
                FocusCameraOnPoints(activePoints.ToArray(), renderSettings.NodeRadius);
            }
            else if (inactivePoints.Count > 0)
            {
                FocusCameraOnPoints(inactivePoints.ToArray(), renderSettings.NodeRadius);
            }
            else
            {
                ResetCamera(false);
            }
        }
        
        public void Build(FlowLayoutGraph graph)
        {
            SxLayout3DWorldBuilder.Build(World, graph);
            renderStateInvalidated = true;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid3D\FlowLayoutToolGraphRendering.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.Flow.Items;
using DungeonArchitect.SxEngine;
using DungeonArchitect.SxEngine.Utils;
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D
{
    public class SxLayout3DWorldBuilder
    {
        public class BuildSettings
        {
            public SxMaterial NodeMaterial;
            public SxMaterial SubNodeMaterial;
            public SxMaterial MergedNodeMaterial;
            public SxMaterial ItemMaterial;

            private BuildSettings()
            {
            }

            public static BuildSettings Create()
            {
                var settings = new BuildSettings();
                settings.NodeMaterial = SxMaterialRegistry.Get<SxFlowNodeMaterial>();
                settings.SubNodeMaterial = SxMaterialRegistry.Get<SxFlowSubNodeMaterial>();
                settings.MergedNodeMaterial = SxMaterialRegistry.Get<SxFlowMergedNodeMaterial>();
                settings.ItemMaterial = SxMaterialRegistry.Get<SxFlowItemMaterial>();
                return settings;
            }
        }

        public static void Build(SxWorld world, FlowLayoutGraph graph)
        {
            Build(world, graph, BuildSettings.Create(), new FlowLayout3DRenderSettings(0.5f));
        }
        
        public static void Build(SxWorld world, FlowLayoutGraph graph, BuildSettings buildSettings, FlowLayout3DRenderSettings renderSettings) 
        {
            world.Clear();
            
            // build a grid
            {
                var gridMesh = world.SpawnActor<SxMeshActor>(true);
                gridMesh.SetMesh(SxMeshUtils.CreateGridMesh(10, 1.0f));
                gridMesh.SetMaterial<SxGridMaterial>();
            }

            if (graph == null)
            {
                return;
            }

            var graphQuery = new FlowLayoutGraphQuery(graph);
            
            // Build the node actors
            var nodeActors = new Dictionary<DungeonUID, SxLayoutNodeActor>();
            foreach (var layoutNode in graph.Nodes)
            {
                var nodeActor = world.SpawnActor<SxLayoutNodeActor>(true);
                
                var settings = new SxLayoutNodeActor.NodeRenderSettings();
                settings.Position = layoutNode.position;
                settings.NodeRadius = layoutNode.active ? renderSettings.NodeRadius : renderSettings.InactiveNodeRadius;
                settings.Color = layoutNode.active ? layoutNode.color : FlowLayout3DConstants.InactiveNodeColor;
                settings.Material = buildSettings.NodeMaterial;
                nodeActor.Initialize(settings);
                nodeActor.LayoutNode = layoutNode;

                nodeActors[layoutNode.nodeId] = nodeActor;
            }
            
            // Draw the merged node visuals
            foreach (var node in graph.Nodes)
            {
                if (node.MergedCompositeNodes.Count <= 1) continue;

                var bounds = new Bounds(node.position, Vector3.zero);
                foreach (var subNode in node.MergedCompositeNodes)
                {
                    bounds.Encapsulate(subNode.position);
                    
                    // Draw the sub node
                    var subNodeActor = world.SpawnActor<SxLayoutNodeActor>(true);
                    var settings = new SxLayoutNodeActor.NodeRenderSettings();
                    settings.Position = subNode.position;
                    settings.NodeRadius = renderSettings.InactiveNodeRadius;
                    settings.Color = new Color(0, 0, 0, 0.75f);
                    settings.Material = buildSettings.SubNodeMaterial;
                    subNodeActor.Initialize(settings);
                    subNodeActor.LayoutNode = subNode;

                    nodeActors[subNode.nodeId] = subNodeActor;
                }

                bounds.extents += Vector3.one * renderSettings.NodeRadius;

                {
                    var cubeActor = world.SpawnActor<SxLayoutMergedNodeActor>(true);
                    var settings = new SxLayoutMergedNodeActor.RenderSettings();
                    settings.Color = node.color;
                    settings.Bounds = bounds;
                    settings.Material = buildSettings.MergedNodeMaterial;
                    cubeActor.Initialize(settings);
                }
            }

            // Build the link actors
            var linkActors = new Dictionary<DungeonUID, SxLayoutLinkActor>();
            foreach (var link in graph.Links)
            {
                if (link.state.type == FlowLayoutGraphLinkType.Unconnected)
                {
                    continue;
                }

                var startNode = link.sourceSubNode.IsValid() ? graphQuery.GetSubNode(link.sourceSubNode) : graphQuery.GetNode(link.source);
                var endNode = link.destinationSubNode.IsValid() ? graphQuery.GetSubNode(link.destinationSubNode) : graphQuery.GetNode(link.destination);
                if (startNode == null || endNode == null)
                {
                    continue;
                }
                
                SxLayoutNodeActor startNodeActor = nodeActors.ContainsKey(startNode.nodeId) ? nodeActors[startNode.nodeId] : null;
                SxLayoutNodeActor endNodeActor = nodeActors.ContainsKey(endNode.nodeId) ? nodeActors[endNode.nodeId] : null;
                if (startNodeActor != null && endNodeActor != null)
                {
                    var linkActor = world.SpawnActor<SxLayoutLinkActor>(true);
                    bool oneWay = (link.state.type == FlowLayoutGraphLinkType.OneWay);
                    var settings = new SxLayoutLinkActor.LinkRenderSettings();
                    settings.StartNode = startNodeActor;
                    settings.EndNode = endNodeActor;
                    settings.StartRadius = renderSettings.NodeRadius;
                    settings.EndRadius = renderSettings.NodeRadius;
                    settings.OneWay = oneWay;
                    settings.Color = oneWay ? FlowLayout3DConstants.LinkOneWayColor : FlowLayout3DConstants.LinkColor;
                    settings.Thickness = renderSettings.LinkThickness;
                    linkActor.Initialize(settings);
                    linkActor.Link = link;

                    linkActors[link.linkId] = linkActor;
                }
            }
            
            var itemActors = new Dictionary<DungeonUID, SxLayoutItemActor>();
            // Build the node item actors
            foreach (var layoutNode in graph.Nodes)
            {
                if (!layoutNode.active || !nodeActors.ContainsKey(layoutNode.nodeId)) continue;
                
                var nodeActor = nodeActors[layoutNode.nodeId];
                if (nodeActor == null) continue;

                var nodeItems = layoutNode.items;
                float itemCount = nodeItems.Count;
                for (var i = 0; i < nodeItems.Count; i++)
                {
                    var item = nodeItems[i];
                    var angle = 2.0f * Mathf.PI / itemCount * i;
                    var offset = 1 - FlowLayout3DConstants.ItemNodeScaleMultiplier - 0.05f;
                    var x = Mathf.Cos(angle) * offset;
                    var y = Mathf.Sin(angle) * offset;
                    var itemActor = world.SpawnActor<SxLayoutItemActor>(false);

                    Color colorBackground;
                    Color colorText;
                    
                    FlowItemUtils.GetFlowItemColor(item, out colorBackground, out colorText);
                    var itemText = FlowItemUtils.GetFlowItemText(item);
                    
                    var offsetZSign = -1;
                    
                    var settings = new SxLayoutNodeActor.NodeRenderSettings();
                    settings.Position = new Vector3(x, y, -0.05f * offsetZSign);
                    settings.NodeRadius = FlowLayout3DConstants.ItemNodeScaleMultiplier;
                    settings.Color = colorBackground;
                    settings.Material = buildSettings.ItemMaterial;
                    settings.Text = itemText;
                    settings.TextColor = colorText;
                    settings.TextScale = 1.5f;
                    settings.TextDepthBias = -1;
                    
                    itemActor.Initialize(settings);
                    itemActor.Item = item;
                    itemActor.AlignToCamera = false;
                    
                    nodeActor.AddChild(itemActor);
                    
                    itemActors[item.itemId] = itemActor;
                }
            }
            
            // Build the link item actors
            foreach (var link in graph.Links)
            {
                if (link.state.type == FlowLayoutGraphLinkType.Unconnected)
                {
                    continue;
                }

                if (!linkActors.ContainsKey(link.linkId))
                {
                    continue;
                }

                var linkActor = linkActors[link.linkId];
                if (linkActor == null || linkActor.StartActor == null || linkActor.EndActor == null)
                {
                    continue;
                }

                var startPosition = linkActor.StartActor.Position;
                var endPosition = linkActor.EndActor.Position;
                var center = (startPosition + endPosition) * 0.5f;
                var direction = (endPosition - startPosition).normalized;

                var linkItems = link.state.items;
                for (var i = 0; i < linkItems.Count; i++)
                {
                    var item = linkItems[i];
                    
                    var angle = Mathf.PI * 0.5f + 2.0f * Mathf.PI / linkItems.Count * i;
                    var distance = renderSettings.ItemRadius * 1.5f;
                    var x = Mathf.Cos(angle) * distance;
                    var z = Mathf.Sin(angle) * distance;

                    var rotation = Quaternion.FromToRotation(Vector3.up, direction);
                    var offset = rotation * new Vector3(x, 0, z);
                    var position = center + offset;
                 
                    var itemActor = world.SpawnActor<SxLayoutItemActor>(true);

                    Color colorBackground;
                    Color colorText;
                    
                    FlowItemUtils.GetFlowItemColor(item, out colorBackground, out colorText);
                    var itemText = FlowItemUtils.GetFlowItemText(item);
                    
                    var settings = new SxLayoutNodeActor.NodeRenderSettings();
                    settings.Position = position;
                    settings.NodeRadius = renderSettings.NodeRadius * FlowLayout3DConstants.ItemNodeScaleMultiplier;
                    settings.Color = colorBackground;
                    settings.Material = buildSettings.ItemMaterial;
                    settings.Text = itemText;
                    settings.TextColor = colorText;
                    settings.TextScale = 1.5f;
                    settings.TextDepthBias = -2f;
                    
                    itemActor.Initialize(settings);
                    itemActor.Item = item;
                    
                    itemActors[item.itemId] = itemActor;
                }
            }
            
            // Link the referenced items
            var allItems = new List<FlowItem>();
            foreach (var layoutNode in graph.Nodes)
            {
                allItems.AddRange(layoutNode.items);
            }
            foreach (var item in allItems)
            {
                if (!itemActors.ContainsKey(item.itemId)) continue;
                var itemActor = itemActors[item.itemId];
                foreach (var referencedItemId in item.referencedItemIds)
                {
                    if (!itemActors.ContainsKey(referencedItemId)) continue;
                    var referencedItem = itemActors[referencedItemId];

                    SxLayoutItemActor startNodeActor = itemActor;
                    SxLayoutItemActor endNodeActor = referencedItem;
                    
                    var linkActor = world.SpawnActor<SxLayoutLinkActor>(true);
                    var settings = new SxLayoutLinkActor.LinkRenderSettings();
                    settings.StartNode = startNodeActor;
                    settings.EndNode = endNodeActor;
                    settings.StartRadius = renderSettings.ItemRadius;
                    settings.EndRadius = renderSettings.ItemRadius;
                    settings.OneWay = false;
                    settings.Color = FlowLayout3DConstants.LinkItemRefColor;
                    settings.Thickness = renderSettings.LinkThickness * 0.5f;
                    linkActor.Initialize(settings);
                    linkActor.FixPositionEveryFrame = true;
                }
            }
        }
    }
    
    public class SxLayoutLinkActor : SxMeshActor
    {
        public FlowLayoutGraphLink Link;
        public bool FixPositionEveryFrame = false;
        private LinkRenderSettings settings = new LinkRenderSettings();
        private SxMeshActor headActor;

        public SxActor StartActor
        {
            get => settings.StartNode;
        }
        
        public SxActor EndActor
        {
            get => settings.EndNode;
        }
        
        public LinkRenderSettings Settings
        {
            get => settings;
        }

        public struct LinkRenderSettings
        {
            public SxActor StartNode;
            public float StartRadius;
            public SxActor EndNode;
            public float EndRadius;
            public bool OneWay;
            public Color Color;
            public float Thickness;
        }

        public void Initialize(LinkRenderSettings settings)
        {
            this.settings = settings;
            
            RemoveAllChildren();
            SetMesh(new SxQuadMesh(settings.Color));
            SetMaterial<SxFlowLinkMaterial>();
            
            headActor = World.SpawnActor<SxMeshActor>(false);
            AddChild(headActor);

            if (settings.OneWay)
            {
                headActor.SetMaterial<SxFlowLinkOneWayHeadMaterial>();
            }
            else
            {
                headActor.SetMaterial<SxFlowLinkHeadMaterial>();
            }
            headActor.SetMesh(new SxQuadMesh(settings.Color));

            OrientLinkToNodes();
        }
        
        public override void Tick(SxRenderContext context, float deltaTime)
        {
            base.Tick(context, deltaTime);

            if (FixPositionEveryFrame)
            {
                OrientLinkToNodes();
            }
            
            OrientLinkToCamera(context.CameraPosition);
        }

        void OrientLinkToNodes()
        {
            var headThickness = settings.Thickness * FlowLayout3DConstants.LinkHeadThicknessMultiplier;
            float headLength = headThickness;
            float headWidth = headThickness;
            if (settings.OneWay)
            {
                headLength *= 2;
            }

            var startTransform = SxSceneGraphUtils.AccumulateTransforms(settings.StartNode);
            var endTransform = SxSceneGraphUtils.AccumulateTransforms(settings.EndNode);

            var start = Matrix.GetTranslation(ref startTransform);
            var end = Matrix.GetTranslation(ref endTransform);

            var direction = (end - start).normalized;
            start = start + direction * settings.StartRadius;
            end = end - direction * (settings.EndRadius + headLength);

            var length = (end - start).magnitude;
            
            Rotation = Quaternion.FromToRotation(new Vector3(1, 0, 0), direction);
            Position = start + (end - start) * 0.5f;
            Scale = new Vector3(length / 2.0f, settings.Thickness / 2.0f, 1);

            {
                var headScale = Vector3.Scale(Vector3.one / 2.0f, new Vector3(headLength, headWidth, 1));
                headScale = MathUtils.Divide(headScale, Scale);
                headActor.Scale = headScale;
                headActor.Position = MathUtils.Divide(new Vector3(length * 0.5f + headLength * 0.5f, 0, 0), Scale);
            }
        }

        void OrientLinkToCamera(Vector3 cameraPosition)
        {
            if (settings.StartNode != null && settings.EndNode != null)
            {
                var startTransform = SxSceneGraphUtils.AccumulateTransforms(settings.StartNode);
                var endTransform = SxSceneGraphUtils.AccumulateTransforms(settings.EndNode);

                var start = Matrix.GetTranslation(ref startTransform);
                var end = Matrix.GetTranslation(ref endTransform);
                
                var length = (end - start).magnitude;
                var axisX = (end - start) / length;
                var axisZ = (cameraPosition - Position).normalized;
                var axisY = Vector3.Cross(axisZ, axisX);
                axisZ = Vector3.Cross(axisX, axisY);

                var rotationMatrix = new Matrix4x4(axisX, axisY, axisZ, new Vector4(0, 0, 0, 1));
                Rotation = rotationMatrix.rotation;
            }
        }
    }

    public class SxLayoutNodeActor : SxLayoutNodeActorBase
    {
        public FlowLayoutGraphNode LayoutNode;
    }
    
    public class SxLayoutItemActor : SxLayoutNodeActorBase
    {
        public FlowItem Item;
    }

    public class SxLayoutMergedNodePlaneActor : SxMeshActor
    {
        public void Initialize(Color color, SxMaterial material)
        {
            SetMesh(new SxQuadMesh(color));
            SetMaterial(material);
        }
    }
    
    public class SxLayoutMergedNodeActor : SxActor
    {
        public struct RenderSettings
        {
            public Bounds Bounds;
            public Color Color;
            public SxMaterial Material;
        }

        struct PlaneTransform
        {
            public Vector3 position;
            public Quaternion rotation;

            public PlaneTransform(Vector3 position, Quaternion rotation)
            {
                this.position = position;
                this.rotation = rotation;
            }
        }

        public void Initialize(RenderSettings settings)
        {
            var planeOffsets = new Vector3[]
            {
                new Vector3(1, 0, 0),
                new Vector3(-1, 0, 0),
                new Vector3(0, 0, 1),
                new Vector3(0, 0, -1),
                new Vector3(0, 1, 0),
                new Vector3(0, -1, 0)
            };

            var quadForward = new Vector3(0, 0, -1);
            foreach (var offset in planeOffsets)
            {
                var side = World.SpawnActor<SxLayoutMergedNodePlaneActor>(false);
                side.Initialize(settings.Color, settings.Material);
                side.Position = offset;
                side.Rotation = Quaternion.FromToRotation(quadForward, offset);
                AddChild(side);    
            }
            
            Scale = settings.Bounds.extents;
            Position = settings.Bounds.center;
        }
    }
    
    public abstract class SxLayoutNodeActorBase : SxMeshActor
    {
        public struct NodeRenderSettings
        {
            public float NodeRadius;
            public Vector3 Position;
            public Color Color;
            public SxMaterial Material;
            public string Text;
            public Color TextColor;
            public float TextScale;
            public float TextDepthBias;
        }
        
        public bool AlignToCamera { get; set; } = true;
        private NodeRenderSettings settings;

        public void Initialize(NodeRenderSettings settings)
        {
            this.settings = settings;
            Position = settings.Position;
            var color = settings.Color;
            var scaleF = settings.NodeRadius;
            
            Scale = new Vector3(scaleF, scaleF, scaleF);
            SetMesh(new SxQuadMesh(color));
            SetMaterial(settings.Material);

            if (settings.Text != null)
            {
                var textActor = World.SpawnActor<SxTextActor>(false);
                var textSettings = new SxTextComponentSettings()
                {
                    Font = Layout3DGraphRenderingResource.GetFont(),
                    Color = settings.TextColor,
                    Scale = settings.TextScale,
                    HAlign = SxTextHAlign.Center,
                    VAlign = SxTextVAlign.Center,
                    DepthBias = settings.TextDepthBias,
                };
                
                textActor.TextComponent.Initialize(textSettings);
                textActor.TextComponent.SetText(settings.Text);

                textActor.Position = new Vector3(0, 0, 0.1f);
                textActor.Rotation = Quaternion.AngleAxis(180, Vector3.up);
                AddChild(textActor);
            }
        }

        public override void Tick(SxRenderContext context, float deltaTime)
        {
            base.Tick(context, deltaTime);
            if (AlignToCamera)
            {
                // Align the quad to camera
                var axisZ = (context.CameraPosition - Position).normalized;
                var axisX = Vector3.Cross(Vector3.up, axisZ);
                var axisY = Vector3.Cross(axisZ, axisX);

                var rotationMatrix = new Matrix4x4(axisX, axisY, axisZ, new Vector4(0, 0, 0, 1));
                Rotation = rotationMatrix.rotation;
            }
        }
    }
    
    class Layout3DGraphRenderingResource
    {
        private static Font font;

        public static Font GetFont()
        {
            if (font == null)
            {
                font = Resources.Load<Font>("ConsolasBold");
            }
            
            return font;
        }
    }
    
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid3D\FlowLayoutToolMaterials.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.SxEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D
{
    public class SxFlowNodeMaterial : SxUnityResourceMaterial
    {
        public SxFlowNodeMaterial() : base("FlowNodeMaterial") {}
    }
    
    public class SxFlowSubNodeMaterial : SxUnityResourceMaterial
    {
        public SxFlowSubNodeMaterial() : base("FlowNodeMaterial")
        {
        }
    }
    
    public class SxFlowMergedNodeMaterial : SxUnityResourceMaterial
    {
        public SxFlowMergedNodeMaterial() : base("FlowMergedNodeMaterial")
        {
            DepthBias = -2;
        }
    }
    
    public class SxFlowMergedNodeMaterialZWrite : SxUnityResourceMaterial
    {
        public SxFlowMergedNodeMaterialZWrite() : base("FlowMergedNodeMaterial_ZWrite")
        {
            DepthBias = -2;
        }
    }
    
    public class SxFlowItemMaterial : SxUnityResourceMaterial
    {
        public SxFlowItemMaterial() : base("FlowItemMaterial")
        {
            DepthBias = -0.25f;
        }
    }

    public class SxFlowItemMaterialZWrite : SxUnityResourceMaterial
    {
        public SxFlowItemMaterialZWrite() : base("FlowItemMaterial_ZWrite")
        {
            DepthBias = -0.25f;
        }
    }
    public class SxFlowLinkMaterial : SxUnityResourceMaterial
    {
        public SxFlowLinkMaterial() : base("FlowLinkMaterial") {}
    }
    
    public class SxFlowLinkHeadMaterial : SxUnityResourceMaterial
    {
        public SxFlowLinkHeadMaterial() : base("FlowLinkHeadMaterial") {}
    }
    
    public class SxFlowLinkOneWayHeadMaterial : SxUnityResourceMaterial
    {
        public SxFlowLinkOneWayHeadMaterial() : base("FlowLinkOneWayMaterial") {}
    }
    
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Actions\Info\ActionGraphCompiler.cs:
 using System.Collections.Generic;
using System.Linq;
using DungeonArchitect.Graphs;
using DungeonArchitect.MarkerGenerator.Pins;
using DungeonArchitect.MarkerGenerator.Rule;

namespace DungeonArchitect.MarkerGenerator.Nodes.Actions.Info
{
    public static class ActionGraphCompiler
    {
        public static void Compile(MarkerGenRuleGraph ruleGraph, MarkerGenRuleActionList actions)
        {
            if (ruleGraph == null || actions == null)
            {
                return;
            }
            
            actions.Clear();
            var actionsInfoList = new List<MarkerGenRuleActionInfo>();

            var visited = new HashSet<MarkerGenRuleGraphNodeActionBase>();
            var outgoingPins = BuildOutgoingPinMap(ruleGraph);
            var node = GetOutgoingNode(ruleGraph.passNode, outgoingPins);
            while (node != null && !visited.Contains(node))
            {
                var actionInfo = node.CreateActionInfo();
                if (actionInfo != null)
                {
                    actionsInfoList.Add(actionInfo);
                }
                visited.Add(node);
                node = GetOutgoingNode(node, outgoingPins);
            }

            actions.actionList = actionsInfoList.ToArray();
            
            foreach (var actionInfo in actions.actionList)
            {
                if (actionInfo is MarkerGenRuleActionInfoAddMarker)
                {
                    actions.hints.emitsMarker = true;
                }
            }
        }

        private static MarkerGenRuleGraphNodeActionBase GetOutgoingNode(MarkerGenRuleGraphNodeActionBase node, Dictionary<GraphPin, GraphPin> outgoingPins)
        {
            var outputPin = node.OutputPin;
            if (!outgoingPins.ContainsKey(outputPin))
            {
                return null;
            }

            var linkedToPin = outgoingPins[outputPin];
            return linkedToPin.Node as MarkerGenRuleGraphNodeActionBase;
        }
        
        
        private static Dictionary<GraphPin, GraphPin> BuildOutgoingPinMap(Graph graph)
        {
            var outgoingPins = new Dictionary<GraphPin, GraphPin>();
            foreach (var link in graph.Links)
            {
                var input = link.Input as MarkerGenRuleGraphPin;
                var output = link.Output as MarkerGenRuleGraphPin;
                if (input == null || output == null) continue;
                
                outgoingPins[output] = input;
            }

            return outgoingPins;
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Actions\Info\MarkerGenRuleActionInfo.cs:
 using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Nodes.Actions.Info
{
    public class MarkerGenRuleActionInfo : ScriptableObject
    {
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Actions\Info\MarkerGenRuleActionInfoAddMarker.cs:
 
using UnityEngine;

namespace DungeonArchitect.MarkerGenerator.Nodes.Actions.Info
{
    public class MarkerGenRuleActionInfoAddMarker : MarkerGenRuleActionInfo
    {
        public string markerName = "";
        public string[] copyRotationFromMarkers;
        public string[] copyHeightFromMarkers;
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Core\Frameworks\MarkerGenerator\Graph\Nodes\Actions\Info\MarkerGenRuleActionInfoRemoveMarker.cs:
 
namespace DungeonArchitect.MarkerGenerator.Nodes.Actions.Info
{
    public class MarkerGenRuleActionInfoRemoveMarker : MarkerGenRuleActionInfo
    {
        public string markerName = "";
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid3D\UnityRenderer\FlowLayoutCamAlignerBase.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D
{
    [ExecuteInEditMode]
    public abstract class FlowLayoutCamAlignerBase : MonoBehaviour
    {
        void OnDrawGizmos()
        {
            AlignToCam();
        }
        
        void OnDrawGizmosSelected()
        {
            AlignToCam();
        }

        public void AlignToCam()
        {
            var cameraPosition = GetCameraPosition();
            AlignToCamImpl(cameraPosition);
        }

        void Update()
        {
            if (Application.isPlaying)
            {
                AlignToCam();
            }
        }

        protected Vector3 GetCameraPosition()
        {
            
            if (Application.isPlaying)
            {
                if (Camera.main != null)
                {
                    return Camera.main.transform.position;
                }
            }
            else
            {
#if UNITY_EDITOR
                var sceneView = UnityEditor.SceneView.lastActiveSceneView;
                if (sceneView != null && sceneView.camera != null)
                {
                    return sceneView.camera.transform.position;
                }
#endif // UNITY_EDITOR
            }

            return Vector3.zero;
        }
        
        protected abstract void AlignToCamImpl(Vector3 cameraPosition);
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid3D\UnityRenderer\FlowLayoutLinkCamAligner.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using DungeonArchitect.Utils;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D
{
    [ExecuteInEditMode]
    public class FlowLayoutLinkCamAligner : FlowLayoutCamAlignerBase
    {
        public Transform startTransform;
        public Transform endTransform;

        public float thickness;
        public float startRadius;
        public float endRadius;
        public bool oneWay;
        

        protected override void AlignToCamImpl(Vector3 cameraPosition)
        {
            if (startTransform == null || endTransform == null) return;
            OrientLinkToNodes();

            var axisX = (endTransform.position - startTransform.position).normalized;
            var axisZ = (cameraPosition - transform.position).normalized;
            var axisY = Vector3.Cross(axisZ, axisX);
            axisZ = Vector3.Cross(axisX, axisY);
            
            var rotationMatrix = new Matrix4x4(axisX, axisY, axisZ, new Vector4(0, 0, 0, 1));
            transform.rotation = rotationMatrix.rotation;
        }
        
        void OrientLinkToNodes()
        {
            var headThickness = thickness * FlowLayout3DConstants.LinkHeadThicknessMultiplier;
            float headLength = headThickness;
            float headWidth = headThickness;
            if (oneWay)
            {
                headLength *= 2;
            }

            var start = startTransform.position;
            var end = endTransform.position;

            var direction = (end - start).normalized;
            start = start + direction * startRadius;
            end = end - direction * (endRadius + headLength);

            var length = (end - start).magnitude;
            
            transform.rotation = Quaternion.FromToRotation(new Vector3(1, 0, 0), direction);
            transform.position = start + (end - start) * 0.5f;
            var scale = new Vector3(length / 2.0f, thickness / 2.0f, 1);
            transform.localScale = scale;

            if (transform.childCount > 0)
            {
                var headTransform = transform.GetChild(0);
                var headScale = Vector3.Scale(Vector3.one / 2.0f, new Vector3(headLength, headWidth, 1));
                headScale = MathUtils.Divide(headScale, scale);
                headTransform.localScale = headScale;
                headTransform.localPosition = MathUtils.Divide(new Vector3(length * 0.5f + headLength * 0.5f, 0, 0), scale);
            }
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid3D\UnityRenderer\FlowLayoutNodeCamAligner.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D
{
    public class FlowLayoutNodeCamAligner : FlowLayoutCamAlignerBase
    {
        protected override void AlignToCamImpl(Vector3 cameraPosition)
        {
            var direction = (cameraPosition - transform.position).normalized;
            transform.rotation = Quaternion.LookRotation(direction, Vector3.up);
        }
    }
} 

// Assets\CodeRespawn\DungeonArchitect\Scripts\Modules\Flow\Domains\LayoutGraph\Tooling\Grid3D\UnityRenderer\FlowLayoutToolUnityRenderer.cs:
 //$ Copyright 2015-22, Code Respawn Technologies Pvt Ltd - All Rights Reserved $//
using System.Collections.Generic;
using DungeonArchitect.SxEngine;
using UnityEngine;

namespace DungeonArchitect.Flow.Domains.Layout.Tooling.Graph3D
{

    [System.Serializable]
    class FlowLayoutGraphUnityVisualizerObject
    {
        [SerializeField]
        public GameObject gameObject;
        
        [SerializeField]
        private MeshFilter meshFilter;

        [SerializeField]
        private MeshRenderer meshRenderer;

        public void Build(SxRenderCommand command, Transform parent, ISxSceneNode node)
        {
            Destroy();

            gameObject = new GameObject();
            gameObject.transform.parent = parent;
            gameObject.transform.localPosition = node.WorldTransform.Positon;
            gameObject.transform.localRotation = node.WorldTransform.Rotation;
            gameObject.transform.localScale = node.WorldTransform.Scale;

            if (command == null || command.Mesh == null) return;
            var material = command.Material != null ? command.Material.UnityMaterial : null;
            if (command.Material == null) return;

            meshFilter = gameObject.AddComponent<MeshFilter>();
            meshRenderer = gameObject.AddComponent<MeshRenderer>();

            var mesh = new Mesh();
            meshFilter.sharedMesh = mesh;
            meshRenderer.sharedMaterial = material;

            var vertices = new List<Vector3>();
            var uvs = new List<Vector2>();
            var colors = new List<Color>();
            var normals = new List<Vector3>();
            var triangles = new List<int>();

            foreach (var sectionEntry in command.Mesh.Sections)
            {
                var section = sectionEntry.Value;
                if (section == null || section.Vertices.Length == 0) continue;

                if (section.DrawMode != GL.QUADS) continue;

                for (var i = 0; i + 3 < section.Vertices.Length; i += 4)
                {
                    var baseIndex = vertices.Count;
                    var p0 = section.Vertices[i + 0];
                    var p1 = section.Vertices[i + 1];
                    var p2 = section.Vertices[i + 2];
                    var p3 = section.Vertices[i + 3];

                    var quad = new SxMeshVertex[] {p0, p1, p2, p3};
                    foreach (var vert in quad)
                    {
                        var worldPosition = vert.Position;
                        vertices.Add(worldPosition);
                        uvs.Add(vert.UV0);
                        colors.Add(vert.Color);
                    }

                    triangles.Add(baseIndex + 0);
                    triangles.Add(baseIndex + 1);
                    triangles.Add(baseIndex + 2);

                    triangles.Add(baseIndex + 0);
                    triangles.Add(baseIndex + 2);
                    triangles.Add(baseIndex + 3);
                }
            }

            mesh.vertices = vertices.ToArray();
            mesh.uv = uvs.ToArray();
            mesh.colors = colors.ToArray();
            mesh.normals = normals.ToArray();
            mesh.triangles = triangles.ToArray();
        }

        public void Destroy()
        {
            // Destroy, if already created
            if (gameObject != null)
            {
                DungeonUtils.DestroyObject(gameObject);
            }

            meshFilter = null;
            meshRenderer = null;
            gameObject = null;
        }
    }
    
    public class FlowLayoutGraphUnityVisualizer
    {
        private List<FlowLayoutGraphUnityVisualizerObject> subObjects = new List<FlowLayoutGraphUnityVisualizerObject>();
        
        public GameObject Build(SxWorld world) 
        {
            var gameObject = new GameObject("SnapGridFlowDebugVisualizer");

            var context = new SxRenderContext();
            var nodeTransforms = new Dictionary<ISxSceneNode, Transform>();
            BuildRecursive(context, world.RootNode, gameObject.transform, Matrix4x4.identity, new HashSet<ISxSceneNode>(), 0, nodeTransforms);

            return gameObject;
        }
        
        void BuildRecursive(SxRenderContext context, ISxSceneNode node, Transform parent, Matrix4x4 incomingWorldTransform, HashSet<ISxSceneNode> visited, int depth, Dictionary<ISxSceneNode, Transform> nodeTransforms)
        {
            if (visited.Contains(node))
            {
                return;
            }

            visited.Add(node);

            var accumulatedWorldTransform = incomingWorldTransform * node.WorldTransform.Matrix;

            var renderCommandList = new SxRenderCommandList();
            node.Draw(context, accumulatedWorldTransform, renderCommandList);
            
            // Build the game object
            var subObject = new FlowLayoutGraphUnityVisualizerObject();
            var renderCommand = renderCommandList.Commands.Length == 1 ? renderCommandList.Commands[0] : null; 
            subObject.Build(renderCommand, parent, node);
            subObject.gameObject.transform.parent = parent;
            nodeTransforms.Add(node, subObject.gameObject.transform);

            var camAligners = new List<FlowLayoutCamAlignerBase>();
            
            if (node is SxLayoutNodeActor)
            {
                var camAligner = subObject.gameObject.AddComponent<FlowLayoutNodeCamAligner>();
                camAligners.Add(camAligner);
            }
            else if (node is SxLayoutLinkActor)
            {
                var linkActor = node as SxLayoutLinkActor;
                if (nodeTransforms.ContainsKey(linkActor.StartActor) && nodeTransforms.ContainsKey(linkActor.EndActor))
                {
                    var startTransform = nodeTransforms[linkActor.StartActor];
                    var endTransform = nodeTransforms[linkActor.EndActor];
                
                    var camAligner = subObject.gameObject.AddComponent<FlowLayoutLinkCamAligner>();
                    camAligner.startTransform = startTransform;
                    camAligner.endTransform = endTransform;
                    camAligner.thickness = linkActor.Settings.Thickness;
                    camAligner.startRadius = linkActor.Settings.StartRadius;
                    camAligner.endRadius = linkActor.Settings.EndRadius;
                    camAligner.oneWay = linkActor.Settings.OneWay;
                    camAligners.Add(camAligner);
                }
            }
            else if (node is SxLayoutItemActor && depth == 1)
            {
                var camAligner = subObject.gameObject.AddComponent<FlowLayoutNodeCamAligner>();
                camAligners.Add(camAligner);
            }
            
            
            // Iterate the children
            foreach (var childNode in node.Children)
            {
                BuildRecursive(context, childNode, subObject.gameObject.transform, accumulatedWorldTransform, visited, depth + 1, nodeTransforms);
            }
            
            foreach (var camAligner in camAligners)
            {
                camAligner.AlignToCam();
            }
        }
    }
} 



# TASK: how to generate and save node connections when dungeon is built in editor mode?