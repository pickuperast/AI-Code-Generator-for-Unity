# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
# CODE: // Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\ElectricDash.cs:
 using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using Invector;
using UnityEngine;
using FishNet.Object;
using FishNet.Connection;
using FishnetInvector;

public class ElectricDash : Ability
{
    private static readonly float DASH_DISTANCE = 10.0f;
    private static readonly float DASH_DURATION = 1.0f;
    private static readonly int DASH_STEPS = 10;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE = 10f;
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Electric;
    private readonly float DAMAGE_RADIUS = 2f;

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        if (casterComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = casterComps.HealthController.Owner;
        TargetElectricDash(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetElectricDash(NetworkConnection conn, int casterNetId)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;

        Vector3 startPosition = hero.position;
        Vector3 endPosition = startPosition + hero.forward * DASH_DISTANCE;

        ElectricDashServerRpc(startPosition, endPosition, casterNetId);
    }

    [ServerRpc(RequireOwnership = false)]
    private void ElectricDashServerRpc(Vector3 startPosition, Vector3 endPosition, int casterNetId)
    {
        StartCoroutine(PerformElectricDash(startPosition, endPosition, casterNetId));
    }

    private IEnumerator PerformElectricDash(Vector3 startPosition, Vector3 endPosition, int casterNetId)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = casterComps.InvectorManager;
        float stepDistance = DASH_DISTANCE / DASH_STEPS;
        float stepDuration = DASH_DURATION / DASH_STEPS;
        HashSet<int> damagedUnits = new HashSet<int>();

        for (int i = 0; i < DASH_STEPS; i++)
        {
            float t = (float)i / (DASH_STEPS - 1);
            Vector3 newPosition = Vector3.Lerp(startPosition, endPosition, t);
            playerFim.OwnerTeleport(newPosition);

            SpawnEffectOnObservers(newPosition, playerFim.transform.rotation);
            ApplyDamageToNearbyEnemies(newPosition, casterComps, damagedUnits);

            yield return new WaitForSeconds(stepDuration);
        }
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 position, Quaternion rotation)
    {
        var fx = _abilityDefinition.RanksDatas[0].hitEffect;
        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, position, rotation);
            Destroy(fxInstance, 1.5f);
        }
    }

    private void ApplyDamageToNearbyEnemies(Vector3 position, UnitComponents caster, HashSet<int> damagedUnits)
    {
        float damage = CalculateDamage(caster.StatsController);
        vDamage vdamage = new vDamage(damage, caster.HealthController.transform, DAMAGE_TYPE);
        vdamage.senderNetworkObjectID = caster.NetworkObject.ObjectId;

        var targets = EnemyTargetsInSphereSelection(position, caster, DAMAGE_RADIUS);
        foreach (var target in targets)
        {
            if (!damagedUnits.Contains(target.NetworkObject.ObjectId))
            {
                target.TakeDamage(vdamage);
                damagedUnits.Add(target.NetworkObject.ObjectId);
            }
        }
    }

    private float CalculateDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE + statsController.GetStatByType(AFFECTING_STAT).CurrentAmount * 0.1f;
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\ElectricDash.cs:
 using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using Invector;
using UnityEngine;
using FishNet.Object;
using FishNet.Connection;
using FishnetInvector;

public class ElectricDash : Ability
{
    private static readonly float DASH_DISTANCE = 10.0f;
    private static readonly float DASH_DURATION = 1.0f;
    private static readonly int DASH_STEPS = 10;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE = 10f;
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Electric;
    private readonly float DAMAGE_RADIUS = 2f;

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        if (casterComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = casterComps.HealthController.Owner;
        TargetElectricDash(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetElectricDash(NetworkConnection conn, int casterNetId)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;

        Vector3 startPosition = hero.position;
        Vector3 endPosition = startPosition + hero.forward * DASH_DISTANCE;

        ElectricDashServerRpc(startPosition, endPosition, casterNetId);
    }

    [ServerRpc(RequireOwnership = false)]
    private void ElectricDashServerRpc(Vector3 startPosition, Vector3 endPosition, int casterNetId)
    {
        StartCoroutine(PerformElectricDash(startPosition, endPosition, casterNetId));
    }

    private IEnumerator PerformElectricDash(Vector3 startPosition, Vector3 endPosition, int casterNetId)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = casterComps.InvectorManager;
        float stepDistance = DASH_DISTANCE / DASH_STEPS;
        float stepDuration = DASH_DURATION / DASH_STEPS;
        HashSet<int> damagedUnits = new HashSet<int>();

        for (int i = 0; i < DASH_STEPS; i++)
        {
            float t = (float)i / (DASH_STEPS - 1);
            Vector3 newPosition = Vector3.Lerp(startPosition, endPosition, t);
            playerFim.OwnerTeleport(newPosition);

            SpawnEffectOnObservers(newPosition, playerFim.transform.rotation);
            ApplyDamageToNearbyEnemies(newPosition, casterComps, damagedUnits);

            yield return new WaitForSeconds(stepDuration);
        }
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 position, Quaternion rotation)
    {
        var fx = _abilityDefinition.RanksDatas[0].hitEffect;
        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, position, rotation);
            Destroy(fxInstance, 1.5f);
        }
    }

    private void ApplyDamageToNearbyEnemies(Vector3 position, UnitComponents caster, HashSet<int> damagedUnits)
    {
        float damage = CalculateDamage(caster.StatsController);
        vDamage vdamage = new vDamage(damage, caster.HealthController.transform, DAMAGE_TYPE);
        vdamage.senderNetworkObjectID = caster.NetworkObject.ObjectId;

        var targets = EnemyTargetsInSphereSelection(position, caster, DAMAGE_RADIUS);
        foreach (var target in targets)
        {
            if (!damagedUnits.Contains(target.NetworkObject.ObjectId))
            {
                target.TakeDamage(vdamage);
                damagedUnits.Add(target.NetworkObject.ObjectId);
            }
        }
    }

    private float CalculateDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE + statsController.GetStatByType(AFFECTING_STAT).CurrentAmount * 0.1f;
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Blink.cs:
 using System.Collections;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

public class Blink : Ability
{
    private static float BLINK_DISTANCE = 8.0f;

    public override IEnumerator Activate(AbilityCastingData data) 
    {
        Debug.Log("Blink ability activated.");

        var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if(unitComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = unitComps.HealthController.Owner;
        TargetBlinkForward(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetBlinkForward(NetworkConnection conn, int casterNetId) 
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("[Blink][TargetBlinkForward]");

        RaycastHit hit;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;
        
        //get desired position with same y + forward + distance
        var lookRotation = Quaternion.LookRotation(hero.forward);
        sb.Append($" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}");
        Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f);
        sb.Append($" rotationNormalized: {rotationNormalized}; ");
        
        Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE;
        sb.Append($" destination: {destination}; ");

        var defaultLayerMask = LayerMask.GetMask("Default");
        if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask))
        {
            destination = hero.position + hero.forward * (hit.distance-.5f);
        }

        // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) 
        // {
        //     destination = hit.point;
        //     destination.y += .5f;
        // }
        destination.y += .2f;
        if (hit.transform != null)
        {
            sb.Append($" hit: {hit.transform}, hit pos: {hit.transform.position}; ");
        }
        sb.Append($"result destination: {destination}, after pos: {transform.position}");
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        Vector3 oldPos = hero.position;
        playerFim.OwnerTeleport(destination);
        BlinkForwardServerRpc(oldPos, destination);
        Vector3 middlePoint = (oldPos + destination) / 2;
    }

    [ServerRpc(RequireOwnership = false)]
    private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) 
    {
        Debug.Log("Blink forward on server.");
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        Debug.Log($"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}");
        SpawnEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalBlinkEffect(middlePoint, directionRotation);
    }
    
    private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        Debug.Log("Spawning blink effect.");

        var fx = _abilityDefinition.RanksDatas[0].hitEffect;

        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation);
            Destroy(fxInstance, 1.5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        string mainEdited = _abilityDefinition.mainDescription;
        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Blink.cs:
 using System.Collections;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

public class Blink : Ability
{
    private static float BLINK_DISTANCE = 8.0f;

    public override IEnumerator Activate(AbilityCastingData data) 
    {
        Debug.Log("Blink ability activated.");

        var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if(unitComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = unitComps.HealthController.Owner;
        TargetBlinkForward(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetBlinkForward(NetworkConnection conn, int casterNetId) 
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("[Blink][TargetBlinkForward]");

        RaycastHit hit;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;
        
        //get desired position with same y + forward + distance
        var lookRotation = Quaternion.LookRotation(hero.forward);
        sb.Append($" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}");
        Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f);
        sb.Append($" rotationNormalized: {rotationNormalized}; ");
        
        Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE;
        sb.Append($" destination: {destination}; ");

        var defaultLayerMask = LayerMask.GetMask("Default");
        if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask))
        {
            destination = hero.position + hero.forward * (hit.distance-.5f);
        }

        // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) 
        // {
        //     destination = hit.point;
        //     destination.y += .5f;
        // }
        destination.y += .2f;
        if (hit.transform != null)
        {
            sb.Append($" hit: {hit.transform}, hit pos: {hit.transform.position}; ");
        }
        sb.Append($"result destination: {destination}, after pos: {transform.position}");
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        Vector3 oldPos = hero.position;
        playerFim.OwnerTeleport(destination);
        BlinkForwardServerRpc(oldPos, destination);
        Vector3 middlePoint = (oldPos + destination) / 2;
    }

    [ServerRpc(RequireOwnership = false)]
    private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) 
    {
        Debug.Log("Blink forward on server.");
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        Debug.Log($"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}");
        SpawnEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalBlinkEffect(middlePoint, directionRotation);
    }
    
    private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        Debug.Log("Spawning blink effect.");

        var fx = _abilityDefinition.RanksDatas[0].hitEffect;

        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation);
            Destroy(fxInstance, 1.5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        string mainEdited = _abilityDefinition.mainDescription;
        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Ability.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using DuloGames.UI;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using Invector;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class Ability: NetworkBehaviour
{
    protected int _rank;
    [SerializeField] protected AbilityDefinition _abilityDefinition;
    public Buff Buff => _buff;
    [SerializeField] protected Buff _buff;
    [SerializeField] protected bool isPassiveSkill;
    public static Dictionary<NetworkConnection, uint> StacksCounter { get; private set; } = new ();
    public static Dictionary<NetworkConnection, uint> RankCounter { get; private set; } = new ();
    public AbilityDefinition AbilityDefinition => _abilityDefinition;
    public static Action OnAbilityLearned;
    public Action<NetworkConnection, byte, uint> OnRankLevelUp;
    protected string _abilityName => _abilityDefinition.Name;
    protected GameplayManager _gameplayManager;
    protected bool _isDebug = true;
    protected readonly string COLOR_DURATION = "#00F0FF";
    protected readonly string COLOR_AFFECTING_STAT = "#00F0FF";
    protected readonly string COLOR_DAMAGE = "#ff3517";
    protected readonly string COLOR_HEAL = "#0ec949";
    protected readonly string COLOR_STAT = "#96e33d";
    protected readonly string COLOR_XP = "#c3eb34";
    protected readonly string COLOR_COOLDOWN = "#c8e609";

    protected readonly Color DEBUG_SPHERE_DEFAULT_COLOR = new Color(1f, 0f, 0f, 0.5f);
    protected readonly Color DEBUG_SPHERE_ACTIVATE_COLOR = new Color(1f, 0f, 1f, 0.5f);
    protected Color _debugSphereColor;
    protected bool _showDebugSphere;
    protected Vector3 _debugSpherePos;
    protected float _debugSphereRadius = 1f;

    public virtual void InitAbility()
    {
        if (_buff != null) 
        {
            _buff.Init(GameplayManager.Instance);
        }
        else
        {
            Debug.LogWarning($"Buff is null during ability {_abilityName} initialization.");
        }
    }

    public virtual float CalculateValueBasedOnStacks(uint stacks) => .01f;
    
    public virtual int CalculateRankBasedOnStacks(uint stacks) => 1;
    
    public virtual float CalculateDamageBasedOnRank(int rank) => 1;
    
    public virtual uint GetStacksForRank() => 1;
    
    public uint AddRank(NetworkConnection connection)
    {
        if (RankCounter.ContainsKey(connection))
        {
            RankCounter[connection]++;
        }
        else
        {
            RankCounter.Add(connection, 1);
        }
        OnRankLevelUp?.Invoke(connection, _abilityDefinition.Id, RankCounter[connection]);
        return RankCounter[connection];
    }

    public uint ServerAddStack(FNAbilityController abilityController, uint amount)
    {
        if (!abilityController.LearnedAbilityDict.ContainsKey(AbilityDefinition.Id))
        {
            Debug.LogError($"Ability {AbilityDefinition.Name} is not learned by player {abilityController.gameObject.name}. Cannot add stacks.");
            return 0;
        }
        
        AbilityInfo targetsAbilityStats = abilityController.LearnedAbilityDict[AbilityDefinition.Id];
        targetsAbilityStats.Stacks = Math.Max(0, targetsAbilityStats.Stacks + amount);
        abilityController.AddOrSetAbility(targetsAbilityStats);
        return targetsAbilityStats.Stacks;
    }
    
    public uint AddStack(NetworkConnection connection)
    {
        if (StacksCounter.ContainsKey(connection))
        {
            StacksCounter[connection]++;
        }
        else
        {
            StacksCounter.Add(connection, 1);
        }
        
        if (EnoughStacksToLevelup(connection))
        {
            StacksCounter[connection] = 0;
            AddRank(connection);
            return 1;
        }
        else
        {
            return 0;
        }
        
        return StacksCounter[connection];
    }
    
    public UISpellInfo GetUISpellInfo(byte abilityId, uint stacks)
    {
        UISpellInfo spellInfo = new UISpellInfo();
        spellInfo.ID = _abilityDefinition.Id;
        uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId);
        int abilityRankBasedOnStacks = CalculateRankBasedOnStacks(abilityStacksForPlayer);
        spellInfo.Name = GetAbilityName(abilityRankBasedOnStacks);
        spellInfo.Icon = _abilityDefinition.Icon;
        spellInfo.Description = GetAbilityDescription(abilityRankBasedOnStacks, abilityStacksForPlayer);
        if (_abilityDefinition.IsPassive)
        {
            spellInfo.Flags = UISpellInfo_Flags.Passive;
        }
        else
        {
            AbilityDefinition.RPGAbilityRankData rankData = _abilityDefinition.RanksDatas[0];

            if (rankData != null)
            {
                switch (rankData.activationType)
                {
                    case AbilityDefinition.AbilityActivationType.Instant:
                        spellInfo.Flags = UISpellInfo_Flags.InstantCast;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCircle:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCircle;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCone:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCone;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedAim:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastAim;
                        break;
                    default:
                        spellInfo.Flags = UISpellInfo_Flags.PowerCostInPct;
                        break;

                }

                spellInfo.Range = rankData.maxRange;
                spellInfo.Cooldown = rankData.cooldown;
                if (rankData.castTime > 0)
                {
                    spellInfo.CastTime = rankData.castTime;
                }
                spellInfo.PowerCost = rankData.manaCost;
            }
            else
            {
                Debug.LogError($"Ability {spellInfo.Name} does not have rank {abilityId}. Setting default values.");
            }
        }
        return spellInfo;
    }

    private bool EnoughStacksToLevelup(NetworkConnection connection)
    {
        return StacksCounter[connection] >= GetStacksForRank();
    }

    public virtual string GetAbilityName(int rank) => _abilityDefinition.Name;
    public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description;
    public virtual string GetAbilityDescription(int rank, FNStatsController statsController) => _abilityDefinition.persistDescription;
    
    public virtual float GetAbilityCastingTime(int rank, FNStatsController statsController)
    {
        float castingTime = _abilityDefinition.RanksDatas[rank].castTime;
        return castingTime;
    }

    public virtual IEnumerator Activate(AbilityCastingData data)
    {
        yield return null;
    }

    [Server]
    protected virtual void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f)
    {
        Debug.Log($"{_abilityName} Applying caster buff.");
        _buff.Activate(casterBuffData, new int[]{}, duration:duration);
    }

    protected virtual List<Collider> TargetsSelection(Transform caster) 
    {
        Debug.LogWarning($"{_abilityName} TargetsSelection method has not been implemented yet.");
        throw new NotImplementedException();
    }

    [Server]
    protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage, bool isExcludeSelf = false)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        var targets = TargetsInSphereSelection(playerComps, radius);
        for (int i = 0; i < targets.Count; i++) 
        {
            if (isExcludeSelf && targets[i] == playerComps.HealthController)
            {
                continue;
            }
            damage.receiver = targets[i].transform;
            targets[i].TakeDamage(damage);

            Debug.Log($"[{_abilityDefinition.Name}] Damage applied to {targets[i].name}");
        }
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, Buff.BuffData caster, float radius)
    {
        //Debug.Log($"{_abilityName} Selecting targets in sphere.");
        List<FishnetInvectorHealthController> targets = EnemyTargetsInRadius(pos, caster, radius);
        //Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");
        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsExcludingTagsInSphereSelection(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = TargetsInRadiusExcludingTags(tags, pos, caster, radius);
        return targets;
    }
    
    public static List<FishnetInvectorHealthController> TargetsInRadiusExcludingTags(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            for (int i = 0; i < tags.Length; i++)
            {
                if (targetNob.CompareTag(tags[i]))
                {
                    continue;
                }
            }
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            targets.Add(targetComps.HealthController);
        }
        return targets;
    }

    public static List<FishnetInvectorHealthController> EnemyTargetsInRadius(Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            Buff.BuffData targetData = new Buff.BuffData(targetComps.HealthController.ObjectId, targetComps.HealthController.gameObject.tag, 0f, caster.abilityId, 0, null, null, 0);
            if (IsNotValidTargetEnemy(caster, targetData))
                continue;
            
            targets.Add(targetComps.HealthController);
        }

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsInSphereSelection(UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var target in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(target).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNob.ObjectId);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(caster.HealthController.transform.position, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(target);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [ObserversRpc]
    protected void RpcShowEffectForObservers(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect for observers.");

        GameplayManager.Instance.StartCoroutine(ShowEffectOnTarget(targetNetId, abilityId, rank, timeout));
    }
    
    protected virtual IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if(targetComps == null)
        {
            Debug.LogError($"{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        List<GameObject> effects = new List<GameObject>(); 
        foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints)
        {
            Assert.IsNotNull(_abilityDefinition.RanksDatas[rank].hitEffect, $"Hit effect is null for {_abilityName}.");
            Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint);
            GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position + Vector3.up, Quaternion.identity, GameplayManager.Instance.transform);
            effect.transform.SetParent(pointTransform);
            effects.Add(effect);
        }

        yield return new WaitForSeconds(timeout);
        foreach (var effect in effects)
        {
            Destroy(effect, timeout);
        }
    }
    
    public static bool IsNotValidTargetEnemy(Buff.BuffData casterData, Buff.BuffData targetData)
    {
        if (casterData.ObjectId == targetData.ObjectId)
        {
            return true;
        }

        int casterTeam = GameplayManager.Instance.GetUnitTeamId(casterData.ObjectId);
        int targetTeam = GameplayManager.Instance.GetUnitTeamId(targetData.ObjectId);
        if (casterData.Tag == GameplayManager.TAG_PLAYER)
        {
            if (casterTeam == targetTeam)
            {
                return true;
            }
            return false;
        }else if (targetData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
        {
            if (casterData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
            {
                return true;
            }
            return false;
        }

        return false;
    }

    protected bool IsNotValidTargetEnemy(UnitComponents target, UnitComponents caster)
    {
        //Debug.Log($"{_abilityName} Checking if target is valid.");
        if (target == null)
            return true;
        
        if (target == caster)
        {
            //Debug.Log($"{_abilityName} Target is the same as caster. Invalid target.");
            return true;
        }

        var targetHealthController = target.HealthController;
        if (targetHealthController == null)
        {
            return true;
        }
        if (targetHealthController.CompareTag(GameplayManager.TAG_PLAYER))
        {
            //Debug.Log($"{_abilityName} Target is a player. Valid target.");
            return false;
        }else if (targetHealthController.CompareTag("Enemy"))
        {
            //Debug.Log($"{_abilityName} Target is an enemy. Valid target.");
            if (caster.HealthController.CompareTag("Enemy"))
            {
                return true;
            }
            return false;
        }

        //Debug.Log($"{_abilityName} Target does not have a Player or Enemy tag. Invalid target.");

        return false;
    }
    
    protected void DrawDebugSphere(Vector3 pos, float radius)
    {
        _debugSpherePos = pos;
        _debugSphereRadius = radius;
        _showDebugSphere = true;
        _debugSphereColor = DEBUG_SPHERE_ACTIVATE_COLOR;
        StartCoroutine(ResetDebugSphereColorAfterDelay(0.3f));
    }
    
    protected IEnumerator ResetDebugSphereColorAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        _debugSphereColor = DEBUG_SPHERE_DEFAULT_COLOR;
        _showDebugSphere = false;
    }
    
    public virtual float CalcAmount(FNStatsController statsController) {
        return 1f;
    }
    
    public virtual float CalcDuration(FNStatsController statsController) {
        return 1f;
    }
    
#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        if (_showDebugSphere)
        {
            Gizmos.color = _debugSphereColor;
            Gizmos.DrawSphere(_debugSpherePos, _debugSphereRadius);
        }
    }
#endif
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\PoisonNova.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
#endif

public class PoisonNova : Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float POISON_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_TICK = .01853143f;
    private readonly float BASE_DURATION = 5f;
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison;
    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private float GetPoisonFeildDuration()
    {
        return POISON_FIELD_DURATION;
    }    
    private float CalculateTickDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE_PER_TICK * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition);
        var healthController = casterComps.HealthController;
        NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity);
        Spawn(nps);
        RpcShowEffectForObservers(data.casterNetId, abilityId, _rank, GetPoisonFeildDuration());

        Debug.Log($"{ClassName} Activated for unit #{data.casterNetId} with abilityId #{abilityId} and rank {data.rank}");
        float currentDuration = 0f;
        float tickTime = 1f;
        float radius = 1f;
        Buff.BuffData casterData = new Buff.BuffData(data.casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, 
            CalculateTickDamage(casterComps.StatsController));

        vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE);
        Vector3 poisonCloudPos = healthController.transform.position;
        while (currentDuration < GetPoisonFeildDuration())
        {
            currentDuration += tickTime;
            InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS);
            yield return new WaitForSeconds(tickTime);
        }
        Despawn(nps);
    }
    
    
    [Server]
    private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius)
    {
        DrawDebugSphere(pos, radius);
        var caster = UnitComponentsManager.GetUnitComponentsServerAndClient(casterData.ObjectId);
        if (caster != null)
        {
            damage = UpdateDamage(ref casterData, caster);
        }
        var targets = EnemyTargetsInSphereSelection(pos, casterData, radius);
        //remove duplicates
        var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray();
        if (targetCleared.Length == 0)
        {
            //Debug.Log($"{ClassName} No targets in sphere.");
            return;
        }
        else
        {
            _buff.Activate(casterData, targetCleared, BASE_DURATION, damage);
            //Debug.Log($"[{ClassName}] Buff activated for {targetCleared.Length} targets.");
        }
    }

    private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster)
    {
        vDamage damage;
        casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null,
            CalculateTickDamage(caster.StatsController));
        damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE);
        return damage;
    }

    protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if (targetComps == null)
        {
            Debug.LogError($"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        Vector3 pos = targetComps.HealthController.transform.position;
        GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity);
        VisualEffect vfxGraph = effect.GetComponent<VisualEffect>();
        float cloudCurrentSize = vfxGraph.GetFloat("SmokeSize");
        float timeElapsed = 0f;
        while (timeElapsed < TIME_TO_REACH_END_SIZE)
        {
            cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE);
            vfxGraph.SetFloat("SmokeSize", cloudCurrentSize);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        Destroy(effect, timeout);
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }

} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\PoisonNova.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
#endif

public class PoisonNova : Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float POISON_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_TICK = .01853143f;
    private readonly float BASE_DURATION = 5f;
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison;
    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private float GetPoisonFeildDuration()
    {
        return POISON_FIELD_DURATION;
    }    
    private float CalculateTickDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE_PER_TICK * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition);
        var healthController = casterComps.HealthController;
        NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity);
        Spawn(nps);
        RpcShowEffectForObservers(data.casterNetId, abilityId, _rank, GetPoisonFeildDuration());

        Debug.Log($"{ClassName} Activated for unit #{data.casterNetId} with abilityId #{abilityId} and rank {data.rank}");
        float currentDuration = 0f;
        float tickTime = 1f;
        float radius = 1f;
        Buff.BuffData casterData = new Buff.BuffData(data.casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, 
            CalculateTickDamage(casterComps.StatsController));

        vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE);
        Vector3 poisonCloudPos = healthController.transform.position;
        while (currentDuration < GetPoisonFeildDuration())
        {
            currentDuration += tickTime;
            InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS);
            yield return new WaitForSeconds(tickTime);
        }
        Despawn(nps);
    }
    
    
    [Server]
    private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius)
    {
        DrawDebugSphere(pos, radius);
        var caster = UnitComponentsManager.GetUnitComponentsServerAndClient(casterData.ObjectId);
        if (caster != null)
        {
            damage = UpdateDamage(ref casterData, caster);
        }
        var targets = EnemyTargetsInSphereSelection(pos, casterData, radius);
        //remove duplicates
        var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray();
        if (targetCleared.Length == 0)
        {
            //Debug.Log($"{ClassName} No targets in sphere.");
            return;
        }
        else
        {
            _buff.Activate(casterData, targetCleared, BASE_DURATION, damage);
            //Debug.Log($"[{ClassName}] Buff activated for {targetCleared.Length} targets.");
        }
    }

    private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster)
    {
        vDamage damage;
        casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null,
            CalculateTickDamage(caster.StatsController));
        damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE);
        return damage;
    }

    protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if (targetComps == null)
        {
            Debug.LogError($"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        Vector3 pos = targetComps.HealthController.transform.position;
        GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity);
        VisualEffect vfxGraph = effect.GetComponent<VisualEffect>();
        float cloudCurrentSize = vfxGraph.GetFloat("SmokeSize");
        float timeElapsed = 0f;
        while (timeElapsed < TIME_TO_REACH_END_SIZE)
        {
            cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE);
            vfxGraph.SetFloat("SmokeSize", cloudCurrentSize);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        Destroy(effect, timeout);
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }

} 

// Assets\Invector-3rdPersonController\Basic Locomotion\Scripts\ObjectDamage\vDamage.cs:
 using System;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet;
using UnityEngine;
namespace Invector
{
    [System.Serializable]
    public class vDamage
    {
        [Tooltip("Apply damage to the Character Health")]
        public int damageValue = 15;
        [Tooltip("How much stamina the target will lost when blocking this attack")]
        public float staminaBlockCost = 5;
        [Tooltip("How much time the stamina of the target will wait to recovery")]
        public float staminaRecoveryDelay = 1;
        [Tooltip("Apply damage even if the Character is blocking")]
        public bool ignoreDefense;
        [Tooltip("Activated Ragdoll when hit the Character")]
        public bool activeRagdoll;
        [vHideInInspector("activeRagdoll"),Tooltip("Time to keep Ragdoll active")]
        public float senselessTime;

        [Tooltip("0 - for body, 1 - for head, 2 - for heavy")]
        public float hitHeight;
        [NonSerialized] public Transform Sender;
        public int senderNetworkObjectID;
        [NonSerialized]
        public Transform receiver;
        [HideInInspector]
        public Vector3 hitPosition = Vector3.zero;
        public bool IsCriticalDamage;
        public bool hitReaction = true;
        public bool IsShowDamage = true;
        [HideInInspector]
        public int recoil_id = 0;
        [HideInInspector]
        public int reaction_id = 0;
        public string damageType;
        public DamageType type;
        [HideInInspector] public byte SwingCounter;
        [HideInInspector] public Vector3 force;
        public int abilityId;
        public int weaponItemId;
        public enum DamageType {
            Melee,
            Arrow,
            Fire,
            Ice,
            Lightning,
            Poison,
            Bleeding,
            Magic,
            Fall,
            Shockwave,
            Explosion,
            Custom,
            Trap,
            Blood,
            Electric
        }

        public vDamage()
        {
            this.damageValue = 15;
            this.staminaBlockCost = 5;
            this.staminaRecoveryDelay = 1;
            this.hitReaction = true;
        }

        public void Copy (vDamage source)
        {
            this.damageValue = source.damageValue;
            this.hitPosition = source.hitPosition;
            this.Sender = source.Sender;
            this.senderNetworkObjectID = source.senderNetworkObjectID;
            this.staminaBlockCost = source.staminaBlockCost;
            this.staminaRecoveryDelay = source.staminaRecoveryDelay;
            this.ignoreDefense = source.ignoreDefense;
            this.reaction_id = source.reaction_id;
            this.recoil_id = source.recoil_id;
        }

        public vDamage(int value)
        {
            this.damageValue = value;
            this.hitReaction = true;
        }

        public vDamage(float value, int senderNetworkObjectID, Transform senderTrans, string damageType)
        {
            this.senderNetworkObjectID = senderNetworkObjectID;
            this.Sender = senderTrans;
            this.damageType = damageType;
            this.damageValue = (int)value;
            this.hitReaction = true;
        }

        public vDamage(int value, bool ignoreReaction)
        {
            this.damageValue = value;
            this.hitReaction = !ignoreReaction;
            if (ignoreReaction)
            {
                this.recoil_id = -1;
                this.reaction_id = -1;
            }                
        }

        public vDamage(vDamage damage)
        {
            this.damageValue = damage.damageValue;
            this.staminaBlockCost = damage.staminaBlockCost;
            this.staminaRecoveryDelay = damage.staminaRecoveryDelay;
            this.ignoreDefense = damage.ignoreDefense;
            this.activeRagdoll = damage.activeRagdoll;
            this.Sender = damage.Sender;
            this.receiver = damage.receiver;
            this.recoil_id = damage.recoil_id;
            this.reaction_id = damage.reaction_id;
            this.damageType = damage.damageType;
            this.hitPosition = damage.hitPosition;
            this.senselessTime = damage.senselessTime;
            this.force = damage.force;
            this.weaponItemId = damage.weaponItemId;
        }

        /// <summary>
        /// Calc damage Resuction percentage
        /// </summary>
        /// <param name="damageReduction"></param>
        public void ReduceDamage(float damageReduction)
        {
            int result = (int)(this.damageValue - ((this.damageValue * damageReduction) / 100));
            this.damageValue = result;
        }

        public FNvDamage ToFNvDamage()
        {
            FNvDamage damage = new FNvDamage();
            damage.damageValue = this.damageValue;
            damage.staminaBlockCost = this.staminaBlockCost;
            damage.ignoreDefense = this.ignoreDefense;
            damage.hitPosition = this.hitPosition;
            damage.force = this.force;
            damage.damageType = this.type;
            damage.senderNetworkObjectId = this.senderNetworkObjectID;
            damage.weaponItemId = this.weaponItemId;
            return damage;
        }

        public void SetDamage(float newValue)
        {
            string senderName = Sender == null ? "null" : Sender.name;
            string receiverName = receiver == null ? "null" : receiver.name;
            #if UNITY_EDITOR
            senderName = $"<color=green>{senderName}</color>";
            receiverName = $"<color=red>{receiverName}</color>";
            #endif
            Debug.Log($"[vDamage] SetDamage {senderName} {damageValue}->{newValue} {receiverName}");
            this.damageValue = (int)newValue;
        }
    }

    public class FNvDamage
    {
        public int senderNetworkObjectId;
        public int damageValue;
        public float staminaBlockCost;
        public bool ignoreDefense;
        public float hitHeight;
        public Vector3 hitPosition;
        public Vector3 force;
        public vDamage.DamageType damageType;
        public byte SwingCounter;
        public int abilityId;
        public int weaponItemId;
        
        public FNvDamage() { }
        
        public vDamage ToVDamage()
        {
            vDamage damage = new vDamage();
            if (InstanceFinder.ServerManager.Objects.Spawned.ContainsKey(senderNetworkObjectId))
                damage.Sender = InstanceFinder.ServerManager.Objects.Spawned[senderNetworkObjectId].transform;
            else
            {
                var nob = UnitComponentsManager.GetUnitComponentsServerAndClient(senderNetworkObjectId);
                if (nob == null)
                    Debug.LogError($"[vDamage] Sender with network object id {senderNetworkObjectId} not found.");
                else
                    damage.Sender = nob.HealthController.transform;
            }
            damage.damageValue = this.damageValue;
            damage.staminaBlockCost = this.staminaBlockCost;
            damage.ignoreDefense = this.ignoreDefense;
            damage.hitPosition = this.hitPosition;
            damage.force = this.force;
            damage.type = this.damageType;
            damage.senderNetworkObjectID = this.senderNetworkObjectId;
            damage.SwingCounter = SwingCounter;
            damage.abilityId = abilityId;
            damage.weaponItemId = weaponItemId;
            return damage;
        }
    }
} 



# TASK: Rework ElectricDash Move player 10 times by distance of 1 and at each point should create effect and damage enemies near that point. So in total after 1 sec player should be moved by distance of 10 in front direction