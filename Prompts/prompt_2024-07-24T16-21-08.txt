# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
# CODE: // Assets\-ZombieRoyale\Scripts\InRoomSystems\Gameplay\TorchGlobalManager.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using _ZombieRoyale.Scripts.Dungeon;
using FishNet;
using FishNet.Connection;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using Invector.vCharacterController.vActions;
using UnityEngine;

public class TorchGlobalManager : NetworkBehaviour
{
    private TorchStatus[] _torches;
    [SyncObject] private readonly SyncList<TorchStatusNetworked> _torchesNetworked = new();
    public static TorchGlobalManager Instance { get; private set; }
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    protected string _className;

    protected Dictionary<int, ObjectAction> _playerInteractingCoroutines = new();
    protected Dictionary<int, Vector3> _playerPositions = new ();
    public Action<NetworkConnection> OnLocalPlayerFinishedInteracting;
    public Action<NetworkConnection> OnPlayerFinishedInteracting;
    public Action<NetworkConnection> OnPlayerStartedInteracting;
    public Action<NetworkConnection> OnPlayerCanceledInteracting;
    public Action<NetworkConnection> OnPlayerActivatedObject;
    public Action<int, int> OnTorchInteractionFinished;

    private void Awake()
    {
        Instance = this;
        _torchesNetworked.OnChange += _torchesNetworked_OnChange;
    }
    
    public void InitForServer()
    {
        _torches = DungeonHolder.Instance.LoadTorches();
        for (int i = 0; i < _torches.Length; i++)
        {
            _torches[i].TorchController.SetId(i);
            _torches[i].TorchController.DrawTorch(false);
            _torchesNetworked.Add(new TorchStatusNetworked {torchId = i, isOn = true});
        }
        
    }

    public void InitForClient()
    {
        _torches = DungeonHolder.Instance.LoadTorches();
        for (int i = 0; i < _torches.Length; i++)
        {
            _torches[i].TorchController.SetId(i);
            _torches[i].TorchController.DrawTorch(true);
            _torches[i].TorchController.TurnOnTimedAction();
        }
    }

    [ServerRpc(RequireOwnership = false)]
    public void CmdPlayerStartedInteracting(int torchId, NetworkConnection conn = null)
    {
        Debug.Log($"{ClassName} Player started interacting with torch #{torchId} {gameObject.name}.",gameObject);
        vTriggerGenericAction triggerAction = GetTorchStatus(torchId).TorchController.TriggerGenericAction;
        _playerPositions[conn.ClientId] = UnitComponentsManager.GetPlayerHeroComponentsServerAndClient(conn).InvectorManager.transform.position;
        switch (triggerAction.inputType)
        {
            case vTriggerGenericAction.InputType.GetButtonDown:
                InternalPlayerFinishedInteracting(torchId);
                break;
            case vTriggerGenericAction.InputType.GetButtonTimer:
                AllocateObjectInteractingAction(conn.ClientId, torchId);
                break;
            case vTriggerGenericAction.InputType.GetTimerAction:
                AllocateObjectInteractingAction(conn.ClientId, torchId);
                break;
            default:
                break;
        }
        
        OnPlayerStartedInteracting?.Invoke(conn);
        var playerHero = GameplayManager.Instance.GetPlayerNob(conn);
        _playerPositions[playerHero.ObjectId] = playerHero.transform.position;
    }
    
    [Server]
    private void InternalPlayerCanceledInteracting(int clientId, int torchId)
    {
        DeallocateObjectInteractingAction(clientId);
        try
        {
            NetworkConnection conn = InstanceFinder.ServerManager.Clients[clientId];
            TargetHeroCanceledInteracting(conn, torchId);
        }catch (Exception e)
        {
            Debug.LogError($"{ClassName} InternalPlayerCanceledInteracting {e.Message}");
        }
    }

    [TargetRpc]
    private void TargetHeroCanceledInteracting(NetworkConnection conn, int torchId)
    {
        _torches[torchId].TorchController.PlayerCanceledInteracting();
    }

    [Server]
    private void InternalPlayerFinishedInteracting(int torchId)
    {
        TorchStatusNetworked torchStatus = _torchesNetworked[torchId];
        torchStatus.isOn = !_torchesNetworked[torchId].isOn;
        _torchesNetworked[torchId] = torchStatus;
    }

    public TorchStatus GetTorchStatus(int torchId)
    {
        return _torches[torchId];
    }

    private void _torchesNetworked_OnChange(SyncListOperation op, int index, TorchStatusNetworked oldItem, TorchStatusNetworked newItem, bool asServer)
    {   
        StringBuilder sb = new StringBuilder($"{ClassName} _torchesNetworked_OnChange asServer({asServer}) {op} id #{index}; ");
        if (asServer)
            return;
        
        switch (op)
        {
            case SyncListOperation.Add:
                sb.Append($"{newItem.isOn}");
                return;
            
            case SyncListOperation.Set:
                sb.Append($"{oldItem.isOn} -> {newItem.isOn}");
                _torches[index].TorchController.DrawTorch(newItem.isOn);
                break;
        }
        Debug.Log(sb.ToString());
    }

    [Server]
    protected void AllocateObjectInteractingAction(int clientId, int torchId)
    {
        if (_playerInteractingCoroutines.ContainsKey(clientId))
        {
            DeallocateObjectInteractingAction(clientId);
        }

        ObjectAction objectAction = new ObjectAction(StartCoroutine(ObjectInteractingEligibilitySwither(clientId, torchId)));
        _playerInteractingCoroutines.Add(clientId, objectAction);
    }

    [Server]
    protected void DeallocateObjectInteractingAction(int clientId)
    {
        if (_playerInteractingCoroutines.ContainsKey(clientId))
        {
            Coroutine coroutine = _playerInteractingCoroutines[clientId].ActionCoroutine;
            _playerInteractingCoroutines.Remove(clientId);
            StopCoroutine(coroutine);
        }
    }

    [Server]
    protected IEnumerator ObjectInteractingEligibilitySwither(int clientId, int torchId)
    {
        vTriggerGenericAction triggerAction = GetTorchStatus(torchId).TorchController.TriggerGenericAction;
        float time = triggerAction.buttonTimer;
        float allowedDistance = GetTorchStatus(torchId).TorchController.PlayerAllowedMoveDistance;
        float allowedDistanceSq = allowedDistance * allowedDistance;
        Vector3 interactionStartPos = _playerPositions[clientId];
        while (time > 0)
        {
            float dstSq = Vector3.SqrMagnitude(interactionStartPos - _playerPositions[clientId]);
            if (dstSq > allowedDistanceSq)
            {
                InternalPlayerCanceledInteracting(clientId, torchId);
                yield break;
            }
            time -= Time.deltaTime;
            try
            {
                NetworkConnection playerConn = InstanceFinder.ServerManager.Clients[clientId];
                _playerPositions[clientId] = UnitComponentsManager.GetPlayerHeroComponentsServerAndClient(playerConn).InvectorManager.transform.position;
            }catch (Exception e)
            {
                Debug.LogError($"{ClassName} ObjectInteractingEligibilitySwither {e.Message}");
            }
            
            yield return null;
        }
        _playerInteractingCoroutines[clientId].IsEligibleToInteract = true;
        OnTorchInteractionFinished?.Invoke(clientId, torchId);
        InternalPlayerFinishedInteracting(torchId);
        DeallocateObjectInteractingAction(clientId);
    }

    [Serializable]
    public class TorchStatus
    {
        public TorchControllerNoNetwork TorchController;
        
        public TorchStatus(TorchControllerNoNetwork torchController)
        {
            TorchController = torchController;
        }
    }

    [Serializable]
    public class TorchStatusNetworked
    {
        public int torchId;
        public bool isOn;
    }

    public class ObjectAction
    {
        public Coroutine ActionCoroutine;
        public bool IsEligibleToInteract;

        public ObjectAction(Coroutine actionCoroutine)
        {
            ActionCoroutine = actionCoroutine;
            IsEligibleToInteract = false;
        }
    }
} 

// Assets\-ZombieRoyale\Scripts\InRoomSystems\Gameplay\TorchControllerNoNetwork.cs:
 using System;
using core.client.mechanics;
using FishnetInvector;
using Invector;
using Invector.vCharacterController.vActions;
using UnityEngine;

[Serializable]
public class TorchControllerNoNetwork : MonoBehaviour
{
    public int Id { get; private set; }
    public TorchGlobalManager.TorchStatus TorchStatus { get; private set; }
    public bool IsOn { get; private set; }
    [SerializeField] private GameObject _lightFx;
    [SerializeField] private VfxGraphController _vfxFire;
    public vTriggerGenericAction TriggerGenericAction => _triggerGenericAction;
    [SerializeField] protected vTriggerGenericAction _triggerGenericAction;
    public float PlayerAllowedMoveDistance => playerAllowedMoveDistance;
    [SerializeField] private float playerAllowedMoveDistance;
    [SerializeField] private string soundNameStartInteraction;
    [SerializeField] private string soundNameSuccessfullFinishOnInteraction;
    [SerializeField] private string soundNameSuccessfullFinishOffInteraction;
    [SerializeField] private string soundNameCancelledInteraction;
    [SerializeField] private vLookAtCamera _lookAtCameraUI;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    protected string _className;
    private GameObject _localPlayer;

    protected virtual void OnValidate()
    {
        AssignComponentsIfRequired();
    }

    private void OnEnable()
    {
        AddTimedActionListeners();
    }

    private void OnDisable()
    {
        RemoveTimedActionListeners();
    }

    protected virtual void Awake()
    {
        AssignComponentsIfRequired();
    }

    public void InitForLocalPlayer(GameObject localPlayer)
    {
        _localPlayer = localPlayer;
        TriggerGenericAction.OnPlayerEnter.AddListener(OnSomePlayerEntered);
        TriggerGenericAction.OnPlayerExit.AddListener(OnSomePlayerExited);
    }

    private void OnSomePlayerExited(GameObject enteringSubject)
    {
        if (NotLocalPlayer(enteringSubject)) return;
        
        _lookAtCameraUI.gameObject.SetActive(false);
    }

    private void OnSomePlayerEntered(GameObject enteringSubject)
    {
        if (NotLocalPlayer(enteringSubject)) return;

        _lookAtCameraUI.gameObject.SetActive(true);
    }

    public void TurnOnTimedAction()
    {
        _triggerGenericAction.gameObject.SetActive(true);
    }

    private bool NotLocalPlayer(GameObject enteringSubject)
    {
        if (enteringSubject != _localPlayer)
            return false;
        
        // if (!enteringSubject.CompareTag("Player"))
        //     return true;
        //
        // if (FishnetInvectorManager.LocalPlayer.gameObject != enteringSubject)
        //     return true;
        return true;
    }


    protected void AssignComponentsIfRequired()
    {  
        if (_triggerGenericAction == null)
            _triggerGenericAction = GetComponentInChildren<vTriggerGenericAction>();

        _lookAtCameraUI ??= GetComponentInChildren<vLookAtCamera>();
    }
    
    public void SetId(int id)
    {
        Id = id;
    }
    
    public void SetTorchStatus(TorchGlobalManager.TorchStatus torchStatus)
    {
        TorchStatus = torchStatus;
    }

    public void SetVFXOnOff(bool isOn)
    {
        if (!IsOn)
            return;
        
        _vfxFire.SetActive(isOn);
    }
    
    public void SetIsOn(bool isOn)
    {
        IsOn = isOn;
        _lightFx.SetActive(IsOn);
        _vfxFire.SetActive(IsOn);
    }
    
    public void ToggleTorch()
    {
        IsOn = !IsOn;
        _lightFx.SetActive(IsOn);
        _vfxFire.SetActive(IsOn);
    }

    public void DrawTorch(bool isOn)
    {
        if (isOn)
        {
            MusicController.PlaySound(soundNameSuccessfullFinishOnInteraction, transform.position);
        }
        else
        {
            MusicController.PlaySound(soundNameSuccessfullFinishOffInteraction, transform.position);
        }
        SetIsOn(isOn);
    }
    
    protected void AddTimedActionListeners()
    {
        _triggerGenericAction.OnPressActionInput.AddListener(PlayerStartedInteracting);
        _triggerGenericAction.OnFinishActionInput.AddListener(PlayerFinishedInteracting);
        _triggerGenericAction.OnCancelActionInput.AddListener(PlayerCanceledInteracting);
    }

    protected void RemoveTimedActionListeners()
    {
        try
        {
            _triggerGenericAction.OnPressActionInput.RemoveAllListeners();
            _triggerGenericAction.OnFinishActionInput.RemoveAllListeners();
            _triggerGenericAction.OnCancelActionInput.RemoveAllListeners();
        }catch (Exception e) { }
    }

    protected void PlayerStartedInteracting()
    {
        TorchGlobalManager.Instance.CmdPlayerStartedInteracting(Id);
        switch (_triggerGenericAction.inputType)
        {
            case vTriggerGenericAction.InputType.GetButtonDown:
                
                break;
            case vTriggerGenericAction.InputType.GetButtonTimer:
                LoadingBarLogic.Instance.StartLoading(_triggerGenericAction.buttonTimer);
                break;
            case vTriggerGenericAction.InputType.GetTimerAction:
                LoadingBarLogic.Instance.StartLoading(_triggerGenericAction.buttonTimer);
                break;
            default:
                break;
        }
    }

    protected virtual void PlayerFinishedInteracting()
    {
        //TorchGlobalManager.Instance.CmdPlayerFinishedInteracting(Id);
    }

    public void PlayerCanceledInteracting()
    {
        LoadingBarLogic.Instance.CancelLoading();
        MusicController.PlaySound(soundNameCancelledInteraction, transform.position);
    }
}
 

// Assets\-ZombieRoyale\Scripts\InRoomSystems\Gameplay\RespawnManager.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using DungeonScrollerCore;
using FishNet.Object;
using Pathfinding;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Serialization;
using Zomb.Creatures.Module;


namespace _ZombieRoyale.Scripts.Core
{
public struct SearchNearestCreaturesToEachPlayerJob : IJob
{
    //Unmanaged types:
    //sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, or bool, Any enum type, Any pointer type
    //NativeStream example: https://github.com/Unity-Technologies/SimpleUIDemo/blob/master/Tiny3D/Library/PackageCache/com.unity.collections%400.3.0-preview.0/Unity.Collections.Tests/NativeStreamTests.cs

    private static readonly float DISTANCE_TO_SPAWN_AI_SQUARED = 200f;//14.1f
    private static readonly float DISTANCE_TO_DESPAWN_AI_SQUARED = 1600f;//40f
    private static readonly float DISTANCE_TO_BLOCK_POINTS_SQUARED = 225f;
    // Jobs declare all data that will be accessed in the job
    // By declaring it as read only, multiple jobs are allowed to access the data in parallel
    [ReadOnly]
    public NativeArray<SpawnPointForJob> JSpawnPointsArray;
    public NativeArray<Vector3> PlayersPosArray;
    
    
    public NativeList<ushort> ResultPointsToSpawn;
    public NativeList<ushort> ResultPointsToDespawn;
    public bool IsSpawnBasedOnPlayers;
    

    public void Execute()
    {
        for (int j = 0; j < JSpawnPointsArray.Length; j++)
        {
            var spawnPoint = JSpawnPointsArray[j];
            if (spawnPoint.isUsed)
            {
                byte playerNearby = 0;
                for (int i = 0; i < PlayersPosArray.Length; i++)
                {
                    var playerPos = PlayersPosArray[i];
                    float distSquared = (playerPos - spawnPoint.position).sqrMagnitude;
                    if (distSquared < DISTANCE_TO_DESPAWN_AI_SQUARED)
                        playerNearby++;
                }
                if (playerNearby > 0)
                    continue;
                    
                ResultPointsToDespawn.Add(spawnPoint.id);
            }
            else
            {
                for (int i = 0; i < PlayersPosArray.Length; i++)
                {
                    var playerPos = PlayersPosArray[i];
                    float distSquared = (playerPos - spawnPoint.position).sqrMagnitude;
                    if (distSquared > DISTANCE_TO_SPAWN_AI_SQUARED)
                        continue;
                    
                    ResultPointsToSpawn.Add(spawnPoint.id);
                    break;
                }
            }
        }
        
        //TODO check and insert this logic
        // if (IsSpawnBasedOnPlayers)
        // {
        //     for (int i = 0; i < JSpawnPointsArray.Length; i++)
        //     {
        //         var spawnPoint = JSpawnPointsArray[i];
        //         if (spawnPoint.isUsed)
        //             continue;
        //         
        //         if (spawnPoint.IsUsedAsNeighbourToOtherPoint)
        //             continue;
        //         
        //         byte playerNearby = 0;
        //         for (int j = 0; j < PlayersPosArray.Length; j++)
        //         {
        //             var playerPos = PlayersPosArray[j];
        //             float distSquared = (playerPos - spawnPoint.position).sqrMagnitude;
        //             if (distSquared > DISTANCE_TO_BLOCK_POINTS_SQUARED)
        //                 continue;
        //             playerNearby++;
        //             spawnPoint.closestPlayerDistance = distSquared;
        //         }
        //         if (playerNearby <= 0)
        //             continue;
        //         ResultPointsToSpawn.Add(spawnPoint.id);
        //         for (int j = 0; j < JSpawnPointsArray.Length; j++)
        //         {
        //             if (i == j)
        //                 continue;
        //             var point = JSpawnPointsArray[j];
        //             if (point.isUsed)
        //             {
        //                 continue;
        //             }
        //             float distance = (spawnPoint.position - point.position).sqrMagnitude;
        //             if (distance > DISTANCE_TO_BLOCK_POINTS_SQUARED)
        //             {
        //                 continue;
        //             }
        //             point.IsUsedAsNeighbourToOtherPoint = true;
        //         }
        //     }
        // }
    }
}

[ExecuteInEditMode]
public class RespawnManager : RoomManager {
    protected const float DEFAULT_MONSTER_RESPAWN_TIME = 600f;
    public static string TAG_PORTAL_SPAWN_POINT = "EscapePortalPoint";
    public static string TAG_MONSTER_SPAWN_POINT = "MonsterSpawnPoint";
    public static string TAG_BOSS_SPAWN_POINT = "BossSpawnPoint";
    protected static float DISTANCE_TO_SPAWN_AI = 20f;
    protected static float DISTANCE_TO_DESPAWN_AI = 40f;
    protected static float DISTANCE_TO_BLOCK_POINTS = 15f;
    [SerializeField] protected List<SpawnPoint> _spawnPoints = new List<SpawnPoint>();
    protected NativeArray<SpawnPointForJob> SpawnPointsArray;
    [SerializeField] protected EnemyDefinitionsHolderSO _enemyDefinitionsHolderSO;
    [SerializeField] protected bool _isSpawnBasedOnPlayers;
    protected CreaturesFactory _creaturesFactory;
    protected bool _isActivated = true;
    protected ushort _startingFromIndex = 0;
    public Action<List<Vector3>> OnBossSpawnPointsPopulated;
    [field: SerializeField] public List<Vector3> PortalPoints { get; protected set; } = new (); 
    protected bool _isDebug = true;
    protected bool _isSpawnPointsInitialized;
    [SerializeField] private bool _isSpawnPointsInsideHolder = false;
    public static RespawnManager Instance { get; protected set; }

    protected void OnDisable() { Debug.Log($"[RespawnManager] OnDisable"); }
    protected void OnEnable() { Debug.Log($"[RespawnManager] OnEnable"); }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(this);
        }
    }

    public override void OnStartNetwork() {
        base.OnStartNetwork();

        if (IsServer || IsHost) {
            _creaturesFactory = GetComponent<CreaturesFactory>();
        }
    }
    
    public override void OnStopNetwork() {
        base.OnStopNetwork();
        if (IsServer || IsHost) {
            if (SpawnPointsArray.IsCreated)
                SpawnPointsArray.Dispose();
        }
    }

    protected IEnumerator CorUpdate()
    {
        var time = new WaitForSeconds(1f);
        while (true)
        {
            if (!_isActivated)
                yield return null;
            // StartCoroutine(SpawnCreaturesIfRequired());
            // StartCoroutine(DespawnCreaturesIfRequired());
            CheckPlayers();
            yield return time;
        }
    }

    private void CheckPlayers()
    {
        if (GameplayManager.SpawnedPlayerHeroes.Count == 0)
            return;
        
        if (SpawnPointsArray.Length == 0)
        {
            Debug.LogError($"[RespawnManager] SpawnPointsArray.Length == 0");
            return;
        }
        var playerPosArray = new NativeArray<Vector3>(GameplayManager.SpawnedPlayerHeroes.Count, Allocator.TempJob);
        for (int i = 0; i < GameplayManager.SpawnedPlayerHeroes.Count; i++)
        {
            playerPosArray[i] = GameplayManager.SpawnedPlayerHeroes[i].transform.position;
        }
        
        NativeList<ushort> resultPointsToSpawn = new NativeList<ushort>(Allocator.TempJob);
        NativeList<ushort> resultPointsToDespawn = new NativeList<ushort>(Allocator.TempJob);
        var job = new SearchNearestCreaturesToEachPlayerJob
        {
            JSpawnPointsArray = SpawnPointsArray,
            PlayersPosArray = playerPosArray,
            ResultPointsToSpawn = resultPointsToSpawn,
            ResultPointsToDespawn = resultPointsToDespawn,
            IsSpawnBasedOnPlayers = _isSpawnBasedOnPlayers
        };
        job.Schedule().Complete();
        StringBuilder result = new StringBuilder("[RespawnManager] CheckPlayers ");
        if (resultPointsToSpawn.Length > 0)
        {
            result.Append($"Spawn(resultPointsToSpawn.Length): ");
            for (int i = 0; i < resultPointsToSpawn.Length; i++)
            {
                result.Append($"{resultPointsToSpawn[i]}, ");
            }
        }
        
        if (resultPointsToDespawn.Length > 0)
        {
            result.Append($". Despawn(resultPointsToDespawn.Length): ");
            for (int i = 0; i < resultPointsToDespawn.Length; i++)
            {
                result.Append($"{resultPointsToDespawn[i]}, ");
            }
        }
        //Debug.Log($"{result}");
        
        foreach (var pointId in resultPointsToDespawn)
        {
            SpawnPoint point = _spawnPoints[pointId];
            point.UpdateClosestPlayerDistance(DISTANCE_TO_DESPAWN_AI+1f);
            _creaturesFactory.DeallocateCreature(point.SpawnedAI);
            point.RemoveAIUnit();
            point.SetUsedAs(false);
            SpawnPointsArray[pointId] = new SpawnPointForJob()
            {
                id = point.Id,
                type = point.GetCreatureType(),
                position = point.Position,
                isUsed = false,
                spawnedAIObjectId = -1,
                IsUsedAsNeighbourToOtherPoint = false
            };
            Debug.Log($"{ClassAndRoomName} despawned point {pointId}");
        }
        
        foreach (var pointId in resultPointsToSpawn)
        {
            SpawnPoint point = _spawnPoints[pointId];
            ushort creatureType = point.GetCreatureType();
            var creature = SpawnCreatureAtPoint(point.Position, creatureType);
            _spawnPoints[pointId].SetUsedAs(true);
            _spawnPoints[pointId].StoreAIUnit(creature.Controller);
            SpawnPointsArray[pointId] = new SpawnPointForJob()
            {
                id = point.Id,
                type = creatureType,
                position = point.Position,
                isUsed = true,
                spawnedAIObjectId = creature.Controller.ObjectId,
                IsUsedAsNeighbourToOtherPoint = false
            };
            creature.Controller.OnHideCreature += Controller_OnHideCreature;
        }
        
        resultPointsToSpawn.Dispose();
        resultPointsToDespawn.Dispose();
        playerPosArray.Dispose();
    }
    
    protected bool IsThereAnySpawnPointsToDespawn(out HashSet<int> pointsToDespawn) {
        pointsToDespawn = new HashSet<int>();
        for (int i = 0; i < _spawnPoints.Count; i++)
        {
            var spawnPoint = _spawnPoints[i];
            if (!spawnPoint.IsUsed)
                continue;
            
            if (spawnPoint.IsUsedAsNeighbourToOtherPoint) {
                continue;
            }
            
            int playersNearby = 0;
            foreach (var playerNob in UnitComponentsManager.GetAllPlayersHeroes())
            {
                var playerPosition = playerNob.transform.position;
                float distance = Vector3.Distance(spawnPoint.Position, playerPosition);
                if (distance < DISTANCE_TO_DESPAWN_AI)
                    playersNearby++;
            }
            
            if (playersNearby > 0)
                continue;
            
            pointsToDespawn.Add(spawnPoint.Id);
        }
        if (pointsToDespawn.Count == 0)
            return false;
        return true;
    }

    protected bool IsThereAnySpawnPointsToSpawn(out HashSet<int> pointsToSpawn) {
        //TODO optimize from O(n2) -> O(nlogn) using chunks
        pointsToSpawn = new HashSet<int>();

        for (int i = 0; i < _spawnPoints.Count; i++)
        {
            var spawnPoint = _spawnPoints[i];
            if (spawnPoint.IsUsed) {
                continue;
            }
            
            if (spawnPoint.IsUsedAsNeighbourToOtherPoint) {
                continue;
            }
            
            int playersNearby = 0;
            foreach (var playerNob in GameplayManager.SpawnedPlayerHeroes)
            {
                var playerPosition = playerNob.transform.position;
                float distance = Vector3.Distance(spawnPoint.Position, playerPosition);
                if (distance > DISTANCE_TO_SPAWN_AI) {
                    continue;
                }
                playersNearby++;
                spawnPoint.UpdateClosestPlayerDistance(distance);
            }
            if (playersNearby <= 0)
                continue;
            
            pointsToSpawn.Add(spawnPoint.Id);
            
            SpawnFilterBasedOnPlayersCountIfRequired(i, spawnPoint, playersNearby);
        }

        //Debug.Log($"{ClassAndRoomName} need to spawn {_pointsToSpawn.Count} points");
        if (pointsToSpawn.Count == 0)
            return false;
        return true;
    }

    protected void SpawnFilterBasedOnPlayersCountIfRequired(int i, SpawnPoint spawnPoint, int playersNearby)
    {
        if (!_isSpawnBasedOnPlayers) return;
        
        List<SpawnPoint> pointsNearby = new List<SpawnPoint>();
        //near each point should be only players*points active points
        for (int j = 0; j < _spawnPoints.Count; j++)
        {
            if (i == j)
                continue;
            var point = _spawnPoints[j];
            if (point.IsUsed)
            {
                continue;
            }

            float distance = Vector3.Distance(spawnPoint.Position, point.Position);
            if (distance > DISTANCE_TO_BLOCK_POINTS)
            {
                continue;
            }

            pointsNearby.Add(point);
        }

        foreach (var pointNear in pointsNearby)
        {
            if (playersNearby > 0)
            {
                playersNearby--;
                pointNear.IsUsedAsNeighbourToOtherPoint = true;
                continue;
            }
            else
            {
                pointNear.SetUsedAs(true);
            }
        }
    }

    public CreaturesFactory.PooledCreature SpawnCreatureAtPoint(Vector3 pos, ushort creatureType)
    {
        NNInfo astarPoint = GameplayManager.AstarPath.GetNearest(pos);
        Vector3 point = astarPoint.position;
        if(astarPoint.node == null)
        {
            Debug.LogError($"[RespawnManager] SpawnCreatureAtPoint {pos} astarPoint.node == null");
            point = pos;
        }
        CreaturesFactory.PooledCreature creature =
            _creaturesFactory.AllocateCreature(creatureType, point, GameplayManager);
        return creature;
    }

    protected void Controller_OnHideCreature(AIUnit controller) {
        //TODO spawn point id not setting properly
        ushort pointId = controller.SpawnPointId;
        SpawnPoint point = SpawnPointsGetFromId(pointId);
        point.SetUsedAs(false);
    }

    protected SpawnPoint SpawnPointsGetFromId(ushort id) { return _spawnPoints[id]; }

    [Server]
    public void MonsterSpawnPointsPopulate() {
        ushort index = 0;
        PopulateMonsterSpots(EnemyDefinition.Type.Monster);
        PopulateMonsterSpots(EnemyDefinition.Type.Boss);
        Debug.Log($"[RespawnManager] SpawnPointsPopulate: {_spawnPoints.Count}");
        _isSpawnPointsInitialized = true;
    }

    public void InitIfAllRequirementsMet()
    {
        StartCoroutine(LateInit());
    }

    protected IEnumerator LateInit()
    {
        if (!IsHost)
        {
            yield return new WaitUntil(() => GameplayManager.IsAllPlayersSpawned);
        }
        DebugWrite.Log($"[RespawnManager] Init", gameObject, _isDebug);
        StartCoroutine(CorUpdate());
    }
    
    public void RemovePortalSpawnPoints() {
        GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_PORTAL_SPAWN_POINT);
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            Destroy(spawnPointHolders[j]);
        }
    }
    
    public void RemoveMonsterSpawnPoints() {
        StringBuilder sb = new StringBuilder($"{ClassAndRoomName} RemoveMonsterSpawnPoints ");
        GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_MONSTER_SPAWN_POINT);
        sb.Append($"[RespawnManager] RemoveMonsterSpawnPoints {TAG_MONSTER_SPAWN_POINT}: {spawnPointHolders.Length}");
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            Destroy(spawnPointHolders[j]);
        }
        spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_BOSS_SPAWN_POINT);
        sb.Append($"[RespawnManager] RemoveMonsterSpawnPoints {TAG_BOSS_SPAWN_POINT}: {spawnPointHolders.Length}");
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            Destroy(spawnPointHolders[j]);
        }
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        if (!IsHost)
            Destroy(this.gameObject);
    }

    [Server]
    public void PopulatePortalPoints()
    {
        GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_PORTAL_SPAWN_POINT);
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            PortalPoints.Add(spawnPointHolders[j].transform.position);
            Destroy(spawnPointHolders[j]);
        }
    }

    [Server]
    protected void PopulateMonsterSpots(EnemyDefinition.Type type)
    {
        StringBuilder sb = new StringBuilder();
        string tag = "";
        float respawnTime = DEFAULT_MONSTER_RESPAWN_TIME;
        switch (type)
        {
            case EnemyDefinition.Type.Monster:
                tag = TAG_MONSTER_SPAWN_POINT;
                break;
            case EnemyDefinition.Type.Boss:
                tag = TAG_BOSS_SPAWN_POINT;
                respawnTime = 999999f;
                break;
        }

        sb.Append($"[RespawnManager] PopulateMonsterSpots of type: {tag}. ");
        GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(tag);
        sb.Append($"Found {spawnPointHolders.Length} points. ");
        List<Transform> spawnPoints = new List<Transform>();
        if (_isSpawnPointsInsideHolder)
        {
            List<Transform> spawnPointHoldersCleared = new List<Transform>();
            //Clear from those that dont have children, because in unity calling FindGameObjectsWithTag gives results with gameobjects that are not tagged with that tag, but they are children of game objects with that tag
            for (int i = 0; i < spawnPointHolders.Length; i++)
            {
                if (spawnPointHolders[i].transform.childCount > 0)
                {
                    spawnPointHoldersCleared.Add(spawnPointHolders[i].transform);
                }
            }
            sb.Append($"generate enemies: ");
            foreach (var holderGo in spawnPointHoldersCleared)
            {
                int childCount = holderGo.childCount;
                byte[] randomEnemies = new byte[childCount];
                for (int i = 0; i < childCount; i++)
                {
                    spawnPoints.Add(holderGo.GetChild(i));
                    randomEnemies[i] = _enemyDefinitionsHolderSO.GetRandomEnemyId(type);
                    sb.Append($"id: {randomEnemies[i]}, ");
                }
                PopulateSpawnPointsWith(randomEnemies, spawnPoints, respawnTime);
            }
            DebugWrite.Log($"[RespawnManager] {sb}", gameObject, _isDebug);
        }
        else
        {
            byte[] randomEnemies = new byte[spawnPointHolders.Length];
            for (int i = 0; i < spawnPointHolders.Length; i++)
            {
                spawnPoints.Add(spawnPointHolders[i].transform);
                randomEnemies[i] = _enemyDefinitionsHolderSO.GetRandomEnemyId(type);
                sb.Append($"id: {randomEnemies[i]}, ");
            }
            PopulateSpawnPointsWith(randomEnemies, spawnPoints, respawnTime);
            DebugWrite.Log($"[RespawnManager] {sb}", gameObject, _isDebug);
        }
        
        
        
        if (type == EnemyDefinition.Type.Boss)
            AddBossPoints(spawnPoints);
        
        for (int j = 0; j < spawnPointHolders.Length; j++) {
            Destroy(spawnPointHolders[j]);
        }
    }

    [Server]
    protected void AddBossPoints(List<Transform> spawnPointHoldersCleared)
    {
        List<Vector3> positions = new List<Vector3>();
        foreach (var holderGo in spawnPointHoldersCleared)
        {
            positions.Add(holderGo.position);
        }
        Debug.Log($"[RespawnManager] Added {positions.Count} BossPoints");
        OnBossSpawnPointsPopulated?.Invoke(positions);
    }

    protected void PopulateSpawnPointsWith(byte[] randomEnemies, List<Transform> spawnPoints, float respawnTime)
    {
        foreach (var trans in spawnPoints)
        {
            byte randomEnemy = randomEnemies[spawnPoints.IndexOf(trans)];
            SpawnPoint spawnPoint = new SpawnPoint(_startingFromIndex, randomEnemy, trans.position, respawnTime);
            
            Debug.Log($"[RespawnManager] Added spawnPoint #{_startingFromIndex} with enemyId {randomEnemy}, at {trans.position} with respawnTime {respawnTime}", gameObject);
            _spawnPoints.Add(spawnPoint);
            _startingFromIndex++;
        }
        
        SpawnPointsArray = new NativeArray<SpawnPointForJob>(_spawnPoints.Count, Allocator.Persistent);
        for (int i = 0; i < _spawnPoints.Count; i++)
        {
            SpawnPointsArray[i] = new SpawnPointForJob()
            {
                id = _spawnPoints[i].Id,
                type = _spawnPoints[i].GetCreatureType(),
                position = _spawnPoints[i].Position,
                isUsed = _spawnPoints[i].IsUsed,
                spawnedAIObjectId = -1,
                IsUsedAsNeighbourToOtherPoint = false
            };
        }
    }
    
#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        //draw spheres
        if (_spawnPoints == null)
            return;
        for (int i = 0; i < _spawnPoints.Count; i++)
        {
            var spawnPoint = _spawnPoints[i];
            if (spawnPoint.IsUsed)
            {
                Gizmos.color = Color.red;
            }
            else
            {
                Gizmos.color = Color.green;
            }
            Gizmos.DrawSphere(spawnPoint.Position, 1f);
        }
    }
#endif
}
} 

// Assets\FishNet Invector\Scripts\Networked\FishnetInvectorManager.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using Character;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Clients;
using FishNet.Component.Animating;
using FishNet.Component.Transforming;
using FishNet.Connection;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using FishNet.Observing;
using Invector.vCharacterController;
using Invector.vItemManager;
using NHance.Assets.Scripts;
using PixelCrushers;
using UnityEngine;
using UnityEngine.UI;
using Zomb.Creatures.Helpers;
using PixelCrushers.DialogueSystem.Wrappers;
using Backend;

namespace FishnetInvector{
[RequireComponent(typeof(NetworkTransform))]
[RequireComponent(typeof(NetworkObserver))]
[RequireComponent(typeof(NetworkAnimator))]
[RequireComponent(typeof(BehavioursSwitcher))]
public class FishnetInvectorManager : Unit {
    private static string DEBG_LOG_PREFIX = "<color=orange>[FishnetInvectorManager]</color>";
    #region Camera
    private FNvThirdPersonCamera _fishnetThirdPersonCamera;
    [SerializeField] private GameObject _inventoryCamera;
    #endregion

    #region Client-specific GOs
    [SerializeField] private GameObject inventory_CameraPreview;
    [SerializeField] private GameObject ui;
    [SerializeField] private GameObject shooterUIGO;
    [SerializeField] private GameObject _gOFishnetThirdPersonCamera;
    [SerializeField] private GameObject[] _hiddenOnServer;
    #endregion

    private List<Behaviour> _componentsToDisable = new List<Behaviour>();
    [SerializeField] private Rigidbody _rb;
    private vThirdPersonInput tpInput;
    private GameObject currentCamera;
    [SerializeField] private vInventory _inventory;
    [SerializeField] private vShooterMeleeInput _shooterMeleeInput;
    public AnimatorDecorator AnimatorDecorator => _animatorDecorator;
    [SerializeField] private AnimatorDecorator _animatorDecorator;
    [SerializeField] private FNvMeleeManager _meleeManager;
    [SerializeField] private FNvThirdPersonController _thirdPersonController;
    [SerializeField] private vChangeAnimatorUpdateMode _vChangeAnimatorUpdateMode;
    [Tooltip("Optional canvas group, for example to play fade animations.")]
    public CanvasGroup canvasGroup = null;
    [Tooltip("UI text control for bark text.")]
    public UITextField barkText = null;
    [Tooltip("Optional UI text control for barker's name if Include Name is ticked. If unassigned and Include Name is ticked, name is prepended to Bark Text.")]
    public UITextField nameText = null;
    [field:SerializeField] public List<RendererColor> rendererColor { get; protected set; }

    [SerializeField] private GameObject dashEffect;
    public FNvThirdPersonController ThirdPersonController => _thirdPersonController;
    public vInventory Inventory => _inventory;
    public CharacterSkin CharacterSkin => _characterSkin;
    [SerializeField] private CharacterSkin _characterSkin;
    public NHAvatar Avatar => avatar;
    [SerializeField] private NHAvatar avatar;
    public int ObjectId => NetworkObject.ObjectId;
    [SerializeField] private CapsuleCollider _capsuleCollider;
    public static Action<FishnetInvectorManager> OnPlayerInRangeDetected;
    public static Action<FishnetInvectorManager> OnPlayerLeftFromRangeDetected;
    public static Action OnOwnerInitialized;
    public Action OnThisOwnerInitialized;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;
    #region Client-specific Components
    public static FishnetInvectorManager LocalPlayer;
    private GameplayManager _gameplayManager;
    public GameplayManager GameplayManager => _gameplayManager;
    private Vector3 _lastPosition;
    
    
    public static Action OnLocalPlayerInitialized;
    public static bool IsLocalPlayerInitialized { get; private set; }
    public ClientInstance ClientInstance { get; private set; }

    public Action OnObservingPlayerInitialized;
    public Action<NetworkObject, Vector3> OnPlayerPositionChanged;
    private bool _isDebug = true;
    [SyncVar] private Vector3 _spawnedPosition = Vector3.zero;

    #endregion
    
    protected override void OnValidate() {
        base.OnValidate();
        _characterSkin ??= GetComponentInChildren<CharacterSkin>();
        _inventory ??= GetComponentInChildren<vInventory>();
        _inventoryCamera ??= GetComponentInChildren<vInventory>().gameObject;
        _rb ??= GetComponent<Rigidbody>();
        _capsuleCollider ??= GetComponent<CapsuleCollider>();
        _shooterMeleeInput ??= GetComponent<vShooterMeleeInput>();
        _meleeManager ??= GetComponent<FNvMeleeManager>();
        _thirdPersonController ??= GetComponent<FNvThirdPersonController>();
        _animatorDecorator ??= GetComponent<AnimatorDecorator>();
        _vChangeAnimatorUpdateMode ??= GetComponentInChildren<vChangeAnimatorUpdateMode>();
        _inventory ??= GetComponentInChildren<vInventory>();
    }

    private void Awake()
    {
        if (CharacterSkin != null)
            CharacterSkin.OnGenderChanged += UpdateGenderVoices;
        RoomLODDetector.OnLocalPlayerDetected += ActivateRB;
    }

    public override void OnStartNetwork() {
        base.OnStartNetwork();
        ChangeGOName(base.Owner.IsLocalClient);
        int clientId = IsHost ? 0 : Owner.ClientId;
        if (IsHost)
        {
            //NetworkConnection conn = InstanceFinder.ServerManager.Clients[clientId];
            //ClientInstance = ClientInstance.ClientInstances[conn];
        }
        else
        {
            ClientInstance = ClientInstance.ClientInstances[Owner];
        }
        
        if (!base.IsHost && !base.Owner.IsLocalClient) {
            _rb.isKinematic = true;
        }
    }

    private void InitServerAndOwner()
    {
        if (UnitComps != null)
            return;
        
        if (!(base.IsHost || base.Owner.IsLocalClient)) {
            _vChangeAnimatorUpdateMode.gameObject.SetActive(false);
        }
    }
    
    IEnumerator DelayedRigidBodyActivator(float delay)
    {
        _rb.isKinematic = true;
        yield return new WaitForSeconds(delay);
        ActivateRB();
    }
    
    private void ActivateRB()
    {
        Debug.Log($"[FishnetInvectorManager] ActivateRB for {gameObject} at {transform.position}", gameObject);
        _rb.isKinematic = false;
    }
    
    public override void OnStartClient()
    {
        base.OnStartClient();
        InitServerAndOwner();
        if (IsOwner) {
            Init();
            _spawnedPosition = transform.position;
            if (_characterSkin != null)
                _characterSkin.SetSkinData(CharacterDataController.Instance.CharacterSkinData);
            else if (avatar != null)
                avatar.SetSkinData(CharacterDataController.Instance.CharacterSkinData);
            OnOwnerInitialized?.Invoke();
            OnThisOwnerInitialized?.Invoke();
            //StandardBarkUI.OnBarkUIInit += AssignMyBarkUI;
            _thirdPersonController.OnRoll.AddListener(CmdTryRoll);
            var torchesArray = GameplayManager.Instance.DungeonHolder.LoadTorches();
            for (int i = 0; i < torchesArray.Length; i++)
            {
                torchesArray[i].TorchController.InitForLocalPlayer(gameObject);
                //TODO: change to JOBs system
                StartCoroutine(TorchesActivator(torchesArray));
            }
            StartCoroutine(DelayedRigidBodyActivator(5f));
        }
    
        if (!IsOwner)
        {
            OnObservingPlayerInitialized?.Invoke();
            DebugWrite.Log($"[OnStartClient] Player #{NetworkObject.OwnerId} OnPlayerInRangeDetected, OnObservingPlayerInitialized", gameObject, _isDebug);
            OnPlayerInRangeDetected?.Invoke(this);
            ObserversUpdateSkin();
            UnitComps.AnimatorDecorator.TurnOffRootMotion();
        }
    }

    private IEnumerator TorchesActivator(TorchGlobalManager.TorchStatus[] torches)
    {
        var time = new WaitForSeconds(1f);
        var lastPosition = Vector3.negativeInfinity;
        float sqrtDistToDraw = 900f;
        TorchControllerNoNetwork[] torchControllers = new TorchControllerNoNetwork[torches.Length];
        for (int i = 0; i < torches.Length; i++)
        {
            torchControllers[i] = torches[i].TorchController;
        }
        while (true)
        {
            yield return time;
            bool isMoved = !Mathf.Approximately(transform.position.y, lastPosition.y)
                           || !Mathf.Approximately(transform.position.x, lastPosition.x)
                           || !Mathf.Approximately(transform.position.z, lastPosition.z);
            if (isMoved)
            {
                for (int i = 0; i < torchControllers.Length; i++)
                {
                    if (torchControllers[i] == null)
                        continue;
                    float sqrDist = (torchControllers[i].transform.position - transform.position).sqrMagnitude;
                    if (sqrDist < sqrtDistToDraw)
                    {
                        torchControllers[i].SetVFXOnOff(true);
                    }
                    else
                    {
                        torchControllers[i].SetVFXOnOff(false);
                    }
                }
            }
        }
    }

    private void AssignMyBarkUI(StandardBarkUI barkUI)
    {
        barkUI.InitLocalPlayer(canvasGroup, barkText, nameText);
    }

    private void ObserversUpdateSkin() {
        Debug.Log($"[FishnetInvectorManager] UpdateSkin for {gameObject}");
        //get owners PlayerSettings
        ClientInstance ownerClientInstance = ClientInstance.ClientInstances[Owner];
        if (CharacterSkin != null)
            BackendReadWrites.GetCharacterSkin(ownerClientInstance.PlayerSettings.CharacterSkinData.Id, CharacterSkin.SetSkinData);
        else if (avatar != null)
            BackendReadWrites.GetCharacterSkin(ownerClientInstance.PlayerSettings.CharacterSkinData.Id, Avatar.SetSkinData);
    }

    public override void OnStopClient()
    {
        base.OnStopClient();
        if (IsOwner)
        {
            IsLocalPlayerInitialized = false;
            LocalPlayer = null;
        }
        else
        {
            DebugWrite.Log($"[OnStopClient] Player #{NetworkObject.OwnerId} OnPlayerLeftFromRangeDetected", gameObject, _isDebug);
            OnPlayerLeftFromRangeDetected?.Invoke(this);
        }
    }

    public override void OnStartServer()
    {
        base.OnStartServer();
        InitServerAndOwner();
        //_capsuleCollider.isTrigger = true;
        for (int i = 0; i < _hiddenOnServer.Length; i++)
        {
            _hiddenOnServer[i].SetActive(false);
        }
        StartCoroutine(PlayerPositionsUpdater());
    }
    
    public void SetupGameplayManager(GameplayManager gameplayManager)
    {
        _gameplayManager = gameplayManager;
    }

    [Server]
    private IEnumerator PlayerPositionsUpdater()
    {
        var time = new WaitForSeconds(.5f);
        while (true)
        {
            Vector3 currentPosition = transform.position;
            if (_lastPosition == null || currentPosition != _lastPosition)
            {
                _lastPosition = currentPosition;
                OnPlayerPositionChanged?.Invoke(NetworkObject, currentPosition);
            }

            yield return time;
        }
    }

    private void ChangeGOName(bool isOwner) {
        string local = isOwner ? "(Local)" : "";
        string oldName = gameObject.name;
        gameObject.name = $"{gameObject.name.Substring(0,oldName.Length-7)} #{NetworkObject.ObjectId} - Player #{NetworkObject.OwnerId}{local}";
    }

    private void Init() {
        ActivateClientSpecificGOs();
        SpawnCamera();
        InitEvents();
        LocalPlayer = this;
        //ActivateCamera();
        IsLocalPlayerInitialized = true;
        OnLocalPlayerInitialized?.Invoke();
        Debug.Log($"{ClassName} OnLocalPlayerInitialized Invoke IsLocalPlayerInitialized: {IsLocalPlayerInitialized}");
        _shooterMeleeInput.OnAnimatorTriggerSet += OnAnimatorTriggerSet;
        _thirdPersonController.OnAnimatorTriggerSet += OnAnimatorTriggerSet;
        StartCoroutine(CheckIfFallingDown());
        Debug.Log($"Object: {base.ObjectId}; Owner: {base.OwnerId}; name: {gameObject.name}; IsOwner: {base.IsOwner}");
    }

    private IEnumerator CheckIfFallingDown()
    {
        var time = new WaitForSeconds(1f);
        while (true)
        {
            if (transform.position.y < -200)
            {
                Debug.Log($"[FishnetInvectorManager] CheckIfFallingDown: {gameObject.name} is falling down. Teleporting to {_spawnedPosition}");
                transform.position = _spawnedPosition + 2*Vector3.up;
            }
            yield return time;
        }
    }

    private void OnAnimatorTriggerSet(int hash)
    {
        _animatorDecorator.SetTrigger(hash);
    }

    private void ActivateClientSpecificGOs() {
        //ActivateLocalClientInventory();
        //inventory_CameraPreview.SetActive(true);
        //ui.SetActive(true);
        //shooterUIGO.SetActive(true);
    }

    private void ActivateLocalClientInventory() {
        Canvas canvas = _inventory.GetComponent<Canvas>();
        CanvasScaler canvasScaler = _inventory.GetComponent<CanvasScaler>();
        GraphicRaycaster graphicRaycaster = _inventory.GetComponent<GraphicRaycaster>();
        //vJoystickMouseInput joystickMouseInput = _inventory.GetComponent<vJoystickMouseInput>();
        canvas.enabled = true;
        canvasScaler.enabled = true;
        graphicRaycaster.enabled = true;
        _inventory.enabled = true;
        //joystickMouseInput.enabled = true;
        string[] goNamesToActivate = new[] { "ItemCollectionDisplay", "EquipmentDisplayWindow", "Inventory_UI", "OpenInventory" };
        StringBuilder sbLog = new StringBuilder();
        sbLog.AppendLine($"Activating inventory for {gameObject.name} client id #{base.OwnerId}");
        foreach (Transform Child in _inventory.transform) {
            foreach (string goName in goNamesToActivate) {
                if (goName == Child.name) {
                    Child.gameObject.SetActive(true);
                    sbLog.AppendLine($"Activating {goName}; ");
                }
            }
        }
        Debug.Log($"{sbLog}", _inventory);
    }

    private void ActivateClientSpecificComponents() {
        vInventory inventory = GetComponentInChildren<vInventory>();
        vJoystickMouseInput joystickMouseInput = GetComponentInChildren<vJoystickMouseInput>();
    }

    private void OnDisable() {
        Debug.Log($"[FishnetInvectorManager] OnDisable: {base.ObjectId}; Owner: {base.OwnerId}; name: {gameObject.name}; IsOwner: {base.IsOwner}");
    }

    private void SpawnCamera() {
         currentCamera = Instantiate(_gOFishnetThirdPersonCamera);
         Debug.Log($"[FishnetInvectorManager] SpawnCamera: {currentCamera.name}", currentCamera);
        _gOFishnetThirdPersonCamera = currentCamera;// mainCameraGO.transform.parent.gameObject;
        _fishnetThirdPersonCamera = _gOFishnetThirdPersonCamera.GetComponent<FNvThirdPersonCamera>();
        _fishnetThirdPersonCamera.mainTarget = transform;
        _fishnetThirdPersonCamera.Init(this);
    }

    private void ActivateInventoryView()
    {
        _fishnetThirdPersonCamera.gameObject.SetActive(false);
        _inventoryCamera.SetActive(true);
    }

    private void DeactivateInventoryView()
    {
        _fishnetThirdPersonCamera.gameObject.SetActive(true);
        _inventoryCamera.SetActive(false);
    }

    public void ChangeCameraInventoryState(bool value)
    {
        if (value)
        {
            _fishnetThirdPersonCamera.ChangeState("Default");
        }
        else
        {
            _fishnetThirdPersonCamera.ChangeState("InventoryMode");
        }
    }

    private void InitEvents() // add listeners to basic invector events
    {
        //TCGGameManager.GameManager.GetInstance().OnLockInput += LockInputs;
    }

    private void OnDestroy()
    {
        //TCGGameManager.GameManager.GetInstance().OnLockInput -= LockInputs;
        Destroy(currentCamera);
    }

    public void ServerTeleportPlayer(Vector3 position)
    {
        TeleportPlayerDecorator(Owner, position);
    }

    public void OwnerTeleport(Vector3 position)
    {
        transform.position = position;
    }

        public void OwnerSmoothTeleport(Vector3 position , float duration)
        {
            StartCoroutine(SmoothMoveCoroutine(position, duration));
        }

        private IEnumerator SmoothMoveCoroutine(Vector3 destination, float duration)
        {
            float elapsedTime = 0;

            while (elapsedTime < duration)
            {
                transform.position = Vector3.Lerp(transform.position, destination, elapsedTime / duration);
                elapsedTime += Time.deltaTime;
                yield return null;
            }

          //  transform.position = destination; // Ensure the object reaches the target position
        }

        [TargetRpc]
    public void TeleportPlayerDecorator(NetworkConnection conn, Vector3 position) {
        transform.position = position;
    }

    public void SwitchCamera()
    {
        //_fishnetThirdPersonCamera.SwitchCamera();
    }

    public void StoreRendererColors()
    {
        
    }

    [ServerRpc]
    public void CmdTryRoll()
    {
        //TODO: stamina antihack check
        bool isStaminaOk = true;
        if (isStaminaOk)
        {
            _thirdPersonController.SetIsRolling(true);
        }
    }

    private float _testForce = 100f;
    public void TestForce()
    {
        #if UNITY_EDITOR
        _thirdPersonController.AddForce(Vector3.forward, _testForce);
        _testForce += 100f;
#endif
    }

    [ServerRpc]
    public void SpawnDashEffect(Vector3 oldPos, Vector3 destination)
    {
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        SpawnDashEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnDashEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalDashEffect(middlePoint, directionRotation);
    }

    public void InternalDashEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        if (dashEffect != null)
        {
            GameObject fxInstance = Instantiate(dashEffect, middlePoint, directionRotation);
            Destroy(fxInstance, .5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }
}
} 



# TASK: write me JOBS system variant for TorchesActivator logic for example you can use jobs from RespawnManager