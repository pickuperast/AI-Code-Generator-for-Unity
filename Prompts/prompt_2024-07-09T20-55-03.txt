# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.

# CODE: using UnityEngine;using UnityEngine.UI;using System.Collections.Generic;using DuloGames.UI;using Invector.vItemManager;using Backend.BackendAuction;public class AuctionController : MonoBehaviour{ [SerializeField] private UIItemDatabase itemDatabase; [SerializeField] private UIInventory playerInventory; [SerializeField] private UIItemSlot[] auctionSlots; [SerializeField] private Button buyTabButton; [SerializeField] private Button sellTabButton; [SerializeField] private Button myLotsTabButton; [SerializeField] private InputField searchInputField; [SerializeField] private InputField priceInputField; [SerializeField] private InputField quantityInputField; [SerializeField] private Dropdown durationDropdown; [SerializeField] private Text commissionText; [SerializeField] private Button sellButton; private List<AuctionItem> currentAuctionItems = new List<AuctionItem>(); private AuctionTab currentTab = AuctionTab.Buy; private vItem selectedItem; private enum AuctionTab { Buy, Sell, MyLots } private void Start() { buyTabButton.onClick.AddListener(() => SwitchTab(AuctionTab.Buy)); sellTabButton.onClick.AddListener(() => SwitchTab(AuctionTab.Sell)); myLotsTabButton.onClick.AddListener(() => SwitchTab(AuctionTab.MyLots)); searchInputField.onValueChanged.AddListener(OnSearchInputChanged); priceInputField.onValueChanged.AddListener(OnPriceInputChanged); quantityInputField.onValueChanged.AddListener(OnQuantityInputChanged); durationDropdown.onValueChanged.AddListener(OnDurationChanged); sellButton.onClick.AddListener(OnSellButtonClicked); playerInventory.onRightClickSlot.AddListener(OnInventoryItemRightClicked); playerInventory.onShiftLeftClickSlot.AddListener(OnInventoryItemShiftLeftClicked); SwitchTab(AuctionTab.Buy); } private void SwitchTab(AuctionTab tab) { currentTab = tab; ClearAuctionSlots(); switch (tab) { case AuctionTab.Buy: LoadBuyTab(); break; case AuctionTab.Sell: LoadSellTab(); break; case AuctionTab.MyLots: LoadMyLotsTab(); break; } } private void LoadBuyTab() { BackendAuction.AuctionQueryData queryData = new BackendAuction.AuctionQueryData { page = 1, category = "", searchQuery = searchInputField.text }; BackendAuction.GetAuctionedItems(queryData, (exception, response, body) => { if (exception == null) { currentAuctionItems = JsonUtility.FromJson<List<AuctionItem>>(body); DisplayAuctionItems(); } else { Debug.LogError("Failed to load auction items: " + exception.Message); } }); } private void LoadSellTab() { // This tab is loaded when an item is right-clicked in the inventory } private void LoadMyLotsTab() { BackendAuction.GetUserAuctionedItems((exception, response, body) => { if (exception == null) { currentAuctionItems = JsonUtility.FromJson<List<AuctionItem>>(body); DisplayAuctionItems(); } else { Debug.LogError("Failed to load user's auction items: " + exception.Message); } }); } private void DisplayAuctionItems() { ClearAuctionSlots(); for (int i = 0; i < Mathf.Min(currentAuctionItems.Count, auctionSlots.Length); i++) { AuctionItem auctionItem = currentAuctionItems[i]; UIItemInfo itemInfo = itemDatabase.GetItemById(auctionItem.itemId).ToUIItemInfo(); itemInfo.Amount = auctionItem.quantity; auctionSlots[i].Assign(itemInfo); } } private void ClearAuctionSlots() { foreach (UIItemSlot slot in auctionSlots) { slot.Unassign(); } } private void OnInventoryItemRightClicked(UIItemSlot slot) { if (currentTab != AuctionTab.Sell) { SwitchTab(AuctionTab.Sell); } selectedItem = itemDatabase.GetItemById(slot.GetItemInfo().ID); DisplaySellTabForItem(selectedItem); } private void OnInventoryItemShiftLeftClicked(UIItemSlot slot) { SwitchTab(AuctionTab.Buy); searchInputField.text = slot.GetItemInfo().Name; LoadBuyTab(); } private void DisplaySellTabForItem(vItem item) { // Display item details and market prices BackendAuction.GetMarketPrices(new MarketPricesData { itemId = item.id }, (exception, response, body) => { if (exception == null) { List<MarketPrice> marketPrices = JsonUtility.FromJson<List<MarketPrice>>(body); // Display market prices in UI // You need to implement a UI to show these prices } else { Debug.LogError("Failed to load market prices: " + exception.Message); } }); } private void OnSearchInputChanged(string value) { if (currentTab == AuctionTab.Buy) { LoadBuyTab(); } } private void OnPriceInputChanged(string value) { UpdateCommission(); } private void OnQuantityInputChanged(string value) { UpdateCommission(); } private void OnDurationChanged(int index) { UpdateCommission(); } private void UpdateCommission() { // Calculate and display auction commission // This is a placeholder calculation, adjust according to your game's rules float price = float.Parse(priceInputField.text); int quantity = int.Parse(quantityInputField.text); int duration = (durationDropdown.value + 1) * 12; // Assuming options are 12, 24, 48 hours float commission = price * quantity * (duration / 24f) * 0.05f; // 5% commission per day commissionText.text = "Commission: " + commission.ToString("F2") + " gold"; } private void OnSellButtonClicked() { if (selectedItem == null) return; AuctionListItemData listItemData = new AuctionListItemData { itemId = selectedItem.id, amount = int.Parse(quantityInputField.text), startingBid = float.Parse(priceInputField.text), buyoutPrice = float.Parse(priceInputField.text), duration = (durationDropdown.value + 1) * 12 // Assuming options are 12, 24, 48 hours }; BackendAuction.ListAuctionItem(listItemData, (exception, response, body) => { if (exception == null) { Debug.Log("Item listed successfully"); // Remove item from player's inventory // Refresh inventory display } else { Debug.LogError("Failed to list item: " + exception.Message); } }); } // Additional classes to represent auction data [System.Serializable] private class AuctionItem { public int id; public int itemId; public int quantity; public float currentBid; public float buyoutPrice; public int timeLeft; } [System.Serializable] private class MarketPrice { public float price; public int quantity; }} using System;using System.Collections;using System.Collections.Generic;using Backend;using DungeonScrollerCore;using HeathenEngineering.SteamworksIntegration;using UnityEngine;using Newtonsoft.Json;using SingletonsExtension;using TMPro;using UnityEngine.Serialization;using UnityEngine.UI;namespace _ZombieRoyale.Scripts.Clients{public class PlayerData : MonoBehaviour{ private static string PLAYER_PREFS_PLAYER_ID_KEY = "username"; private static string PLAYER_PREFS_PLAYER_PASSWORD = "password"; private static string PLAYER_PREFS_EMAIL = "email"; private static string PLAYER_PREFS_TOKEN = "access_token"; [field:SerializeField] public bool IsUsingBackend { get; private set; } public Action OnPlayerLoggedIn; private Action OnPlayerIdAndPasswordLoaded; public Action<CharacterData> OnCharacterLoaded; [SerializeField] private TextMeshProUGUI backendResponseStatusText; [SerializeField] private Button savePlayerDataBtn; [SerializeField] private TMP_InputField usernameInputField; [SerializeField] private TMP_InputField _passwordInputField; [SerializeField] private TMP_InputField _emailInputField; [SerializeField] private TextMeshProUGUI _playerNameText; [SerializeField] private TextMeshProUGUI _playerEmailText; [SerializeField] private TextMeshProUGUI _playerPasswordText; public PlayerRegisterData MyPlayerRegisterData => _playerRegisterData; private PlayerRegisterData _playerRegisterData = new PlayerRegisterData(); [field:SerializeField] public string Username { get; private set; } [field:SerializeField] public string SteamUsername { get; private set; } public enum FieldType { Username, Email, Password } public static PlayerData Instance { get; private set; } public BackendReadWrites.Player Player => _player; private BackendReadWrites.Player _player = new BackendReadWrites.Player(); public string Token => _token; private string _token; private string _nickName; private bool _isDebug; private bool _isSteamInitialized; public void OnSteamInitialized() { _isSteamInitialized = true; SteamUsername = UserData.Me.Name; } public string GetPlayerName() { if (_isSteamInitialized) { return SteamUsername; } else { return Username; } } public void StoreUsername(string username) { if (_player.username == username) return; _player.username = username; UpdateVisualField(FieldType.Username, username); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_ID_KEY, username); } public void StorePassword(string password) { if (_player.password == password) return; _player.password = password; _playerRegisterData.password = password; UpdateVisualField(FieldType.Password, _playerRegisterData.password); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_PASSWORD, password); } public void StoreEmail(string email) { if (_player.email == email) return; _player.email = email; _playerRegisterData.email = email; UpdateVisualField(FieldType.Email, _playerRegisterData.email); PlayerPrefs.SetString(PLAYER_PREFS_EMAIL, email); } public void StoreToken(string token) { _token = token; PlayerPrefs.SetString(PLAYER_PREFS_TOKEN, token); MasterManager.Instance.SetToken(token); } private void UpdateVisualField(FieldType fieldType, string value) { switch (fieldType) { case FieldType.Username: _playerNameText.text = value; break; case FieldType.Email: _playerEmailText.text = value; break; case FieldType.Password: _playerPasswordText.text = value; break; } } public void LoadPlayerDataFromPlayerPrefs() { _playerRegisterData.email = PlayerPrefs.GetString(PLAYER_PREFS_EMAIL); _playerRegisterData.password = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_PASSWORD); Username = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_ID_KEY); UpdateVisualField(FieldType.Username, Username); UpdateVisualField(FieldType.Email, _playerRegisterData.email); UpdateVisualField(FieldType.Password, _playerRegisterData.password); Debug.Log($"Loaded player data from player prefs: {MyPlayerRegisterData.email}"); } public bool IsPlayerPersistInPlayerPrefs() { return PlayerPrefs.HasKey(PLAYER_PREFS_EMAIL) && PlayerPrefs.HasKey(PLAYER_PREFS_PLAYER_PASSWORD); } public void UpdateToken() { BackendReadWrites.Player player = new BackendReadWrites.Player(); player.email = MyPlayerRegisterData.email; player.password = MyPlayerRegisterData.password; LoginPlayer(player); } private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else { Destroy(gameObject); } } public void RegisterPlayer(BackendReadWrites.Player player) { Debug.Log($"_username: {player.username}; _password: {player.password}; _email: {player.email}"); if (IsUsingBackend) { BackendReadWrites.RegisterUser(player, (exception, response, body) => { bool isSuccessful = true; if (exception != null) { Debug.Log(exception.Message); return; } Debug.Log($"[RegisterPlayer] response: {response}, body: {body}"); if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(player.username); StorePassword(player.password); StoreEmail(player.email); StoreToken(token.access_token); OnPlayerLoggedIn?.Invoke(); Debug.Log($"token: {token}"); } }); } else { //generate unique id PlayerRegisterData playerRegisterData = new PlayerRegisterData(); playerRegisterData.email = Guid.NewGuid().ToString(); playerRegisterData.password = Guid.NewGuid().ToString(); //callback(playerRegisterData.ToString()); OnPlayerLoggedIn?.Invoke(); } } public void LoginPlayer(BackendReadWrites.Player player) { Debug.Log($"[PlayerData.LoginPlayer] _password: {player.password}; _email: {player.email}"); if (IsUsingBackend) { BackendReadWrites.Login(player, (exception, response, body) => { bool isSuccessful = true; if (exception != null) { Debug.Log($"[LoginPlayer] {exception.Message}"); if (exception.Message.Contains("HTTP/1.1 400 Bad Request")) { FlushPlayerPrefs(); GetOrCreatePlayerIdAndPassword(); } return; } Debug.Log($"[LoginPlayer] response: {response}, body: {body}"); if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(token.username); StorePassword(player.password); StoreEmail(player.email); StoreToken(token.access_token); OnPlayerLoggedIn?.Invoke(); Debug.Log($"token raw: {token}"); } }); } } private void GetOrCreatePlayerIdAndPassword() { Action<string> callback = (data) => { Debug.Log($"data raw: {data}"); PlayerRegisterData json = JsonConvert.DeserializeObject<PlayerRegisterData>(data); _playerRegisterData.email = json.email; _playerRegisterData.password = json.password; PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_ID_KEY, MyPlayerRegisterData.email); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_PASSWORD, MyPlayerRegisterData.password); OnPlayerIdAndPasswordLoaded?.Invoke(); }; if (!PlayerPrefs.HasKey(PLAYER_PREFS_PLAYER_ID_KEY)) { if (IsUsingBackend) { BackendReadWrites.Player _player = new BackendReadWrites.Player(); _player.username = MyPlayerRegisterData.email; _player.password = MyPlayerRegisterData.password; _player.email = MyPlayerRegisterData.email; BackendReadWrites.RegisterUser(_player, (exception, response, body) => { if (exception != null) { DebugWrite.LogError("Error registering user: " + exception.Message, gameObject, _isDebug); return; } DebugWrite.Log("User registered: " + body, gameObject, _isDebug); callback(body); }); } else { //generate unique id PlayerRegisterData playerRegisterData = new PlayerRegisterData(); playerRegisterData.email = Guid.NewGuid().ToString(); playerRegisterData.password = Guid.NewGuid().ToString(); callback(playerRegisterData.ToString()); } } else { _playerRegisterData.email = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_ID_KEY); _playerRegisterData.password = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_PASSWORD); } } /// <summary> /// Called from inspector button /// </summary> /// <param name="nickname"></param> public void OnClickSavePlayerData() { string newUsername = usernameInputField.text == "" ? _playerNameText.text : usernameInputField.text; string newEmail = _emailInputField.text == "" ? _playerEmailText.text : _emailInputField.text; string newPassword = _passwordInputField.text == "" ? _playerPasswordText.text : _passwordInputField.text; backendResponseStatusText.text = $"saving..."; BackendReadWrites.ChangePlayerData(_token, newUsername, newEmail, newPassword, (exception, response, body) => { if (exception != null) { Debug.LogError($"[OnClickSavePlayerData] {exception.Message}"); return; } else { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(newUsername); StorePassword(newPassword); StoreEmail(newEmail); StoreToken(token.access_token); SwitchSaveBtn(false); StartCoroutine(ShowStatus("saved!")); Debug.Log($"[OnClickSavePlayerData] response: {response}, body: {body}"); } }); } private IEnumerator ShowStatus(string saved) { backendResponseStatusText.text = $"{saved}"; yield return new WaitForSeconds(2f); backendResponseStatusText.text = String.Empty; } public void UnlockSaveButtonIfRequired() { bool isOn = usernameInputField.text != Username || _emailInputField.text != _playerRegisterData.email || _passwordInputField.text != _playerRegisterData.password; SwitchSaveBtn(isOn); } private void SwitchSaveBtn(bool isOn) { savePlayerDataBtn.interactable = isOn; } [Serializable] public class PlayerRegisterData { public string email; public string password; } public void FlushPlayerPrefs() { PlayerPrefs.DeleteAll(); }}} using System;using System.Collections.Generic;using System.Diagnostics;using System.Text;using _ZombieRoyale.Scripts.Clients;using Newtonsoft.Json;using Proyecto26;using SingletonsExtension;using UnityEngine;using UnityEngine.Networking;using UnityEngine.Serialization;using Debug = UnityEngine.Debug;namespace Backend{public static class BackendReadWrites{ #region open data public static readonly string BACKEND_URL = "https://astanagames.online/api/"; private static readonly string GET_ABILITY_STACKS = "character/get_ability_stacks/"; private static readonly string REGISTER_CHARACTER = "character/new-character"; private static readonly string CHARACTER_GET_SKIN = "character/get_skin/"; private static readonly string CHARACTER_GET_PLAYER_NAME = "character/get_player_name/"; private static readonly string GET_CHARACTER = "character/0"; private static readonly string GET_FIRST_CHARACTER = "character/server_get_first_character"; private static readonly string CHANGE_EMAIL_PASSWORD = "player/change_email_password/"; private static readonly string REGISTER_USER = "player/register/"; private static readonly string LOGIN_USER = "auth/login/"; private static readonly string GET_ALL_SERVERS = "server/get_all_servers"; private static readonly string GET_AVAILABLE_SERVERS = "server/get_servers_by_version/"; #if UNITY_EDITOR || UNITY_SERVER || UNITY_STANDALONE_LINUX private static readonly string HATHORA_GET_ROOM_ID = "https://api.hathora.dev/rooms/v2/";//"https://api.hathora.dev/rooms/v2/app-60bc431b-e9b7-4139-845d-2b9899e026cd/list/"; private static readonly string HATHORA_GET_CONNECTION_INFO = "https://api.hathora.dev/rooms/v2/";//"https://api.hathora.dev/rooms/v2/app-60bc431b-e9b7-4139-845d-2b9899e026cd/connectioninfo/"; private static readonly string HATHORA_TOKEN = "_Chky51qPZz-q7wz7YPcPZZrEeI8UoayOhnkG2CsSZdXf";//"jlZ-xwlRF8_3BufxnI1MEwHr57Mgm4G-wN3WGXJ6RMWDu"; private static readonly string SET_CHARACTER_ABILITY_STACKS = "character/set_ability_stacks/"; private static readonly string ADD_CHARACTER_INVENTORY = "character/add_inventory"; private static readonly string DELETE_CHARACTER_INVENTORY = "character/remove_inventory";#endif private static string GetMyProcessID() { // Gets the current process var currentProcess = Process.GetCurrentProcess(); // Returns the process ID as a string return currentProcess.Id.ToString(); } public static Action<CharacterSkinData> OnCharacterCreated; #endregion #region closed data#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX private static readonly string SAVE_USER_DATA_TO_BACKEND = "character/"; private static readonly string POST_REGISTER_SERVER = "server/register_server"; private static readonly string POST_UNREGISTER_SERVER = "server/unregister_server";#endif #endregion public static void GetPlayerNameBasedOnCharacterId(int id, Action<string> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $"{BACKEND_URL}{CHARACTER_GET_PLAYER_NAME}{id}" }; DefaultGetRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError("Error geting character: " + exception.Message); return; } Debug.Log($"[BackendReadWrites] GetPlayerNameBasedOnCharacterId for id #{id}: {body}"); callback?.Invoke(body); }); } public static void GetCharacterSkin(int id, Action<CharacterSkinData> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $"{BACKEND_URL}{CHARACTER_GET_SKIN}{id}" }; CharacterSkinData skinData = new CharacterSkinData(); DefaultGetRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError("Error geting character: " + exception.Message); return; } Debug.Log($"[BackendReadWrites] GetCharacterSkin for id #{id}: {body}"); skinData = JsonConvert.DeserializeObject<CharacterSkinData>(body); Debug.Log($"[BackendReadWrites] GetCharacterSkin check class: {skinData.ToString()}"); StringBuilder sb = new StringBuilder($"[BackendReadWrites] GetCharacterSkin for id #{id}: {skinData}"); callback?.Invoke(skinData); if (skinData.Id == 0) { sb.Append($"Character not found"); Debug.LogError(sb); } else { Debug.Log(sb); } }); } public static void SetAbilityStacks(string token, AbilityInfo[] abilityInfos, Action<int> callback) {#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX RequestHelper request = new RequestHelper { Uri = $"{BACKEND_URL}{SET_CHARACTER_ABILITY_STACKS}", BodyString = JsonConvert.SerializeObject(abilityInfos), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + token } }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? "success" : "Character not found!"; Debug.Log($"[BackendReadWrites.SetCharacterAbilityStacks] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}"); var requestException = new RequestException(error.Message); });#endif } public static void AddInventory(CharacterDataDTO characterData, Action<int> callback) {#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string secretKey = "SanatMadina";//Environment.GetEnvironmentVariable characterData.serverKey = secretKey; //async addInventory(@Body() characterData: CharacterDataDTO, secretKey: string): Promise<number> RequestHelper request = new RequestHelper { Uri = $"{BACKEND_URL}{ADD_CHARACTER_INVENTORY}", BodyString = JsonConvert.SerializeObject(characterData) }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? "success" : "Character not found!"; Debug.Log($"[BackendReadWrites.AddInventory] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($"[BackendReadWrites.AddInventory] {request.Uri} response error: {error.Message} {error.StackTrace}"); var requestException = new RequestException(error.Message); });#endif } public static void DeleteInventory(CharacterDataDTO characterData, Action<int> callback) {#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string secretKey = "SanatMadina";//Environment.GetEnvironmentVariable //async addInventory(@Body() characterData: CharacterDataDTO, secretKey: string): Promise<number> RequestHelper request = new RequestHelper { Uri = $"{BACKEND_URL}{DELETE_CHARACTER_INVENTORY}", BodyString = JsonConvert.SerializeObject(characterData), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + secretKey } }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? "success" : "Character not found!"; Debug.Log($"[BackendReadWrites.DeleteInventory] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($"[BackendReadWrites.DeleteInventory] {request.Uri} response error: {error.Message} {error.StackTrace}"); var requestException = new RequestException(error.Message); });#endif } public static void GetAbilityStacksForCharacter(int characterId, byte abilityId, Action<AbilityInfo> callback) { string url = $"{BACKEND_URL}{GET_ABILITY_STACKS}{characterId}/{abilityId}"; Debug.Log($"[BackendReadWrites] GetAbilityStacksForCharacter {url} for character #{characterId} and ability #{abilityId}"); RequestHelper requestHelper = new RequestHelper { Uri = $"{url}" }; DefaultGetRequest(requestHelper, (exception, response, body) => { AbilityInfo abilityInfo = new AbilityInfo(); abilityInfo.Id = abilityId; abilityInfo.Rank = 1; if (exception != null) { Debug.LogError("Error geting ability rank: " + exception.Message); callback?.Invoke(abilityInfo); return; } Debug.Log($"[BackendReadWrites] GetAbilityRankForPlayer for ability #{abilityId}: {body}"); abilityInfo = JsonConvert.DeserializeObject<AbilityInfo>(body); abilityInfo.Id = abilityId; abilityInfo.Rank = 1; callback?.Invoke(abilityInfo); }); } public static string RegisterCharacter(CharacterSkinData skinData) { string jsonBody = JsonConvert.SerializeObject(skinData); RequestHelper requestHelper = new RequestHelper { Uri = $"{BACKEND_URL}{REGISTER_CHARACTER}", BodyString = jsonBody, EnableDebug = true, Headers = new Dictionary<string, string>() { //authorization bearer token ["authorization"] = "Bearer " + PlayerData.Instance.Token // ["unique_user_id"] = playerRegisterData.unique_user_id, // ["password_hash"] = playerRegisterData.password_hash },// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError("Error registering character: " + exception.Message); return; } int responseInt = int.Parse(body); if (responseInt > 0) { Debug.Log("Character registered with id:" + body); skinData.Id = responseInt; OnCharacterCreated?.Invoke(skinData); }else { Debug.Log("Character not registered. Code #" + body); } }); return ""; } //https://hathora.dev/api#tag/RoomV2/operation/GetActiveRoomsForProcess public static void GetHathoraRoomId(Action<RequestException, ResponseHelper, string> callback) {#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string currentProcessHathoraId = Environment.GetEnvironmentVariable("HATHORA_PROCESS_ID"); string appId = Environment.GetEnvironmentVariable("HATHORA_APP_ID"); string token = Environment.GetEnvironmentVariable("HATHORA_APP_SECRET"); Debug.Log($"[BackendReadWrites] GetHathoraRoomId for process #{currentProcessHathoraId}; token: {token}"); RequestHelper requestHelper = new RequestHelper { Uri = $"{HATHORA_GET_ROOM_ID}{appId}/list/{currentProcessHathoraId}/active", Headers = new Dictionary<string, string>() { ["Authorization"] = "Bearer " + HATHORA_TOKEN}, }; RestClient.Get(requestHelper).Then(response => { Debug.Log($"[BackendReadWrites.GetHathoraRoomId] {requestHelper.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }); #endif } public static void GetHathoraConnectionInfo(string roomId, Action<RequestException, ResponseHelper, string> callback) {#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX Debug.Log($"[BackendReadWrites] GetHathoraConnectionInfo"); string appId = Environment.GetEnvironmentVariable("HATHORA_APP_ID"); RequestHelper requestHelper = new RequestHelper { Uri = $"{HATHORA_GET_CONNECTION_INFO}{appId}/connectioninfo/{roomId}", }; RestClient.Get(requestHelper).Then(response => { Debug.Log($"[BackendReadWrites.GetHathoraConnectionInfo] {requestHelper.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($"[BackendReadWrites.GetHathoraConnectionInfo] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}"); //callback?.Invoke(null, null, "error"); }); #endif } #region PlayerData public static void RegisterUser(Player playerData, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(playerData); RequestHelper requestHelper = new RequestHelper { Uri = $"{BACKEND_URL}{REGISTER_USER}", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { ["Authorization"] = "Bearer "},// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, callback); } public static void Login(Player playerData, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(playerData); RequestHelper requestHelper = new RequestHelper { Uri = $"{BACKEND_URL}{LOGIN_USER}", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { ["Authorization"] = "Bearer "},// + WebsiteRestConfig.Profile.token }; RestClient.Post(requestHelper).Then(response => { Debug.Log($"[BackendReadWrites.Login] {requestHelper.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($"[BackendReadWrites.Login] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, "error"); }) .Finally(() => { }); } public static void ChangePlayerData(string token, string newUsername, string newEmail, string newPassword, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(new { username = newUsername, email = newEmail, password = newPassword }); RequestHelper request = new RequestHelper { Uri = $"{BACKEND_URL}{CHANGE_EMAIL_PASSWORD}", BodyString = jsonBody, Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + token } }; RestClient.Post(request).Then(response => { Debug.Log($"[BackendReadWrites.ChangePlayerData] {response.StatusCode} {request.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, "error"); }) .Finally(() => { }); } #endregion //TODO: Create GetCharacterData to load several characters with several included tokens public static void GetCharacterData(string token, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BACKEND_URL}{GET_FIRST_CHARACTER}", Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + token } }; RestClient.Get(request).Then(response => { Debug.Log($"[BackendReadWrites.GetCharacterData] {response.StatusCode} {request.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}"); //callback?.Invoke(null, null, "error"); }) .Finally(() => { }); } public static void GetCharacterData(PlayerData.PlayerRegisterData playerRegisterData, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BACKEND_URL}{GET_CHARACTER}", BodyString = JsonConvert.SerializeObject(playerRegisterData), Headers = new Dictionary<string, string> { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; RestClient.Get(request).Then(response => { Debug.Log($"[BackendReadWrites.GetCharacterData] {response.StatusCode} {request.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}"); var requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, error.Message); }) .Finally(() => { }); } public static void AiDoDialog(string m_question, int m_asker, int m_answerer, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(new { question = m_question, asker = m_asker, answerer = m_answerer }); Debug.Log($"[BackendReadWrites.AiDoDialog] url: {BACKEND_URL}ai/do-dialog; jsonBody: {jsonBody}"); RequestHelper requestHelper = new RequestHelper { Uri = $"{BACKEND_URL}ai/do-dialog", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { ["Authorization"] = "Bearer "},// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, callback); } public static void GetAudioFile(string audioFilePath, string audioFileName, Action<AudioClip> onSuccess, Action<string> onError) { string url = $"{BACKEND_URL}audio"; var audioData = new { path = audioFilePath, filename = audioFileName + ".mp3" }; Debug.Log($"[BackendReadWrites.GetAudioFile] url: {url}, audioData: {audioData}"); string jsonBody = JsonConvert.SerializeObject(audioData); RestClient.Get(new RequestHelper { Uri = url, BodyString = jsonBody, DownloadHandler = new DownloadHandlerAudioClip(url, AudioType.MPEG) // Adjust AudioType based on your file format }).Then(response => { AudioClip audioClip = ((DownloadHandlerAudioClip)response.Request.downloadHandler).audioClip; onSuccess?.Invoke(audioClip); }).Catch(error => { onError?.Invoke(error.Message); }); } #region ServerData public static void RegisterServer(string JSON, Action<RequestException, ResponseHelper, string> callback) {#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX RequestHelper request = new RequestHelper { Uri = $"{BACKEND_URL}{POST_REGISTER_SERVER}", BodyString = JSON }; DefaultPostRequest(request, callback);#endif } public static void UnregisterServer(string JSON, Action<RequestException, ResponseHelper, string> callback) {#if UNITY_SERVER || UNITY_EDITOR RequestHelper request = new RequestHelper { Uri = $"{BACKEND_URL}{POST_REGISTER_SERVER}", BodyString = JSON }; DefaultPostRequest(request, callback);#endif } public static void GetServersByVersion(string version, Action<RequestException, ResponseHelper, string> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $"{BACKEND_URL}{GET_AVAILABLE_SERVERS}{version}", Timeout = 50, }; RestClient.Get(requestHelper).Then(response => { Debug.Log($"[BackendReadWrites.DefaultGetRequest] {requestHelper.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($"[BackendReadWrites.DefaultGetRequest] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, "error"); }); } #endregion #region Default Post/Get public static void DefaultPostRequestNoLogs(RequestHelper request, Action<RequestException, ResponseHelper, string> callback) { RestClient.Post(request).Then(response => { callback?.Invoke(null, response, response.Text); }) .Catch(error => { }); } public static void DefaultPostRequest(RequestHelper request, Action<RequestException, ResponseHelper, string> callback) { RestClient.Post(request).Then(response => { Debug.Log($"[BackendReadWrites.Post] {request.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($"[BackendReadWrites.Post] {request.Uri} response error: {error.Message} {error.StackTrace}"); //callback?.Invoke(null, null, "error"); }) .Finally(() => { }); } public static void DefaultGetRequest(RequestHelper request, Action<RequestException, ResponseHelper, string> callback) { RestClient.Get(request).Then(response => { Debug.Log($"[BackendReadWrites.DefaultGetRequest] {request.Uri} response success: {response.Text}"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($"[BackendReadWrites.DefaultGetRequest] {request.Uri} response error: {error.Message} {error.StackTrace}"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, "error"); }) .Finally(() => { }); } #endregion [Serializable] public class Player { public string username; public string password; public string email; } [Serializable] public class Token { public string username; public string access_token; } public class CharacterDataDTO { public int id; public SlotItem[] bank_items = new SlotItem[0]; public SlotItem[] backpack_items = new SlotItem[0]; public SlotItem[] equipment_items = new SlotItem[0]; public string serverKey; } [Serializable] public class SlotItem{ public int slotId; public int itemId; public int amount; }} } using System;using System.Collections.Generic;using System.Data;using UnityEngine;[CreateAssetMenu(fileName = "Stat", menuName = "ScriptableObjects/Stat")]public class Stat : DatabaseEntry{ [Header("-----BASE DATA-----")] [HideInInspector] public string _name; [HideInInspector] public string _fileName; [HideInInspector] public string displayName; [HideInInspector] public string description; [SerializeField] public STAT_TYPE statType; public bool minCheck; public float minValue; public bool maxCheck; public float maxValue; //A typical server-side SyncVar. //[SyncVar] public float baseValue; //A client-side SyncVar. //[field: SyncVar] public float baseValue { get; [ServerRpc] set; } public bool isShiftingInSprint = true; public bool isShiftingInBlock = true; public bool isShiftingOutsideCombat; public bool isShiftingInCombat; public float shiftAmountOutsideCombat; public float shiftIntervalOutsideCombat; public float shiftAmountInCombat; public float shiftIntervalInCombat; public float startPercentage = 100; public bool isPercentStat; public bool IsPersistent; [Tooltip("Example formule: (0.0006 * ARMOR) / (1 + 0.0006 * ARMOR)")] public string formula; // IMPORTANT!!!! New stats should be added only in the end of this list public enum STAT_TYPE { NONE = 0, ACCURACY = 1, ABILITY_ENERGY_SHIELD_ABSORBTIONS = 2, ABILITY_MAX_HIT = 3, ABILITY_TARGET_MAX_RANGE = 4, ABILITY_TARGET_MIN_RANGE = 5, ABSORBTION = 6, AGILITY = 7, AOE_RADIUS = 8, ARMOR = 9, ATTACK_SPEED = 10, BASE_DAMAGE_TYPE = 11, BASE_RESISTANCE_TYPE = 12, BLOCK_ACTIVE_ANGLE = 13, BLOCK_ACTIVE_CHARGE_TIME_SPEED_MODIFIER = 14, BLOCK_ACTIVE_COUNT = 15, BLOCK_ACTIVE_DECAY_MODIFIER = 16, BLOCK_ACTIVE_DURATION_MODIFIER = 17, BLOCK_ACTIVE_FLAT_AMOUNT = 18, BLOCK_ACTIVE_PERCENT_AMOUNT = 19, BLOCK_CHANCE = 20, BLOCK_FLAT = 21, BLOCK_MODIFIER = 22, BODY_SCALE = 23, CAST_SPEED = 24, CC_POWER = 25, CC_RESISTANCE = 26, CD_RECOVERY_SPEED = 27, CRITICAL_STRIKE_CHANCE = 28, CRITICAL_STRIKE_POWER = 29, DAMAGE = 30, DMG_DEALT = 31, DMG_TAKEN = 32, DODGE_CHANCE = 33, DOT_BONUS = 34, DURABILITY = 35, EFFECT_TRIGGER = 36, ENDURANCE = 37, EXPERIENCE_MODIFIER = 38, GCD_DURATION = 39, GLANCING_BLOW_CHANCE = 40, GLOBAL_HEALING = 41, HEAL_DONE = 42, HEAL_RECEIVED = 43, HEALING = 44, HEALTH_ON_BLOCK = 45, HEALTH_ON_HIT = 46, HEALTH_ON_KILL = 47, HOT_BONUS = 48, HUNGER = 49, INTELLECT = 50, LIFESTEAL = 51, LOOT_CHANCE_MODIFIER = 52, MINION_CRITICAL_STRIKE_CHANCE = 53, MINION_CRITICAL_STRIKE_POWER = 54, MINION_DAMAGE = 55, MINION_DODGE_CHANCE = 56, MINION_DURATION = 57, MINION_GLANCING_BLOW_CHANCE = 58, MINION_HEALTH_ON_BLOCK = 59, MINION_HEALTH_ON_HIT = 60, MINION_HEALTH_ON_KILL = 61, MINION_HEALTH = 62, MINION_LIFESTEAL = 63, MINION_MAGICAL_DAMAGE = 64, MINION_PHYSICAL_DAMAGE = 65, MINION_THORN = 66, MOVEMENT_SPEED = 67, PENETRATION = 68, PROJECTILE_ANGLE_SPREAD = 69, PROJECTILE_COUNT = 70, PROJECTILE_RANGE = 71, PROJECTILE_SPEED = 72, RELOADING = 73, RESISTANCE = 74, STRENGTH = 75, SUMMON_COUNT = 76, THORN = 77, VITALITY_BONUS = 78, VITALITY_REGEN = 79, XP = 80, CONSTITUTION = 81, Wisdom = 82, Charisma = 83, HEALTH = 84, MANA = 85, POISONED = 86, MAGIC_DAMAGE = 87, PHYSICAL_ARMOR = 88, MAGICAL_ARMOR = 89, POWER = 90, LEECH = 91, HASTE = 92, COOLDOWN_REDUCTION = 93, WEAPON_ANIMATION_TIME = 94, CRITICAL_STRIKE_CHANCE_RATING = 95, CRITICAL_STRIKE_POWER_RATING = 96, MOVE_SPEED_RATING = 97, LEECH_RATING = 98, COOLDOWN_REDUCTION_RATING = 99, HASTE_RATING = 100, RESILIENCE_GLOBULES_STACKS = 101, PARRY = 102, MAGICAL_ARMOR_RATING = 103, PHYSICAL_ARMOR_RATING = 104, CONSTITUTION_RATING = 105, HEALTH_REGEN = 106, HEALTH_REGEN_RATING = 107, } public float Calculate(Dictionary<STAT_TYPE, float> statValues) { if (string.IsNullOrEmpty(formula)) return baseValue; string expression = formula; foreach (var stat in statValues) { expression = expression.Replace(stat.Key.ToString(), stat.Value.ToString()); } return Evaluate(expression); } private float Evaluate(string expression) { var dataTable = new DataTable(); return Convert.ToSingle(dataTable.Compute(expression, string.Empty)); } } using System.Collections.Generic;using DuloGames.UI;using FishnetInvector;using UnityEngine;using UnityEngine.Serialization;namespace Invector.vItemManager{ [System.Serializable] public partial class vItem : ScriptableObject { #region SerializedProperties in customEditor public string Name => name; public int id; public string description = "Item Description"; public int Price; public vItemType type; //[System.NonSerialized] - causes icons not to be saved public Sprite icon; public bool stackable = true; public int maxStack; public int amount = 1; public GameObject originalObject; public GameObject dropObject; public List<vItemAttribute> attributes = new List<vItemAttribute>(); public bool isInEquipArea; public bool isEquiped; public bool isArmorItem; public int ArmorId; public int durability; public Rarity rarity = Rarity.Trash; public AbilityDefinition[] ActiveAbilities; #endregion public vItem(vItem item) { name = item.name; id = item.id; description = item.description; type = item.type; icon = item.icon; stackable = item.stackable; maxStack = item.maxStack; amount = item.amount; originalObject = item.originalObject; dropObject = item.dropObject; attributes = item.attributes; isInEquipArea = item.isInEquipArea; isEquiped = item.isEquiped; isArmorItem = item.isArmorItem; ArmorId = item.ArmorId; durability = item.durability; rarity = item.rarity; } public enum EquipAreaNames { mainHand, offHand, helmet, amulet, shoulders, chest, wrist, elbow, gloves, belt, pants, boots, ring, potions, cape, empty} public enum Rarity {Trash, Common, Uncommon, Rare, Epic, Legendary, Mythic, Unique} #region Properties in defaultInspector public bool destroyAfterUse = true; public bool canBeUsed = true; public bool canBeDroped = true; public bool canBeDestroyed = true; [Header("Animation Settings")] [vHelpBox("Triggers a animation when Equipping a Weapon or enabling item.\nYou can also trigger an animation if the ItemType is a Consumable")] public string EnableAnim = "LowBack"; [vHelpBox("Triggers a animation when Unequipping a Weapon or disable item")] public string DisableAnim = "LowBack"; [vHelpBox("Delay to enable the Weapon/Item object when Equipping\n If ItemType is a Consumable use this to delay the item usage.")] public float enableDelayTime = 0.5f; [vHelpBox("Delay to hide the Weapon/Item object when Unequipping")] public float disableDelayTime = 0.5f; [vHelpBox("If the item is equippable use this to set a custom handler to instantiate the SpawnObject")] public string customHandler; [vHelpBox("If the item is equippable and need to use two hand\n<color=yellow><b>This option makes it impossible to equip two items</b></color>")] public bool twoHandWeapon; public EquipAreaNames equipArea; [HideInInspector] public OnHandleItemEvent onDestroy; #endregion public ItemReference ToItemReference() { ItemReference itemReference = new ItemReference(id, amount, attributes); itemReference.amount = amount == 0 ? 1 : amount; itemReference.autoEquip = isEquiped; itemReference.addToEquipArea = isInEquipArea; return itemReference; } public void OnDestroy() { onDestroy.Invoke(this); } public bool IsItemHaveAbility(int id) { if (ActiveAbilities == null || ActiveAbilities.Length == 0) return false; return System.Array.Exists(ActiveAbilities, ability => ability.Id == id); } public string GetHolderAreaNameForBack() { switch (equipArea) { case EquipAreaNames.mainHand: return "RightArmBack"; case EquipAreaNames.offHand: return "LeftArmBack"; } Debug.LogError($"[vItem] GetHolderAreaNameForBack - equipArea: {equipArea} not found."); return ""; } public string GetHolderAreaName() { switch (equipArea) { case EquipAreaNames.mainHand: return "RightArm"; case EquipAreaNames.offHand: return "LeftArm"; } Debug.LogError($"[vItem] GetHolderAreaName() - equipArea: {equipArea} not found."); return ""; } /// <summary> /// Convert Sprite icon to texture /// </summary> public Texture2D iconTexture { get { if (!icon) return null; try { if (icon.rect.width != icon.texture.width || icon.rect.height != icon.texture.height) { Texture2D newText = new Texture2D((int)icon.textureRect.width, (int)icon.textureRect.height); newText.name = icon.name; Color[] newColors = icon.texture.GetPixels((int)icon.textureRect.x, (int)icon.textureRect.y, (int)icon.textureRect.width, (int)icon.textureRect.height); newText.SetPixels(newColors); newText.Apply(); return newText; } else return icon.texture; } catch { Debug.LogWarning("Icon texture of the " + name + " is not Readable", icon.texture); return icon.texture; } } } /// <summary> /// Get the Item Attribute via <seealso cref="vItemAttribute"/> /// </summary> /// <param name="attribute"></param> /// <returns></returns> public vItemAttribute GetItemAttribute(AttributeTypes attribute) { if (attributes != null) return attributes.Find(_attribute => _attribute.Type == attribute); return null; } public UIItemInfo ToUIItemInfo() { UIItemInfo uiItem = new UIItemInfo(); uiItem.ID = id; uiItem.Amount = amount; uiItem.Name = name; uiItem.Icon = icon; uiItem.Description = description; uiItem.rarity = rarity; uiItem.equipArea = equipArea; uiItem.ItemType = (int)type; uiItem.Subtype = type.ToString(); if (equipArea != EquipAreaNames.potions) uiItem.EquipType = GetEquipmentType(); if (GetItemAttribute(AttributeTypes.Damage) != null) uiItem.Damage = (int)GetItemAttribute(AttributeTypes.Damage).value; if (GetItemAttribute(AttributeTypes.Armor) != null) uiItem.Armor = GetItemAttribute(AttributeTypes.Armor).value; if (GetItemAttribute(AttributeTypes.Agility) != null) uiItem.Agility = GetItemAttribute(AttributeTypes.Agility).value; if (GetItemAttribute(AttributeTypes.Strength) != null) uiItem.Strength = GetItemAttribute(AttributeTypes.Strength).value; if (GetItemAttribute(AttributeTypes.Intellect) != null) uiItem.Intellect = GetItemAttribute(AttributeTypes.Intellect).value; if (GetItemAttribute(AttributeTypes.Constitution) != null) uiItem.Constitution = GetItemAttribute(AttributeTypes.Constitution).value; if (GetItemAttribute(AttributeTypes.Wisdom) != null) uiItem.Wisdom = GetItemAttribute(AttributeTypes.Wisdom).value; if (GetItemAttribute(AttributeTypes.Charisma) != null) uiItem.Charisma = GetItemAttribute(AttributeTypes.Charisma).value; return uiItem; } /// <summary> /// Get the Item Attribute via string /// </summary> /// <param name="name"></param> /// <returns></returns> public vItemAttribute GetItemAttribute(string name) { if (attributes != null) return attributes.Find(attribute => attribute.Type.ToString().Equals(name)); return null; } /// <summary> /// Get Selected Item Attributes via <seealso cref="vItemAttribute"/> by ignoring the ones you don't want /// </summary> /// <param name="ignore"></param> /// <returns></returns> public string GetItemAttributesText(List<AttributeTypes> ignore = null) { System.Text.StringBuilder text = new System.Text.StringBuilder(); for (int i = 0; i < attributes.Count; i++) { if (attributes[i].value == 0) continue; if (ignore == null || !ignore.Contains(attributes[i].Type)) text.AppendLine(GetItemAttributeText(i)); } return text.ToString(); } /// <summary> /// Get Item Attribute Text /// </summary> /// <param name="i"></param> /// <returns></returns> protected string GetItemAttributeText(int i) { if (attributes.Count > 0 && i < attributes.Count) { if (attributes.Count > 0 && i < attributes.Count) { return attributes[i].GetDisplayText(); } } return string.Empty; } /// <summary> /// Get Item Attribut Text with a custom Format to display /// </summary> /// <param name="i"></param> /// <param name="customFormat"></param> /// <returns></returns> protected string GetItemAttributeText(int i, string customFormat) { if (attributes.Count > 0 && i < attributes.Count) { return attributes[i].GetDisplayText(customFormat); } return string.Empty; } /// <summary> /// Get Default Item type text /// </summary> /// <returns></returns> public string ItemTypeText() { return ItemTypeText(type.DisplayFormat()); } /// <summary> /// Get Custom Item type text /// </summary> /// <param name="format"> Custom format for text </param> /// <returns></returns> public string ItemTypeText(string format) { var _text = format; var value = type.ToString().InsertSpaceBeforeUpperCase().RemoveUnderline(); if (string.IsNullOrEmpty(_text)) return value; else if (_text.Contains("(NAME)")) _text.Replace("(NAME)", value); return _text; } /// <summary> /// Get Item Full Description text including item Name, Type, Description and Attributes /// </summary> /// <param name="format">Custom format</param> /// <param name="ignoreAttributes">Attributes to ignore</param> /// <returns></returns> public string GetFullItemDescription(string format = null, List<AttributeTypes> ignoreAttributes = null) { string text = ""; if (string.IsNullOrEmpty(format)) { text += (name); text += "\n" + (ItemTypeText()); text += "\n" + (description); text += "\n" + (GetItemAttributesText()); } else { text = format; if (text.Contains("(NAME)")) text = text.Replace("(NAME)", name); if (text.Contains("(TYPE)")) text = text.Replace("(TYPE)", ItemTypeText()); if (text.Contains("(DESC)")) text = text.Replace("(DESC)", description); if (text.Contains("(ATTR)")) text = text.Replace("(ATTR)", GetItemAttributesText(ignoreAttributes)); } return text; } public FNvItemManager.ItemReferenceBackend ToItemReferenceBackend() { return new FNvItemManager.ItemReferenceBackend(this.id, this.amount, this.attributes, this.type); } public static string GetRarityHexColorCode(Rarity rarity) { switch (rarity) { case Rarity.Trash: return "#9d9d9d"; case Rarity.Common: return "#FFFFFF"; case Rarity.Uncommon: return "#1eff00"; case Rarity.Rare: return "#0070dd"; case Rarity.Epic: return "#a335ee"; case Rarity.Legendary: return "#ff8000"; case Rarity.Mythic: return "#dd0000"; case Rarity.Unique: return "#3fc7eb"; default: return "#FFFFFF"; } } public UIEquipmentType GetEquipmentType() { switch (equipArea) { case EquipAreaNames.helmet: return UIEquipmentType.Head; case EquipAreaNames.amulet: return UIEquipmentType.Necklace; case EquipAreaNames.shoulders: return UIEquipmentType.Shoulders; case EquipAreaNames.chest: return UIEquipmentType.Chest; case EquipAreaNames.ring: return UIEquipmentType.Finger; case EquipAreaNames.gloves: return UIEquipmentType.Gloves; case EquipAreaNames.wrist: return UIEquipmentType.Bracers; case EquipAreaNames.pants: return UIEquipmentType.Pants; case EquipAreaNames.boots: return UIEquipmentType.Boots; case EquipAreaNames.belt: return UIEquipmentType.Belt; case EquipAreaNames.mainHand: return UIEquipmentType.Weapon_MainHand; case EquipAreaNames.offHand: return UIEquipmentType.Weapon_OffHand; case EquipAreaNames.empty: return UIEquipmentType.None; } Debug.LogError($"[vItem] GetEquipmentType() - equipArea: {equipArea} not found."); return UIEquipmentType.None; } public static EquipAreaNames GetEquipAreaNames(UIEquipmentType type) { switch (type) { case UIEquipmentType.Head: return EquipAreaNames.helmet; case UIEquipmentType.Necklace: return EquipAreaNames.amulet; case UIEquipmentType.Shoulders: return EquipAreaNames.shoulders; case UIEquipmentType.Chest: return EquipAreaNames.chest; case UIEquipmentType.Finger: return EquipAreaNames.ring; case UIEquipmentType.Gloves: return EquipAreaNames.gloves; case UIEquipmentType.Bracers: return EquipAreaNames.wrist; case UIEquipmentType.Pants: return EquipAreaNames.pants; case UIEquipmentType.Boots: return EquipAreaNames.boots; case UIEquipmentType.Belt: return EquipAreaNames.belt; case UIEquipmentType.Weapon_MainHand: return EquipAreaNames.mainHand; case UIEquipmentType.Weapon_OffHand: return EquipAreaNames.offHand; } Debug.LogError($"[vItem] GetEquipAreaNames() - type: {type} not found."); return EquipAreaNames.potions; } public float GetAttributeValue(AttributeTypes type) { foreach (var attribute in attributes) { if (attribute.Type == type) { return attribute.value; } } return 0; } }} using UnityEngine;using UnityEngine.Events;using UnityEngine.EventSystems;using System;using System.Collections.Generic;using System.Text;using Invector.vItemManager;using SingletonsExtension;using TMPro;using Object = UnityEngine.Object;namespace DuloGames.UI{ [AddComponentMenu("UI/Icon Slots/Item Slot", 12)] public class UIItemSlot : UISlotBase, IUIItemSlot, IUISlotHasCooldown { [Serializable] public class OnRightClickEvent : UnityEvent<UIItemSlot> { } [Serializable] public class OnDoubleClickEvent : UnityEvent<UIItemSlot> { } [Serializable] public class OnAssignEvent : UnityEvent<UIItemSlot> { } [Serializable] public class OnAssignWithSourceEvent : UnityEvent<UIItemSlot, Object> { } [Serializable] public class OnUnassignEvent : UnityEvent<UIItemSlot> { } [SerializeField] private UIItemSlot_Group m_SlotGroup = UIItemSlot_Group.None; [SerializeField] private int m_ID = 0; [SerializeField] private TMProDecorator textAmount; public UISlotCooldown cooldownComponent { get { return this.m_Cooldown; } } private UISlotCooldown m_Cooldown; /// <summary> /// Gets or sets the slot group. /// </summary> /// <value>The slot group.</value> public UIItemSlot_Group slotGroup { get { return this.m_SlotGroup; } set { this.m_SlotGroup = value; } } /// <summary> /// Gets or sets the slot ID. /// </summary> /// <value>The I.</value> public int ID { get { return this.m_ID; } set { this.m_ID = value; } } public UIItemInfo ItemInfo => m_ItemInfo; /// <summary> /// The assigned item info. /// </summary> private UIItemInfo m_ItemInfo; /// <summary> /// The right click event delegate. /// </summary> public OnRightClickEvent onRightClick = new OnRightClickEvent(); /// <summary> /// The double click event delegate. /// </summary> public OnDoubleClickEvent onDoubleClick = new OnDoubleClickEvent(); /// <summary> /// The assign event delegate. /// </summary> public OnAssignEvent onAssign = new OnAssignEvent(); /// <summary> /// The assign with source event delegate. /// </summary> public OnAssignWithSourceEvent onAssignWithSource = new OnAssignWithSourceEvent(); /// <summary> /// The unassign event delegate. /// </summary> public OnUnassignEvent onUnassign = new OnUnassignEvent(); /// <summary> /// Gets the item info of the item assigned to this slot. /// </summary> /// <returns>The spell info.</returns> public UIItemInfo GetItemInfo() { return this.m_ItemInfo; } /// <summary> /// Determines whether this slot is assigned. /// </summary> /// <returns><c>true</c> if this instance is assigned; otherwise, <c>false</c>.</returns> public override bool IsAssigned() { return (this.m_ItemInfo != null); } /// <summary> /// Assign the slot by new item info while refering to the source. /// </summary> /// <param name="itemInfo">The item info.</param> /// <param name="source">The source slot (Could be null).</param> /// <returns><c>true</c> if this instance is assigned; otherwise, <c>false</c>.</returns> public bool Assign(UIItemInfo itemInfo, Object source) { if (itemInfo == null) return false; // Make sure we unassign first, so the event is called before new assignment this.Unassign(); StringBuilder sb = new StringBuilder($"[UIItemSlot] Assign: {itemInfo.Name}"); // Use the base class assign to set the icon this.Assign(itemInfo.Icon); if (itemInfo.Amount > 1) { sb.Append($" x{itemInfo.Amount}"); textAmount.SetText(itemInfo.Amount.ToString()); } // Set the spell info this.m_ItemInfo = itemInfo; Debug.Log(sb.ToString()); // Invoke the on assign event if (this.onAssign != null) this.onAssign.Invoke(this); // Invoke the on assign event if (this.onAssignWithSource != null) this.onAssignWithSource.Invoke(this, source); // Success return true; } /// <summary> /// Assign the slot by item info. /// </summary> /// <param name="itemInfo">The item info.</param> public bool Assign(UIItemInfo itemInfo) { return this.Assign(itemInfo, null); } /// <summary> /// Assign the slot by the passed source slot. /// </summary> /// <param name="source">Source.</param> public override bool Assign(Object source) { if (source is IUIItemSlot) { IUIItemSlot sourceSlot = source as IUIItemSlot; if (sourceSlot != null) return this.Assign(sourceSlot.GetItemInfo(), source); } // Default return false; } /// <summary> /// Unassign this slot. /// </summary> public override void Unassign() { // Remove the icon base.Unassign(); // Clear the spell info this.m_ItemInfo = null; // Invoke the on unassign event if (this.onUnassign != null) this.onUnassign.Invoke(this); } /// <summary> /// Determines whether this slot can swap with the specified target slot. /// </summary> /// <returns><c>true</c> if this instance can swap with the specified target; otherwise, <c>false</c>.</returns> /// <param name="target">Target.</param> public override bool CanSwapWith(Object target) { if (target is IUIItemSlot) { // Check if the equip slot accpets this item if (target is UIEquipSlot) { return (target as UIEquipSlot).CheckEquipType(this.GetItemInfo()); } // It's an item slot return true; } // Default return false; } // <summary> /// Performs a slot swap. /// </summary> /// <returns><c>true</c>, if slot swap was performed, <c>false</c> otherwise.</returns> /// <param name="sourceSlot">Source slot.</param> public override bool PerformSlotSwap(Object sourceObject) { // Get the source slot IUIItemSlot sourceSlot = (sourceObject as IUIItemSlot); // Get the source item info UIItemInfo sourceItemInfo = sourceSlot.GetItemInfo(); // Assign the source slot by this slot bool assign1 = sourceSlot.Assign(this.GetItemInfo(), this); // Assign this slot by the source slot bool assign2 = this.Assign(sourceItemInfo, sourceObject); // Return the status return (assign1 && assign2); } /// <summary> /// Raises the tooltip event. /// </summary> /// <param name="show">If set to <c>true</c> show.</param> public override void OnTooltip(bool show) { // Make sure we have spell info, otherwise game might crash if (this.m_ItemInfo == null) return; // If we are showing the tooltip if (show) { UITooltip.InstantiateIfNecessary(this.gameObject); // Prepare the tooltip UIItemSlot.PrepareTooltip(this.m_ItemInfo); // Anchor to this slot UITooltip.AnchorToRect(this.transform as RectTransform); // Show the tooltip UITooltip.Show(); } else { // Hide the tooltip UITooltip.Hide(); } } /// <summary> /// Raises the pointer click event. /// </summary> /// <param name="eventData">Event data.</param> public override void OnPointerClick(PointerEventData eventData) { base.OnPointerClick(eventData); // Make sure the slot is assigned if (!this.IsAssigned()) return; // Check for left double click if (eventData.button == PointerEventData.InputButton.Left && eventData.clickCount == 2) { // Reset the click count eventData.clickCount = 0; // Invoke the double click event if (this.onDoubleClick != null) this.onDoubleClick.Invoke(this); } // Check for right click if (eventData.button == PointerEventData.InputButton.Right) { // Invoke the double click event if (this.onRightClick != null) this.onRightClick.Invoke(this); } } /// <summary> /// This method is raised when the slot is denied to be thrown away and returned to it's source. /// </summary> protected override void OnThrowAwayDenied() { if (!this.IsAssigned()) return; if (UIModalBoxManager.Instance == null) { Debug.LogWarning("Could not load the modal box manager while creating a modal box."); return; } UIModalBox box = UIModalBoxManager.Instance.Create(this.gameObject); if (box != null) { box.SetText1("Do you really want to destroy \"" + this.m_ItemInfo.Name + "\"?"); box.SetText2("You wont be able to reverse this operation and your item will be permamently removed."); box.SetConfirmButtonText("DESTROY"); box.onConfirm.AddListener(Unassign); box.Show(); } } /// <summary> /// Unassign this slot. /// </summary> public void UnassignNoEvent() { // Remove the icon base.Unassign(); // Clear the spell info this.m_ItemInfo = null; } public UISpellInfo GetSpellInfo() { return null; //TODO: Implement this //return this.m_SpellInfo; } public void SetCooldownComponent(UISlotCooldown cooldown) { this.m_Cooldown = cooldown; } #region Static Methods /// <summary> /// Gets all the item slots. /// </summary> /// <returns>The slots.</returns> public static List<UIItemSlot> GetSlots() { List<UIItemSlot> slots = new List<UIItemSlot>(); UIItemSlot[] sl = Resources.FindObjectsOfTypeAll<UIItemSlot>(); foreach (UIItemSlot s in sl) { // Check if the slow is active in the hierarchy if (s.gameObject.activeInHierarchy) slots.Add(s); } return slots; } /// <summary> /// Gets all the item slots with the specified ID. /// </summary> /// <returns>The slots.</returns> /// <param name="ID">The slot ID.</param> public static List<UIItemSlot> GetSlotsWithID(int ID) { List<UIItemSlot> slots = new List<UIItemSlot>(); UIItemSlot[] sl = Resources.FindObjectsOfTypeAll<UIItemSlot>(); foreach (UIItemSlot s in sl) { // Check if the slow is active in the hierarchy if (s.gameObject.activeInHierarchy && s.ID == ID) slots.Add(s); } return slots; } /// <summary> /// Gets all the item slots in the specified group. /// </summary> /// <returns>The slots.</returns> /// <param name="group">The item slot group.</param> public static List<UIItemSlot> GetSlotsInGroup(UIItemSlot_Group group) { List<UIItemSlot> slots = new List<UIItemSlot>(); UIItemSlot[] sl = Resources.FindObjectsOfTypeAll<UIItemSlot>(); foreach (UIItemSlot s in sl) { // Check if the slow is active in the hierarchy if (s.gameObject.activeInHierarchy && s.slotGroup == group) slots.Add(s); } // Sort the slots by id slots.Sort(delegate (UIItemSlot a, UIItemSlot b) { return a.ID.CompareTo(b.ID); }); return slots; } /// <summary> /// Gets the slot with the specified ID and Group. /// </summary> /// <returns>The slot.</returns> /// <param name="ID">The slot ID.</param> /// <param name="group">The slot Group.</param> public static UIItemSlot GetSlot(int ID, UIItemSlot_Group group) { UIItemSlot[] sl = Resources.FindObjectsOfTypeAll<UIItemSlot>(); foreach (UIItemSlot s in sl) { // Check if the slow is active in the hierarchy if (s.gameObject.activeInHierarchy && s.ID == ID && s.slotGroup == group) return s; } return null; } /// <summary> /// Prepares the tooltip with the specified item info. /// </summary> /// <param name="itemInfo">Item info.</param> public static void PrepareTooltip(UIItemInfo itemInfo) { if (itemInfo == null) return; // Set the tooltip width if (UITooltipManager.Instance != null) UITooltip.SetWidth(UITooltipManager.Instance.itemTooltipWidth); // Set the title and description UITooltip.AddTitle("<color=#" + UIItemQualityColor.GetHexColor(itemInfo.Quality) + ">" + itemInfo.Name + "</color>"); // Spacer UITooltip.AddSpacer(); // Item types UITooltip.AddLineColumn(itemInfo.Type, "ItemAttribute"); UITooltip.AddLineColumn(itemInfo.Subtype, "ItemAttribute"); if (itemInfo.ItemType == (int)vItemType.MeleeWeapon || itemInfo.ItemType == (int)vItemType.ShooterWeapon) { UITooltip.AddLineColumn(itemInfo.Damage.ToString() + " Damage", "ItemAttribute"); UITooltip.AddLineColumn(itemInfo.AttackSpeed.ToString("0.0") + " Attack speed", "ItemAttribute"); UITooltip.AddLine("(" + ((float)itemInfo.Damage / itemInfo.AttackSpeed).ToString("0.0") + " damage per second)", "ItemAttribute"); } else if (itemInfo.ItemType == (int)vItemType.Armor) { if (itemInfo.Armor > float.Epsilon) UITooltip.AddLineColumn(itemInfo.Armor.ToString() + " Armor", "ItemAttribute"); if (itemInfo.Block > 0) UITooltip.AddLineColumn(itemInfo.Block.ToString() + " Block", "ItemAttribute"); } UITooltip.AddSpacer(); DrawStats(itemInfo); UITooltip.AddSpacer(); if (itemInfo.Durability > float.Epsilon) UITooltip.AddLine("Durability " + itemInfo.Durability + "/" + itemInfo.Durability, "ItemAttribute"); if (itemInfo.RequiredLevel > 0) UITooltip.AddLine("Requires Level " + itemInfo.RequiredLevel, "ItemAttribute"); // Set the item description if not empty if (!string.IsNullOrEmpty(itemInfo.Description)) { UITooltip.AddSpacer(); UITooltip.AddLine(itemInfo.Description, "ItemDescription"); } } private static void DrawStats(UIItemInfo itemInfo) { if (itemInfo.Stamina > float.Epsilon) UITooltip.AddLine($"+{itemInfo.Stamina} Stamina", "ItemStat"); if (itemInfo.Strength > float.Epsilon) UITooltip.AddLine("+" + itemInfo.Strength.ToString() + " Strength", "ItemStat"); if (itemInfo.Agility > float.Epsilon) UITooltip.AddLine("+" + itemInfo.Agility.ToString() + " Agility", "ItemStat"); if (itemInfo.Intellect > float.Epsilon) UITooltip.AddLine("+" + itemInfo.Intellect.ToString() + " Intellect", "ItemStat"); if (itemInfo.Constitution > float.Epsilon) UITooltip.AddLine("+" + itemInfo.Constitution.ToString() + " Constitution", "ItemStat"); if (itemInfo.Wisdom > float.Epsilon) UITooltip.AddLine("+" + itemInfo.Wisdom.ToString() + " Wisdom", "ItemStat"); if (itemInfo.Charisma > float.Epsilon) UITooltip.AddLine("+" + itemInfo.Charisma.ToString() + " Charisma", "ItemStat"); } #endregion public void UpdateAmount(int itemAmount) { if (itemAmount > 1) { textAmount.SetText(itemAmount.ToString()); } else { textAmount.SetText(""); } } }} using System;using System.Collections.Generic;using System.Linq;using _ZombieRoyale.Scripts.Clients;using Newtonsoft.Json;using Proyecto26;namespace Backend.BackendAuction{ public static class BackendAuction{ private static readonly string LIST_AUCTION_ITEM = "auction/list"; private static readonly string GET_AUCTIONED_ITEMS = "auction/items"; private static readonly string GET_AUCTION_ITEM_DETAILS = "auction/item/"; private static readonly string PLACE_BID = "auction/bid"; private static readonly string BUYOUT_ITEM = "auction/buyout"; private static readonly string GET_USER_AUCTIONED_ITEMS = "auction/user-items"; private static readonly string CANCEL_AUCTION = "auction/cancel"; private static readonly string GET_USER_BIDDING_HISTORY = "auction/bids"; private static readonly string GET_USER_PURCHASE_HISTORY = "auction/purchases"; private static readonly string SEARCH_AUCTION_ITEMS = "auction/search"; private static readonly string GET_MARKET_PRICES = "auction/market-prices"; private static readonly string BUY_MULTIPLE_ITEMS = "auction/buy-multiple"; public static void ListAuctionItem(AuctionListItemData data, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{LIST_AUCTION_ITEM}", BodyString = JsonConvert.SerializeObject(data), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultPostRequest(request, callback); } public static string ToQueryString(AuctionQueryData queryData) { var properties = from p in queryData.GetType().GetProperties() where p.GetValue(queryData, null) != null select p.Name + "=" + System.Web.HttpUtility.UrlEncode(p.GetValue(queryData, null).ToString()); return String.Join("&", properties.ToArray()); } public static void GetAuctionedItems(AuctionQueryData query, Action<RequestException, ResponseHelper, string> callback) { string queryString = ToQueryString(query); RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{GET_AUCTIONED_ITEMS}?{queryString}", Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultGetRequest(request, callback); } public static void GetAuctionItemDetails(string auctionId, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{GET_AUCTION_ITEM_DETAILS}{auctionId}", Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultGetRequest(request, callback); } public static void PlaceBid(AuctionBidData data, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{PLACE_BID}", BodyString = JsonConvert.SerializeObject(data), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultPostRequest(request, callback); } public static void BuyoutItem(AuctionBuyoutData data, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{BUYOUT_ITEM}", BodyString = JsonConvert.SerializeObject(data), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultPostRequest(request, callback); } public static void GetUserAuctionedItems(Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{GET_USER_AUCTIONED_ITEMS}", Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultGetRequest(request, callback); } public static void CancelAuction(AuctionCancelData data, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{CANCEL_AUCTION}", BodyString = JsonConvert.SerializeObject(data), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultPostRequest(request, callback); } public static void GetUserBiddingHistory(Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{GET_USER_BIDDING_HISTORY}", Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultGetRequest(request, callback); } public static void GetUserPurchaseHistory(Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{GET_USER_PURCHASE_HISTORY}", Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultGetRequest(request, callback); } public static void SearchAuctionItems(AuctionSearchData data, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{SEARCH_AUCTION_ITEMS}", BodyString = JsonConvert.SerializeObject(data), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultPostRequest(request, callback); } public static void GetMarketPrices(MarketPricesData data, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{GET_MARKET_PRICES}", BodyString = JsonConvert.SerializeObject(data), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultPostRequest(request, callback); } public static void BuyMultipleItems(BuyMultipleItemsData data, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $"{BackendReadWrites.BACKEND_URL}{BUY_MULTIPLE_ITEMS}", BodyString = JsonConvert.SerializeObject(data), Headers = new Dictionary<string, string>() { ["authorization"] = "Bearer " + PlayerData.Instance.Token } }; BackendReadWrites.DefaultPostRequest(request, callback); } // New data classes for auction API [Serializable] public class AuctionListItemData { public int itemId; public int amount; public float startingBid; public float buyoutPrice; public int duration; } [Serializable] public class AuctionQueryData { public int page; public string category; public string searchQuery; } [Serializable] public class AuctionBidData { public string auctionId; public float amount; } [Serializable] public class AuctionBuyoutData { public string auctionId; public int amount; } [Serializable] public class AuctionCancelData { public string auctionId; public int amount; } [Serializable] public class AuctionSearchData { public string searchQuery; public string itemType; public string slot; public string quality; public int level; public string[] stats; public int page; } [Serializable] public class MarketPricesData { public int itemId; } [Serializable] public class BuyMultipleItemsData { public List<AuctionBuyoutData> purchases; }}} using System.Collections.Generic;using Invector.vItemManager;using UnityEngine;using ScriptableObjectVariables;namespace SingletonsExtension {[CreateAssetMenu(menuName = "Assets/MasterManager")]//Only one copy for entire project public class MasterManager : SingletonScriptableObject<MasterManager> { [SerializeField] private vItemListData _itemListData; public vItemListData ItemListData => _itemListData; [SerializeField] private StatsLibrary _statsLibrary; public StatsLibrary StatsLibrary => _statsLibrary; [SerializeField] private AbilityDefinitionHolder _abilityDefinitionHolder; public AbilityDefinitionHolder AbilityDefinitionHolder => _abilityDefinitionHolder; // public const string KeyTalentsData = "Talents"; // public const string KeyIsGraphCantBeLaunched = "KeyIsGraphCantBeLaunched"; // public const string KeyIsNeedToCheckBeatsVisual = "KeyIsNeedToCheckBeatsVisual";//0 - graph, 1 - UI // public const string KeyOptionBeatsVisual = "KeyOptionBeatsVisual";//0 - graph, 1 - UI public bool IsClient => _IsClientVariableBool.Value; public bool IsServer => _IsServerVariableBool.Value; [SerializeField] private GameObject[] entityPrefabsPremadePlot; [SerializeField] private Transform _player; private bool _isServer; public bool IsPlayerPersist = false; public Vector3 GetPlayerPosition() => _player.transform.position; /// <summary> /// Variables: can be edited in editor and accessed from anywhere, values does not persist between game launches /// </summary> [Header("Variables:")] [SerializeField] private VariableString _userId; public string UserId => _userId.Value; public void SetUserId(int userId) { Debug.Log($"[MasterManager.SetUserId] userId: {userId}"); _userId.Value = userId.ToString(); } [SerializeField] private VariableString _userEmail; public string UserEmail => _userEmail.Value; public void SetUserEmail(string email) { Debug.Log($"[MasterManager.SetUserEmail] email: {email}"); _userEmail.Value = email; } [SerializeField] private VariableBool _IsClientVariableBool; [SerializeField] private VariableBool _IsServerVariableBool; //[field: SerializeField] public Channel3DPropertiesSO GlobalPositionalChannelProperties { get; private set; } [SerializeField] private Mesh[] _terrainsMeshes; /// <summary> /// impostors have lower tris, so we will keep them too /// </summary> [SerializeField] private Mesh[] _terrainsMeshesLowTris; [SerializeField] private Material[] _terrainsMaterials; [SerializeField] private VariableString _userName; public string UserName => _userName.Value; public void SetUsername(string username) { Debug.Log($"[MasterManager.SetUsername] username: {username}"); _userName.Value = username; } public string Token => _token; [SerializeField] private string _token; public void SetToken(string token) { Debug.Log($"[MasterManager.SetToken] token: {token}"); _token = token; } //[SerializeField] public VariableStringDictionaryInventory _inventoryConverter; public void SetLocalPlayerTransform(Transform trans) { Debug.Log($"[MasterManager.SetLocalPlayerTransform] name: {trans.name}"); IsPlayerPersist = true; _player = trans; } public void SetServer(bool isOn) => _IsServerVariableBool.Value = isOn; public void SetClient(bool isOn) => _IsClientVariableBool.Value = isOn; public Mesh[] GetTerrainsMeshes() => _terrainsMeshes; public Mesh[] GetTerrainMesheLowRes() => _terrainsMeshesLowTris; public Material[] GetTerrainMaterial() => _terrainsMaterials; public GameObject GetEntityPrefab(int id) => entityPrefabsPremadePlot[id]; // [SerializeField] PlayerData _playerData; // [SerializeField] DatabaseXP _databaseXP; // [SerializeField] MonsterData _monsterData; // [SerializeField] TalentsDB _talentsDB; // // public static AdmobScriptableObject AdmobManager { get {return Instance._admobManager;}} // public static PlayerData GetPlayerDataManager { get {return Instance._playerData;} } // public static DatabaseXP lDatabaseXP { get { return Instance._databaseXP; } } // public static MonsterData lMonsterData { get { return Instance._monsterData; } } // public static TalentsDB GetTalentsDB { get { return Instance._talentsDB; } } //public static bool isNoAdsOwned => _isNoAdsOwned.Value; //public static bool isHitCrit { get { return _isHitCrit.Value; } } // private void Awake() { // Debug.Log("MasterManager Awake"); // Instance._IsClientVariableBool.Value = false; // Instance.IsPlayerPersist = false; // } [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)] private static void FirstInitialize() { //AdmobManager.CustomAwake(); } public static vItem GetVItem(int itemID) { return Instance.ItemListData.GetItem(itemID); } }} using Invector;using System.Collections;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using UnityEditor;using UnityEngine;using Debug = UnityEngine.Debug;namespace Invector.vItemManager{ [CreateAssetMenu(menuName = "Invector/Inventory/New Item List")] public class vItemListData : ScriptableObject { public List<vItem> items = new List<vItem>(); public GameObject DefaultPickUpObject; public bool inEdition; public bool itemsHidden = true; public ItemRarityAttributesInfoHolder ItemRarityAttributesInfoHolder; public ItemVariantHolder ItemVariantHolder; private Dictionary<int, vItem> _itemDictionary = new Dictionary<int, vItem>(); public Dictionary<vItem.Rarity, List<int>> ItemDropChanceDictionary => _itemDropChanceDictionary; private Dictionary<vItem.Rarity, List<int>> _itemDropChanceDictionary; public enum SortType { Amount, Id }; public SortType sortType = 0; public vItem GetItem(int id) { if (_itemDictionary.Count == 0) { foreach (var item in items) { _itemDictionary.Add(item.id, item); } } if (_itemDictionary.ContainsKey(id)) { return _itemDictionary[id]; } else { Debug.LogError($"[vItemListData] Item with id {id} not found"); return null; } } public void CreateNCopies(vItem item, int howManyCopies) {#if UNITY_EDITOR for (int i = 0; i < howManyCopies; i++) { vItem newItem = AddNewItem(); newItem.name = item.name; newItem.amount = 1; newItem.description = item.description; newItem.dropObject = item.dropObject; newItem.equipArea = item.equipArea; newItem.icon = item.icon; newItem.isArmorItem = item.isArmorItem; newItem.ArmorId = item.ArmorId; newItem.maxStack = item.maxStack; newItem.originalObject = item.originalObject; newItem.stackable = item.stackable; newItem.rarity = item.rarity; newItem.type = item.type; List<vItemAttribute> generatedAttributes = GenerateRandomAttributes(newItem); newItem.attributes = generatedAttributes; newItem.hideFlags = HideFlags.HideInHierarchy; Debug.Log($"[ItemCreator] Created {newItem.name} with attributes: {string.Join(", ", generatedAttributes.Select(t => t.Type.ToString() + ": " + t.value.ToString()).ToArray())}"); }#endif } public void CreateNCopies(ItemVariant item, int howManyCopies) {#if UNITY_EDITOR Stopwatch stopwatch = new Stopwatch(); stopwatch.Start(); // Start the stopwatch timer foreach (var iconAndRarity in item.rarityIcons) { for (int i = 0; i < howManyCopies; i++) { vItem newItem = AddNewItem(); newItem.name = item.Name; newItem.amount = 1; newItem.description = item.description; newItem.dropObject = item.dropObject; newItem.equipArea = item.equipArea; newItem.icon = iconAndRarity.Icon; newItem.isArmorItem = item.isArmorItem; newItem.ArmorId = item.ArmorId; newItem.stackable = item.stackable; newItem.maxStack = item.maxStack; newItem.originalObject = item.originalObject; newItem.rarity = iconAndRarity.Rarity; newItem.type = item.type; List<vItemAttribute> generatedAttributes = GenerateRandomAttributes(newItem); newItem.attributes = generatedAttributes; newItem.hideFlags = HideFlags.HideInHierarchy; Debug.Log($"[CreateNCopies] Created {newItem.name} with attributes: {string.Join(", ", generatedAttributes.Select(t => t.Type.ToString() + ": " + t.value.ToString()).ToArray())}"); } } stopwatch.Stop(); // Stop the stopwatch timer Debug.Log($"Time taken to create {howManyCopies * item.rarityIcons.Count} items: {stopwatch.ElapsedMilliseconds / 1000} s"); #endif } private List<vItemAttribute> GenerateRandomAttributes(vItem newItem) { ItemRarityAttributesInfo rarityAttributesInfo = ItemRarityAttributesInfoHolder.GetItemRarityAttributesInfo(newItem.type, newItem.rarity); List<vItemAttribute> generatedAttributes = rarityAttributesInfo.GetAttributes(); return generatedAttributes; } public vItem AddNewItem() { vItem newItem = ScriptableObject.CreateInstance<vItem>(); newItem.name = "New Item"; newItem.id = GetUniqueID(); newItem.amount = 1; newItem.originalObject = DefaultPickUpObject; newItem.hideFlags = HideFlags.HideInHierarchy;#if UNITY_EDITOR AssetDatabase.AddObjectToAsset(newItem, AssetDatabase.GetAssetPath(this)); if (items.Exists(it => it.id.Equals(newItem.id))) newItem.id = GetUniqueID(); items.Add(newItem); OrderBy(); //serializedObject.ApplyModifiedProperties(); EditorUtility.SetDirty(this); AssetDatabase.SaveAssets();#endif return newItem; } public void RemoveLastNCopies(int howManyCopies) {#if UNITY_EDITOR for (int i = 0; i < howManyCopies; i++) { int index = items.Count - 1; var item = items[index]; items.RemoveAt(index); DestroyImmediate(item, true); } OrderBy(); AssetDatabase.SaveAssets(); //serializedObject.ApplyModifiedProperties(); EditorUtility.SetDirty(this); #endif } public void RemoveItem(int id) {#if UNITY_EDITOR vItem item = items.Find(i => i.id.Equals(id)); items.Remove(item); DestroyImmediate(item, true); OrderBy(); AssetDatabase.SaveAssets(); EditorUtility.SetDirty(this); #endif } public int GetUniqueID(int value = 0) { var result = value; for (int i = 0; i < items.Count + 1; i++) { var item = items.Find(t => t.id == i); if (item == null) { result = i; break; } } return result; } public void OrderByID() { if (items != null && items.Count > 0) { items = items.OrderBy(i => i.id).ToList(); } } public void OrderByAmount() { if (items != null && items.Count > 0) { items = items.OrderBy(i => i.amount).ToList(); } } public void OrderBy(int? index = null) { if( index!= null ) sortType = (SortType) index; switch (index) { case 0: OrderByAmount(); break; case 1: OrderByID(); break; } } public void IncreaseArmorIndex(int changeArmorIndexFromId, int changeArmorIndexToId) { foreach (var item in items) { if (item.id >= changeArmorIndexFromId && item.id <= changeArmorIndexToId) { item.ArmorId++; } } } public List<int> GetPossibleItemsForChance(float chance, out vItem.Rarity rarity) { InitDropChanceDictIfRequired(); rarity = BestRarityForRoll(chance); return ItemDropChanceDictionary[rarity]; } public List<int> GetPossibleItemsForRarity(vItem.Rarity rarity) { InitDropChanceDictIfRequired(); return ItemDropChanceDictionary[rarity]; } private void InitDropChanceDictIfRequired() { if (ItemDropChanceDictionary != null) return; _itemDropChanceDictionary = new Dictionary<vItem.Rarity, List<int>>(); foreach (var item in items) { int itemId = item.id; if (_itemDropChanceDictionary.ContainsKey(item.rarity)) { _itemDropChanceDictionary[item.rarity].Add(itemId); } else { _itemDropChanceDictionary.Add(item.rarity, new List<int> {itemId}); } } } public static vItem.Rarity BestRarityForRoll(float roll) { // if (roll <= 0.005f) { // return vItem.Rarity.Mythic; // } // else if (roll <= 0.01f) { // return vItem.Rarity.Legendary; // } if (roll <= 0.05f) { return vItem.Rarity.Epic; } else if (roll <= 0.1f) { return vItem.Rarity.Rare; } else if (roll <= 0.15f) { return vItem.Rarity.Uncommon; } else if (roll <= 0.2f) { return vItem.Rarity.Common; }else { return vItem.Rarity.Trash; } } public static float DropChance(vItem.Rarity rarity) { switch (rarity) { case vItem.Rarity.Trash: return .3f; case vItem.Rarity.Common: return .2f; case vItem.Rarity.Uncommon: return .15f; case vItem.Rarity.Rare: return .1f; case vItem.Rarity.Epic: return .05f; case vItem.Rarity.Legendary: return .005f; case vItem.Rarity.Mythic: return .001f; default: return .0f; } } }} using Invector;using System.Collections;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using UnityEditor;using UnityEngine;using Debug = UnityEngine.Debug;namespace Invector.vItemManager{ [CreateAssetMenu(menuName = "Invector/Inventory/New Item List")] public class vItemListData : ScriptableObject { public List<vItem> items = new List<vItem>(); public GameObject DefaultPickUpObject; public bool inEdition; public bool itemsHidden = true; public ItemRarityAttributesInfoHolder ItemRarityAttributesInfoHolder; public ItemVariantHolder ItemVariantHolder; private Dictionary<int, vItem> _itemDictionary = new Dictionary<int, vItem>(); public Dictionary<vItem.Rarity, List<int>> ItemDropChanceDictionary => _itemDropChanceDictionary; private Dictionary<vItem.Rarity, List<int>> _itemDropChanceDictionary; public enum SortType { Amount, Id }; public SortType sortType = 0; public vItem GetItem(int id) { if (_itemDictionary.Count == 0) { foreach (var item in items) { _itemDictionary.Add(item.id, item); } } if (_itemDictionary.ContainsKey(id)) { return _itemDictionary[id]; } else { Debug.LogError($"[vItemListData] Item with id {id} not found"); return null; } } public void CreateNCopies(vItem item, int howManyCopies) {#if UNITY_EDITOR for (int i = 0; i < howManyCopies; i++) { vItem newItem = AddNewItem(); newItem.name = item.name; newItem.amount = 1; newItem.description = item.description; newItem.dropObject = item.dropObject; newItem.equipArea = item.equipArea; newItem.icon = item.icon; newItem.isArmorItem = item.isArmorItem; newItem.ArmorId = item.ArmorId; newItem.maxStack = item.maxStack; newItem.originalObject = item.originalObject; newItem.stackable = item.stackable; newItem.rarity = item.rarity; newItem.type = item.type; List<vItemAttribute> generatedAttributes = GenerateRandomAttributes(newItem); newItem.attributes = generatedAttributes; newItem.hideFlags = HideFlags.HideInHierarchy; Debug.Log($"[ItemCreator] Created {newItem.name} with attributes: {string.Join(", ", generatedAttributes.Select(t => t.Type.ToString() + ": " + t.value.ToString()).ToArray())}"); }#endif } public void CreateNCopies(ItemVariant item, int howManyCopies) {#if UNITY_EDITOR Stopwatch stopwatch = new Stopwatch(); stopwatch.Start(); // Start the stopwatch timer foreach (var iconAndRarity in item.rarityIcons) { for (int i = 0; i < howManyCopies; i++) { vItem newItem = AddNewItem(); newItem.name = item.Name; newItem.amount = 1; newItem.description = item.description; newItem.dropObject = item.dropObject; newItem.equipArea = item.equipArea; newItem.icon = iconAndRarity.Icon; newItem.isArmorItem = item.isArmorItem; newItem.ArmorId = item.ArmorId; newItem.stackable = item.stackable; newItem.maxStack = item.maxStack; newItem.originalObject = item.originalObject; newItem.rarity = iconAndRarity.Rarity; newItem.type = item.type; List<vItemAttribute> generatedAttributes = GenerateRandomAttributes(newItem); newItem.attributes = generatedAttributes; newItem.hideFlags = HideFlags.HideInHierarchy; Debug.Log($"[CreateNCopies] Created {newItem.name} with attributes: {string.Join(", ", generatedAttributes.Select(t => t.Type.ToString() + ": " + t.value.ToString()).ToArray())}"); } } stopwatch.Stop(); // Stop the stopwatch timer Debug.Log($"Time taken to create {howManyCopies * item.rarityIcons.Count} items: {stopwatch.ElapsedMilliseconds / 1000} s"); #endif } private List<vItemAttribute> GenerateRandomAttributes(vItem newItem) { ItemRarityAttributesInfo rarityAttributesInfo = ItemRarityAttributesInfoHolder.GetItemRarityAttributesInfo(newItem.type, newItem.rarity); List<vItemAttribute> generatedAttributes = rarityAttributesInfo.GetAttributes(); return generatedAttributes; } public vItem AddNewItem() { vItem newItem = ScriptableObject.CreateInstance<vItem>(); newItem.name = "New Item"; newItem.id = GetUniqueID(); newItem.amount = 1; newItem.originalObject = DefaultPickUpObject; newItem.hideFlags = HideFlags.HideInHierarchy;#if UNITY_EDITOR AssetDatabase.AddObjectToAsset(newItem, AssetDatabase.GetAssetPath(this)); if (items.Exists(it => it.id.Equals(newItem.id))) newItem.id = GetUniqueID(); items.Add(newItem); OrderBy(); //serializedObject.ApplyModifiedProperties(); EditorUtility.SetDirty(this); AssetDatabase.SaveAssets();#endif return newItem; } public void RemoveLastNCopies(int howManyCopies) {#if UNITY_EDITOR for (int i = 0; i < howManyCopies; i++) { int index = items.Count - 1; var item = items[index]; items.RemoveAt(index); DestroyImmediate(item, true); } OrderBy(); AssetDatabase.SaveAssets(); //serializedObject.ApplyModifiedProperties(); EditorUtility.SetDirty(this); #endif } public void RemoveItem(int id) {#if UNITY_EDITOR vItem item = items.Find(i => i.id.Equals(id)); items.Remove(item); DestroyImmediate(item, true); OrderBy(); AssetDatabase.SaveAssets(); EditorUtility.SetDirty(this); #endif } public int GetUniqueID(int value = 0) { var result = value; for (int i = 0; i < items.Count + 1; i++) { var item = items.Find(t => t.id == i); if (item == null) { result = i; break; } } return result; } public void OrderByID() { if (items != null && items.Count > 0) { items = items.OrderBy(i => i.id).ToList(); } } public void OrderByAmount() { if (items != null && items.Count > 0) { items = items.OrderBy(i => i.amount).ToList(); } } public void OrderBy(int? index = null) { if( index!= null ) sortType = (SortType) index; switch (index) { case 0: OrderByAmount(); break; case 1: OrderByID(); break; } } public void IncreaseArmorIndex(int changeArmorIndexFromId, int changeArmorIndexToId) { foreach (var item in items) { if (item.id >= changeArmorIndexFromId && item.id <= changeArmorIndexToId) { item.ArmorId++; } } } public List<int> GetPossibleItemsForChance(float chance, out vItem.Rarity rarity) { InitDropChanceDictIfRequired(); rarity = BestRarityForRoll(chance); return ItemDropChanceDictionary[rarity]; } public List<int> GetPossibleItemsForRarity(vItem.Rarity rarity) { InitDropChanceDictIfRequired(); return ItemDropChanceDictionary[rarity]; } private void InitDropChanceDictIfRequired() { if (ItemDropChanceDictionary != null) return; _itemDropChanceDictionary = new Dictionary<vItem.Rarity, List<int>>(); foreach (var item in items) { int itemId = item.id; if (_itemDropChanceDictionary.ContainsKey(item.rarity)) { _itemDropChanceDictionary[item.rarity].Add(itemId); } else { _itemDropChanceDictionary.Add(item.rarity, new List<int> {itemId}); } } } public static vItem.Rarity BestRarityForRoll(float roll) { // if (roll <= 0.005f) { // return vItem.Rarity.Mythic; // } // else if (roll <= 0.01f) { // return vItem.Rarity.Legendary; // } if (roll <= 0.05f) { return vItem.Rarity.Epic; } else if (roll <= 0.1f) { return vItem.Rarity.Rare; } else if (roll <= 0.15f) { return vItem.Rarity.Uncommon; } else if (roll <= 0.2f) { return vItem.Rarity.Common; }else { return vItem.Rarity.Trash; } } public static float DropChance(vItem.Rarity rarity) { switch (rarity) { case vItem.Rarity.Trash: return .3f; case vItem.Rarity.Common: return .2f; case vItem.Rarity.Uncommon: return .15f; case vItem.Rarity.Rare: return .1f; case vItem.Rarity.Epic: return .05f; case vItem.Rarity.Legendary: return .005f; case vItem.Rarity.Mythic: return .001f; default: return .0f; } } }}

# TASK: 1)Fix AuctionController script to use vItem instead itemDatabase and keep in mind that uiitemslot uses item id from vItem; that will use BackendAuction api calls, map it to specific buttons that will be stored in their fields with full logic to cover this functionality description: Я захожу во вкладку "Аукцион". В окне "Аукцион" я вижу свой инвентарь в одной части экрана, а в другой части экрана вижу окно Аукцион. Снизу (или сверху, или справа, или слева, неважно) я вижу три вкладки: "Купить", "Продать", "Мои лоты". Я хочу продать свой предмет, для этого я нажимаю правой кнопкой мыши на предмет в своём инвентаре, который хочу продать. После этого окно Аукцион переходит из вкладки "Купить" во вкладку "Продать". Во вкладке "Продать" начинают отображаться все лоты по этому предмету. Если предмет, который я хочу продать, расходуемый, т.е. зелья, свитки и так далее, то в окне Аукцион я вижу все лоты по своему предмету. Предметы сгруппированы по своей выкупной стоимости. В первую очередь я вижу предметы с наименьшей стоимостью. Я вижу каждую стоимость предмета и дорогую и дешевую и вижу количество продаваемого предмета по стоимости. Я вижу, что самый дешевый вариант продажи - это продажа по стоимости 22 голды, но данная цена меня не устраивает, тем более я вижу, что по данной стоимости всего 5 штук зелий, я хочу выбрать цену подороже, и выбираю в списке самую популярную стоимость - 24 голды. По этой стоимости продаётся 18 785 штук зелья лечения. Выбрав эту стоимость из списка, в отдельном месте окна аукциона отобразилась стоимость продажи.
Я могу её скорректировать, и вместо 24 голд, продать предметы за 25 голды. Далее я вижу длительность лота - 12 часов, я могу поставить больше - 48 часов, но это увеличило комиссию аукциона, которая отображается чуть ниже. Теперь я хочу продать предмет экипировки - плечи 130 уровня предметов с вторичными характеристиками Leech и CDR (COOLDOWN_REDUCTION). Я также нажимаю в окне своего инвентаря правой кнопкой мыши на эти плечи и они сразу перетаскивается во вкладку Продать. Здесь предметы не группируются по стоимости. Они никак не группируются, продаваясь в одном экземпляре каждый. Окно Аукцион не отображает мне все плечи, и даже не все плечи с Leech и COOLDOWN_REDUCTION одного уровня предметов, оно отображает мне все плечи, которые дают Leech и COOLDOWN_REDUCTION, что и мои плечи. В итоге я вижу разные уровни предметов. Все также сортировано по стоимости. Логично, что самые верхние лоты - это низкоуровневые плечи с Leech и COOLDOWN_REDUCTION. Я возле стоимости предмета вижу уровень предмета, поэтому для меня не составляет труда найти 130 уровень предмета моих плечей. Я просто жму левую кнопку мыши на этот экземпляр моих плечей и жму кнопку Продать.
Теперь я хочу купить "Зелье Скорости". У меня в инвентаре уже есть зелья скорости. Я жму Shift+LMB на зелья скорости в своём инвентаре и окно Аукцион автоматически из вкладки Продать переходит во вкладку Купить, где в поисковике уже вбито "Зелье Скорости". Игра отобразила все предметы, которые по названию похожи на "Зелье Скорости". Выбрав интересующий для меня предмет, а именно "Зелье Скорости" редкого качества, окно Аукцион отобразило мне все лоты с зельями скорости редкого качества. Они также как было во вкладке Продать сгруппированы по стоимости. Я просто пишу сколько я хочу купить, т.е. 26 штук. Написав 26, окно Аукцион отобразило мне сколько денег я потрачу, а в другой части окна Аукцион у меня подсветилось, что я покупаю по 4 разным ценам: 2 по цене 15 gold, 14 по цене 16 gold, 7 по стоимости 18 gold и 3 по стоимости 24 gold. Игра автоматически выбрала самые дешевые варианты покупки. Я не могу купить по самой дорогой цене зелья скорости, игра не позволяет мне этого сделать. Я нажимаю кнопку Купить и сразу получаю эти предметы в свой инвентарь, если есть свободные слоты, если свободных слотов нет, то они должны падать в банк, если и там нет, то аукцион должен выдать ошибку что нет свободных слотов и не дать мне купить.
Далее я хочу купить "Dragon Stamina Helm". У меня есть два варианта как найти его. Первый просто написать в поисковик "Dragon S" и найти в предложенном списке интересующий меня шлем, либо вторым вариантом я могу использовать фильтры, а именно нажать "Броня" --> "Голова", затем задать вторичные характеристики. Я помню, что этот шлем давал Haste и CRITICAL_CHANCE. забив эти статы, я увидел сразу же мой шлем. Нажав на него, открылся список всех этих шлемов, они также как и во вкладке Продать не сгруппированы вообще никак. Я вижу их уровни предметов. В данном случае меня интересует 180 уровень этого шлема. Я поскролил вниз, потому что лоты отсортированы по стоимости, и логично что дешевле всего будут самые слабые шлемы. Найдя интересующий шлем, я просто выкупил его. # BACKEND CODE: import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, OneToMany, CreateDateColumn } from "typeorm"; import { Character } from "./character.entity"; import { Item } from "./item.entity"; import { Bid } from "./Bid.entity";  @Entity('auction') export class Auction {     @PrimaryGeneratedColumn()     id: number;      @ManyToOne(() => Character, character => character.listedAuctions)     seller: Character;      @ManyToOne(() => Item)     item: Item;      @Column()     quantity: number;      @Column()     startingBid: number;      @Column()     buyoutPrice: number;      @Column()     duration: number;      @CreateDateColumn()     createdAt: Date;      @Column({ default: false })     isCancelled: boolean;      @Column({ default: false })     isCompleted: boolean;      @OneToMany(() => Bid, bid => bid.auction)     bids: Bid[]; }import { Entity, PrimaryGeneratedColumn, Column, ManyToOne } from "typeorm"; import { AiNpc } from "./AiNpc.entity"; import { Character } from "./character.entity";  @Entity('bankItem') export class BankItem {     @PrimaryGeneratedColumn()     id: number;      @Column({default: 0})     slotId: number;      @Column({default: 0})     itemId: number;      @Column({default: 0})     quantity: number;            }import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, CreateDateColumn } from "typeorm"; import { Character } from "./character.entity"; import { Auction } from "./auction.entity";  @Entity('bid') export class Bid {     @PrimaryGeneratedColumn()     id: number;      @ManyToOne(() => Character, character => character.bids)     bidder: Character;      @ManyToOne(() => Auction, auction => auction.bids)     auction: Auction;      @Column()     amount: number;      @CreateDateColumn()     createdAt: Date; }import { Entity, Column, PrimaryGeneratedColumn, OneToMany, OneToOne, ManyToMany, ManyToOne, JoinColumn, JoinTable } from 'typeorm'; import { Item } from './item.entity'; import { DialogueHistory } from './DialogueHistory.entity'; import { Player } from './Player.entity'; import { Equipment } from './equipment.entity'; import { Race } from './race.entity'; import { Profession } from './profession.entity'; import { Skill } from './skill.entity'; import { Like } from './like.entity'; import { Faction } from './faction.entity'; import { RelationshipsCharacter } from './RelationshipsCharacter.entity'; import { AiNpc } from './AiNpc.entity'; import { CharacterStats } from './characterStats.entity'; import { Proficiency } from './proficiency.entity'; import { Dislike } from './dislike.entity'; import { BankItem } from './bankItem.entity'; import { InventoryItem } from './inventoryItems.entity'; import { AbilityInfo } from './abilityInfo.entity'; import { Auction } from './Auction.entity'; import { Bid } from './Bid.entity';  @Entity('character') export class Character {   @PrimaryGeneratedColumn()   id: number;    @OneToOne(() => AiNpc, (ainpc) => ainpc.character, { nullable: true, eager: true })   @JoinColumn({ name: "ai_npc_id" })   ainpc: AiNpc;    @Column({ nullable: true })   token: string;    @Column({ default: "D&D" })   realm: string;      @Column({ default: "" })   backstory: string;    @Column({ default: "" })   name: string;    @Column({ default: 0 })   genderId: number;    @Column({ default: 0 })   skinColorId: number;    @Column({ default: 0 })   beardId: number;    @Column({ default: 0 })   bodyArtId: number;    @Column({ default: 0 })   faceId: number;    @Column({ default: 0 })   hairId: number;    @Column({ default: 0 })   hairColorId: number;    @Column({ nullable: true })   age: number;    @Column({default: ""})   charClass: string;    @Column({ default: 0 })   level: number;    @Column({default: 0})   xp: number;    @Column({ default: 0 })   gold: number;    @Column({type: "decimal", precision: 5, scale: 2, default: 0})   health: number;    @Column({type: "decimal", precision: 5, scale: 2, default: 0})   mana: number;    @Column({type: "decimal", precision: 5, scale: 2, default: 0})   stamina: number;    @OneToOne(() => CharacterStats, (stats) => stats.character, { nullable: true, eager: true })   @JoinColumn({name: "stats_id"})   stats: CharacterStats;    @ManyToMany(() => Proficiency, (p) => p.characters, {nullable: true})   @JoinTable()   proficiencies: Proficiency[];    @OneToMany(() => Race, (race) => race.character)   race: Race[];    @ManyToMany(() => Faction, (f) => f.characters, {nullable: true})   @JoinTable()   factions: Faction[];    @OneToMany(() => Profession, (profession) => profession.character)   profession: Profession[];    @OneToMany(() => Skill, (skill) => skill.character)   skills: Skill[];    @OneToMany(() => AbilityInfo, (abilityInfo) => abilityInfo.character)   @JoinColumn({name: "ability_info_id"})   abilities: AbilityInfo[];       @OneToMany(() => Item, (slotItem) => slotItem.characterBank)   bank_items: Item[];       @OneToMany(() => Item, item => item.characterBackpack)   backpack_items: Item[];       @OneToMany(() => Item, (equipment) => equipment.characterBank)   equipment_items: Item[];    @Column("int", { array: true, default: [] })   skill_ids: number[];    @OneToMany(() => Like, (like) => like.characterLikes)   likes: Like[];    @OneToMany(() => Dislike, (dislike) => dislike.characterDislikes)   dislikes: Dislike[];    @ManyToOne(() => Player, (player) => player.character, { nullable: true, eager: true })   player: Player;    @Column("int", { array: true, default: [] })   item_ids: number[];    @OneToMany(() => DialogueHistory, (dialogueHistory) => dialogueHistory.sender)   sentMessages: DialogueHistory[];    @OneToMany(() => DialogueHistory, (dialogueHistory) => dialogueHistory.recipient)   receivedMessages: DialogueHistory[];    @Column("int", { array: true, default: [] })   equipment_ids: number[];    @OneToMany(() => RelationshipsCharacter, (relationship) => relationship.me)   relationsAsMe: RelationshipsCharacter[];    @OneToMany(() => RelationshipsCharacter, (relationship) => relationship.to)   relationsAsTo: RelationshipsCharacter[];    @Column({type: "decimal", precision: 5, scale: 2, default: 0})   x: number;    @Column({type: "decimal", precision: 5, scale: 2, default: 0})   y: number;    @Column({type: "decimal", precision: 5, scale: 2, default: 0})   z: number;    @Column({type: "decimal", precision: 5, scale: 2, default: 0})   rotation: number;    @OneToMany(() => Auction, auction => auction.seller)     listedAuctions: Auction[];      @OneToMany(() => Bid, bid => bid.bidder)     bids: Bid[]; }import { Entity, PrimaryGeneratedColumn, Column, ManyToOne } from "typeorm"; import { AiNpc } from "./AiNpc.entity"; import { Character } from "./character.entity";  @Entity('inventory_item') export class InventoryItem {     @PrimaryGeneratedColumn()     id: number;      @Column({default: 0})     slotId: number;      @Column({default: 0})     itemId: number;      @Column({default: 0})     quantity: number;      @ManyToOne(() => Character, (character) => character.backpack_items)     character: Character; }import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, OneToMany, OneToOne } from 'typeorm'; import { Character } from './character.entity'; import { ItemRarity } from './itemRarity.entity'; import { Equipment } from './equipment.entity'; import { ItemStats } from './itemStats.entity'; import { Auction } from './Auction.entity';  @Entity('item') export class Item {   @PrimaryGeneratedColumn()   id: number;    @Column({ default: '' })   name: string;    @Column({ default: 0 })   itemId: number;    @Column({default: 1})   amount: number;    @Column({ default: "" })   description: string;    @Column({ default: 0 })   price: number;    @Column({type: "decimal", precision: 5, scale: 2, default: 0})   weight: number;    @Column({ default: false })   isInBank: boolean;    @Column({ default: false })   isInTrade: boolean;    @OneToOne(() => ItemStats, stats => stats.item)   stats: ItemStats;    @ManyToOne(() => Character, character => character.backpack_items, { nullable: true })   characterBackpack: Character;    @ManyToOne(() => Character, character => character.bank_items, { nullable: true })   characterBank: Character;    @ManyToOne(() => Character, character => character.equipment_items, { nullable: true })   characterEquipment: Character;    @ManyToOne(() => ItemRarity, rarity => rarity.items)   rarity: ItemRarity;    @OneToMany(() => Equipment, equipment => equipment.item)   equipment: Equipment[];    @OneToMany(() => Auction, auction => auction.item)     auctions: Auction[]; }import { Entity, PrimaryGeneratedColumn, Column, Index, OneToOne, ManyToOne, JoinColumn, OneToMany, BeforeInsert } from "typeorm" import { Item } from "./item.entity"; import { Character } from "./character.entity";  @Entity('player') export class Player {     @PrimaryGeneratedColumn()     id: number;      @Column({ default: "" })     username: string;      @Column({ unique: true })     email: string;      @Column()     password: string;      @OneToMany(() => Character, (character) => character.player)     character: Character[];      @OneToMany(() => Item, item => item.characterBank)     inventory: Item[]; }import { Controller, Post, Get, Delete, Body, Param, Query, UseGuards } from '@nestjs/common'; import { AuctionService } from './auction.service'; import { AuthGuard } from '../auth/auth.guard';  @Controller('auction') @UseGuards(AuthGuard) export class AuctionController {   constructor(private readonly auctionService: AuctionService) {}    @Post('list')   listItem(@Body() listItemDto: any) {     return this.auctionService.listItem(listItemDto);   }    @Get('items')   getAuctionedItems(@Query() query: any) {     return this.auctionService.getAuctionedItems(query);   }    @Get('item/:auctionId')   getItemDetails(@Param('auctionId') auctionId: string) {     return this.auctionService.getItemDetails(auctionId);   }    @Post('bid')   placeBid(@Body() bidDto: any) {     return this.auctionService.placeBid(bidDto);   }    @Post('buyout')   buyoutItem(@Body() buyoutDto: any) {     return this.auctionService.buyoutItem(buyoutDto);   }    @Get('user-items')   getUserAuctionedItems(@Body('token') token: string) {     return this.auctionService.getUserAuctionedItems(token);   }    @Delete('cancel')   cancelAuction(@Body() cancelDto: any) {     return this.auctionService.cancelAuction(cancelDto);   }    @Get('bids')   getUserBiddingHistory(@Body('token') token: string) {     return this.auctionService.getUserBiddingHistory(token);   }    @Get('purchases')   getUserPurchaseHistory(@Body('token') token: string) {     return this.auctionService.getUserPurchaseHistory(token);   }    @Get('search')   searchItems(@Body() searchDto: any) {     return this.auctionService.searchItems(searchDto);   }    @Get('market-prices')   getMarketPrices(@Body() marketPricesDto: any) {     return this.auctionService.getMarketPrices(marketPricesDto);   }    @Post('buy-multiple')   buyMultipleItems(@Body() buyMultipleDto: any) {     return this.auctionService.buyMultipleItems(buyMultipleDto);   } }import { Module } from '@nestjs/common'; import { TypeOrmModule } from '@nestjs/typeorm'; import { AuctionController } from './auction.controller'; import { AuctionService } from './auction.service'; import { Auction } from '../../entities/Auction.entity'; import { Character } from '../../entities/character.entity'; import { Item } from '../../entities/item.entity'; import { Bid } from '../../entities/Bid.entity';  @Module({   imports: [TypeOrmModule.forFeature([Auction, Character, Item, Bid])],   controllers: [AuctionController],   providers: [AuctionService], }) export class AuctionModule {}import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository } from 'typeorm'; import { Auction } from '../../entities/Auction.entity'; import { Character } from '../../entities/character.entity'; import { Item } from '../../entities/item.entity'; import { Bid } from '../../entities/Bid.entity';  @Injectable() export class AuctionService {   constructor(     @InjectRepository(Auction)     private auctionRepository: Repository<Auction>,     @InjectRepository(Character)     private characterRepository: Repository<Character>,     @InjectRepository(Item)     private itemRepository: Repository<Item>,     @InjectRepository(Bid)     private bidRepository: Repository<Bid>   ) {}    async listItem(listItemDto: any) {     const character = await this.characterRepository.findOne({ where: { id: listItemDto.token } });     if (!character) throw new NotFoundException('Character not found');      const item = await this.itemRepository.findOne({ where: { id: listItemDto.itemId } });     if (!item) throw new NotFoundException('Item not found');      const auction = this.auctionRepository.create({       seller: character,       item: item,       quantity: listItemDto.amount,       startingBid: listItemDto.startingBid,       buyoutPrice: listItemDto.buyoutPrice,       duration: listItemDto.duration     });      await this.auctionRepository.save(auction);      return { status: 'success', auctionId: auction.id };   }    async getAuctionedItems(query: any) {     const queryBuilder = this.auctionRepository.createQueryBuilder('auction')       .leftJoinAndSelect('auction.item', 'item')       .where('auction.isCompleted = :isCompleted', { isCompleted: false })       .andWhere('auction.isCancelled = :isCancelled', { isCancelled: false });      if (query.category) {       queryBuilder.andWhere('item.category = :category', { category: query.category });     }      if (query.searchQuery) {       queryBuilder.andWhere('item.name LIKE :searchQuery', { searchQuery: `%${query.searchQuery}%` });     }      const auctions = await queryBuilder       .skip((query.page - 1) * 10)       .take(10)       .getMany();      return { status: 'success', items: auctions };   }    async getItemDetails(auctionId: string) {     const auction = await this.auctionRepository.findOne({        where: { id: parseInt(auctionId) },       relations: ['item', 'bids']     });      if (!auction) throw new NotFoundException('Auction not found');      return { status: 'success', item: auction };   }    async placeBid(bidDto: any) {     const auction = await this.auctionRepository.findOne({        where: { id: parseInt(bidDto.auctionId) },       relations: ['bids']     });      if (!auction) throw new NotFoundException('Auction not found');      if (auction.buyoutPrice <= bidDto.amount) {       return this.buyoutItem({ token: bidDto.token, auctionId: bidDto.auctionId });     }      const highestBid = Math.max(...auction.bids.map(bid => bid.amount), auction.startingBid);      if (bidDto.amount <= highestBid) {       throw new BadRequestException('Bid amount must be higher than the current highest bid');     }      const character = await this.characterRepository.findOne({ where: { id: bidDto.token } });     if (!character) throw new NotFoundException('Character not found');      const newBid = this.bidRepository.create({       bidder: character,       auction: auction,       amount: bidDto.amount     });      await this.bidRepository.save(newBid);      return { status: 'success', currentBid: bidDto.amount };   }    async buyoutItem(buyoutDto: any) {     const auction = await this.auctionRepository.findOne({        where: { id: parseInt(buyoutDto.auctionId) },       relations: ['item', 'seller']     });      if (!auction) throw new NotFoundException('Auction not found');      const buyer = await this.characterRepository.findOne({ where: { id: buyoutDto.token } });     if (!buyer) throw new NotFoundException('Buyer not found');      if (buyer.gold < auction.buyoutPrice) {       throw new BadRequestException('Not enough gold');     }      const amountToBuy = buyoutDto.amount || auction.quantity;      if (amountToBuy > auction.quantity) {       throw new BadRequestException('Not enough items in the auction');     }      buyer.gold -= auction.buyoutPrice * amountToBuy;     auction.seller.gold += auction.buyoutPrice * amountToBuy;     auction.quantity -= amountToBuy;      if (auction.quantity === 0) {       auction.isCompleted = true;     }      await this.characterRepository.save(buyer);     await this.characterRepository.save(auction.seller);     await this.auctionRepository.save(auction);      return {        status: 'success',        purchasedAmount: amountToBuy,        remainingAmount: auction.quantity      };   }    async getUserAuctionedItems(token: string) {     const character = await this.characterRepository.findOne({ where: { token: token },       relations: ['listedAuctions']     });      if (!character) throw new NotFoundException('Character not found');      return { status: 'success', items: character.listedAuctions };   }    async cancelAuction(cancelDto: any) {     const auction = await this.auctionRepository.findOne({        where: { id: parseInt(cancelDto.auctionId) },       relations: ['seller']     });      if (!auction) throw new NotFoundException('Auction not found');      if (auction.seller.id !== cancelDto.token) {       throw new BadRequestException('You can only cancel your own auctions');     }      const amountToCancel = cancelDto.amount || auction.quantity;      if (amountToCancel > auction.quantity) {       throw new BadRequestException('Cannot cancel more than the auctioned amount');     }      auction.quantity -= amountToCancel;      if (auction.quantity === 0) {       auction.isCancelled = true;     }      await this.auctionRepository.save(auction);      return {        status: 'success',        cancelledAmount: amountToCancel,        remainingAmount: auction.quantity      };   }    async getUserBiddingHistory(token: string) {     const character = await this.characterRepository.findOne({        where: { token: token },       relations: ['bids', 'bids.auction', 'bids.auction.item']     });      if (!character) throw new NotFoundException('Character not found');      return { status: 'success', bids: character.bids };   }    async getUserPurchaseHistory(token: string) {          throw new Error('Method not implemented.');   }    async searchItems(searchDto: any) {     const queryBuilder = this.itemRepository.createQueryBuilder('item')       .leftJoinAndSelect('item.auctions', 'auction')       .where('auction.isCompleted = :isCompleted', { isCompleted: false })       .andWhere('auction.isCancelled = :isCancelled', { isCancelled: false });      if (searchDto.searchQuery) {       queryBuilder.andWhere('item.name LIKE :searchQuery', { searchQuery: `%${searchDto.searchQuery}%` });     }      if (searchDto.itemType) {       queryBuilder.andWhere('item.type = :itemType', { itemType: searchDto.itemType });     }      if (searchDto.slot) {       queryBuilder.andWhere('item.slot = :slot', { slot: searchDto.slot });     }      if (searchDto.quality) {       queryBuilder.andWhere('item.quality = :quality', { quality: searchDto.quality });     }      if (searchDto.level) {       queryBuilder.andWhere('item.level = :level', { level: searchDto.level });     }      if (searchDto.stats && searchDto.stats.length > 0) {       searchDto.stats.forEach((stat, index) => {         queryBuilder.andWhere(`item.stats LIKE :stat${index}`, { [`stat${index}`]: `%${stat}%` });       });     }      const items = await queryBuilder       .skip((searchDto.page - 1) * 10)       .take(10)       .getMany();      return { status: 'success', items: items };   }    async getMarketPrices(marketPricesDto: any) {     const queryBuilder = this.auctionRepository.createQueryBuilder('auction')       .leftJoinAndSelect('auction.item', 'item')       .where('item.id = :itemId', { itemId: marketPricesDto.itemId })       .andWhere('auction.isCompleted = :isCompleted', { isCompleted: false })       .andWhere('auction.isCancelled = :isCancelled', { isCancelled: false })       .select('auction.buyoutPrice', 'price')       .addSelect('SUM(auction.quantity)', 'quantity')       .groupBy('auction.buyoutPrice')       .orderBy('auction.buyoutPrice', 'ASC');      const prices = await queryBuilder.getRawMany();      const item = await this.itemRepository.findOne({ where: { id: marketPricesDto.itemId } });      return {        status: 'success',        item_name: item.name,       prices: prices     };   }    async buyMultipleItems(buyMultipleDto: any) {     const buyer = await this.characterRepository.findOne({ where: { id: buyMultipleDto.token } });     if (!buyer) throw new NotFoundException('Buyer not found');      let totalCost = 0;     const purchasedItems = [];     const failedPurchases = [];      for (const purchase of buyMultipleDto.purchases) {       const auction = await this.auctionRepository.findOne({          where: { id: parseInt(purchase.auctionId) },         relations: ['item', 'seller']       });        if (!auction || auction.isCompleted || auction.isCancelled) {         failedPurchases.push({ auctionId: purchase.auctionId, reason: 'Auction not available' });         continue;       }        if (purchase.quantity > auction.quantity) {         failedPurchases.push({ auctionId: purchase.auctionId, reason: 'Not enough items in the auction' });         continue;       }        const cost = auction.buyoutPrice * purchase.quantity;       if (buyer.gold < totalCost + cost) {         failedPurchases.push({ auctionId: purchase.auctionId, reason: 'Not enough gold' });         continue;       }        totalCost += cost;       auction.quantity -= purchase.quantity;       auction.seller.gold += cost;        if (auction.quantity === 0) {         auction.isCompleted = true;       }        purchasedItems.push({         auction_id: auction.id,         item_id: auction.item.id,         quantity: purchase.quantity,         price_per_unit: auction.buyoutPrice       });        await this.auctionRepository.save(auction);       await this.characterRepository.save(auction.seller);     }      buyer.gold -= totalCost;     await this.characterRepository.save(buyer);      return {       status: 'success',       total_cost: totalCost,       purchased_items: purchasedItems,       failed_purchases: failedPurchases     };   }    async checkInventorySpace(token: string, itemId: number, quantity: number) {     const character = await this.characterRepository.findOne({        where: { token: token },       relations: ['backpack_items', 'bank_items']     });      if (!character) throw new NotFoundException('Character not found');      const item = await this.itemRepository.findOne({ where: { id: itemId } });     if (!item) throw new NotFoundException('Item not found');      const inventorySlots = this.calculateRequiredSlots(character.backpack_items, item, quantity);     const bankSlots = this.calculateRequiredSlots(character.bank_items, item, quantity);      return {       status: 'success',       has_space: inventorySlots > 0 || bankSlots > 0,       inventory_slots: inventorySlots,       bank_slots: bankSlots     };   }    private calculateRequiredSlots(items: Item[], newItem: Item, quantity: number): number {          const existingStack = items.find(item => item.itemId === newItem.itemId);     if (existingStack) {       return Math.max(0, quantity - (existingStack.amount % newItem.amount));     }     return Math.ceil(quantity / newItem.amount);   } }import { Controller, Post, Body, Headers, Get, UseGuards, Request, Param, ParseIntPipe, UnauthorizedException } from '@nestjs/common'; import { Character } from 'src/entities/character.entity'; import { CharacterService } from './character.service'; import { AuthGuard } from '../auth/auth.guard'; import { PlayerService } from '../player/player.service'; import { AbilityInfoDTO, AppearanceDTO, CharacterDataDTO } from './dto';  @Controller('character') export class CharacterController {   constructor(     private readonly characterService: CharacterService,     private readonly playerService: PlayerService     ) {}    @UseGuards(AuthGuard)   @Post('new-character')   async registerCharacter(@Request() req, @Body() appearanceDto: AppearanceDTO) {     const player = await this.playerService.findUserByEmail(req.user.email);     return await this.characterService.registerCharacterWithAppearance(player, appearanceDto);   }    @UseGuards(AuthGuard)   @Get(':id')   async getCharacter(@Request() req, @Param('id', ParseIntPipe) id: number) {     const player = await this.playerService.findUserByEmail(req.user.email);     return await this.characterService.findCharacterById(player, id);   }    @Get('get_skin/:id')   async getCharacterSkin(@Param('id', ParseIntPipe) id: number) {     return await this.characterService.getCharacterSkin(id);   }    @Get('get_player_name/:id')   async getPlayerName(@Param('id', ParseIntPipe) id: number): Promise<string> {     return await this.characterService.getPlayerNameByCharacterId(id);   }    @Get('get_ability_stacks/:characterId/:abilityId')   async getCharacterAbilityStacks(       @Param('characterId', ParseIntPipe) characterId: number,        @Param('abilityId', ParseIntPipe) abilityId: number     ): Promise<AbilityInfoDTO> {     return await this.characterService.getCharacterAbilityStacks(characterId, abilityId);   }    @Post('add_inventory')   async addInventory(@Body() characterData: CharacterDataDTO): Promise<number> {     console.log(`characterData: ${characterData.backpack_items}; ${characterData.bank_items}; ${characterData.equipment_items}`);     const secretKey = 'SanatMadina';     if (characterData.serverKey !== secretKey) {       throw new UnauthorizedException('Invalid secret key');     }      return await this.characterService.addInventory(characterData);   }    @Post('remove_inventory')   async removeInventory(     @Body() characterData: CharacterDataDTO,     @Headers('authorization') authHeader: string     ): Promise<number> {     const secretKey = 'SanatMadina';     const token = authHeader?.split(' ')[1];      if (token !== secretKey) {       throw new UnauthorizedException('Invalid secret key');     }      return await this.characterService.deleteInventory(characterData);   }     @UseGuards(AuthGuard)   @Post('set_ability_stacks')   async setCharacterAbilityStacks(@Request() req, @Body() abilityInfos: AbilityInfoDTO[]): Promise<number> {     const player = await this.playerService.findUserByEmail(req.user.email);     return await this.characterService.setCharacterAbilityStacks(player, abilityInfos);   }    @UseGuards(AuthGuard)   @Get('server_get_first_character')   async getFirstCharacter(@Request() req) {     const player = await this.playerService.findUserByEmail(req.user.email);     return await this.characterService.getFirstCharacter(player);   } }import { Module } from '@nestjs/common'; import { TypeOrmModule } from '@nestjs/typeorm'; import { CharacterController } from './character.controller'; import { CharacterService } from './character.service'; import { PlayerService } from '../player/player.service'; import { Character } from 'src/entities/character.entity'; import { Player } from 'src/entities/Player.entity'; import { JwtModule } from '@nestjs/jwt'; import { jwtConstants } from 'src/modules/auth/constants'; import { AbilityInfo } from 'src/entities/abilityInfo.entity'; import { Item } from 'src/entities/item.entity';  @Module({   imports: [     TypeOrmModule.forFeature([Character, Player, AbilityInfo, Item]),     JwtModule.register({        secret: jwtConstants.secret,       signOptions: { expiresIn: '7d' },      }),   ],   controllers: [CharacterController],   providers: [CharacterService, PlayerService], }) export class CharacterModule {} import { Injectable } from '@nestjs/common'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository } from 'typeorm'; import { Character } from 'src/entities/character.entity'; import { Player } from 'src/entities/Player.entity'; import { AppearanceDTO, CharacterDataDTO, CharacterSkinData, AbilityInfoDTO, SlotItem } from './dto'; import { AbilityInfo } from 'src/entities/abilityInfo.entity'; import { Item } from 'src/entities/item.entity';  @Injectable() export class CharacterService {   constructor(     @InjectRepository(Player)     private PlayerRepository: Repository<Player>,     @InjectRepository(Character)     private CharacterRepository: Repository<Character>,     @InjectRepository(AbilityInfo)     private AbilityInfoRepository: Repository<AbilityInfo>,     @InjectRepository(Item)     private ItemRepository: Repository<Item>,   ) {}    private log(method: string , message: string) {     console.log(`[CharacterService][${method}] ${new Date().toLocaleString()}: ${message}`);   }    async registerCharacterWithAppearance(_player: Player, appearanceDto: AppearanceDTO) {     const newCharacter = new Character();     newCharacter.genderId = appearanceDto.genderId;     newCharacter.skinColorId = appearanceDto.skinColorId;     newCharacter.hairColorId = appearanceDto.hairColorId;     newCharacter.beardId = appearanceDto.beardId;     newCharacter.bodyArtId = appearanceDto.bodyArtId;     newCharacter.faceId = appearanceDto.faceId;     newCharacter.hairId = appearanceDto.hairId;     newCharacter.player = _player;     const savedChar = await this.CharacterRepository.save(newCharacter);          if (savedChar) {       return savedChar.id;     }     return 0;   }    async getPlayerNameByCharacterId(id: number): Promise<string> {          const character = await this.CharacterRepository.findOne({       where: { id: id },       relations: ['player'],     });           if (character && character.player) {       this.log('getPlayerNameByCharacterId', `found player: ${character.player.id}; for id: ${id}; username: ${character.player.username}`);       return character.player.username;     }           return "";   }    async getCharacterSkin(id: number): Promise<CharacterSkinData>{     const character = await this.CharacterRepository.findOne({ where: { id: id } });     const characterSkinData = new CharacterSkinData();     if (character) {       characterSkinData.genderId = character.genderId;       characterSkinData.skinColorId = character.skinColorId;       characterSkinData.beardId = character.beardId;       characterSkinData.bodyArtId = character.bodyArtId;       characterSkinData.faceId = character.faceId;       characterSkinData.hairId = character.hairId;       characterSkinData.hairColorId = character.hairColorId;     }     return characterSkinData;   }    async getCharacterAbilityStacks(characterId: number, abilityId: number): Promise<AbilityInfoDTO> {     const character = await this.CharacterRepository.findOne({ where: { id: characterId } });     this.log('getCharacterAbilityStacks', `found character id: ${character.id}; faceId: ${character.faceId}; genderId: ${character.genderId}; skinColorId: ${character.skinColorId}; beardId: ${character.beardId}; bodyArtId: ${character.bodyArtId}; hairId: ${character.hairId}; hairColorId: ${character.hairColorId}`);     const abilityInfoDTO = new AbilityInfoDTO();     if (character) {       const charAbilities = await this.AbilityInfoRepository.find({ where: { character: character } });       if (charAbilities == null) {         this.log('getCharacterAbilityStacks', `character abilities is null`);         return abilityInfoDTO;       }        for (const abilityInfo of charAbilities) {         if (abilityInfo.abilityId === abilityId) {           abilityInfoDTO.Stacks = abilityInfo.stacks;           this.log('getCharacterAbilityStacks', `generated answer: ${abilityInfoDTO}`);           return abilityInfoDTO;         }       }        this.log('getCharacterAbilityStacks', `generated answer: ${abilityInfoDTO}`);     }     return abilityInfoDTO;   }    async setCharacterAbilityStacks(_player: Player, abilityInfos: AbilityInfoDTO[]) {     const characterData = await this.getFirstCharacter(_player);     if (characterData != -1) {       const character = await this.CharacterRepository.findOneBy( { id: characterData.id });       const charAbilities = await this.AbilityInfoRepository.find({ where: { character: character } });        if (charAbilities == null) {         for (const abilityInfo of abilityInfos) {           this.addNewAbilityToCharacter(character, abilityInfo.Stacks, abilityInfo.Id);         }         return 2;       }else{         for (const abilityInfo of abilityInfos) {           let found = false;           charAbilities.forEach((abilityInfoFromDB) => {             if (abilityInfoFromDB.abilityId !== abilityInfo.Id){               return;              }              found = true;             this.AbilityInfoRepository.update(abilityInfoFromDB.id, { stacks: abilityInfo.Stacks });           });                      if (found) {             continue;            }           this.addNewAbilityToCharacter(character, abilityInfo.Stacks, abilityInfo.Id);         }         return 1;       }     }     return 0;   }    async addNewAbilityToCharacter(m_character: Character, m_stacks: number, m_abilityId: number) {     const ability = this.AbilityInfoRepository.save({ abilityId: m_abilityId, stacks: m_stacks, character: m_character });   }    async getCharacterAbilityInfos(characterId: number): Promise<AbilityInfoDTO[]> {     const character = await this.CharacterRepository.findOneBy( { id: characterId });     this.log('getCharacterAbilityInfos', `found character: ${character.id}; faceId: ${character.faceId}; genderId: ${character.genderId}; skinColorId: ${character.skinColorId}; beardId: ${character.beardId}; bodyArtId: ${character.bodyArtId}; hairId: ${character.hairId}; hairColorId: ${character.hairColorId}`);     const abilityInfosDTO = [];     if (character) {       const characterAbilities = await this.AbilityInfoRepository.find( {where : { character: character }});       if (characterAbilities == null) {         return abilityInfosDTO;       }       characterAbilities.forEach((abilityInfo) => {         const abilityInfoDTO = new AbilityInfoDTO();         abilityInfoDTO.Id = abilityInfo.abilityId;         abilityInfoDTO.Stacks = abilityInfo.stacks;         abilityInfosDTO.push(abilityInfoDTO);       });       this.log('getCharacterAbilityInfos', `generated answer: ${abilityInfosDTO}`);     }     return abilityInfosDTO;   }      async findCharacterById(_player: Player, id: number) {     const allPlayerCharacters = await this.CharacterRepository.find({where: { player: _player }});     this.log('findCharacterById', `allPlayerCharacters amount: ${allPlayerCharacters.length}`);     if (allPlayerCharacters.length === 0) {       return -1;     }      let index = 0;     for (const character of allPlayerCharacters) {       this.log('findCharacterById', `index: ${index}; id: ${id}`);       if (index == id) {         this.log('findCharacterById', `checking character: ${character.id}; faceId: ${character.faceId}`);         const characterData = new CharacterDataDTO();         characterData.id = character.id;         characterData.genderId = character.genderId;         characterData.skinColorId = character.skinColorId;         characterData.beardId = character.beardId;         characterData.bodyArtId = character.bodyArtId;         characterData.faceId = character.faceId;         characterData.hairId = character.hairId;         characterData.hairColorId = character.hairColorId;         characterData.xp = character.xp;         characterData.level = character.level;         characterData.gold = character.gold;         characterData.skill_ids = character.skill_ids;                  if (character.bank_items === undefined) {           character.bank_items = [];         }else{           character.bank_items.forEach((item) => {             const slotItem = new SlotItem();             slotItem.itemId = item.itemId;             slotItem.amount = item.amount;             characterData.bank_items.push(slotItem);           });         }                  if (character.backpack_items === undefined) {           character.backpack_items = [];         }else{           character.backpack_items.forEach((item) => {             const slotItem = new SlotItem();             slotItem.itemId = item.itemId;             slotItem.amount = item.amount;             characterData.backpack_items.push(slotItem);           });         }                  if (character.equipment_items === undefined) {           character.equipment_items = [];         }else{           character.equipment_items.forEach((item) => {             const slotItem = new SlotItem();             slotItem.itemId = item.itemId;             slotItem.amount = item.amount;             characterData.equipment_items.push(slotItem);           });         }         characterData.abiliyInfo = await this.getCharacterAbilityInfos(character.id);         this.log('findCharacterById', `return id: ${characterData.id}; faceId: ${characterData.faceId}; genderId: ${characterData.genderId}; skinColorId: ${characterData.skinColorId}; beardId: ${characterData.beardId}; bodyArtId: ${characterData.bodyArtId}; hairId: ${characterData.hairId}; hairColorId: ${characterData.hairColorId}; xp: ${characterData.xp}; level: ${characterData.level}; gold: ${characterData.gold}; skill_ids: ${characterData.skill_ids}; bank_items: ${characterData.bank_items}; inventory_items: ${characterData.backpack_items}; equipment_ids: ${characterData.equipment_items};`);         return characterData;       }       index++;     }   }    async getFirstCharacter(_player: Player) {     const allPlayerCharacters = await this.CharacterRepository.find({where:{ player: _player }});     this.log('findCharacterById', `allPlayerCharacters amount: ${allPlayerCharacters.length}`);     if (allPlayerCharacters.length === 0) {       return -1;     }      this.log('findCharacterById', `checking character: ${allPlayerCharacters[0].id}; faceId: ${allPlayerCharacters[0].faceId}`);     const characterData = new CharacterDataDTO();     characterData.id = allPlayerCharacters[0].id;     characterData.genderId = allPlayerCharacters[0].genderId;     characterData.skinColorId = allPlayerCharacters[0].skinColorId;     characterData.beardId = allPlayerCharacters[0].beardId;     characterData.bodyArtId = allPlayerCharacters[0].bodyArtId;     characterData.faceId = allPlayerCharacters[0].faceId;     characterData.hairId = allPlayerCharacters[0].hairId;     characterData.hairColorId = allPlayerCharacters[0].hairColorId;     characterData.xp = allPlayerCharacters[0].xp;     characterData.level = allPlayerCharacters[0].level;     characterData.gold = allPlayerCharacters[0].gold;     characterData.skill_ids = allPlayerCharacters[0].skill_ids;     if (allPlayerCharacters[0].bank_items === undefined) {       allPlayerCharacters[0].bank_items = [];     }else{       allPlayerCharacters[0].bank_items.forEach((item) => {         const slotItem = new SlotItem();         slotItem.itemId = item.itemId;         slotItem.amount = item.amount;         characterData.bank_items.push(slotItem);       });     }     if (allPlayerCharacters[0].backpack_items === undefined) {       allPlayerCharacters[0].backpack_items = [];     }else{       allPlayerCharacters[0].backpack_items.forEach((item) => {         const slotItem = new SlotItem();         slotItem.itemId = item.itemId;         slotItem.amount = item.amount;         characterData.backpack_items.push(slotItem);       });     }     if (allPlayerCharacters[0].equipment_items === undefined) {       allPlayerCharacters[0].equipment_items = [];     }else{       allPlayerCharacters[0].equipment_items.forEach((item) => {         const slotItem = new SlotItem();         slotItem.itemId = item.itemId;         slotItem.amount = item.amount;         characterData.equipment_items.push(slotItem);       });     }     characterData.abiliyInfo = await this.getCharacterAbilityInfos(allPlayerCharacters[0].id);     return characterData;   }             async deleteInventory(characterData: CharacterDataDTO) {          const character = await this.CharacterRepository.findOneBy( { id: characterData.id });      if (character) {              for (const backpackItem of characterData.backpack_items) {         await this.ItemRepository.delete(backpackItem.itemId);       }               for (const bankItem of characterData.bank_items) {         await this.ItemRepository.delete(bankItem.itemId);       }               for (const equipmentItem of characterData.equipment_items) {         await this.ItemRepository.delete(equipmentItem.itemId);       }               return 1;     }           return 0;   }             async addInventory(characterData: CharacterDataDTO): Promise<number> {          const character = await this.CharacterRepository.findOneBy( { id: characterData.id });      if (!character) {       this.log('addInventory', `character not found`);       return 0;     }      var itemIds = '';          if (characterData.backpack_items) {       for (const backpackItemDto of characterData.backpack_items) {         itemIds += `${backpackItemDto.itemId}, `;         await this.ItemRepository.save({           item_id: backpackItemDto.itemId,           amount: backpackItemDto.amount,           character_backpack: character,         });       }       this.log('addInventory', `backpack_items: ${itemIds}`);     }           if (characterData.bank_items) {       itemIds = '';       for (const bankItemDto of characterData.bank_items) {         itemIds += `${bankItemDto.itemId}, `;         await this.ItemRepository.save({           item_id: bankItemDto.itemId,           amount: bankItemDto.amount,           character_bank: character,         });       }       this.log('addInventory', `bank_items: ${itemIds}`);     }           if (characterData.equipment_items) {       itemIds = '';       for (const equipmentItemDto of characterData.equipment_items) {         itemIds += `${equipmentItemDto.itemId}, `;         await this.ItemRepository.save({           item_id: equipmentItemDto.itemId,           amount: equipmentItemDto.amount,           character_equipment: character,         });         this.log('addInventory', `equipment_items: ${itemIds}`);       }     }           return 1;   } }import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post, UseGuards } from '@nestjs/common'; import { ItemObject } from 'src/Objects/item.object'; import { ItemService } from './item.service';  @Controller('items') export class ItemController {   constructor(private readonly itemService: ItemService) {}    @Post('import-json')   create(@Body() itemData: ItemObject[]): Promise<number[]> {     return this.itemService.importItemFromJson(itemData);   } } import { Module } from '@nestjs/common'; import { TypeOrmModule } from '@nestjs/typeorm'; import { Item } from 'src/entities/item.entity'; import { ItemRarity } from 'src/entities/itemRarity.entity'; import { ItemController } from './item.controller'; import { ItemService } from './item.service';  @Module({   imports: [     TypeOrmModule.forFeature([         Item,          ItemRarity     ]),   ],   controllers: [ItemController],   providers: [ItemService], }) export class ItemModule {} import { Injectable } from '@nestjs/common'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository } from 'typeorm'; import { Item } from 'src/entities/item.entity'; import { ItemObject } from 'src/Objects/item.object'; import { ItemRarity } from 'src/entities/itemRarity.entity';  @Injectable() export class ItemService {   constructor(     @InjectRepository(Item)     private itemRepository: Repository<Item>,     @InjectRepository(ItemRarity)     private itemRarityRepository: Repository<ItemRarity>,   ) {}    async generateOrFindItems(item_ids: number[]): Promise<Item[]>{     console.log(item_ids);     const result = await this.itemRepository.findByIds(item_ids);     console.log(result)     return result;   }    async importItemFromJson(data: ItemObject[]): Promise<number[]> {     let result = [];     for (let singleItem of data) {         let newRarity = await this.findOrCreateRelatedEntities(singleItem.rarity, this.itemRarityRepository);         let newItem = await this.itemRepository.create({             name: singleItem.name,             description: singleItem.description,             price: singleItem.price,             rarity: newRarity,             weight: singleItem.weight,             stats: singleItem.stats,             characterBank: null         })         result.push((await this.itemRepository.save(newItem)).id);                                                                                                                                                }     return result;   }    async findOrCreateRelatedEntities(name: string, repository: Repository<any>): Promise<any> {          const entity = await repository.findOneBy({ name });     if (entity) {         return entity;     } else {         const newEntity = repository.create({ name });         return await repository.save(newEntity);     }       return null;   } } import { Controller, Post, Body, Get, Req, UseGuards, UnauthorizedException, NotFoundException, Request, Res  } from '@nestjs/common'; import { PlayerService } from './player.service'; import { RegisterDTO } from './dto'; import { AuthGuard } from '../auth/auth.guard';  @Controller('player') export class PlayerController {   constructor(     private readonly playerService: PlayerService     ) {}      private log(method: string , message: string) {       console.log(`[PlayerController][${method}] ${new Date().toLocaleString()}: ${message}`);   }      @Post('register')     async register(@Body() registerDto: RegisterDTO)  {         return this.playerService.createUser(registerDto);     }      @UseGuards(AuthGuard)     @Post('change_email_password')     async changeEmailPassword(@Request() req, @Body() data)  {       let email = req.user.email;       this.log('changeEmailPassword', `email: ${email}, data: ${JSON.stringify(data)}`);       return this.playerService.changeEmailPassword(email, data);     } }import { Module, Global } from '@nestjs/common'; import { TypeOrmModule } from '@nestjs/typeorm'; import { PlayerController } from './player.controller'; import { PlayerService } from './player.service'; import { Player } from 'src/entities/Player.entity'; import { JwtModule } from '@nestjs/jwt'; import { jwtConstants } from '../auth/constants';  @Module({   imports: [     TypeOrmModule.forFeature([Player]),     JwtModule.register({        secret: jwtConstants.secret,       signOptions: { expiresIn: '7d' },      }),   ],    controllers: [PlayerController],   providers: [PlayerService], }) export class PlayerModule {} import { BadRequestException, Injectable, NotFoundException, Request, UnauthorizedException } from '@nestjs/common'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository } from 'typeorm'; import * as bcrypt from 'bcrypt'; import { Player } from 'src/entities/Player.entity'; import { RegisterDTO } from './dto'; import { AppError } from 'src/common/errors'; import { JwtService } from '@nestjs/jwt'; import { Character } from 'src/entities/character.entity';  @Injectable() export class PlayerService {   constructor(     @InjectRepository(Player)     private playerRepository: Repository<Player>,     private jwtService: JwtService,     private characterRepository: Repository<Character>   ) {}     private log(method: string , message: string) {     console.log(`[CreatureService][${method}] ${new Date().toLocaleString()}: ${message}`);   }    async hashPassword(password: string): Promise<string> {     return await bcrypt.hash(password, 10);   }    async changeEmailPassword(email: string, data: any) {     let newUsername = data.username;     let newEmail = data.email;     let newPassword = data.password;      const user = await this.playerRepository.findOneBy({ email });     if (!user) {       throw new NotFoundException(AppError.USER_NOT_FOUND);     }     if (email != user.email) {       throw new UnauthorizedException(AppError.USER_NOT_AUTHORIZED);     }     if (newUsername){       user.username = newUsername;     }     if (newEmail) {       user.email = newEmail;     }     if (newPassword) {       user.password = await this.hashPassword(newPassword);     }     const savedPlayer = await this.playerRepository.save(user);          const payload = { sub: savedPlayer.id, email: savedPlayer.email };     const token = this.jwtService.signAsync(payload);      return {         username: savedPlayer.username,         access_token: token     };   }    async createUser(dto) {     const existPlayer = await this.findUserByEmail(dto.email);     if (existPlayer) {       throw new BadRequestException(AppError.USER_EXIST);     }     dto.password = await this.hashPassword(dto.password);     const savedPlayer = await this.playerRepository.save(dto);     const payload = { sub: savedPlayer.id, email: savedPlayer.email };         const token = this.jwtService.sign(payload);          return {             username: savedPlayer.username,             access_token: token         };   }    findAll(): Promise<Player[]> {     return this.playerRepository.find();   }    async remove(id: number): Promise<void> {     await this.playerRepository.delete(id);   }    async findOne(username: string): Promise<Player> {     return await this.playerRepository.findOneBy({ username });   }    async findUserByEmail(email: string) {     return this.playerRepository.findOneBy({ email });   }    async loginAndGenerateToken(email: string, password: string) {     const player = await this.playerRepository.findOne({        where: { email },       relations: ['character']     });      if (!player) {       throw new NotFoundException(AppError.USER_NOT_FOUND);     }      const isPasswordValid = await bcrypt.compare(password, player.password);     if (!isPasswordValid) {       throw new UnauthorizedException("INVALID_CREDENTIALS");     }      const payload = { sub: player.id, email: player.email };     const token = this.jwtService.sign(payload);           const characters = await this.characterRepository.find({ where: { player: player } });        if (characters) {       for (let character of characters) {         character.token = token;       }       await this.characterRepository.save(player.character);     }      return {       username: player.username,       access_token: token     };   }    async logout(playerId: number) {     const player = await this.playerRepository.findOne({        where: { id: playerId },       relations: ['character']     });      const characters = await this.characterRepository.find({ where: { player: player } });        if (player && characters) {       for (let character of characters) {         character.token = null;       }       await this.characterRepository.save(player.character);     }        return { message: 'Logged out successfully' };   }  } 
        