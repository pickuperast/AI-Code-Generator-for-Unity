# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
# CODE: // Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\ElectricDash.cs:
 using System.Collections;
using _ZombieRoyale.Scripts.Core;
using Invector;
using UnityEngine;
using Invector.vCharacterController;
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
#endif

public class ElectricDash: Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float CRYSTAL_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_WAVE = 5f;
    private readonly float TICK_TIME = 3f;
    private readonly float BASE_DURATION = 5f;
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Magic;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private Transform pivot;
    private float randomTimer = 0f;
    private float startSpeed = 10f;
    private Vector3 stepPosition;
    private float speed = 18;
    private float forceMagnitude = 20000;
    private float forceDuration = 0.3f;
    private float drug = 1f;
    private float spawnRate = 1f;
    private float positionOffset = 2f;
    private float spawnDuration = 0.6f;
    private Vector3 startRotation = Vector3.zero;

    private float GetShockWaveDuration()
    {
        return CRYSTAL_FIELD_DURATION;
    }

    private float CalculateTickDamage(float wisdom)
    {
        return BASE_DAMAGE_PER_WAVE + wisdom * .1f;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        var healthController = casterComps.HealthController;
        var casterPos = healthController.transform;

        var effect = Instantiate(_abilityDefinition.RanksDatas[data.rank].hitEffect, healthController.transform.position, Quaternion.identity);
        Spawn(effect);

        Vector3 targetPoint = casterPos.position;
        Vector3 npsPos = effect.transform.position;
        pivot = casterPos;

        startSpeed = speed;
        transform.parent = null;
        transform.position = pivot.position;
        var lookPos = targetPoint - transform.position;
        lookPos.y = 0;
      
        transform.rotation = Quaternion.LookRotation(lookPos);

        stepPosition = pivot.position;
        randomTimer = 0;

        var rb = casterPos.GetComponent<Rigidbody>();
        // casterPos.GetComponent<Rigidbody>().AddForce(casterPos.transform.forward * force, ForceMode.Impulse);
        StartCoroutine(ApplyForceOverTime(casterComps, rb, casterPos.transform.forward, forceDuration));

        while (true)
        {
            randomTimer += Time.deltaTime;
            startSpeed = startSpeed * drug;

            effect.transform.position += casterPos.transform.forward * (startSpeed * Time.deltaTime);
        
            var heading = effect.transform.position - stepPosition;
            var distance = heading.magnitude;

            if (distance > spawnRate)
            {
                if (_abilityDefinition.RanksDatas[data.rank].hitEffect != null)
                {
                    Vector3 randomPosition = new Vector3(Random.Range(-positionOffset, positionOffset), 0, Random.Range(-positionOffset, positionOffset));
                    Vector3 pos = effect.transform.position + (randomPosition * randomTimer * 2);

                    //to create effects on terrain
                    if (Terrain.activeTerrain != null)
                    {
                        pos.y = Terrain.activeTerrain.SampleHeight(effect.transform.position);
                    }

                    var craterInstance = Instantiate(_abilityDefinition.RanksDatas[data.rank].hitEffect, pos, Quaternion.identity);
                    Spawn(craterInstance);
                    craterInstance.transform.localScale += new Vector3(randomTimer * 2, randomTimer * 2, randomTimer * 2); 
                    var craterPs = craterInstance.GetComponent<ParticleSystem>();
                    if (craterPs != null)
                    {
                        DelayDestroy(craterInstance, craterPs.main.duration);
                    }
                    else
                    {
                        var flashPsParts = craterInstance.transform.GetChild(0).GetComponent<ParticleSystem>();                      
                        DelayDestroy(craterInstance, flashPsParts.main.duration);
                    }
                }
                //distance = 0;
                stepPosition = effect.transform.position;
            }
            if (randomTimer > spawnDuration)
            {
                effect.transform.parent = pivot;
                effect.transform.position = pivot.position;
                effect.transform.rotation = Quaternion.Euler(startRotation);
                yield break;
            }
            yield return null;
        }    
    }

    IEnumerator DelayDestroy(GameObject nps, float timeout)
    {
        yield return new WaitForSeconds(timeout);
        Despawn(nps);
    }

    private IEnumerator ApplyForceOverTime(UnitComponents unit, Rigidbody rb, Vector3 direction, float duration)
    {
        unit.InvectorManager.ThirdPersonController.TurnOffGravity();
        var meleeInput = rb.GetComponent<vShooterMeleeInput>();
        meleeInput.SetLockAllInput(true);

        float elapsed = 0f;
      
        while (elapsed < duration)
        {
            float forceThisFrame = (forceMagnitude / duration) * Time.deltaTime;
            rb.AddForce(direction * forceThisFrame, ForceMode.Impulse);
            elapsed += Time.deltaTime;
            yield return null;
        }

        unit.InvectorManager.ThirdPersonController.TurnOnGravity();
        meleeInput.SetLockAllInput(false);
    }

    IEnumerator ApplySmoothForce(Rigidbody rb, Vector3 totalForce, float duration)
    {
        Vector3 forcePerFrame = totalForce / (duration / Time.fixedDeltaTime);
        float elapsedTime = 0f;

        while (elapsedTime < duration)
        {
            rb.AddForce(forcePerFrame, ForceMode.Force);
            elapsedTime += Time.fixedDeltaTime;
            yield return new WaitForFixedUpdate();
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController.GetAllCurrentValueServerOnly(AFFECTING_STAT));

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToRoundedString()}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\ElectricDash.cs:
 using System.Collections;
using _ZombieRoyale.Scripts.Core;
using Invector;
using UnityEngine;
using Invector.vCharacterController;
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
#endif

public class ElectricDash: Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float CRYSTAL_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_WAVE = 5f;
    private readonly float TICK_TIME = 3f;
    private readonly float BASE_DURATION = 5f;
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Magic;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private Transform pivot;
    private float randomTimer = 0f;
    private float startSpeed = 10f;
    private Vector3 stepPosition;
    private float speed = 18;
    private float forceMagnitude = 20000;
    private float forceDuration = 0.3f;
    private float drug = 1f;
    private float spawnRate = 1f;
    private float positionOffset = 2f;
    private float spawnDuration = 0.6f;
    private Vector3 startRotation = Vector3.zero;

    private float GetShockWaveDuration()
    {
        return CRYSTAL_FIELD_DURATION;
    }

    private float CalculateTickDamage(float wisdom)
    {
        return BASE_DAMAGE_PER_WAVE + wisdom * .1f;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        var healthController = casterComps.HealthController;
        var casterPos = healthController.transform;

        var effect = Instantiate(_abilityDefinition.RanksDatas[data.rank].hitEffect, healthController.transform.position, Quaternion.identity);
        Spawn(effect);

        Vector3 targetPoint = casterPos.position;
        Vector3 npsPos = effect.transform.position;
        pivot = casterPos;

        startSpeed = speed;
        transform.parent = null;
        transform.position = pivot.position;
        var lookPos = targetPoint - transform.position;
        lookPos.y = 0;
      
        transform.rotation = Quaternion.LookRotation(lookPos);

        stepPosition = pivot.position;
        randomTimer = 0;

        var rb = casterPos.GetComponent<Rigidbody>();
        // casterPos.GetComponent<Rigidbody>().AddForce(casterPos.transform.forward * force, ForceMode.Impulse);
        StartCoroutine(ApplyForceOverTime(casterComps, rb, casterPos.transform.forward, forceDuration));

        while (true)
        {
            randomTimer += Time.deltaTime;
            startSpeed = startSpeed * drug;

            effect.transform.position += casterPos.transform.forward * (startSpeed * Time.deltaTime);
        
            var heading = effect.transform.position - stepPosition;
            var distance = heading.magnitude;

            if (distance > spawnRate)
            {
                if (_abilityDefinition.RanksDatas[data.rank].hitEffect != null)
                {
                    Vector3 randomPosition = new Vector3(Random.Range(-positionOffset, positionOffset), 0, Random.Range(-positionOffset, positionOffset));
                    Vector3 pos = effect.transform.position + (randomPosition * randomTimer * 2);

                    //to create effects on terrain
                    if (Terrain.activeTerrain != null)
                    {
                        pos.y = Terrain.activeTerrain.SampleHeight(effect.transform.position);
                    }

                    var craterInstance = Instantiate(_abilityDefinition.RanksDatas[data.rank].hitEffect, pos, Quaternion.identity);
                    Spawn(craterInstance);
                    craterInstance.transform.localScale += new Vector3(randomTimer * 2, randomTimer * 2, randomTimer * 2); 
                    var craterPs = craterInstance.GetComponent<ParticleSystem>();
                    if (craterPs != null)
                    {
                        DelayDestroy(craterInstance, craterPs.main.duration);
                    }
                    else
                    {
                        var flashPsParts = craterInstance.transform.GetChild(0).GetComponent<ParticleSystem>();                      
                        DelayDestroy(craterInstance, flashPsParts.main.duration);
                    }
                }
                //distance = 0;
                stepPosition = effect.transform.position;
            }
            if (randomTimer > spawnDuration)
            {
                effect.transform.parent = pivot;
                effect.transform.position = pivot.position;
                effect.transform.rotation = Quaternion.Euler(startRotation);
                yield break;
            }
            yield return null;
        }    
    }

    IEnumerator DelayDestroy(GameObject nps, float timeout)
    {
        yield return new WaitForSeconds(timeout);
        Despawn(nps);
    }

    private IEnumerator ApplyForceOverTime(UnitComponents unit, Rigidbody rb, Vector3 direction, float duration)
    {
        unit.InvectorManager.ThirdPersonController.TurnOffGravity();
        var meleeInput = rb.GetComponent<vShooterMeleeInput>();
        meleeInput.SetLockAllInput(true);

        float elapsed = 0f;
      
        while (elapsed < duration)
        {
            float forceThisFrame = (forceMagnitude / duration) * Time.deltaTime;
            rb.AddForce(direction * forceThisFrame, ForceMode.Impulse);
            elapsed += Time.deltaTime;
            yield return null;
        }

        unit.InvectorManager.ThirdPersonController.TurnOnGravity();
        meleeInput.SetLockAllInput(false);
    }

    IEnumerator ApplySmoothForce(Rigidbody rb, Vector3 totalForce, float duration)
    {
        Vector3 forcePerFrame = totalForce / (duration / Time.fixedDeltaTime);
        float elapsedTime = 0f;

        while (elapsedTime < duration)
        {
            rb.AddForce(forcePerFrame, ForceMode.Force);
            elapsedTime += Time.fixedDeltaTime;
            yield return new WaitForFixedUpdate();
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController.GetAllCurrentValueServerOnly(AFFECTING_STAT));

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToRoundedString()}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Blink.cs:
 using System.Collections;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

public class Blink : Ability
{
    private static float BLINK_DISTANCE = 8.0f;

    public override IEnumerator Activate(AbilityCastingData data) 
    {
        Debug.Log("Blink ability activated.");

        var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if(unitComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = unitComps.HealthController.Owner;
        TargetBlinkForward(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetBlinkForward(NetworkConnection conn, int casterNetId) 
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("[Blink][TargetBlinkForward]");

        RaycastHit hit;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;
        
        //get desired position with same y + forward + distance
        var lookRotation = Quaternion.LookRotation(hero.forward);
        sb.Append($" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}");
        Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f);
        sb.Append($" rotationNormalized: {rotationNormalized}; ");
        
        Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE;
        sb.Append($" destination: {destination}; ");

        var defaultLayerMask = LayerMask.GetMask("Default");
        if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask))
        {
            destination = hero.position + hero.forward * (hit.distance-.5f);
        }

        // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) 
        // {
        //     destination = hit.point;
        //     destination.y += .5f;
        // }
        destination.y += .2f;
        if (hit.transform != null)
        {
            sb.Append($" hit: {hit.transform}, hit pos: {hit.transform.position}; ");
        }
        sb.Append($"result destination: {destination}, after pos: {transform.position}");
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        Vector3 oldPos = hero.position;
        playerFim.OwnerTeleport(destination);
        BlinkForwardServerRpc(oldPos, destination);
        Vector3 middlePoint = (oldPos + destination) / 2;
    }

    [ServerRpc(RequireOwnership = false)]
    private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) 
    {
        Debug.Log("Blink forward on server.");
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        Debug.Log($"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}");
        SpawnEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalBlinkEffect(middlePoint, directionRotation);
    }
    
    private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        Debug.Log("Spawning blink effect.");

        var fx = _abilityDefinition.RanksDatas[0].hitEffect;

        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation);
            Destroy(fxInstance, 1.5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        string mainEdited = _abilityDefinition.mainDescription;
        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Blink.cs:
 using System.Collections;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

public class Blink : Ability
{
    private static float BLINK_DISTANCE = 8.0f;

    public override IEnumerator Activate(AbilityCastingData data) 
    {
        Debug.Log("Blink ability activated.");

        var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if(unitComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = unitComps.HealthController.Owner;
        TargetBlinkForward(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetBlinkForward(NetworkConnection conn, int casterNetId) 
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("[Blink][TargetBlinkForward]");

        RaycastHit hit;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;
        
        //get desired position with same y + forward + distance
        var lookRotation = Quaternion.LookRotation(hero.forward);
        sb.Append($" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}");
        Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f);
        sb.Append($" rotationNormalized: {rotationNormalized}; ");
        
        Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE;
        sb.Append($" destination: {destination}; ");

        var defaultLayerMask = LayerMask.GetMask("Default");
        if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask))
        {
            destination = hero.position + hero.forward * (hit.distance-.5f);
        }

        // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) 
        // {
        //     destination = hit.point;
        //     destination.y += .5f;
        // }
        destination.y += .2f;
        if (hit.transform != null)
        {
            sb.Append($" hit: {hit.transform}, hit pos: {hit.transform.position}; ");
        }
        sb.Append($"result destination: {destination}, after pos: {transform.position}");
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        Vector3 oldPos = hero.position;
        playerFim.OwnerTeleport(destination);
        BlinkForwardServerRpc(oldPos, destination);
        Vector3 middlePoint = (oldPos + destination) / 2;
    }

    [ServerRpc(RequireOwnership = false)]
    private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) 
    {
        Debug.Log("Blink forward on server.");
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        Debug.Log($"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}");
        SpawnEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalBlinkEffect(middlePoint, directionRotation);
    }
    
    private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        Debug.Log("Spawning blink effect.");

        var fx = _abilityDefinition.RanksDatas[0].hitEffect;

        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation);
            Destroy(fxInstance, 1.5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        string mainEdited = _abilityDefinition.mainDescription;
        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Ability.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using DuloGames.UI;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using Invector;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class Ability: NetworkBehaviour
{
    protected int _rank;
    [SerializeField] protected AbilityDefinition _abilityDefinition;
    public Buff Buff => _buff;
    [SerializeField] protected Buff _buff;
    [SerializeField] protected bool isPassiveSkill;
    public static Dictionary<NetworkConnection, uint> StacksCounter { get; private set; } = new ();
    public static Dictionary<NetworkConnection, uint> RankCounter { get; private set; } = new ();
    public AbilityDefinition AbilityDefinition => _abilityDefinition;
    public static Action OnAbilityLearned;
    public Action<NetworkConnection, byte, uint> OnRankLevelUp;
    protected string _abilityName => _abilityDefinition.Name;
    protected GameplayManager _gameplayManager;
    protected bool _isDebug = true;
    protected readonly string COLOR_DURATION = "#00F0FF";
    protected readonly string COLOR_AFFECTING_STAT = "#00F0FF";
    protected readonly string COLOR_DAMAGE = "#ff3517";
    protected readonly string COLOR_HEAL = "#0ec949";
    protected readonly string COLOR_STAT = "#96e33d";
    protected readonly string COLOR_XP = "#c3eb34";
    protected readonly string COLOR_COOLDOWN = "#c8e609";

    protected readonly Color DEBUG_SPHERE_DEFAULT_COLOR = new Color(1f, 0f, 0f, 0.5f);
    protected readonly Color DEBUG_SPHERE_ACTIVATE_COLOR = new Color(1f, 0f, 1f, 0.5f);
    protected Color _debugSphereColor;
    protected bool _showDebugSphere;
    protected Vector3 _debugSpherePos;
    protected float _debugSphereRadius = 1f;

    public virtual void InitAbility()
    {
        if (_buff != null) 
        {
            _buff.Init(GameplayManager.Instance);
        }
        else
        {
            Debug.LogWarning($"Buff is null during ability {_abilityName} initialization.");
        }
    }

    public virtual float CalculateValueBasedOnStacks(uint stacks) => .01f;
    
    public virtual int CalculateRankBasedOnStacks(uint stacks) => 1;
    
    public virtual float CalculateDamageBasedOnRank(int rank) => 1;
    
    public virtual uint GetStacksForRank() => 1;
    
    public uint AddRank(NetworkConnection connection)
    {
        if (RankCounter.ContainsKey(connection))
        {
            RankCounter[connection]++;
        }
        else
        {
            RankCounter.Add(connection, 1);
        }
        OnRankLevelUp?.Invoke(connection, _abilityDefinition.Id, RankCounter[connection]);
        return RankCounter[connection];
    }

    public uint ServerAddStack(FNAbilityController abilityController, uint amount)
    {
        if (!abilityController.LearnedAbilityDict.ContainsKey(AbilityDefinition.Id))
        {
            Debug.LogError($"Ability {AbilityDefinition.Name} is not learned by player {abilityController.gameObject.name}. Cannot add stacks.");
            return 0;
        }
        
        AbilityInfo targetsAbilityStats = abilityController.LearnedAbilityDict[AbilityDefinition.Id];
        targetsAbilityStats.Stacks = Math.Max(0, targetsAbilityStats.Stacks + amount);
        abilityController.AddOrSetAbility(targetsAbilityStats);
        return targetsAbilityStats.Stacks;
    }
    
    public uint AddStack(NetworkConnection connection)
    {
        if (StacksCounter.ContainsKey(connection))
        {
            StacksCounter[connection]++;
        }
        else
        {
            StacksCounter.Add(connection, 1);
        }
        
        if (EnoughStacksToLevelup(connection))
        {
            StacksCounter[connection] = 0;
            AddRank(connection);
            return 1;
        }
        else
        {
            return 0;
        }
        
        return StacksCounter[connection];
    }
    
    public UISpellInfo GetUISpellInfo(byte abilityId, uint stacks)
    {
        UISpellInfo spellInfo = new UISpellInfo();
        spellInfo.ID = _abilityDefinition.Id;
        uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId);
        int abilityRankBasedOnStacks = CalculateRankBasedOnStacks(abilityStacksForPlayer);
        spellInfo.Name = GetAbilityName(abilityRankBasedOnStacks);
        spellInfo.Icon = _abilityDefinition.Icon;
        spellInfo.Description = GetAbilityDescription(abilityRankBasedOnStacks, abilityStacksForPlayer);
        if (_abilityDefinition.IsPassive)
        {
            spellInfo.Flags = UISpellInfo_Flags.Passive;
        }
        else
        {
            AbilityDefinition.RPGAbilityRankData rankData = _abilityDefinition.RanksDatas[0];

            if (rankData != null)
            {
                switch (rankData.activationType)
                {
                    case AbilityDefinition.AbilityActivationType.Instant:
                        spellInfo.Flags = UISpellInfo_Flags.InstantCast;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCircle:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCircle;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCone:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCone;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedAim:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastAim;
                        break;
                    default:
                        spellInfo.Flags = UISpellInfo_Flags.PowerCostInPct;
                        break;

                }

                spellInfo.Range = rankData.maxRange;
                spellInfo.Cooldown = rankData.cooldown;
                if (rankData.castTime > 0)
                {
                    spellInfo.CastTime = rankData.castTime;
                }
                spellInfo.PowerCost = rankData.manaCost;
            }
            else
            {
                Debug.LogError($"Ability {spellInfo.Name} does not have rank {abilityId}. Setting default values.");
            }
        }
        return spellInfo;
    }

    private bool EnoughStacksToLevelup(NetworkConnection connection)
    {
        return StacksCounter[connection] >= GetStacksForRank();
    }

    public virtual string GetAbilityName(int rank) => _abilityDefinition.Name;
    public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description;
    public virtual string GetAbilityDescription(int rank, FNStatsController statsController) => _abilityDefinition.persistDescription;
    
    public virtual float GetAbilityCastingTime(int rank, FNStatsController statsController)
    {
        float castingTime = _abilityDefinition.RanksDatas[rank].castTime;
        return castingTime;
    }

    public virtual IEnumerator Activate(AbilityCastingData data)
    {
        yield return null;
    }

    [Server]
    protected virtual void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f)
    {
        Debug.Log($"{_abilityName} Applying caster buff.");
        _buff.Activate(casterBuffData, new int[]{}, duration:duration);
    }

    protected virtual List<Collider> TargetsSelection(Transform caster) 
    {
        Debug.LogWarning($"{_abilityName} TargetsSelection method has not been implemented yet.");
        throw new NotImplementedException();
    }

    [Server]
    protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage, bool isExcludeSelf = false)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        var targets = TargetsInSphereSelection(playerComps, radius);
        for (int i = 0; i < targets.Count; i++) 
        {
            if (isExcludeSelf && targets[i] == playerComps.HealthController)
            {
                continue;
            }
            damage.receiver = targets[i].transform;
            targets[i].TakeDamage(damage);

            Debug.Log($"[{_abilityDefinition.Name}] Damage applied to {targets[i].name}");
        }
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, Buff.BuffData caster, float radius)
    {
        //Debug.Log($"{_abilityName} Selecting targets in sphere.");
        List<FishnetInvectorHealthController> targets = EnemyTargetsInRadius(pos, caster, radius);
        //Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");
        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsExcludingTagsInSphereSelection(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = TargetsInRadiusExcludingTags(tags, pos, caster, radius);
        return targets;
    }
    
    public static List<FishnetInvectorHealthController> TargetsInRadiusExcludingTags(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            for (int i = 0; i < tags.Length; i++)
            {
                if (targetNob.CompareTag(tags[i]))
                {
                    continue;
                }
            }
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            targets.Add(targetComps.HealthController);
        }
        return targets;
    }

    public static List<FishnetInvectorHealthController> EnemyTargetsInRadius(Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            Buff.BuffData targetData = new Buff.BuffData(targetComps.HealthController.ObjectId, targetComps.HealthController.gameObject.tag, 0f, caster.abilityId, 0, null, null, 0);
            if (IsNotValidTargetEnemy(caster, targetData))
                continue;
            
            targets.Add(targetComps.HealthController);
        }

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsInSphereSelection(UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var target in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(target).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNob.ObjectId);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(caster.HealthController.transform.position, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(target);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [ObserversRpc]
    protected void RpcShowEffectForObservers(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect for observers.");

        GameplayManager.Instance.StartCoroutine(ShowEffectOnTarget(targetNetId, abilityId, rank, timeout));
    }
    
    protected virtual IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if(targetComps == null)
        {
            Debug.LogError($"{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        List<GameObject> effects = new List<GameObject>(); 
        foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints)
        {
            Assert.IsNotNull(_abilityDefinition.RanksDatas[rank].hitEffect, $"Hit effect is null for {_abilityName}.");
            Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint);
            GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position + Vector3.up, Quaternion.identity, GameplayManager.Instance.transform);
            effect.transform.SetParent(pointTransform);
            effects.Add(effect);
        }

        yield return new WaitForSeconds(timeout);
        foreach (var effect in effects)
        {
            Destroy(effect, timeout);
        }
    }
    
    public static bool IsNotValidTargetEnemy(Buff.BuffData casterData, Buff.BuffData targetData)
    {
        if (casterData.ObjectId == targetData.ObjectId)
        {
            return true;
        }

        int casterTeam = GameplayManager.Instance.GetUnitTeamId(casterData.ObjectId);
        int targetTeam = GameplayManager.Instance.GetUnitTeamId(targetData.ObjectId);
        if (casterData.Tag == GameplayManager.TAG_PLAYER)
        {
            if (casterTeam == targetTeam)
            {
                return true;
            }
            return false;
        }else if (targetData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
        {
            if (casterData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
            {
                return true;
            }
            return false;
        }

        return false;
    }

    protected bool IsNotValidTargetEnemy(UnitComponents target, UnitComponents caster)
    {
        //Debug.Log($"{_abilityName} Checking if target is valid.");
        if (target == null)
            return true;
        
        if (target == caster)
        {
            //Debug.Log($"{_abilityName} Target is the same as caster. Invalid target.");
            return true;
        }

        var targetHealthController = target.HealthController;
        if (targetHealthController == null)
        {
            return true;
        }
        if (targetHealthController.CompareTag(GameplayManager.TAG_PLAYER))
        {
            //Debug.Log($"{_abilityName} Target is a player. Valid target.");
            return false;
        }else if (targetHealthController.CompareTag("Enemy"))
        {
            //Debug.Log($"{_abilityName} Target is an enemy. Valid target.");
            if (caster.HealthController.CompareTag("Enemy"))
            {
                return true;
            }
            return false;
        }

        //Debug.Log($"{_abilityName} Target does not have a Player or Enemy tag. Invalid target.");

        return false;
    }
    
    protected void DrawDebugSphere(Vector3 pos, float radius)
    {
        _debugSpherePos = pos;
        _debugSphereRadius = radius;
        _showDebugSphere = true;
        _debugSphereColor = DEBUG_SPHERE_ACTIVATE_COLOR;
        StartCoroutine(ResetDebugSphereColorAfterDelay(0.3f));
    }
    
    protected IEnumerator ResetDebugSphereColorAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        _debugSphereColor = DEBUG_SPHERE_DEFAULT_COLOR;
        _showDebugSphere = false;
    }
    
    public virtual float CalcAmount(FNStatsController statsController) {
        return 1f;
    }
    
    public virtual float CalcDuration(FNStatsController statsController) {
        return 1f;
    }
    
#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        if (_showDebugSphere)
        {
            Gizmos.color = _debugSphereColor;
            Gizmos.DrawSphere(_debugSpherePos, _debugSphereRadius);
        }
    }
#endif
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\PoisonNova.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
#endif

public class PoisonNova : Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float POISON_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_TICK = .01853143f;
    private readonly float BASE_DURATION = 5f;
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison;
    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private float GetPoisonFeildDuration()
    {
        return POISON_FIELD_DURATION;
    }    
    private float CalculateTickDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE_PER_TICK * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition);
        var healthController = casterComps.HealthController;
        NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity);
        Spawn(nps);
        RpcShowEffectForObservers(data.casterNetId, abilityId, _rank, GetPoisonFeildDuration());

        Debug.Log($"{ClassName} Activated for unit #{data.casterNetId} with abilityId #{abilityId} and rank {data.rank}");
        float currentDuration = 0f;
        float tickTime = 1f;
        float radius = 1f;
        Buff.BuffData casterData = new Buff.BuffData(data.casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, 
            CalculateTickDamage(casterComps.StatsController));

        vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE);
        Vector3 poisonCloudPos = healthController.transform.position;
        while (currentDuration < GetPoisonFeildDuration())
        {
            currentDuration += tickTime;
            InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS);
            yield return new WaitForSeconds(tickTime);
        }
        Despawn(nps);
    }
    
    
    [Server]
    private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius)
    {
        DrawDebugSphere(pos, radius);
        var caster = UnitComponentsManager.GetUnitComponentsServerAndClient(casterData.ObjectId);
        if (caster != null)
        {
            damage = UpdateDamage(ref casterData, caster);
        }
        var targets = EnemyTargetsInSphereSelection(pos, casterData, radius);
        //remove duplicates
        var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray();
        if (targetCleared.Length == 0)
        {
            //Debug.Log($"{ClassName} No targets in sphere.");
            return;
        }
        else
        {
            _buff.Activate(casterData, targetCleared, BASE_DURATION, damage);
            //Debug.Log($"[{ClassName}] Buff activated for {targetCleared.Length} targets.");
        }
    }

    private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster)
    {
        vDamage damage;
        casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null,
            CalculateTickDamage(caster.StatsController));
        damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE);
        return damage;
    }

    protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if (targetComps == null)
        {
            Debug.LogError($"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        Vector3 pos = targetComps.HealthController.transform.position;
        GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity);
        VisualEffect vfxGraph = effect.GetComponent<VisualEffect>();
        float cloudCurrentSize = vfxGraph.GetFloat("SmokeSize");
        float timeElapsed = 0f;
        while (timeElapsed < TIME_TO_REACH_END_SIZE)
        {
            cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE);
            vfxGraph.SetFloat("SmokeSize", cloudCurrentSize);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        Destroy(effect, timeout);
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }

} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\PoisonNova.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
#endif

public class PoisonNova : Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float POISON_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_TICK = .01853143f;
    private readonly float BASE_DURATION = 5f;
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison;
    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private float GetPoisonFeildDuration()
    {
        return POISON_FIELD_DURATION;
    }    
    private float CalculateTickDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE_PER_TICK * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition);
        var healthController = casterComps.HealthController;
        NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity);
        Spawn(nps);
        RpcShowEffectForObservers(data.casterNetId, abilityId, _rank, GetPoisonFeildDuration());

        Debug.Log($"{ClassName} Activated for unit #{data.casterNetId} with abilityId #{abilityId} and rank {data.rank}");
        float currentDuration = 0f;
        float tickTime = 1f;
        float radius = 1f;
        Buff.BuffData casterData = new Buff.BuffData(data.casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, 
            CalculateTickDamage(casterComps.StatsController));

        vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE);
        Vector3 poisonCloudPos = healthController.transform.position;
        while (currentDuration < GetPoisonFeildDuration())
        {
            currentDuration += tickTime;
            InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS);
            yield return new WaitForSeconds(tickTime);
        }
        Despawn(nps);
    }
    
    
    [Server]
    private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius)
    {
        DrawDebugSphere(pos, radius);
        var caster = UnitComponentsManager.GetUnitComponentsServerAndClient(casterData.ObjectId);
        if (caster != null)
        {
            damage = UpdateDamage(ref casterData, caster);
        }
        var targets = EnemyTargetsInSphereSelection(pos, casterData, radius);
        //remove duplicates
        var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray();
        if (targetCleared.Length == 0)
        {
            //Debug.Log($"{ClassName} No targets in sphere.");
            return;
        }
        else
        {
            _buff.Activate(casterData, targetCleared, BASE_DURATION, damage);
            //Debug.Log($"[{ClassName}] Buff activated for {targetCleared.Length} targets.");
        }
    }

    private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster)
    {
        vDamage damage;
        casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null,
            CalculateTickDamage(caster.StatsController));
        damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE);
        return damage;
    }

    protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if (targetComps == null)
        {
            Debug.LogError($"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        Vector3 pos = targetComps.HealthController.transform.position;
        GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity);
        VisualEffect vfxGraph = effect.GetComponent<VisualEffect>();
        float cloudCurrentSize = vfxGraph.GetFloat("SmokeSize");
        float timeElapsed = 0f;
        while (timeElapsed < TIME_TO_REACH_END_SIZE)
        {
            cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE);
            vfxGraph.SetFloat("SmokeSize", cloudCurrentSize);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        Destroy(effect, timeout);
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }

} 



# TASK: Rework electric dash to not use force to move player, instead use moving mechanic from blink ability, and add damaging logic, remove unnecessary code