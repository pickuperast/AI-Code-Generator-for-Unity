# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
# CODE: // Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Ability.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using DuloGames.UI;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using Invector;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class Ability: NetworkBehaviour
{
    protected int _rank;
    [SerializeField] protected AbilityDefinition _abilityDefinition;
    public Buff Buff => _buff;
    [SerializeField] protected Buff _buff;
    [SerializeField] protected bool isPassiveSkill;
    public static Dictionary<NetworkConnection, uint> StacksCounter { get; private set; } = new ();
    public static Dictionary<NetworkConnection, uint> RankCounter { get; private set; } = new ();
    public AbilityDefinition AbilityDefinition => _abilityDefinition;
    public static Action OnAbilityLearned;
    public Action<NetworkConnection, byte, uint> OnRankLevelUp;
    protected string _abilityName => _abilityDefinition.Name;
    protected GameplayManager _gameplayManager;
    protected bool _isDebug = true;
    protected readonly string COLOR_DURATION = "#00F0FF";
    protected readonly string COLOR_AFFECTING_STAT = "#00F0FF";
    protected readonly string COLOR_DAMAGE = "#ff3517";
    protected readonly string COLOR_HEAL = "#0ec949";
    protected readonly string COLOR_STAT = "#96e33d";
    protected readonly string COLOR_XP = "#c3eb34";
    protected readonly string COLOR_COOLDOWN = "#c8e609";

    protected readonly Color DEBUG_SPHERE_DEFAULT_COLOR = new Color(1f, 0f, 0f, 0.5f);
    protected readonly Color DEBUG_SPHERE_ACTIVATE_COLOR = new Color(1f, 0f, 1f, 0.5f);
    protected Color _debugSphereColor;
    protected bool _showDebugSphere;
    protected Vector3 _debugSpherePos;
    protected float _debugSphereRadius = 1f;

    public virtual void InitAbility()
    {
        if (_buff != null) 
        {
            _buff.Init(GameplayManager.Instance);
        }
        else
        {
            Debug.LogWarning($"Buff is null during ability {_abilityName} initialization.");
        }
    }

    public virtual float CalculateValueBasedOnStacks(uint stacks) => .01f;
    
    public virtual int CalculateRankBasedOnStacks(uint stacks) => 1;
    
    public virtual float CalculateDamageBasedOnRank(int rank) => 1;
    
    public virtual uint GetStacksForRank() => 1;
    
    public uint AddRank(NetworkConnection connection)
    {
        if (RankCounter.ContainsKey(connection))
        {
            RankCounter[connection]++;
        }
        else
        {
            RankCounter.Add(connection, 1);
        }
        OnRankLevelUp?.Invoke(connection, _abilityDefinition.Id, RankCounter[connection]);
        return RankCounter[connection];
    }

    public uint ServerAddStack(FNAbilityController abilityController, uint amount)
    {
        if (!abilityController.LearnedAbilityDict.ContainsKey(AbilityDefinition.Id))
        {
            Debug.LogError($"Ability {AbilityDefinition.Name} is not learned by player {abilityController.gameObject.name}. Cannot add stacks.");
            return 0;
        }
        
        AbilityInfo targetsAbilityStats = abilityController.LearnedAbilityDict[AbilityDefinition.Id];
        targetsAbilityStats.Stacks = Math.Max(0, targetsAbilityStats.Stacks + amount);
        abilityController.AddOrSetAbility(targetsAbilityStats);
        return targetsAbilityStats.Stacks;
    }
    
    public uint AddStack(NetworkConnection connection)
    {
        if (StacksCounter.ContainsKey(connection))
        {
            StacksCounter[connection]++;
        }
        else
        {
            StacksCounter.Add(connection, 1);
        }
        
        if (EnoughStacksToLevelup(connection))
        {
            StacksCounter[connection] = 0;
            AddRank(connection);
            return 1;
        }
        else
        {
            return 0;
        }
        
        return StacksCounter[connection];
    }
    
    public UISpellInfo GetUISpellInfo(byte abilityId, uint stacks)
    {
        UISpellInfo spellInfo = new UISpellInfo();
        spellInfo.ID = _abilityDefinition.Id;
        uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId);
        int abilityRankBasedOnStacks = CalculateRankBasedOnStacks(abilityStacksForPlayer);
        spellInfo.Name = GetAbilityName(abilityRankBasedOnStacks);
        spellInfo.Icon = _abilityDefinition.Icon;
        spellInfo.Description = GetAbilityDescription(abilityRankBasedOnStacks, abilityStacksForPlayer);
        if (_abilityDefinition.IsPassive)
        {
            spellInfo.Flags = UISpellInfo_Flags.Passive;
        }
        else
        {
            AbilityDefinition.RPGAbilityRankData rankData = _abilityDefinition.RanksDatas[0];

            if (rankData != null)
            {
                switch (rankData.activationType)
                {
                    case AbilityDefinition.AbilityActivationType.Instant:
                        spellInfo.Flags = UISpellInfo_Flags.InstantCast;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCircle:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCircle;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCone:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCone;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedAim:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastAim;
                        break;
                    default:
                        spellInfo.Flags = UISpellInfo_Flags.PowerCostInPct;
                        break;

                }

                spellInfo.Range = rankData.maxRange;
                spellInfo.Cooldown = rankData.cooldown;
                if (rankData.castTime > 0)
                {
                    spellInfo.CastTime = rankData.castTime;
                }
                spellInfo.PowerCost = rankData.manaCost;
            }
            else
            {
                Debug.LogError($"Ability {spellInfo.Name} does not have rank {abilityId}. Setting default values.");
            }
        }
        return spellInfo;
    }

    private bool EnoughStacksToLevelup(NetworkConnection connection)
    {
        return StacksCounter[connection] >= GetStacksForRank();
    }

    public virtual string GetAbilityName(int rank) => _abilityDefinition.Name;
    public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description;
    public virtual string GetAbilityDescription(int rank, FNStatsController statsController) => _abilityDefinition.persistDescription;
    
    public virtual float GetAbilityCastingTime(int rank, FNStatsController statsController)
    {
        float castingTime = _abilityDefinition.RanksDatas[rank].castTime;
        return castingTime;
    }

    public virtual IEnumerator Activate(AbilityCastingData data)
    {
        yield return null;
    }

    [Server]
    protected virtual void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f)
    {
        Debug.Log($"{_abilityName} Applying caster buff.");
        _buff.Activate(casterBuffData, new int[]{}, duration:duration);
    }
    
    [Server]
    public virtual void CasterRemoveBuff(Buff.BuffData casterBuffData)
    {
        Debug.Log($"{_abilityName} Removing caster buff.");
        _buff.RemoveBuff(casterBuffData.ObjectId, casterBuffData.ObjectId);
    }

    protected virtual List<Collider> TargetsSelection(Transform caster) 
    {
        Debug.LogWarning($"{_abilityName} TargetsSelection method has not been implemented yet.");
        throw new NotImplementedException();
    }

    [Server]
    protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage, bool isExcludeSelf = false)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        var targets = TargetsInSphereSelection(playerComps, radius);
        for (int i = 0; i < targets.Count; i++) 
        {
            if (isExcludeSelf && targets[i] == playerComps.HealthController)
            {
                continue;
            }
            damage.receiver = targets[i].transform;
            targets[i].TakeDamage(damage);

            Debug.Log($"[{_abilityDefinition.Name}] Damage applied to {targets[i].name}");
        }
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, Buff.BuffData caster, float radius)
    {
        //Debug.Log($"{_abilityName} Selecting targets in sphere.");
        List<FishnetInvectorHealthController> targets = EnemyTargetsInRadius(pos, caster, radius);
        //Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");
        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsExcludingTagsInSphereSelection(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = TargetsInRadiusExcludingTags(tags, pos, caster, radius);
        return targets;
    }
    
    public static List<FishnetInvectorHealthController> TargetsInRadiusExcludingTags(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            for (int i = 0; i < tags.Length; i++)
            {
                if (targetNob.CompareTag(tags[i]))
                {
                    continue;
                }
            }
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            targets.Add(targetComps.HealthController);
        }
        return targets;
    }

    public static List<FishnetInvectorHealthController> EnemyTargetsInRadius(Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            Buff.BuffData targetData = new Buff.BuffData(targetComps.HealthController.ObjectId, targetComps.HealthController.gameObject.tag, 0f, caster.abilityId, 0, null, null, 0);
            if (IsNotValidTargetEnemy(caster, targetData))
                continue;
            
            targets.Add(targetComps.HealthController);
        }

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsInSphereSelection(UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var target in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(target).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNob.ObjectId);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(caster.HealthController.transform.position, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(target);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [ObserversRpc]
    protected void RpcShowEffectForObservers(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect for observers.");

        GameplayManager.Instance.StartCoroutine(ShowEffectOnTarget(targetNetId, abilityId, rank, timeout));
    }
    
    protected virtual IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if(targetComps == null)
        {
            Debug.LogError($"{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        List<GameObject> effects = new List<GameObject>(); 
        foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints)
        {
            Assert.IsNotNull(_abilityDefinition.RanksDatas[rank].hitEffect, $"Hit effect is null for {_abilityName}.");
            Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint);
            GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position + Vector3.up, Quaternion.identity, GameplayManager.Instance.transform);
            effect.transform.SetParent(pointTransform);
            effects.Add(effect);
        }

        yield return new WaitForSeconds(timeout);
        foreach (var effect in effects)
        {
            Destroy(effect, timeout);
        }
    }
    
    public static bool IsNotValidTargetEnemy(Buff.BuffData casterData, Buff.BuffData targetData)
    {
        if (casterData.ObjectId == targetData.ObjectId)
        {
            return true;
        }

        int casterTeam = GameplayManager.Instance.GetUnitTeamId(casterData.ObjectId);
        int targetTeam = GameplayManager.Instance.GetUnitTeamId(targetData.ObjectId);
        if (casterData.Tag == GameplayManager.TAG_PLAYER)
        {
            if (casterTeam == targetTeam)
            {
                return true;
            }
            return false;
        }else if (targetData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
        {
            if (casterData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
            {
                return true;
            }
            return false;
        }

        return false;
    }

    protected bool IsNotValidTargetEnemy(UnitComponents target, UnitComponents caster)
    {
        //Debug.Log($"{_abilityName} Checking if target is valid.");
        if (target == null)
            return true;
        
        if (target == caster)
        {
            //Debug.Log($"{_abilityName} Target is the same as caster. Invalid target.");
            return true;
        }

        var targetHealthController = target.HealthController;
        if (targetHealthController == null)
        {
            return true;
        }
        if (targetHealthController.CompareTag(GameplayManager.TAG_PLAYER))
        {
            //Debug.Log($"{_abilityName} Target is a player. Valid target.");
            return false;
        }else if (targetHealthController.CompareTag("Enemy"))
        {
            //Debug.Log($"{_abilityName} Target is an enemy. Valid target.");
            if (caster.HealthController.CompareTag("Enemy"))
            {
                return true;
            }
            return false;
        }

        //Debug.Log($"{_abilityName} Target does not have a Player or Enemy tag. Invalid target.");

        return false;
    }
    
    protected void DrawDebugSphere(Vector3 pos, float radius)
    {
        _debugSpherePos = pos;
        _debugSphereRadius = radius;
        _showDebugSphere = true;
        _debugSphereColor = DEBUG_SPHERE_ACTIVATE_COLOR;
        StartCoroutine(ResetDebugSphereColorAfterDelay(0.3f));
    }
    
    protected IEnumerator ResetDebugSphereColorAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        _debugSphereColor = DEBUG_SPHERE_DEFAULT_COLOR;
        _showDebugSphere = false;
    }
    
    public virtual float CalcAmount(FNStatsController statsController) {
        return 1f;
    }
    
    public virtual float CalcDuration(FNStatsController statsController) {
        return 1f;
    }
    
#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        if (_showDebugSphere)
        {
            Gizmos.color = _debugSphereColor;
            Gizmos.DrawSphere(_debugSpherePos, _debugSphereRadius);
        }
    }
#endif
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\ElectricBall.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;
using Invector.vCharacterController;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class ElectricBall: Ability
{
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE = .1f;

    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Lightning;

    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        var healthController = casterComps.HealthController;
        var casterPos = healthController.transform;

        var bullRotate = Camera.main.GetComponentInParent<Transform>().rotation;

        NetworkObject nps = Instantiate(networkedParticleSystem, casterComps.AbilityController.FirePoint.transform.position, bullRotate);

        vDamage damage = new(CalculateDamage(casterComps.StatsController), data.casterNetId, casterPos, "Lightning");

        damage.type = DAMAGE_TYPE;

        nps.GetComponent<ProjectileMoveScript>().BallDamage = damage;

        Spawn(nps);
        yield return null;
    }

    IEnumerator DelayDestroy(NetworkObject nps, float timeout)
    {
        yield return new WaitForSeconds(timeout);
        Despawn(nps);
    }

    private float CalculateDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\ElectricBall.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;
using Invector.vCharacterController;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class ElectricBall: Ability
{
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE = .1f;

    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Lightning;

    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        var healthController = casterComps.HealthController;
        var casterPos = healthController.transform;

        var bullRotate = Camera.main.GetComponentInParent<Transform>().rotation;

        NetworkObject nps = Instantiate(networkedParticleSystem, casterComps.AbilityController.FirePoint.transform.position, bullRotate);

        vDamage damage = new(CalculateDamage(casterComps.StatsController), data.casterNetId, casterPos, "Lightning");

        damage.type = DAMAGE_TYPE;

        nps.GetComponent<ProjectileMoveScript>().BallDamage = damage;

        Spawn(nps);
        yield return null;
    }

    IEnumerator DelayDestroy(NetworkObject nps, float timeout)
    {
        yield return new WaitForSeconds(timeout);
        Despawn(nps);
    }

    private float CalculateDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\PoisonNova.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;

public class PoisonNova : Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float POISON_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_TICK = .018890456f;
    private readonly float BASE_DURATION = 5f;
    private const string DESCRIPTION = "Unleashes a wave of toxic energy, poisoning all enemies in its radius upon activation. The poison inflicts [damage] damage over time.";
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison;
    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private float GetPoisonFeildDuration()
    {
        return POISON_FIELD_DURATION;
    }    
    private float CalculateTickDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE_PER_TICK * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition);
        var healthController = casterComps.HealthController;
        NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity);
        Spawn(nps);
        RpcShowEffectForObservers(data.casterNetId, abilityId, _rank, GetPoisonFeildDuration());

        Debug.Log($"{ClassName} Activated for unit #{data.casterNetId} with abilityId #{abilityId} and rank {data.rank}");
        float currentDuration = 0f;
        float tickTime = 1f;
        float radius = 1f;
        Buff.BuffData casterData = new Buff.BuffData(data.casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, 
            CalculateTickDamage(casterComps.StatsController));

        vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE);
        Vector3 poisonCloudPos = healthController.transform.position;
        while (currentDuration < GetPoisonFeildDuration())
        {
            currentDuration += tickTime;
            InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS);
            yield return new WaitForSeconds(tickTime);
        }
        Despawn(nps);
    }
    
    
    [Server]
    private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius)
    {
        DrawDebugSphere(pos, radius);
        var caster = UnitComponentsManager.GetUnitComponentsServerAndClient(casterData.ObjectId);
        if (caster != null)
        {
            damage = UpdateDamage(ref casterData, caster);
        }
        var targets = EnemyTargetsInSphereSelection(pos, casterData, radius);
        //remove duplicates
        var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray();
        if (targetCleared.Length == 0)
        {
            //Debug.Log($"{ClassName} No targets in sphere.");
            return;
        }
        else
        {
            _buff.Activate(casterData, targetCleared, BASE_DURATION, damage);
            //Debug.Log($"[{ClassName}] Buff activated for {targetCleared.Length} targets.");
        }
    }

    private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster)
    {
        vDamage damage;
        casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null,
            CalculateTickDamage(caster.StatsController));
        damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE);
        return damage;
    }

    protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if (targetComps == null)
        {
            Debug.LogError($"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        Vector3 pos = targetComps.HealthController.transform.position;
        GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity);
        VisualEffect vfxGraph = effect.GetComponent<VisualEffect>();
        float cloudCurrentSize = vfxGraph.GetFloat("SmokeSize");
        float timeElapsed = 0f;
        while (timeElapsed < TIME_TO_REACH_END_SIZE)
        {
            cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE);
            vfxGraph.SetFloat("SmokeSize", cloudCurrentSize);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        Destroy(effect, timeout);
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController);
        string mainEdited = DESCRIPTION.Replace("[damage]", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\PoisonNova.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;

public class PoisonNova : Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float POISON_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_TICK = .018890456f;
    private readonly float BASE_DURATION = 5f;
    private const string DESCRIPTION = "Unleashes a wave of toxic energy, poisoning all enemies in its radius upon activation. The poison inflicts [damage] damage over time.";
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison;
    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private float GetPoisonFeildDuration()
    {
        return POISON_FIELD_DURATION;
    }    
    private float CalculateTickDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE_PER_TICK * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition);
        var healthController = casterComps.HealthController;
        NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity);
        Spawn(nps);
        RpcShowEffectForObservers(data.casterNetId, abilityId, _rank, GetPoisonFeildDuration());

        Debug.Log($"{ClassName} Activated for unit #{data.casterNetId} with abilityId #{abilityId} and rank {data.rank}");
        float currentDuration = 0f;
        float tickTime = 1f;
        float radius = 1f;
        Buff.BuffData casterData = new Buff.BuffData(data.casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, 
            CalculateTickDamage(casterComps.StatsController));

        vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE);
        Vector3 poisonCloudPos = healthController.transform.position;
        while (currentDuration < GetPoisonFeildDuration())
        {
            currentDuration += tickTime;
            InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS);
            yield return new WaitForSeconds(tickTime);
        }
        Despawn(nps);
    }
    
    
    [Server]
    private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius)
    {
        DrawDebugSphere(pos, radius);
        var caster = UnitComponentsManager.GetUnitComponentsServerAndClient(casterData.ObjectId);
        if (caster != null)
        {
            damage = UpdateDamage(ref casterData, caster);
        }
        var targets = EnemyTargetsInSphereSelection(pos, casterData, radius);
        //remove duplicates
        var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray();
        if (targetCleared.Length == 0)
        {
            //Debug.Log($"{ClassName} No targets in sphere.");
            return;
        }
        else
        {
            _buff.Activate(casterData, targetCleared, BASE_DURATION, damage);
            //Debug.Log($"[{ClassName}] Buff activated for {targetCleared.Length} targets.");
        }
    }

    private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster)
    {
        vDamage damage;
        casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null,
            CalculateTickDamage(caster.StatsController));
        damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE);
        return damage;
    }

    protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if (targetComps == null)
        {
            Debug.LogError($"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        Vector3 pos = targetComps.HealthController.transform.position;
        GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity);
        VisualEffect vfxGraph = effect.GetComponent<VisualEffect>();
        float cloudCurrentSize = vfxGraph.GetFloat("SmokeSize");
        float timeElapsed = 0f;
        while (timeElapsed < TIME_TO_REACH_END_SIZE)
        {
            cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE);
            vfxGraph.SetFloat("SmokeSize", cloudCurrentSize);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        Destroy(effect, timeout);
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController);
        string mainEdited = DESCRIPTION.Replace("[damage]", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Blink.cs:
 using System.Collections;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

public class Blink : Ability
{
    private static float BLINK_DISTANCE = 6.0f;

    public override IEnumerator Activate(AbilityCastingData data) 
    {
        Debug.Log("Blink ability activated.");

        var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if(unitComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = unitComps.HealthController.Owner;
        TargetBlinkForward(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetBlinkForward(NetworkConnection conn, int casterNetId) 
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("[Blink][TargetBlinkForward]");

        RaycastHit hit;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;
        
        //get desired position with same y + forward + distance
        var lookRotation = Quaternion.LookRotation(hero.forward);
        sb.Append($" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}");
        Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f);
        sb.Append($" rotationNormalized: {rotationNormalized}; ");
        
        Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE;
        sb.Append($" destination: {destination}; ");

        var defaultLayerMask = LayerMask.GetMask("Default");
        if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask))
        {
            destination = hero.position + hero.forward * (hit.distance-.5f);
        }

        // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) 
        // {
        //     destination = hit.point;
        //     destination.y += .5f;
        // }
        destination.y += .2f;
        if (hit.transform != null)
        {
            sb.Append($" hit: {hit.transform}, hit pos: {hit.transform.position}; ");
        }
        sb.Append($"result destination: {destination}, after pos: {transform.position}");
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        Vector3 oldPos = hero.position;
        playerFim.OwnerTeleport(destination);
        BlinkForwardServerRpc(oldPos, destination);
        Vector3 middlePoint = (oldPos + destination) / 2;
    }

    [ServerRpc(RequireOwnership = false)]
    private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) 
    {
        Debug.Log("Blink forward on server.");
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        Debug.Log($"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}");
        SpawnEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalBlinkEffect(middlePoint, directionRotation);
    }
    
    private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        Debug.Log("Spawning blink effect.");

        var fx = _abilityDefinition.RanksDatas[0].hitEffect;

        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation);
            Destroy(fxInstance, 1.5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        string mainEdited = _abilityDefinition.mainDescription;
        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Blink.cs:
 using System.Collections;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

public class Blink : Ability
{
    private static float BLINK_DISTANCE = 6.0f;

    public override IEnumerator Activate(AbilityCastingData data) 
    {
        Debug.Log("Blink ability activated.");

        var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if(unitComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = unitComps.HealthController.Owner;
        TargetBlinkForward(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetBlinkForward(NetworkConnection conn, int casterNetId) 
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("[Blink][TargetBlinkForward]");

        RaycastHit hit;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;
        
        //get desired position with same y + forward + distance
        var lookRotation = Quaternion.LookRotation(hero.forward);
        sb.Append($" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}");
        Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f);
        sb.Append($" rotationNormalized: {rotationNormalized}; ");
        
        Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE;
        sb.Append($" destination: {destination}; ");

        var defaultLayerMask = LayerMask.GetMask("Default");
        if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask))
        {
            destination = hero.position + hero.forward * (hit.distance-.5f);
        }

        // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) 
        // {
        //     destination = hit.point;
        //     destination.y += .5f;
        // }
        destination.y += .2f;
        if (hit.transform != null)
        {
            sb.Append($" hit: {hit.transform}, hit pos: {hit.transform.position}; ");
        }
        sb.Append($"result destination: {destination}, after pos: {transform.position}");
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        Vector3 oldPos = hero.position;
        playerFim.OwnerTeleport(destination);
        BlinkForwardServerRpc(oldPos, destination);
        Vector3 middlePoint = (oldPos + destination) / 2;
    }

    [ServerRpc(RequireOwnership = false)]
    private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) 
    {
        Debug.Log("Blink forward on server.");
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        Debug.Log($"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}");
        SpawnEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalBlinkEffect(middlePoint, directionRotation);
    }
    
    private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        Debug.Log("Spawning blink effect.");

        var fx = _abilityDefinition.RanksDatas[0].hitEffect;

        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation);
            Destroy(fxInstance, 1.5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        string mainEdited = _abilityDefinition.mainDescription;
        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityManager.cs:
 using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using FishNet;
using FishNet.Managing.Timing;
using FishNet.Object;
using SingletonsExtension;
using UnityEngine;

public class AbilityManager : RoomManager 
{
    public static AbilityManager Instance { get; private set; }

    public static readonly float GLOBAL_COOLDOWN_TIME = 1.5f;
    [SerializeField] private Ability[] _abilities;
    public Buff[] Buffs => _buffs;
    [SerializeField] private Buff[] _buffs;
    [field:SerializeField] public bool IsInitialized { get; private set; }
    private Dictionary<int, Ability> _abilitiesDictionary = new Dictionary<int, Ability>();

    public void Init(bool asServer)
    {
        // Checking for other instances of AbilityManager.
        if (Instance != null)
        {
            Debug.LogWarning($"{ClassAndRoomName} There is more than one instance of AbilityManager in the scene.");
            return;
        }

        Instance = this;
        _abilities = GetComponents<Ability>();
        _buffs = GetComponents<Buff>();
        Debug.Log($"[AbilityManager] Ability Manager instantiated with " + _abilities.Length + " abilities.");

        // Initializing abilities.
        for (int i = 0; i < _abilities.Length; i++) 
        {
            int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilities[i].AbilityDefinition);

            if (abilityId > -1)
            {
                _abilitiesDictionary.Add(abilityId, _abilities[i]);
                _abilities[i].InitAbility();
                _abilities[i].OnRankLevelUp += GameplayManager.RewardAbilityManager.SetRankToAbility;
                Debug.Log($"{ClassAndRoomName} Initialized ability " + _abilities[i].AbilityDefinition.name + " with ID: " + abilityId);
            }
            else
            {
                Debug.LogWarning($"{ClassAndRoomName} Invalid ability ID: {abilityId}. Skipping ability initialization.");
            }
        }
        IsInitialized = true;
    }

    public BuffDefinition GetBuffDefinition(Buff.BuffType buffType)
    {
        for (int i = 0; i < _buffs.Length; i++)
        {
            if (_buffs[i].BuffDefinition.buffType == buffType)
            {
                return _buffs[i].BuffDefinition;
            }
        }
        return null;
    }

    public Ability GetAbility(int id)
    {
        for (int i = 0; i < _abilities.Length; i++)
        {
            if (_abilities[i].AbilityDefinition.Id == id)
            {
                return _abilities[i];
            }
        }
        return null;
    }
    
    [ServerRpc(RequireOwnership = false)]
    public void InitAbility(AbilityCastingData data)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if (!playerComps.AbilityController.IsEligibleToCast(data.abilityId)) 
        {
            Debug.Log($"{ClassAndRoomName} Player {data.casterNetId} is not eligible to cast ability {data.abilityId}.");
            return;
        }
        
        Ability ability = GetAbility(data.abilityId);
        float abilityCastingTime = ability.GetAbilityCastingTime(data.rank, playerComps.StatsController);
        bool isInstantCast = abilityCastingTime < float.Epsilon;
        if (isInstantCast)
        {
            playerComps.AbilityController.StartGlobalCooldown(GLOBAL_COOLDOWN_TIME);
        }
        
        Debug.Log($"{ClassAndRoomName} Initiating ability {data.abilityId} for player {data.casterNetId} with rank {data.rank}.");
        StartCoroutine(InitCooldown(data.casterNetId, data.abilityId, data.rank));
        StartCoroutine(_abilitiesDictionary[data.abilityId].Activate(data));
    }

    [Server]
    private IEnumerator InitCooldown(int casterNetId, int abilityId, int rank)
    {
        Ability ability = GetAbility(abilityId);
        AbilityDefinition abilityDefinition = ability.AbilityDefinition;
        float cooldown = abilityDefinition.RanksDatas[0].cooldown;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);

        FNAbilityController.CooldownData cooldownData = new FNAbilityController.CooldownData();
        cooldownData.IsOnCooldown = true;
        cooldownData.cooldownFinishTime = (float)InstanceFinder.TimeManager.TicksToTime(InstanceFinder.TimeManager.Tick) + cooldown;
        Debug.Log($"{ClassAndRoomName} Setting ability {abilityId} cooldown for player {casterNetId}; cooldownFinishTime: {cooldownData.cooldownFinishTime}.");
        playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData);

        yield return new WaitForSeconds(cooldown);

        Debug.Log($"{ClassAndRoomName} Resetting ability {abilityId} cooldown for player {casterNetId}.");
        cooldownData.IsOnCooldown = false;
        playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData);
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityManager.cs:
 using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using FishNet;
using FishNet.Managing.Timing;
using FishNet.Object;
using SingletonsExtension;
using UnityEngine;

public class AbilityManager : RoomManager 
{
    public static AbilityManager Instance { get; private set; }

    public static readonly float GLOBAL_COOLDOWN_TIME = 1.5f;
    [SerializeField] private Ability[] _abilities;
    public Buff[] Buffs => _buffs;
    [SerializeField] private Buff[] _buffs;
    [field:SerializeField] public bool IsInitialized { get; private set; }
    private Dictionary<int, Ability> _abilitiesDictionary = new Dictionary<int, Ability>();

    public void Init(bool asServer)
    {
        // Checking for other instances of AbilityManager.
        if (Instance != null)
        {
            Debug.LogWarning($"{ClassAndRoomName} There is more than one instance of AbilityManager in the scene.");
            return;
        }

        Instance = this;
        _abilities = GetComponents<Ability>();
        _buffs = GetComponents<Buff>();
        Debug.Log($"[AbilityManager] Ability Manager instantiated with " + _abilities.Length + " abilities.");

        // Initializing abilities.
        for (int i = 0; i < _abilities.Length; i++) 
        {
            int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilities[i].AbilityDefinition);

            if (abilityId > -1)
            {
                _abilitiesDictionary.Add(abilityId, _abilities[i]);
                _abilities[i].InitAbility();
                _abilities[i].OnRankLevelUp += GameplayManager.RewardAbilityManager.SetRankToAbility;
                Debug.Log($"{ClassAndRoomName} Initialized ability " + _abilities[i].AbilityDefinition.name + " with ID: " + abilityId);
            }
            else
            {
                Debug.LogWarning($"{ClassAndRoomName} Invalid ability ID: {abilityId}. Skipping ability initialization.");
            }
        }
        IsInitialized = true;
    }

    public BuffDefinition GetBuffDefinition(Buff.BuffType buffType)
    {
        for (int i = 0; i < _buffs.Length; i++)
        {
            if (_buffs[i].BuffDefinition.buffType == buffType)
            {
                return _buffs[i].BuffDefinition;
            }
        }
        return null;
    }

    public Ability GetAbility(int id)
    {
        for (int i = 0; i < _abilities.Length; i++)
        {
            if (_abilities[i].AbilityDefinition.Id == id)
            {
                return _abilities[i];
            }
        }
        return null;
    }
    
    [ServerRpc(RequireOwnership = false)]
    public void InitAbility(AbilityCastingData data)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if (!playerComps.AbilityController.IsEligibleToCast(data.abilityId)) 
        {
            Debug.Log($"{ClassAndRoomName} Player {data.casterNetId} is not eligible to cast ability {data.abilityId}.");
            return;
        }
        
        Ability ability = GetAbility(data.abilityId);
        float abilityCastingTime = ability.GetAbilityCastingTime(data.rank, playerComps.StatsController);
        bool isInstantCast = abilityCastingTime < float.Epsilon;
        if (isInstantCast)
        {
            playerComps.AbilityController.StartGlobalCooldown(GLOBAL_COOLDOWN_TIME);
        }
        
        Debug.Log($"{ClassAndRoomName} Initiating ability {data.abilityId} for player {data.casterNetId} with rank {data.rank}.");
        StartCoroutine(InitCooldown(data.casterNetId, data.abilityId, data.rank));
        StartCoroutine(_abilitiesDictionary[data.abilityId].Activate(data));
    }

    [Server]
    private IEnumerator InitCooldown(int casterNetId, int abilityId, int rank)
    {
        Ability ability = GetAbility(abilityId);
        AbilityDefinition abilityDefinition = ability.AbilityDefinition;
        float cooldown = abilityDefinition.RanksDatas[0].cooldown;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);

        FNAbilityController.CooldownData cooldownData = new FNAbilityController.CooldownData();
        cooldownData.IsOnCooldown = true;
        cooldownData.cooldownFinishTime = (float)InstanceFinder.TimeManager.TicksToTime(InstanceFinder.TimeManager.Tick) + cooldown;
        Debug.Log($"{ClassAndRoomName} Setting ability {abilityId} cooldown for player {casterNetId}; cooldownFinishTime: {cooldownData.cooldownFinishTime}.");
        playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData);

        yield return new WaitForSeconds(cooldown);

        Debug.Log($"{ClassAndRoomName} Resetting ability {abilityId} cooldown for player {casterNetId}.");
        cooldownData.IsOnCooldown = false;
        playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData);
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityDefinition.cs:
 using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

[CreateAssetMenu(fileName = "New Ability", menuName = "ScriptableObjects/Ability")]
public class AbilityDefinition : ScriptableObject
{
    public byte Id => _id;
    
    [Header("-----BASE DATA-----")] 
    [SerializeField] private byte _id;
    [SerializeField] private string _name;
    [SerializeField] [TextArea(3, 10)] private string _description;
    [field:SerializeField, TextArea(2,10)] public string mainDescription { get; private set; }
    [field:SerializeField, TextArea(2,10)] public string questDescription { get; private set; }
    [field:SerializeField, TextArea(2,10)] public string persistDescription { get; private set; }
    [SerializeField] private Sprite _icon;
    [field:SerializeField] public int CastID { get; private set; }
    [SerializeField] private RPGAbilityRankData[] _ranksDatas;
    [SerializeField] private Ability ability;
    [field:SerializeField] public bool IsPassive { get; private set; }
    [field: SerializeField] public bool IsHide { get; private set; }
    public bool canBeUsedIfDead = false;

    public Ability AbilityInstance => ability;
    public RPGAbilityRankData[] RanksDatas => _ranksDatas;
    #region Accessors
    public string Name => _name;
    public string Description => _description;
    public Sprite Icon => _icon;
    #endregion
    
    public enum CastType
    {
        Stationary,
        Mobile
    }

    public enum AbilityType
    {
        Normal,
        PlayerAutoAttack,
        PlayerActionAbility
    }
    public enum TARGET_TYPES
    {
        SELF,
        CONE,
        AOE,
        LINEAR,
        PROJECTILE,
        SQUARE,
        GROUND,
        GROUND_LEAP,
        TARGET_PROJECTILE,
        TARGET_INSTANT
    }
    public enum ABILITY_TAGS
    {
        onHit,
        onKill,
        shapeshifting,
        stealth
    }


    public enum AbilityActivationType
    {
        Instant,
        Casted,
        Channeled,
        Charged,
        PreCastedCircle,
        PreCastedCone,
        PreCastedAim
    }
    
    public enum COST_TYPES
    {
        FLAT,
        PERCENT_OF_MAX,
        PERCENT_OF_CURRENT
    }
    
    [Serializable]
    public class RPGAbilityRankData
    {
        public CastType castType;
        public AbilityActivationType activationType;
        public float manaCost;
        public float castTime;
        public bool castInRun;
        public bool canBeUsedStunned;
        public bool cancelStealth = true;

        public TARGET_TYPES targetType;
        public float minRange;
        public float maxRange;
        
        public float projectileSpeed;
        public float projectileDistance;
        public float projectileAngleSpread;
        public int projectileCount = 1;
        public float firstProjectileDelay;
        public float projectileDelay;
        public float projectileDuration = 5;
        public float projectileComeBackTime;
        public float projectileComeBackSpeed;
        public bool isProjectileComeBack;
        public float projectileNearbyUnitDistanceMax;
        public float projectileNearbyUnitMaxHit;
        public bool isProjectileNearbyUnit;
        public bool projectileDestroyedByEnvironment = true;
        public LayerMask projectileDestroyLayers;
        public bool projectileAffectedByGravity;
        public bool projectileShootOnClickPosition;
        
        public bool CanHitPlayer, CanHitAlly, CanHitNeutral = true, CanHitEnemy = true, CanHitSelf, CanHitPet, CanHitOwner;

        public bool UsedOnALly;
        public GameObject projectileEffect;
        public GameObject groundVisualEffect;
        public GameObject hitEffect;

        public float channelTime;

        public bool isAttackSpeedCooldown;
        public bool isAttackSpeedGCD;
        public float cooldown;
        public bool isGCD;
        public bool startCDOnActivate = true;
        public bool CanUseDuringGCD;
        public bool isSharingCooldown;
        [HideInInspector] public string cooldownTag;

        public List<BuffDefinition> targetEffectsApplied = new List<BuffDefinition>();
        public List<float> targetEffectsAppliedDuration;
        public List<BuffDefinition> casterEffectsApplied = new List<BuffDefinition>();
        public List<float> casterEffectsAppliedDuration;
        
        public List<AttachmentPoints.Point> FXattachmentPoints = new List<AttachmentPoints.Point>();

    }

    public void SetId(byte id)
    {
        _id = id;
    }

    public string GetJsonRepresentation()
    {
        StringBuilder jsonBuilder = new StringBuilder();
        jsonBuilder.Append("{\n");
        if (IsPassive)
            jsonBuilder.AppendFormat("  \"Name\": \"{0}\"(Passive),\n", _name);
        else
            jsonBuilder.AppendFormat("  \"Name\": \"{0}\",\n", _name);
        jsonBuilder.AppendFormat("  \"Description\": \"{0}\",\n", mainDescription.ToString());
        jsonBuilder.AppendFormat("  \"QuestDescription\": \"{0}\",\n", questDescription.ToString());
        // Add other necessary fields in the same pattern
        jsonBuilder.Append("}");
        return jsonBuilder.ToString();
    }
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityDefinition.cs:
 using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

[CreateAssetMenu(fileName = "New Ability", menuName = "ScriptableObjects/Ability")]
public class AbilityDefinition : ScriptableObject
{
    public byte Id => _id;
    
    [Header("-----BASE DATA-----")] 
    [SerializeField] private byte _id;
    [SerializeField] private string _name;
    [SerializeField] [TextArea(3, 10)] private string _description;
    [field:SerializeField, TextArea(2,10)] public string mainDescription { get; private set; }
    [field:SerializeField, TextArea(2,10)] public string questDescription { get; private set; }
    [field:SerializeField, TextArea(2,10)] public string persistDescription { get; private set; }
    [SerializeField] private Sprite _icon;
    [field:SerializeField] public int CastID { get; private set; }
    [SerializeField] private RPGAbilityRankData[] _ranksDatas;
    [SerializeField] private Ability ability;
    [field:SerializeField] public bool IsPassive { get; private set; }
    [field: SerializeField] public bool IsHide { get; private set; }
    public bool canBeUsedIfDead = false;

    public Ability AbilityInstance => ability;
    public RPGAbilityRankData[] RanksDatas => _ranksDatas;
    #region Accessors
    public string Name => _name;
    public string Description => _description;
    public Sprite Icon => _icon;
    #endregion
    
    public enum CastType
    {
        Stationary,
        Mobile
    }

    public enum AbilityType
    {
        Normal,
        PlayerAutoAttack,
        PlayerActionAbility
    }
    public enum TARGET_TYPES
    {
        SELF,
        CONE,
        AOE,
        LINEAR,
        PROJECTILE,
        SQUARE,
        GROUND,
        GROUND_LEAP,
        TARGET_PROJECTILE,
        TARGET_INSTANT
    }
    public enum ABILITY_TAGS
    {
        onHit,
        onKill,
        shapeshifting,
        stealth
    }


    public enum AbilityActivationType
    {
        Instant,
        Casted,
        Channeled,
        Charged,
        PreCastedCircle,
        PreCastedCone,
        PreCastedAim
    }
    
    public enum COST_TYPES
    {
        FLAT,
        PERCENT_OF_MAX,
        PERCENT_OF_CURRENT
    }
    
    [Serializable]
    public class RPGAbilityRankData
    {
        public CastType castType;
        public AbilityActivationType activationType;
        public float manaCost;
        public float castTime;
        public bool castInRun;
        public bool canBeUsedStunned;
        public bool cancelStealth = true;

        public TARGET_TYPES targetType;
        public float minRange;
        public float maxRange;
        
        public float projectileSpeed;
        public float projectileDistance;
        public float projectileAngleSpread;
        public int projectileCount = 1;
        public float firstProjectileDelay;
        public float projectileDelay;
        public float projectileDuration = 5;
        public float projectileComeBackTime;
        public float projectileComeBackSpeed;
        public bool isProjectileComeBack;
        public float projectileNearbyUnitDistanceMax;
        public float projectileNearbyUnitMaxHit;
        public bool isProjectileNearbyUnit;
        public bool projectileDestroyedByEnvironment = true;
        public LayerMask projectileDestroyLayers;
        public bool projectileAffectedByGravity;
        public bool projectileShootOnClickPosition;
        
        public bool CanHitPlayer, CanHitAlly, CanHitNeutral = true, CanHitEnemy = true, CanHitSelf, CanHitPet, CanHitOwner;

        public bool UsedOnALly;
        public GameObject projectileEffect;
        public GameObject groundVisualEffect;
        public GameObject hitEffect;

        public float channelTime;

        public bool isAttackSpeedCooldown;
        public bool isAttackSpeedGCD;
        public float cooldown;
        public bool isGCD;
        public bool startCDOnActivate = true;
        public bool CanUseDuringGCD;
        public bool isSharingCooldown;
        [HideInInspector] public string cooldownTag;

        public List<BuffDefinition> targetEffectsApplied = new List<BuffDefinition>();
        public List<float> targetEffectsAppliedDuration;
        public List<BuffDefinition> casterEffectsApplied = new List<BuffDefinition>();
        public List<float> casterEffectsAppliedDuration;
        
        public List<AttachmentPoints.Point> FXattachmentPoints = new List<AttachmentPoints.Point>();

    }

    public void SetId(byte id)
    {
        _id = id;
    }

    public string GetJsonRepresentation()
    {
        StringBuilder jsonBuilder = new StringBuilder();
        jsonBuilder.Append("{\n");
        if (IsPassive)
            jsonBuilder.AppendFormat("  \"Name\": \"{0}\"(Passive),\n", _name);
        else
            jsonBuilder.AppendFormat("  \"Name\": \"{0}\",\n", _name);
        jsonBuilder.AppendFormat("  \"Description\": \"{0}\",\n", mainDescription.ToString());
        jsonBuilder.AppendFormat("  \"QuestDescription\": \"{0}\",\n", questDescription.ToString());
        // Add other necessary fields in the same pattern
        jsonBuilder.Append("}");
        return jsonBuilder.ToString();
    }
} 

// Assets\-ZombieRoyale\Scripts\Core\UnitComponentsManager.cs:
 using System.Collections.Generic;
using FishNet;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

namespace _ZombieRoyale.Scripts.Core
{
    public class UnitComponentsManager
    {
        private Dictionary<int, UnitComponents> _allUnitComponentsDict = new ();
        private Dictionary<int, UnitComponents> _playerHeroUnitComponentsDict = new ();
        private Dictionary<Collider, FishnetInvectorHealthController> _collidersToHealthControllers = new ();

        public UnitComponents SaveUnitComponents(NetworkObject nob)
        {
            if (_allUnitComponentsDict.ContainsKey(nob.ObjectId)) return _allUnitComponentsDict[nob.ObjectId];
            UnitComponents unitComps = UnitComponents.AssignUnitComponents(nob);
            _allUnitComponentsDict.Add(nob.ObjectId, unitComps);
            SaveAsPlayerHeroUnitComponentsIfRequired(unitComps);
            return unitComps;
        }

        private void SaveAsPlayerHeroUnitComponentsIfRequired(UnitComponents unitComps)
        {
            if (unitComps.InvectorManager != null)
            {
                _playerHeroUnitComponentsDict.Add(unitComps.InvectorManager.NetworkObject.ObjectId, unitComps);
            }
        }
        
        public static List<NetworkObject> GetAllPlayersHeroes()
        {
            List<NetworkObject> playersHeroes = new List<NetworkObject>();
            foreach (var kv in GameplayManager.UnitComponentsManager._playerHeroUnitComponentsDict)
            {
                NetworkObject unitNob = kv.Value.NetworkObject;
                if (unitNob == null)
                    continue;
                
                playersHeroes.Add(unitNob);
            }
            return playersHeroes;
        }

        public static UnitComponents GetPlayerHeroComponentsServerAndClient(NetworkConnection conn)
        {
            foreach (var kv in GameplayManager.UnitComponentsManager._playerHeroUnitComponentsDict)
            {
                if (GetUnitComponentsServerAndClient(kv.Key).Owner != conn)
                {
                    continue;
                }
                
                return kv.Value;
            }
            Debug.LogError($"UnitComponents not found for client #{conn.ClientId}");
            return NullUnitComponents.Instance;
        }

        public static UnitComponents GetUnitComponents(NetworkObject nob)
        {
            if (GameplayManager.UnitComponentsManager._allUnitComponentsDict.ContainsKey(nob.ObjectId)) return GameplayManager.UnitComponentsManager._allUnitComponentsDict[nob.ObjectId];
            UnitComponents unitComps = UnitComponents.AssignUnitComponents(nob);
            GameplayManager.UnitComponentsManager._allUnitComponentsDict.Add(nob.ObjectId, unitComps);
            return unitComps;
        }

        public static UnitComponents GetUnitComponentsServerAndClient(int targetId)
        {
            if (targetId == -1)
            {
                Debug.LogError($"[UnitComponentsManager] targetId:{targetId} is -1");
                return NullUnitComponents.Instance;
            }

            if (GameplayManager.UnitComponentsManager._allUnitComponentsDict.TryGetValue(targetId, out var existingComponents))
            {
                return existingComponents;
            }

            var allObjects = InstanceFinder.IsClient ? InstanceFinder.ClientManager.Objects.Spawned : InstanceFinder.ServerManager.Objects.Spawned;
            if (!allObjects.TryGetValue(targetId, out var netObj))
            {
                Debug.LogError($"[UnitComponentsManager] targetId:{targetId} not found in spawned objects");
                return NullUnitComponents.Instance;
            }

            var unitComponents = new UnitComponents(netObj);
            GameplayManager.UnitComponentsManager._allUnitComponentsDict[targetId] = unitComponents;
            Debug.Log($"[UnitComponentsManager] UnitComponents created for object #{targetId}");
            return unitComponents;
        }
        
        public static bool RemoveUnitComponents(UnitComponents unitComps)
        {
            if (GameplayManager.UnitComponentsManager._allUnitComponentsDict.ContainsKey(unitComps.InvectorManager.NetworkObject.ObjectId))
            {
                GameplayManager.UnitComponentsManager._allUnitComponentsDict.Remove(unitComps.InvectorManager.NetworkObject.ObjectId);
                if (GameplayManager.UnitComponentsManager._playerHeroUnitComponentsDict.ContainsKey(unitComps.InvectorManager.NetworkObject.ObjectId))
                {
                    GameplayManager.UnitComponentsManager._playerHeroUnitComponentsDict.Remove(unitComps.InvectorManager.NetworkObject.ObjectId);
                }
                return true;
            }
            return false;
        }

        public void FlushUnitComponentsDict()
        {
            _allUnitComponentsDict.Clear();
        }
    }
} 

// Assets\-ZombieRoyale\Scripts\Core\UnitComponentsManager.cs:
 using System.Collections.Generic;
using FishNet;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

namespace _ZombieRoyale.Scripts.Core
{
    public class UnitComponentsManager
    {
        private Dictionary<int, UnitComponents> _allUnitComponentsDict = new ();
        private Dictionary<int, UnitComponents> _playerHeroUnitComponentsDict = new ();
        private Dictionary<Collider, FishnetInvectorHealthController> _collidersToHealthControllers = new ();

        public UnitComponents SaveUnitComponents(NetworkObject nob)
        {
            if (_allUnitComponentsDict.ContainsKey(nob.ObjectId)) return _allUnitComponentsDict[nob.ObjectId];
            UnitComponents unitComps = UnitComponents.AssignUnitComponents(nob);
            _allUnitComponentsDict.Add(nob.ObjectId, unitComps);
            SaveAsPlayerHeroUnitComponentsIfRequired(unitComps);
            return unitComps;
        }

        private void SaveAsPlayerHeroUnitComponentsIfRequired(UnitComponents unitComps)
        {
            if (unitComps.InvectorManager != null)
            {
                _playerHeroUnitComponentsDict.Add(unitComps.InvectorManager.NetworkObject.ObjectId, unitComps);
            }
        }
        
        public static List<NetworkObject> GetAllPlayersHeroes()
        {
            List<NetworkObject> playersHeroes = new List<NetworkObject>();
            foreach (var kv in GameplayManager.UnitComponentsManager._playerHeroUnitComponentsDict)
            {
                NetworkObject unitNob = kv.Value.NetworkObject;
                if (unitNob == null)
                    continue;
                
                playersHeroes.Add(unitNob);
            }
            return playersHeroes;
        }

        public static UnitComponents GetPlayerHeroComponentsServerAndClient(NetworkConnection conn)
        {
            foreach (var kv in GameplayManager.UnitComponentsManager._playerHeroUnitComponentsDict)
            {
                if (GetUnitComponentsServerAndClient(kv.Key).Owner != conn)
                {
                    continue;
                }
                
                return kv.Value;
            }
            Debug.LogError($"UnitComponents not found for client #{conn.ClientId}");
            return NullUnitComponents.Instance;
        }

        public static UnitComponents GetUnitComponents(NetworkObject nob)
        {
            if (GameplayManager.UnitComponentsManager._allUnitComponentsDict.ContainsKey(nob.ObjectId)) return GameplayManager.UnitComponentsManager._allUnitComponentsDict[nob.ObjectId];
            UnitComponents unitComps = UnitComponents.AssignUnitComponents(nob);
            GameplayManager.UnitComponentsManager._allUnitComponentsDict.Add(nob.ObjectId, unitComps);
            return unitComps;
        }

        public static UnitComponents GetUnitComponentsServerAndClient(int targetId)
        {
            if (targetId == -1)
            {
                Debug.LogError($"[UnitComponentsManager] targetId:{targetId} is -1");
                return NullUnitComponents.Instance;
            }

            if (GameplayManager.UnitComponentsManager._allUnitComponentsDict.TryGetValue(targetId, out var existingComponents))
            {
                return existingComponents;
            }

            var allObjects = InstanceFinder.IsClient ? InstanceFinder.ClientManager.Objects.Spawned : InstanceFinder.ServerManager.Objects.Spawned;
            if (!allObjects.TryGetValue(targetId, out var netObj))
            {
                Debug.LogError($"[UnitComponentsManager] targetId:{targetId} not found in spawned objects");
                return NullUnitComponents.Instance;
            }

            var unitComponents = new UnitComponents(netObj);
            GameplayManager.UnitComponentsManager._allUnitComponentsDict[targetId] = unitComponents;
            Debug.Log($"[UnitComponentsManager] UnitComponents created for object #{targetId}");
            return unitComponents;
        }
        
        public static bool RemoveUnitComponents(UnitComponents unitComps)
        {
            if (GameplayManager.UnitComponentsManager._allUnitComponentsDict.ContainsKey(unitComps.InvectorManager.NetworkObject.ObjectId))
            {
                GameplayManager.UnitComponentsManager._allUnitComponentsDict.Remove(unitComps.InvectorManager.NetworkObject.ObjectId);
                if (GameplayManager.UnitComponentsManager._playerHeroUnitComponentsDict.ContainsKey(unitComps.InvectorManager.NetworkObject.ObjectId))
                {
                    GameplayManager.UnitComponentsManager._playerHeroUnitComponentsDict.Remove(unitComps.InvectorManager.NetworkObject.ObjectId);
                }
                return true;
            }
            return false;
        }

        public void FlushUnitComponentsDict()
        {
            _allUnitComponentsDict.Clear();
        }
    }
} 

// Assets\-ZombieRoyale\Scripts\Core\UnitComponents.cs:
 using System;
using _ZombieRoyale.Scripts.Clients;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;
using Zomb.Creatures.Helpers;

namespace _ZombieRoyale.Scripts.Core
{
    [Serializable]
    public class UnitComponents {
        public FishnetInvectorManager InvectorManager;
        public FishnetInvectorItemManager ItemManager;
        public FishnetInvectorHealthController HealthController;
        public FishnetInvectorShooterManager ShooterManager;
        public FishnetInvectorProjectilesManager ProjectilesManager;
        public FNStatsController StatsController;
        public FNXpController XpController;
        public FNAbilityController AbilityController;
        public FNvMeleeManager MeleeManager;
        public AttachmentPoints AttachmentPoints;
        public AIUnit AiUnit;
        public TeamUIController TeamUiController;
        public FishnetInvectorBuffController BuffController;
        public AnimatorDecorator AnimatorDecorator;
        public NetworkedActionsAnimator ActionsAnimator;
        public Transform Trans => HealthController.transform;
        public NetworkConnection Owner => HealthController.NetworkObject.Owner;
        public NetworkObject NetworkObject => HealthController.NetworkObject;
    
        public UnitComponents(){}
        public UnitComponents(NetworkObject netObj) {
            InvectorManager = netObj.GetComponent<FishnetInvectorManager>();
            ItemManager = netObj.GetComponent<FishnetInvectorItemManager>();
            HealthController = netObj.GetComponent<FishnetInvectorHealthController>();
            ShooterManager = netObj.GetComponent<FishnetInvectorShooterManager>();
            ProjectilesManager = netObj.GetComponent<FishnetInvectorProjectilesManager>();
            StatsController = netObj.GetComponent<FNStatsController>();
            XpController = netObj.GetComponent<FNXpController>();
            AbilityController = netObj.GetComponent<FNAbilityController>();
            MeleeManager = netObj.GetComponent<FNvMeleeManager>();
            AttachmentPoints = netObj.GetComponent<AttachmentPoints>();
            AiUnit = netObj.GetComponent<AIUnit>();
            TeamUiController = netObj.GetComponent<TeamUIController>();
            BuffController = netObj.GetComponent<FishnetInvectorBuffController>();
            AnimatorDecorator = netObj.GetComponent<AnimatorDecorator>();
            ActionsAnimator = netObj.GetComponent<NetworkedActionsAnimator>();
        
            SetParentReference();
        }

        public void Init()
        {
            SetParentReference();
        }

        private void SetParentReference() {
            if (ItemManager != null) ItemManager.UnitComponents = this;
            if (HealthController != null) HealthController.UnitComponents = this;
            if (ShooterManager != null) ShooterManager.UnitComponents = this;
            if (ProjectilesManager != null) ProjectilesManager.UnitComponents = this;
            if (StatsController != null) StatsController.UnitComponents = this;
            if (XpController != null) XpController.UnitComponents = this;
            if (AbilityController != null) AbilityController.UnitComponents = this;
            if (MeleeManager != null) MeleeManager.UnitComponents = this;
            if (AttachmentPoints != null) AttachmentPoints.UnitComponents = this;
            if (AiUnit != null) AiUnit.UnitComponents = this;
            if (TeamUiController != null) TeamUiController.UnitComponents = this;
            if (BuffController != null) BuffController.UnitComponents = this;
            if (AnimatorDecorator != null) AnimatorDecorator.UnitComponents = this;
            if (ActionsAnimator != null) ActionsAnimator.UnitComponents = this;
        }

        public static UnitComponents AssignUnitComponents(NetworkObject nob)
        {
            UnitComponents unitComps = nob.GetComponent<Unit>().UnitComps;
            unitComps.Init();
            return unitComps;
        }
    }
} 

// Assets\FishNet Invector\Scripts\Non-networked\FNvMeleeManager.cs:
 using System;
using System.Collections.Generic;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet_Invector.Scripts.Non_networked;
using FishNet.Object;
using Invector;
using Invector.vItemManager;
using Invector.vMelee;
using SingletonsExtension;
using UnityEngine;
using Zomb.Creatures.Helpers;
using Random = UnityEngine.Random;

namespace FishnetInvector
{
    public class FNvMeleeManager : vMeleeManager
    {
        public UnitComponents UnitComponents { get; set; }
        private bool _isServer = false;
        private bool _isHost = false;
        public bool IsServer => _isServer;
        public bool IsHost => _isHost;
        public bool IsClient { get { return !_isServer; } }
        public GameplayManager GameplayManager => _gameplayManager;
        private GameplayManager _gameplayManager;
        private bool _isOwner = false;
        private bool _isAI = true;
        private NetworkObject _networkObject;
        [SerializeField] private AnimatorDecorator animatorDecorator;
        [SerializeField] private MeleeSlashParameters[] meleeSlashParameters;
        [SerializeField] private FishnetInvectorManager fishnetInvectorManager;
        [SerializeField] private AttackListener attackListener;
        public void SetAsServerOwned() => _isServer = _isOwner = _isAI = true;
        public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
        private string _className;
        
        public FishnetInvectorHealthController HealthController
        {
            get
            {
                if (!_healthController)
                {
                    _healthController = GetComponent<FishnetInvectorHealthController>();
                }

                return _healthController;
            }
        }

        private FishnetInvectorHealthController _healthController;

        public NetworkObject ThisNetworkObject
        {
            get
            {
                if (!_networkObject)
                {
                    _networkObject = GetComponent<NetworkObject>();
                }
                return _networkObject;
            }
        }

        public bool IsOwner
        {
            get { return _isOwner; }set { _isOwner = value; }}
        private FNvMeleeWeapon _fnrWeapon, _fnlWeapon;
        private float nextTimeComboReset = 0;
        private bool isComboResetted = false;

        public FNvMeleeWeapon MainWeapon
        {
            get
            {
                if (rightWeapon && rightWeapon.gameObject.activeInHierarchy) return _fnrWeapon;
                if (leftWeapon && leftWeapon.gameObject.activeInHierarchy) return _fnlWeapon;
                return null;
            }
        }

        public FNvMeleeWeapon FNrWeapon {
            get {
                if (_fnrWeapon == null) {
                    _fnrWeapon = (FNvMeleeWeapon) rightWeapon;
                }
                return _fnrWeapon;
            }
        }
        public FNvMeleeWeapon FNlWeapon {
            get {
                if (_fnlWeapon == null) {
                    _fnlWeapon = (FNvMeleeWeapon) leftWeapon;
                }
                return _fnlWeapon;
            }
        }
        
        public void SetAsHost()
        {
            _isHost = true;
        }

        public void SetAsOwner()
        {
            _isOwner = true;
            Debug.Log($"[FNvMeleeManager][SetAsOwner] {gameObject.name} #{ThisNetworkObject.ObjectId}", gameObject);
        }

        private void OnValidate()
        {
            animatorDecorator ??= GetComponent<AnimatorDecorator>();
            _healthController ??= GetComponent<FishnetInvectorHealthController>();
            fishnetInvectorManager ??= GetComponent<FishnetInvectorManager>();
            attackListener ??= GetComponent<AttackListener>();
            if (attackListener == null)
            {
                attackListener = GetComponentInChildren<AttackListener>();
            }
            if (fishnetInvectorManager == null)
            {
                //CheckBodyMembers();
            }
        }

        public void CheckBodyMembers()
        {
            if (Members.Count > 0)
            {
                foreach (var bodyMember in Members)
                {
                    if (bodyMember.attackObject == null)
                    {
                        Debug.LogError($"[FNvMeleeManager][CheckBodyMembers] {gameObject.name} #{ThisNetworkObject.ObjectId} is missing a MeleeAttackObject reference", gameObject);
                    }
                    else
                    {
                        if (bodyMember.attackObject.overrideDamageSender == null)
                        {
                            bodyMember.attackObject.overrideDamageSender = transform;
                            bodyMember.attackObject.meleeManager = this;
                            Debug.Log($"[FNvMeleeManager][CheckBodyMembers] {gameObject.name} #{ThisNetworkObject.ObjectId} assigned to {bodyMember.attackObject.name}", gameObject);
                        }
                        
                        if (bodyMember.attackObject.hitBoxes.Count > 0)
                        {
                            foreach (var hitBox in bodyMember.attackObject.hitBoxes)
                            {
                                hitBox.attackObject = bodyMember.attackObject;
                                Debug.Log($"[FNvMeleeManager][CheckBodyMembers] {gameObject.name} #{ThisNetworkObject.ObjectId} assigned to {hitBox.trigger.name}", gameObject);
                            }
                        }
                        else
                        {
                            Debug.LogError($"[FNvMeleeManager][CheckBodyMembers] {gameObject.name}'s {bodyMember.attackObject.gameObject.name} #{ThisNetworkObject.ObjectId} is missing a HitBox reference", bodyMember.attackObject.gameObject);
                        }
                    }
                }
            }
        }

        protected override void Awake()
        {
            base.Awake();
            _healthController ??= GetComponent<FishnetInvectorHealthController>();
            fishnetInvectorManager ??= GetComponent<FishnetInvectorManager>();
            if (fishnetInvectorManager != null)
                fishnetInvectorManager.OnThisOwnerInitialized += InitForOwningPlayer;
            
            attackListener.OnAttackStarted += ActivateDamage;
            attackListener.OnAttackFinished += DeactivateDamage;
        }

        private void InitForOwningPlayer()
        {
            SetAsOwner();
            Initialize(GameplayManager.Instance);
        }

        public override void Start() {
            if (_isOwner) {
                base.Start();
            }

            AISetupMeleeManager();
        }

        private void Update()
        {
            if (_isOwner)
            {
                AutomaticComboReset();
            }
        }

        private void OnDisable()
        {
            if (!_isOwner)
                return;
            attackListener.OnAttackStarted -= ActivateDamage;
            attackListener.OnAttackFinished -= DeactivateDamage;
        }

        protected void AISetupMeleeManager()
        {
            if (CompareTag("Player"))
            {
                _isAI = false;
            }
            else
            {
                foreach (var bodyMember in Members) {
                    bodyMember.attackObject.meleeManager = this;
                }
            }
        }

        public void Initialize(GameplayManager gpm)
        {
            Init();
        }
        
        public void SetLeftWeapon(FNvMeleeWeapon weapon)
        {
            if (weapon)
            {
                leftWeapon = weapon;
                leftWeapon.SetActiveDamage(false);
                leftWeapon.meleeManager = this;
                leftWeapon.overrideDamageSender = transform;
                onEquipWeapon.Invoke(weapon.gameObject, true);
            }
            else leftWeapon = null;
        }
        
        
        public void SetRightWeapon(FNvMeleeWeapon weapon)
        {
            if (weapon)
            {
                rightWeapon = weapon;
                rightWeapon.meleeManager = this;
                rightWeapon.SetActiveDamage(false);
                rightWeapon.overrideDamageSender = transform;
                onEquipWeapon.Invoke(weapon.gameObject, false);
            }
            else
            {                
                rightWeapon = null;
            }
        }
        
        public FNvMeleeWeapon CurrentActiveAttackWeapon
        {
            get
            {
                if (rightWeapon && rightWeapon.gameObject.activeInHierarchy && (rightWeapon.meleeType == vMeleeType.OnlyAttack || rightWeapon.meleeType == vMeleeType.AttackAndDefense)) return _fnrWeapon;
                if (leftWeapon && leftWeapon.gameObject.activeInHierarchy && (leftWeapon.meleeType == vMeleeType.OnlyAttack || leftWeapon.meleeType == vMeleeType.AttackAndDefense)) return _fnlWeapon;
                return null;
            }
        }
        /// <summary>
        /// Listener of Damage Event
        /// </summary>
        /// <param name="hitInfo"></param>
        public override void OnDamageHit(ref vHitInfo hitInfo)
        {
            vDamage damage = new vDamage(hitInfo.attackObject.damage);
            damage.Sender = transform;
            damage.senderNetworkObjectID = ThisNetworkObject.ObjectId;
            damage.reaction_id = currentReactionID;
            damage.recoil_id = currentRecoilID;
            damage.type = vDamage.DamageType.Melee;
            damage.SwingCounter = SwingCounter;
            damage.hitPosition = hitInfo.hitPoint;
            damage.weaponItemId = hitInfo.attackObject.itemID;
            // if (damage.weaponItemId > 0)
            // {
            //     var weaponItem = MasterManager.GetVItem(damage.weaponItemId);
            //     damage.damageValue += (int)weaponItem.GetAttributeValue(AttributeTypes.Damage);
            // }
            if (hitInfo.targetCollider.tag == "Enemy")
            {
                damage.hitHeight = 0f;
            }else if (hitInfo.targetCollider.tag == "HeadCollider")
            {
                damage.hitHeight = 1f;
            }else if (hitInfo.targetCollider.tag == "Ignore Ragdoll")
            {
                return;
            }

            if (SwingCounter >= 2)
            {
                damage.hitHeight = 2f;
            }
            if (this.activeRagdoll) damage.activeRagdoll = this.activeRagdoll;
            if (this.attackName != string.Empty) damage.damageType = this.attackName;
            if (this.ignoreDefense) damage.ignoreDefense = this.ignoreDefense;
            if (this.senselessTime != 0) damage.senselessTime = this.senselessTime;
            /// Calc damage with multiplier 
            /// and Call ApplyDamage of attackObject 
            if (damageMultiplier > float.Epsilon)
            {
                damage.damageValue = (int)(damage.damageValue * damageMultiplier);
            }
            FishnetInvectorHealthController targetHealthController = GameplayManager.Instance.GetHealthController(hitInfo.targetCollider);
            if (targetHealthController == null) {
                Debug.LogError($"[FNvMeleeManager][OnDamageHit] No Health Controller found on " + hitInfo.targetCollider.name);
                return;
            }
            int targetObjectId = targetHealthController.ObjectId;
            UnitComponents meDamager = targetHealthController.UnitComponents;
            
            StringBuilder sb = new StringBuilder("[FNvMeleeManager][OnDamageHit] ");
            if (IsOwner && !_isAI)
                sb.Append($"SwingCounter: {damage.SwingCounter}");
            sb.Append($"{gameObject.name} #{ThisNetworkObject.ObjectId} -> {targetHealthController.gameObject.name} #{targetObjectId}");
            Debug.Log(sb.ToString());
            //TODO: this will work only for server
            //Unit is controlled by Server
            if (IsServer)
            {
                targetHealthController.TakeDamage(damage);
            }
            else//This Unit is controlled by Client
            {
                if (_isOwner)// Client is owner of this unit
                {
                    FNvDamage fnvDamage = new FNvDamage();
                    fnvDamage.senderNetworkObjectId = ThisNetworkObject.ObjectId;
                    fnvDamage.damageValue = damage.damageValue;
                    fnvDamage.staminaBlockCost = damage.staminaBlockCost;
                    fnvDamage.ignoreDefense = damage.ignoreDefense;
                    fnvDamage.hitPosition = damage.hitPosition;
                    fnvDamage.force = damage.force;
                    fnvDamage.damageType = damage.type;
                    fnvDamage.SwingCounter = damage.SwingCounter;
                    fnvDamage.hitHeight = damage.hitHeight;
                    fnvDamage.weaponItemId = damage.weaponItemId;
                    targetHealthController.CmdRegisterMeleeHitDamage(fnvDamage);

                    if (meDamager.AiUnit != null) {
                        if (!meDamager.AiUnit.IsDead)
                        {
                            meDamager.AiUnit.GetHitBehaviour(damage);
                        }
                    }
                }
                else {
                    bool ownerOfThisUnitNotServerAndItIsAI = _isAI;
                    if (ownerOfThisUnitNotServerAndItIsAI)
                    {
                        if (targetHealthController.IsDead)
                            return;

                        bool isEnemyVsEnemyAI = false;
                        if (meDamager.AiUnit != null) {
                            bool isTargetEnemyAI = meDamager.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Boss ||
                                                   meDamager.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Summon ||
                                                   meDamager.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Monster;
                            if (isTargetEnemyAI) {
                                UnitComponents unit = UnitComponentsManager.GetUnitComponentsServerAndClient(_networkObject.ObjectId);
                                if (unit.AiUnit != null) {
                                    bool isMeEnemyAI = unit.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Boss ||
                                                       unit.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Summon ||
                                                       unit.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Monster;
                                    if (isMeEnemyAI) {
                                        isEnemyVsEnemyAI = true;
                                    }
                                }
                            }
                        }
                        
                        if (!isEnemyVsEnemyAI) {
                            for (int bodyMemberId = 0; bodyMemberId < Members.Count; bodyMemberId++) {
                                if (Members[bodyMemberId].attackObject == hitInfo.attackObject) {
                                    Debug.Log(
                                        $"[FNvMeleeManager][OnDamageHit] {ThisNetworkObject.ObjectId} -> {targetObjectId} hit by {bodyMemberId}{Members[bodyMemberId].attackObject.name} {hitInfo.hitPoint}");

                                    if (targetObjectId >= 0) {
                                        targetHealthController.CmdRegisterHitByAI(ThisNetworkObject.ObjectId,
                                            bodyMemberId, hitInfo.hitPoint);
                                    }

                                    break;
                                }
                            }
                        }
                    }
                }
            }
            //hitInfo.targetIsBlocking = !hitInfo.attackObject.ApplyDamage(hitInfo.hitBox, hitInfo.targetCollider, damage);

            //onDamageHit.Invoke(hitInfo);            
        }

        public void SetAIDamage(float damageValue)
        {
            foreach (var bodyMember in Members)
            {
                bodyMember.attackObject.damage.damageValue = (int)damageValue;
            }
        }

        public void ResetComboId(int maxComboNumber)
        {
            Debug.Log($"[FNvMeleeManager][ResetComboId] {gameObject.name} #{ThisNetworkObject.ObjectId}");
            int newComboNumber = Random.Range(0, maxComboNumber);
            animatorDecorator.SetInteger("ComboId", newComboNumber);
            nextTimeComboReset = Time.time + 5f;
            isComboResetted = true;
        }
        
        private void AutomaticComboReset()
        {
            if (!isComboResetted)
                return;
            
            if (Time.time >= nextTimeComboReset)
            {
                ResetComboId(0);
                isComboResetted = false;
            }
        }
        
        [Client]
        public void PlaySlash(int slashId)
        {
            if (IsServer && !IsHost)
                return;
            MeleeSlashParameters slash = GetSlashById(slashId);
            Quaternion slashRotationQuaternion = Quaternion.Euler(transform.rotation.eulerAngles + slash.SlashRotation);
            WeaponSlashEffectGlobal.PlaySlashEffect(transform.position, slash.SlashHeight, slashRotationQuaternion, slash.SlashDuration);
        }

        
        public class AttackDetails
        {
            public List<string> CurrentAttackBodyParts ;
            public vAttackType CurrentAttackType ;
            public float CurrentDamageMultiplier ;
            public int CurrentRecoilID ;
            public int CurrentReactionID ;
            public bool CurrentIgnoreDefense ;
            public bool CurrentActiveRagdoll ;
            public float CurrentSenselessTime ;
            public string CurrentAttackName ;
            public byte CurrentSwingCounter ;

            // Default constructor
            public AttackDetails(List<string> bodyParts, vAttackType type,
                float damageMultiplier = 0f, int recoilID = 0, int reactionID = 0, 
                bool ignoreDefense = false, bool activeRagdoll = false, 
                float senselessTime = 0, string attackName = "", 
                byte swingCounter = 0)
            {
                CurrentAttackBodyParts = bodyParts;
                CurrentAttackType = type;
                CurrentDamageMultiplier = damageMultiplier;
                CurrentRecoilID = recoilID;
                CurrentReactionID = reactionID;
                CurrentIgnoreDefense = ignoreDefense;
                CurrentActiveRagdoll = activeRagdoll;
                CurrentSenselessTime = senselessTime;
                CurrentAttackName = attackName;
                CurrentSwingCounter = swingCounter;
            }

            // You can add other constructors, methods, or properties as needed
        }
        
        public AttackDetails CurrentAttackDetails { get; private set; }
        public void SetAttackDatas(AttackDetails attackDetails)
        {
            CurrentAttackDetails = attackDetails;
        }

        public void ActivateDamage()
        {
            Debug.Log($"{ClassName}[ActivateDamage] {gameObject.name} #{ThisNetworkObject.ObjectId}");
            SetActiveAttack(true);
        }

        public void DeactivateDamage()
        {
            Debug.Log($"{ClassName}[DeactivateDamage] {gameObject.name} #{ThisNetworkObject.ObjectId}");
            SetActiveAttack(false);
        }
        
        public virtual void SetActiveAttack(bool active = true)
        {
            var ad = CurrentAttackDetails;
            for (int i = 0; i < ad.CurrentAttackBodyParts.Count; i++)
            {
                var bodyPart = ad.CurrentAttackBodyParts[i];
                SetActiveAttack(bodyPart, ad.CurrentAttackType, ad.CurrentSwingCounter, active, ad.CurrentDamageMultiplier, 
                    ad.CurrentRecoilID, ad.CurrentReactionID, ad.CurrentIgnoreDefense, ad.CurrentActiveRagdoll, ad.CurrentSenselessTime, ad.CurrentAttackName);
            }
        }

        private MeleeSlashParameters GetSlashById(int id)
        {
            for (int i = 0; i < meleeSlashParameters.Length; i++)
            {
                if (meleeSlashParameters[i].Id == id)
                {
                    return meleeSlashParameters[i];
                }
            }

            return new MeleeSlashParameters();
        }
        
        private MeleeSlashParameters GetSlashByName(string name)
        {
            for (int i = 0; i < meleeSlashParameters.Length; i++)
            {
                if (meleeSlashParameters[i].Name == name)
                {
                    return meleeSlashParameters[i];
                }
            }

            return new MeleeSlashParameters();
        }

        [Serializable]
        public struct MeleeSlashParameters
        {
            public int Id;
            public string Name;
            public Vector3 SlashRotation;
            public float SlashDuration;
            public float SlashHeight;
        }
    }
} 

// Assets\FishNet Invector\Scripts\Non-networked\FNvMeleeManager.cs:
 using System;
using System.Collections.Generic;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet_Invector.Scripts.Non_networked;
using FishNet.Object;
using Invector;
using Invector.vItemManager;
using Invector.vMelee;
using SingletonsExtension;
using UnityEngine;
using Zomb.Creatures.Helpers;
using Random = UnityEngine.Random;

namespace FishnetInvector
{
    public class FNvMeleeManager : vMeleeManager
    {
        public UnitComponents UnitComponents { get; set; }
        private bool _isServer = false;
        private bool _isHost = false;
        public bool IsServer => _isServer;
        public bool IsHost => _isHost;
        public bool IsClient { get { return !_isServer; } }
        public GameplayManager GameplayManager => _gameplayManager;
        private GameplayManager _gameplayManager;
        private bool _isOwner = false;
        private bool _isAI = true;
        private NetworkObject _networkObject;
        [SerializeField] private AnimatorDecorator animatorDecorator;
        [SerializeField] private MeleeSlashParameters[] meleeSlashParameters;
        [SerializeField] private FishnetInvectorManager fishnetInvectorManager;
        [SerializeField] private AttackListener attackListener;
        public void SetAsServerOwned() => _isServer = _isOwner = _isAI = true;
        public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
        private string _className;
        
        public FishnetInvectorHealthController HealthController
        {
            get
            {
                if (!_healthController)
                {
                    _healthController = GetComponent<FishnetInvectorHealthController>();
                }

                return _healthController;
            }
        }

        private FishnetInvectorHealthController _healthController;

        public NetworkObject ThisNetworkObject
        {
            get
            {
                if (!_networkObject)
                {
                    _networkObject = GetComponent<NetworkObject>();
                }
                return _networkObject;
            }
        }

        public bool IsOwner
        {
            get { return _isOwner; }set { _isOwner = value; }}
        private FNvMeleeWeapon _fnrWeapon, _fnlWeapon;
        private float nextTimeComboReset = 0;
        private bool isComboResetted = false;

        public FNvMeleeWeapon MainWeapon
        {
            get
            {
                if (rightWeapon && rightWeapon.gameObject.activeInHierarchy) return _fnrWeapon;
                if (leftWeapon && leftWeapon.gameObject.activeInHierarchy) return _fnlWeapon;
                return null;
            }
        }

        public FNvMeleeWeapon FNrWeapon {
            get {
                if (_fnrWeapon == null) {
                    _fnrWeapon = (FNvMeleeWeapon) rightWeapon;
                }
                return _fnrWeapon;
            }
        }
        public FNvMeleeWeapon FNlWeapon {
            get {
                if (_fnlWeapon == null) {
                    _fnlWeapon = (FNvMeleeWeapon) leftWeapon;
                }
                return _fnlWeapon;
            }
        }
        
        public void SetAsHost()
        {
            _isHost = true;
        }

        public void SetAsOwner()
        {
            _isOwner = true;
            Debug.Log($"[FNvMeleeManager][SetAsOwner] {gameObject.name} #{ThisNetworkObject.ObjectId}", gameObject);
        }

        private void OnValidate()
        {
            animatorDecorator ??= GetComponent<AnimatorDecorator>();
            _healthController ??= GetComponent<FishnetInvectorHealthController>();
            fishnetInvectorManager ??= GetComponent<FishnetInvectorManager>();
            attackListener ??= GetComponent<AttackListener>();
            if (attackListener == null)
            {
                attackListener = GetComponentInChildren<AttackListener>();
            }
            if (fishnetInvectorManager == null)
            {
                //CheckBodyMembers();
            }
        }

        public void CheckBodyMembers()
        {
            if (Members.Count > 0)
            {
                foreach (var bodyMember in Members)
                {
                    if (bodyMember.attackObject == null)
                    {
                        Debug.LogError($"[FNvMeleeManager][CheckBodyMembers] {gameObject.name} #{ThisNetworkObject.ObjectId} is missing a MeleeAttackObject reference", gameObject);
                    }
                    else
                    {
                        if (bodyMember.attackObject.overrideDamageSender == null)
                        {
                            bodyMember.attackObject.overrideDamageSender = transform;
                            bodyMember.attackObject.meleeManager = this;
                            Debug.Log($"[FNvMeleeManager][CheckBodyMembers] {gameObject.name} #{ThisNetworkObject.ObjectId} assigned to {bodyMember.attackObject.name}", gameObject);
                        }
                        
                        if (bodyMember.attackObject.hitBoxes.Count > 0)
                        {
                            foreach (var hitBox in bodyMember.attackObject.hitBoxes)
                            {
                                hitBox.attackObject = bodyMember.attackObject;
                                Debug.Log($"[FNvMeleeManager][CheckBodyMembers] {gameObject.name} #{ThisNetworkObject.ObjectId} assigned to {hitBox.trigger.name}", gameObject);
                            }
                        }
                        else
                        {
                            Debug.LogError($"[FNvMeleeManager][CheckBodyMembers] {gameObject.name}'s {bodyMember.attackObject.gameObject.name} #{ThisNetworkObject.ObjectId} is missing a HitBox reference", bodyMember.attackObject.gameObject);
                        }
                    }
                }
            }
        }

        protected override void Awake()
        {
            base.Awake();
            _healthController ??= GetComponent<FishnetInvectorHealthController>();
            fishnetInvectorManager ??= GetComponent<FishnetInvectorManager>();
            if (fishnetInvectorManager != null)
                fishnetInvectorManager.OnThisOwnerInitialized += InitForOwningPlayer;
            
            attackListener.OnAttackStarted += ActivateDamage;
            attackListener.OnAttackFinished += DeactivateDamage;
        }

        private void InitForOwningPlayer()
        {
            SetAsOwner();
            Initialize(GameplayManager.Instance);
        }

        public override void Start() {
            if (_isOwner) {
                base.Start();
            }

            AISetupMeleeManager();
        }

        private void Update()
        {
            if (_isOwner)
            {
                AutomaticComboReset();
            }
        }

        private void OnDisable()
        {
            if (!_isOwner)
                return;
            attackListener.OnAttackStarted -= ActivateDamage;
            attackListener.OnAttackFinished -= DeactivateDamage;
        }

        protected void AISetupMeleeManager()
        {
            if (CompareTag("Player"))
            {
                _isAI = false;
            }
            else
            {
                foreach (var bodyMember in Members) {
                    bodyMember.attackObject.meleeManager = this;
                }
            }
        }

        public void Initialize(GameplayManager gpm)
        {
            Init();
        }
        
        public void SetLeftWeapon(FNvMeleeWeapon weapon)
        {
            if (weapon)
            {
                leftWeapon = weapon;
                leftWeapon.SetActiveDamage(false);
                leftWeapon.meleeManager = this;
                leftWeapon.overrideDamageSender = transform;
                onEquipWeapon.Invoke(weapon.gameObject, true);
            }
            else leftWeapon = null;
        }
        
        
        public void SetRightWeapon(FNvMeleeWeapon weapon)
        {
            if (weapon)
            {
                rightWeapon = weapon;
                rightWeapon.meleeManager = this;
                rightWeapon.SetActiveDamage(false);
                rightWeapon.overrideDamageSender = transform;
                onEquipWeapon.Invoke(weapon.gameObject, false);
            }
            else
            {                
                rightWeapon = null;
            }
        }
        
        public FNvMeleeWeapon CurrentActiveAttackWeapon
        {
            get
            {
                if (rightWeapon && rightWeapon.gameObject.activeInHierarchy && (rightWeapon.meleeType == vMeleeType.OnlyAttack || rightWeapon.meleeType == vMeleeType.AttackAndDefense)) return _fnrWeapon;
                if (leftWeapon && leftWeapon.gameObject.activeInHierarchy && (leftWeapon.meleeType == vMeleeType.OnlyAttack || leftWeapon.meleeType == vMeleeType.AttackAndDefense)) return _fnlWeapon;
                return null;
            }
        }
        /// <summary>
        /// Listener of Damage Event
        /// </summary>
        /// <param name="hitInfo"></param>
        public override void OnDamageHit(ref vHitInfo hitInfo)
        {
            vDamage damage = new vDamage(hitInfo.attackObject.damage);
            damage.Sender = transform;
            damage.senderNetworkObjectID = ThisNetworkObject.ObjectId;
            damage.reaction_id = currentReactionID;
            damage.recoil_id = currentRecoilID;
            damage.type = vDamage.DamageType.Melee;
            damage.SwingCounter = SwingCounter;
            damage.hitPosition = hitInfo.hitPoint;
            damage.weaponItemId = hitInfo.attackObject.itemID;
            // if (damage.weaponItemId > 0)
            // {
            //     var weaponItem = MasterManager.GetVItem(damage.weaponItemId);
            //     damage.damageValue += (int)weaponItem.GetAttributeValue(AttributeTypes.Damage);
            // }
            if (hitInfo.targetCollider.tag == "Enemy")
            {
                damage.hitHeight = 0f;
            }else if (hitInfo.targetCollider.tag == "HeadCollider")
            {
                damage.hitHeight = 1f;
            }else if (hitInfo.targetCollider.tag == "Ignore Ragdoll")
            {
                return;
            }

            if (SwingCounter >= 2)
            {
                damage.hitHeight = 2f;
            }
            if (this.activeRagdoll) damage.activeRagdoll = this.activeRagdoll;
            if (this.attackName != string.Empty) damage.damageType = this.attackName;
            if (this.ignoreDefense) damage.ignoreDefense = this.ignoreDefense;
            if (this.senselessTime != 0) damage.senselessTime = this.senselessTime;
            /// Calc damage with multiplier 
            /// and Call ApplyDamage of attackObject 
            if (damageMultiplier > float.Epsilon)
            {
                damage.damageValue = (int)(damage.damageValue * damageMultiplier);
            }
            FishnetInvectorHealthController targetHealthController = GameplayManager.Instance.GetHealthController(hitInfo.targetCollider);
            if (targetHealthController == null) {
                Debug.LogError($"[FNvMeleeManager][OnDamageHit] No Health Controller found on " + hitInfo.targetCollider.name);
                return;
            }
            int targetObjectId = targetHealthController.ObjectId;
            UnitComponents meDamager = targetHealthController.UnitComponents;
            
            StringBuilder sb = new StringBuilder("[FNvMeleeManager][OnDamageHit] ");
            if (IsOwner && !_isAI)
                sb.Append($"SwingCounter: {damage.SwingCounter}");
            sb.Append($"{gameObject.name} #{ThisNetworkObject.ObjectId} -> {targetHealthController.gameObject.name} #{targetObjectId}");
            Debug.Log(sb.ToString());
            //TODO: this will work only for server
            //Unit is controlled by Server
            if (IsServer)
            {
                targetHealthController.TakeDamage(damage);
            }
            else//This Unit is controlled by Client
            {
                if (_isOwner)// Client is owner of this unit
                {
                    FNvDamage fnvDamage = new FNvDamage();
                    fnvDamage.senderNetworkObjectId = ThisNetworkObject.ObjectId;
                    fnvDamage.damageValue = damage.damageValue;
                    fnvDamage.staminaBlockCost = damage.staminaBlockCost;
                    fnvDamage.ignoreDefense = damage.ignoreDefense;
                    fnvDamage.hitPosition = damage.hitPosition;
                    fnvDamage.force = damage.force;
                    fnvDamage.damageType = damage.type;
                    fnvDamage.SwingCounter = damage.SwingCounter;
                    fnvDamage.hitHeight = damage.hitHeight;
                    fnvDamage.weaponItemId = damage.weaponItemId;
                    targetHealthController.CmdRegisterMeleeHitDamage(fnvDamage);

                    if (meDamager.AiUnit != null) {
                        if (!meDamager.AiUnit.IsDead)
                        {
                            meDamager.AiUnit.GetHitBehaviour(damage);
                        }
                    }
                }
                else {
                    bool ownerOfThisUnitNotServerAndItIsAI = _isAI;
                    if (ownerOfThisUnitNotServerAndItIsAI)
                    {
                        if (targetHealthController.IsDead)
                            return;

                        bool isEnemyVsEnemyAI = false;
                        if (meDamager.AiUnit != null) {
                            bool isTargetEnemyAI = meDamager.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Boss ||
                                                   meDamager.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Summon ||
                                                   meDamager.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Monster;
                            if (isTargetEnemyAI) {
                                UnitComponents unit = UnitComponentsManager.GetUnitComponentsServerAndClient(_networkObject.ObjectId);
                                if (unit.AiUnit != null) {
                                    bool isMeEnemyAI = unit.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Boss ||
                                                       unit.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Summon ||
                                                       unit.AiUnit.EnemyDefinition.EnemyType == EnemyDefinition.Type.Monster;
                                    if (isMeEnemyAI) {
                                        isEnemyVsEnemyAI = true;
                                    }
                                }
                            }
                        }
                        
                        if (!isEnemyVsEnemyAI) {
                            for (int bodyMemberId = 0; bodyMemberId < Members.Count; bodyMemberId++) {
                                if (Members[bodyMemberId].attackObject == hitInfo.attackObject) {
                                    Debug.Log(
                                        $"[FNvMeleeManager][OnDamageHit] {ThisNetworkObject.ObjectId} -> {targetObjectId} hit by {bodyMemberId}{Members[bodyMemberId].attackObject.name} {hitInfo.hitPoint}");

                                    if (targetObjectId >= 0) {
                                        targetHealthController.CmdRegisterHitByAI(ThisNetworkObject.ObjectId,
                                            bodyMemberId, hitInfo.hitPoint);
                                    }

                                    break;
                                }
                            }
                        }
                    }
                }
            }
            //hitInfo.targetIsBlocking = !hitInfo.attackObject.ApplyDamage(hitInfo.hitBox, hitInfo.targetCollider, damage);

            //onDamageHit.Invoke(hitInfo);            
        }

        public void SetAIDamage(float damageValue)
        {
            foreach (var bodyMember in Members)
            {
                bodyMember.attackObject.damage.damageValue = (int)damageValue;
            }
        }

        public void ResetComboId(int maxComboNumber)
        {
            Debug.Log($"[FNvMeleeManager][ResetComboId] {gameObject.name} #{ThisNetworkObject.ObjectId}");
            int newComboNumber = Random.Range(0, maxComboNumber);
            animatorDecorator.SetInteger("ComboId", newComboNumber);
            nextTimeComboReset = Time.time + 5f;
            isComboResetted = true;
        }
        
        private void AutomaticComboReset()
        {
            if (!isComboResetted)
                return;
            
            if (Time.time >= nextTimeComboReset)
            {
                ResetComboId(0);
                isComboResetted = false;
            }
        }
        
        [Client]
        public void PlaySlash(int slashId)
        {
            if (IsServer && !IsHost)
                return;
            MeleeSlashParameters slash = GetSlashById(slashId);
            Quaternion slashRotationQuaternion = Quaternion.Euler(transform.rotation.eulerAngles + slash.SlashRotation);
            WeaponSlashEffectGlobal.PlaySlashEffect(transform.position, slash.SlashHeight, slashRotationQuaternion, slash.SlashDuration);
        }

        
        public class AttackDetails
        {
            public List<string> CurrentAttackBodyParts ;
            public vAttackType CurrentAttackType ;
            public float CurrentDamageMultiplier ;
            public int CurrentRecoilID ;
            public int CurrentReactionID ;
            public bool CurrentIgnoreDefense ;
            public bool CurrentActiveRagdoll ;
            public float CurrentSenselessTime ;
            public string CurrentAttackName ;
            public byte CurrentSwingCounter ;

            // Default constructor
            public AttackDetails(List<string> bodyParts, vAttackType type,
                float damageMultiplier = 0f, int recoilID = 0, int reactionID = 0, 
                bool ignoreDefense = false, bool activeRagdoll = false, 
                float senselessTime = 0, string attackName = "", 
                byte swingCounter = 0)
            {
                CurrentAttackBodyParts = bodyParts;
                CurrentAttackType = type;
                CurrentDamageMultiplier = damageMultiplier;
                CurrentRecoilID = recoilID;
                CurrentReactionID = reactionID;
                CurrentIgnoreDefense = ignoreDefense;
                CurrentActiveRagdoll = activeRagdoll;
                CurrentSenselessTime = senselessTime;
                CurrentAttackName = attackName;
                CurrentSwingCounter = swingCounter;
            }

            // You can add other constructors, methods, or properties as needed
        }
        
        public AttackDetails CurrentAttackDetails { get; private set; }
        public void SetAttackDatas(AttackDetails attackDetails)
        {
            CurrentAttackDetails = attackDetails;
        }

        public void ActivateDamage()
        {
            Debug.Log($"{ClassName}[ActivateDamage] {gameObject.name} #{ThisNetworkObject.ObjectId}");
            SetActiveAttack(true);
        }

        public void DeactivateDamage()
        {
            Debug.Log($"{ClassName}[DeactivateDamage] {gameObject.name} #{ThisNetworkObject.ObjectId}");
            SetActiveAttack(false);
        }
        
        public virtual void SetActiveAttack(bool active = true)
        {
            var ad = CurrentAttackDetails;
            for (int i = 0; i < ad.CurrentAttackBodyParts.Count; i++)
            {
                var bodyPart = ad.CurrentAttackBodyParts[i];
                SetActiveAttack(bodyPart, ad.CurrentAttackType, ad.CurrentSwingCounter, active, ad.CurrentDamageMultiplier, 
                    ad.CurrentRecoilID, ad.CurrentReactionID, ad.CurrentIgnoreDefense, ad.CurrentActiveRagdoll, ad.CurrentSenselessTime, ad.CurrentAttackName);
            }
        }

        private MeleeSlashParameters GetSlashById(int id)
        {
            for (int i = 0; i < meleeSlashParameters.Length; i++)
            {
                if (meleeSlashParameters[i].Id == id)
                {
                    return meleeSlashParameters[i];
                }
            }

            return new MeleeSlashParameters();
        }
        
        private MeleeSlashParameters GetSlashByName(string name)
        {
            for (int i = 0; i < meleeSlashParameters.Length; i++)
            {
                if (meleeSlashParameters[i].Name == name)
                {
                    return meleeSlashParameters[i];
                }
            }

            return new MeleeSlashParameters();
        }

        [Serializable]
        public struct MeleeSlashParameters
        {
            public int Id;
            public string Name;
            public Vector3 SlashRotation;
            public float SlashDuration;
            public float SlashHeight;
        }
    }
} 

// Assets\Invector-3rdPersonController\Melee Combat\Scripts\MeleeWeapon\vMeleeManager.cs:
 using System;
using System.Collections.Generic;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using UnityEngine;

namespace Invector.vMelee
{
    using Invector.vItemManager;
    using UnityEngine.Events;
    using vEventSystems;
    /// <summary>
    /// Event called when you equip a weapon (Weapon, isLeftWeapon)
    /// </summary>
    [System.Serializable]    
    public class OnEquipWeaponEvent : UnityEngine.Events.UnityEvent<GameObject, bool> { }
    public class vMeleeManager : vMonoBehaviour, IWeaponEquipmentListener
    {
        #region SeralizedProperties in CustomEditor

        public List<vBodyMember> Members = new List<vBodyMember>();
        public vDamage defaultDamage = new vDamage(10);
        public HitProperties hitProperties;
        public vMeleeWeapon leftWeapon;
        public vMeleeWeapon rightWeapon;
        public vOnHitEvent onDamageHit, onRecoilHit;
        public OnEquipWeaponEvent onEquipWeapon;
        [field: SerializeField] public byte SwingCounter = 0;
        #endregion

        [Tooltip("NPC ONLY- Ideal distance for the attack")]
        public float defaultAttackDistance = 1f;
        [Tooltip("Default cost for stamina when attack")]
        public float defaultStaminaCost = 20f;
        [Tooltip("Default recovery delay for stamina when attack")]
        public float defaultStaminaRecoveryDelay = 1f;
        [Range(0, 100)]
        public int defaultDefenseRate = 100;
        [Range(0, 180)]
        public float defaultDefenseRange = 90;
        public bool isPhaseDamage { get; protected set; }

        [HideInInspector]
        public vIMeleeFighter fighter;
        protected float damageMultiplier;
        protected int currentRecoilID;
        protected int currentReactionID;
        protected bool ignoreDefense;
        protected bool activeRagdoll;
        protected float senselessTime;
        protected bool inRecoil;
        protected string attackName;
        

        public virtual void Start()
        {
            Init();
        }

        protected virtual void Awake()
        {
            foreach (vBodyMember member in Members)
            {
                member.attackObject.meleeManager = this;
                member.SetActiveDamage(false);
            }
        }

        /// <summary>
        /// Init properties
        /// </summary>
        public virtual void Init()
        {
            fighter = gameObject.GetMeleeFighter();
            ///Initialize all bodyMembers and weapons
            foreach (vBodyMember member in Members)
            {
                ///damage of member will be always the defaultDamage
                //member.attackObject.damage = defaultDamage;       
                if(member.attackObject==null)
                {
                    var attackObjects = GetComponentsInChildren<vMeleeAttackObject>();
                    if (attackObjects.Length > 0)
                        member.attackObject = System.Array.Find(attackObjects, a => a.attackObjectName.Equals(member.bodyPart));

                    if(member.attackObject==null)
                    {
                        Debug.LogWarning("Can't find the attack Object " + member.bodyPart);
                        continue;
                    }
                }
                member.attackObject.damage.damageValue = defaultDamage.damageValue;
                if (member.bodyPart == HumanBodyBones.LeftLowerArm.ToString())
                {
                    var weapon = member.attackObject.GetComponentInChildren<vMeleeWeapon>(true);
                    leftWeapon = weapon;
                }
                if (member.bodyPart == HumanBodyBones.RightLowerArm.ToString())
                {
                    var weapon = member.attackObject.GetComponentInChildren<vMeleeWeapon>(true);
                    rightWeapon = weapon;
                }
            }

            if (leftWeapon != null)
            {
                leftWeapon.SetActiveDamage(false);
                leftWeapon.meleeManager = this;
            }
            if (rightWeapon != null)
            {
                rightWeapon.meleeManager = this;
                rightWeapon.SetActiveDamage(false);
            }            
        }

        /// <summary>
        /// Set active Multiple Parts to attack
        /// </summary>
        /// <param name="bodyParts"></param>
        /// <param name="type"></param>
        /// <param name="active"></param>
        /// <param name="damageMultiplier"></param>
        public virtual void SetActiveAttack(List<string> bodyParts, vAttackType type, bool active = true, 
            float damageMultiplier = 0f, int recoilID = 0, int reactionID = 0, bool ignoreDefense = false, 
            bool activeRagdoll = false, float senselessTime = 0, string attackName = "", byte swingCounter = 0)
        {
            for (int i = 0; i < bodyParts.Count; i++)
            {
                var bodyPart = bodyParts[i];
                SetActiveAttack(bodyPart, type, swingCounter, active, damageMultiplier, recoilID, reactionID, ignoreDefense, activeRagdoll, senselessTime, attackName);
            }
        }

        /// <summary>
        /// Set active Single Part to attack
        /// </summary>
        /// <param name="bodyPart"></param>
        /// <param name="type"></param>
        /// <param name="active"></param>
        /// <param name="damageMultiplier"></param>
        public virtual void SetActiveAttack(string bodyPart, vAttackType type, byte swingCounter, bool active = true, 
            float damageMultiplier = 0f, int recoilID = 0, int reactionID = 0, bool ignoreDefense = false, 
            bool activeRagdoll = false, float senselessTime = 0, string attackName = "")
        {
            this.damageMultiplier = damageMultiplier;
            currentRecoilID = recoilID;
            currentReactionID = reactionID;
            this.ignoreDefense = ignoreDefense;
            this.activeRagdoll = activeRagdoll;
            this.attackName = attackName;
            this.senselessTime = senselessTime;
            SwingCounter = swingCounter;
            isPhaseDamage = active;
            Debug.Log($"[vMeleeManager] isPhaseDamage: {isPhaseDamage}");
            if (type == vAttackType.Unarmed)
            {
                /// find attackObject by bodyPart
                var attackObject = Members.Find(member => member.bodyPart == bodyPart);
                if (attackObject != null)
                {
                    attackObject.SetActiveDamage(active);
                }
            }
            else
            {   ///if AttackType == MeleeWeapon
                ///this work just for Right and Left Lower Arm         
                if (bodyPart == "RightLowerArm" && rightWeapon != null)
                {
                    rightWeapon.meleeManager = this;
                    rightWeapon.SetActiveDamage(active);
                }
                else if (bodyPart == "LeftLowerArm" && leftWeapon != null)
                {
                    leftWeapon.meleeManager = this;
                    leftWeapon.SetActiveDamage(active);
                }
            }
        }

        /// <summary>
        /// Listener of Damage Event
        /// </summary>
        /// <param name="hitInfo"></param>
        public virtual void OnDamageHit(ref vHitInfo hitInfo)
        {
            vDamage damage = new vDamage(hitInfo.attackObject.damage);
            damage.Sender = transform;
            damage.reaction_id = currentReactionID;
            damage.recoil_id = currentRecoilID;
            damage.SwingCounter = SwingCounter;
            if (this.activeRagdoll) damage.activeRagdoll = this.activeRagdoll;
            if (this.attackName != string.Empty) damage.damageType = this.attackName;
            if (this.ignoreDefense) damage.ignoreDefense = this.ignoreDefense;
            if (this.senselessTime != 0) damage.senselessTime = this.senselessTime;
            /// Calc damage with multiplier 
            /// and Call ApplyDamage of attackObject 

            if (damageMultiplier > float.Epsilon)
            {
                damage.damageValue = (int)(damage.damageValue * damageMultiplier);
            }           
            hitInfo.targetIsBlocking = !hitInfo.attackObject.ApplyDamage(hitInfo.hitBox, hitInfo.targetCollider, damage);

            onDamageHit.Invoke(hitInfo);            
        }

        /// <summary>
        /// Listener of Recoil Event
        /// </summary>
        /// <param name="hitInfo"></param>
        public virtual void OnRecoilHit(vHitInfo hitInfo)
        {
            if (hitProperties.useRecoil && InRecoilRange(hitInfo) && !inRecoil)
            {
                inRecoil = true;
                var id = currentRecoilID;
                if (fighter != null) fighter.OnRecoil(id);
                onRecoilHit.Invoke(hitInfo);
                Invoke("ResetRecoil", 1f);
            }
        }

        /// <summary>
        /// Call Weapon Defense Events.
        /// </summary>
        public virtual void OnDefense()
        {
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyAttack && leftWeapon.gameObject.activeInHierarchy)
            {
                leftWeapon.OnDefense();
            }
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyAttack && rightWeapon.gameObject.activeInHierarchy)
            {
                rightWeapon.OnDefense();
            }
        }

        /// <summary>
        /// Get Current Attack ID
        /// </summary>
        /// <returns></returns>
        public virtual int GetAttackID()
        {
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyDefense && rightWeapon.gameObject.activeInHierarchy) return rightWeapon.attackID;
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyDefense && leftWeapon.gameObject.activeInHierarchy) return leftWeapon.attackID;
            return 0;
        }

        /// <summary>
        /// Get StaminaCost
        /// </summary>
        /// <returns></returns>
        public virtual float GetAttackStaminaCost()
        {
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyDefense && rightWeapon.gameObject.activeInHierarchy) return rightWeapon.staminaCost;
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyDefense && leftWeapon.gameObject.activeInHierarchy) return leftWeapon.staminaCost;
            return defaultStaminaCost;
        }

        /// <summary>
        /// Get StaminaCost
        /// </summary>
        /// <returns></returns>
        public virtual float GetAttackStaminaRecoveryDelay()
        {
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyDefense && rightWeapon.gameObject.activeInHierarchy) return rightWeapon.staminaRecoveryDelay;
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyDefense && leftWeapon.gameObject.activeInHierarchy) return leftWeapon.staminaRecoveryDelay;
            return defaultStaminaRecoveryDelay;
        }

        /// <summary>
        /// Get ideal distance for the attack
        /// </summary>
        /// <returns></returns>
        public virtual float GetAttackDistance()
        {
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyDefense && rightWeapon.gameObject.activeInHierarchy) return rightWeapon.distanceToAttack;
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyDefense && leftWeapon.gameObject.activeInHierarchy) return leftWeapon.distanceToAttack;
            return defaultAttackDistance;
        }

        /// <summary>
        /// Get Current Defense ID
        /// </summary>
        /// <returns></returns>
        public virtual int GetDefenseID()
        {
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyAttack && leftWeapon.gameObject.activeInHierarchy)
            {
                GetComponent<Animator>().SetBool("FlipAnimation", false);
                return leftWeapon.defenseID;
            }
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyAttack && rightWeapon.gameObject.activeInHierarchy)
            {
                GetComponent<Animator>().SetBool("FlipAnimation", true);
                return rightWeapon.defenseID;
            }
            return 0;
        }

        /// <summary>
        /// Get Defense Rate of Melee Defense 
        /// </summary>
        /// <returns></returns>
        public int GetDefenseRate()
        {
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyAttack && leftWeapon.gameObject.activeInHierarchy)
            {
                return leftWeapon.defenseRate;
            }
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyAttack && rightWeapon.gameObject.activeInHierarchy)
            {
                return rightWeapon.defenseRate;
            }
            return defaultDefenseRate;
        }

        /// <summary>
        /// Get Current MoveSet ID
        /// </summary>
        /// <returns></returns>
        public virtual int GetMoveSetID()
        {
            if (rightWeapon != null && rightWeapon.gameObject.activeInHierarchy) return rightWeapon.movesetID;
            if (leftWeapon != null && leftWeapon.gameObject.activeInHierarchy) return leftWeapon.movesetID;
            return 0;
        }

        /// <summary>
        /// Check if defence can break Attack
        /// </summary>
        /// <returns></returns>
        public virtual bool CanBreakAttack()
        {
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyAttack && leftWeapon.gameObject.activeInHierarchy)
            {
                return leftWeapon.breakAttack;
            }
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyAttack && rightWeapon.gameObject.activeInHierarchy)
            {
                return rightWeapon.breakAttack;
            }
            return false;
        }

        /// <summary>
        /// Check if attack can be blocked
        /// </summary>
        /// <param name="attackPoint"></param>
        /// <returns></returns>
        public virtual bool CanBlockAttack(Vector3 attackPoint)
        {
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyAttack && leftWeapon.gameObject.activeInHierarchy)
            {
                return Math.Abs(transform.HitAngle(attackPoint)) <= leftWeapon.defenseRange;
            }
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyAttack && rightWeapon.gameObject.activeInHierarchy)
            {
                return Math.Abs(transform.HitAngle(attackPoint)) <= rightWeapon.defenseRange;
            }
            return Math.Abs(transform.HitAngle(attackPoint)) <= defaultDefenseRange;
        }

        /// <summary>
        /// Get defense recoilID for break attack
        /// </summary>
        /// <returns></returns>
        public virtual int GetDefenseRecoilID()
        {
            if (leftWeapon != null && leftWeapon.meleeType != vMeleeType.OnlyAttack && leftWeapon.gameObject.activeInHierarchy)
            {
                return leftWeapon.recoilID;
            }
            if (rightWeapon != null && rightWeapon.meleeType != vMeleeType.OnlyAttack && rightWeapon.gameObject.activeInHierarchy)
            {
                return rightWeapon.recoilID;
            }
            return 0;
        }

        /// <summary>
        /// Check if angle of hit point is in range of recoil
        /// </summary>
        /// <param name="hitInfo"></param>
        /// <returns></returns>
        protected virtual bool InRecoilRange(vHitInfo hitInfo)
        {
            var center = new Vector3(transform.position.x, hitInfo.hitPoint.y, transform.position.z);
            var euler = (Quaternion.LookRotation(hitInfo.hitPoint - center).eulerAngles - transform.eulerAngles).NormalizeAngle();

            return euler.y <= hitProperties.recoilRange;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="weaponObject"></param>
        public virtual void SetLeftWeapon(GameObject weaponObject)
        {
            if (weaponObject)
            {
                leftWeapon = weaponObject.GetComponent<vMeleeWeapon>();
                SetLeftWeapon(leftWeapon);
            }
            else leftWeapon = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="weaponObject"></param>
        public virtual void SetRightWeapon(GameObject weaponObject)
        {
            if (weaponObject)
            {
                rightWeapon = weaponObject.GetComponent<vMeleeWeapon>();
                SetRightWeapon(rightWeapon);
            }
            else rightWeapon = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="weaponObject"></param>
        public virtual void SetLeftWeapon(vMeleeWeapon weapon)
        {
            if (weapon)
            {
                onEquipWeapon.Invoke(weapon.gameObject, true);
                leftWeapon = weapon;
                leftWeapon.SetActiveDamage(false);
                leftWeapon.meleeManager = this;
            }
            else leftWeapon = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="weaponObject"></param>
        public virtual void SetRightWeapon(vMeleeWeapon weapon)
        {
            if (weapon)
            {
                onEquipWeapon.Invoke(weapon.gameObject, false);
                rightWeapon = weapon;
                rightWeapon.meleeManager = this;
                rightWeapon.SetActiveDamage(false);
                DebugWrite.Log($"SetRightWeapon: {rightWeapon.name}");
            }
            else
            {                
                rightWeapon = null;
            }
        }

        public virtual vMeleeWeapon CurrentActiveAttackWeapon
        {
            get
            {
                if (rightWeapon && rightWeapon.gameObject.activeInHierarchy && (rightWeapon.meleeType == vMeleeType.OnlyAttack || rightWeapon.meleeType == vMeleeType.AttackAndDefense)) return rightWeapon;
                if (leftWeapon && leftWeapon.gameObject.activeInHierarchy && (leftWeapon.meleeType == vMeleeType.OnlyAttack || leftWeapon.meleeType == vMeleeType.AttackAndDefense)) return leftWeapon;
                return null;
            }
        }

        public virtual vMeleeWeapon CurrentActiveDefenseWeapon
        {
            get
            {
                if (rightWeapon && rightWeapon.gameObject.activeInHierarchy && (rightWeapon.meleeType == vMeleeType.OnlyDefense || rightWeapon.meleeType == vMeleeType.AttackAndDefense)) return rightWeapon;
                if (leftWeapon && leftWeapon.gameObject.activeInHierarchy && (leftWeapon.meleeType == vMeleeType.OnlyDefense || leftWeapon.meleeType == vMeleeType.AttackAndDefense)) return leftWeapon;
                return null;
            }
        }

        public virtual vMeleeWeapon CurrentAttackWeapon
        {
            get
            {
                if (rightWeapon && (rightWeapon.meleeType == vMeleeType.OnlyAttack || rightWeapon.meleeType == vMeleeType.AttackAndDefense)) return rightWeapon;
                if (leftWeapon && (leftWeapon.meleeType == vMeleeType.OnlyAttack || leftWeapon.meleeType == vMeleeType.AttackAndDefense)) return leftWeapon;
                return null;
            }
        }

        public virtual vMeleeWeapon CurrentDefenseWeapon
        {
            get
            {
                if (rightWeapon && (rightWeapon.meleeType == vMeleeType.OnlyDefense || rightWeapon.meleeType == vMeleeType.AttackAndDefense)) return rightWeapon;
                if (leftWeapon && (leftWeapon.meleeType == vMeleeType.OnlyDefense || leftWeapon.meleeType == vMeleeType.AttackAndDefense)) return leftWeapon;
                return null;
            }
        }

        protected virtual void ResetRecoil()
        {
            inRecoil = false;
        }
    }

    #region Secundary Classes
    [Serializable]
    public class vOnHitEvent : UnityEngine.Events.UnityEvent<vHitInfo> { }

    [Serializable]
    public class vBodyMember
    {
        public Transform transform;
        public string bodyPart;

        public vMeleeAttackObject attackObject;
        public bool isHuman;
        
        public void SetActiveDamage(bool active)
        {
            attackObject.SetActiveDamage(active);
        }
    }

    public enum vHumanBones
    {
        RightHand, RightLowerArm, RightUpperArm, RightShoulder,
        LeftHand, LeftLowerArm, LeftUpperArm, LeftShoulder,
        RightFoot, RightLowerLeg, RightUpperLeg,
        LeftFoot, LeftLowerLeg, LeftUpperLeg,
        Chest,
        Head
    }

    public enum vAttackType
    {
        Unarmed, MeleeWeapon
    }
    #endregion
}
 

// Assets\Invector-3rdPersonController\Melee Combat\Scripts\MeleeWeapon\vMeleeAttackControl.cs:
 using System.Collections.Generic;
using UnityEngine;

namespace Invector.vMelee
{
    using vEventSystems;
    public class vMeleeAttackControl : StateMachineBehaviour
    {
        [Tooltip("normalizedTime of Active Damage")]
        public float startDamage = 0.05f;
        [Tooltip("normalizedTime of Disable Damage")]
        public float endDamage = 0.9f;


        public Vector2[] additionalStartEnds; 
        public float damageMultiplier;
        public int recoilID;
        public int reactionID;

        public vAttackType meleeAttackType = vAttackType.Unarmed;
        [Tooltip("Name used as a reference to trigger a custom HitDamageParticle")]
        public string damageType;
        [HideInInspector]
        [Header("Works with vMeleeManager to activate vMeleeAttackObject from bodyPart and id")]
        public List<string> bodyParts = new List<string> { "RightLowerArm" };
        public bool ignoreDefense;
        public bool activeRagdoll;
        [vHideInInspector("activeRagdoll"), Tooltip("Time to keep Ragdoll active")]
        public float senselessTime;

        // Check this as true in the last attack of a combo to reset the triggers
        [Tooltip("Check true in the last attack of your combo to reset the triggers")]
        public bool resetAttackTrigger;
        
        protected bool isActiveDamagePhase;
        [SerializeField] protected bool debug = false;
        protected vIAttackListener mFighter;
        protected vMeleeManager _meleeManager;
        protected bool isAttacking;

        // Called when the state begins
        override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            mFighter = animator.GetComponent<vIAttackListener>();
            _meleeManager = animator.GetComponent<vMeleeManager>();
            isAttacking = true;
            if (mFighter != null)
                mFighter.OnEnableAttack();

            if (debug)
                Debug.Log("Enter " + damageType);
        }

        // Set the animator speed
        protected void SetAnimatorSpeed(Animator animator, float newSpeed)
        {
            //Debug.Log($"[vMeleeAttackControl] {_meleeManager.gameObject.name} SetAnimatorSpeed: {newSpeed}");
            if (newSpeed < float.Epsilon)
                return;
            if (Mathf.Approximately(animator.speed, newSpeed))
                return;
            animator.speed = newSpeed;
        }

        // Called when the animator is updated
        override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
    
            // If the normalized time is between startDamage and endDamage and isActive is false
            if (stateInfo.normalizedTime % 1 >= startDamage && stateInfo.normalizedTime % 1 <= endDamage && !isActiveDamagePhase)
            {
                // Log if debug is enabled
                if (debug) Debug.Log(animator.name + " attack " + damageType + " enable damage in " + System.Math.Round(stateInfo.normalizedTime % 1, 2));
        
                // Set isActive to true and call ActiveDamage() with true
                isActiveDamagePhase = true;
                ActiveDamage(true);
            }
            // If the normalized time is greater than endDamage and isActive is true
            else if (stateInfo.normalizedTime % 1 > endDamage && isActiveDamagePhase)
            {
                // Log if debug is enabled
                if (debug) Debug.Log(animator.name + " attack " + damageType + " disable damage in " + System.Math.Round(stateInfo.normalizedTime % 1, 2));
        
                // Set isActive to false and call ActiveDamage() with false
                isActiveDamagePhase = false;
                ActiveDamage(false);
            }
    
            // If the normalized time is greater than endDamage and isAttacking is true
            if (stateInfo.normalizedTime % 1 > endDamage && isAttacking)
            {
                // Set isAttacking to false and call OnDisableAttack() on the vIAttackListener component
                isAttacking = false;
                if (mFighter != null) mFighter.OnDisableAttack();
            }
        }

        // Called when the state ends
        override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            SetAnimatorSpeed(animator, 1f);
            if (debug)
                Debug.Log($"Exit " + damageType);

            if (isActiveDamagePhase)
            {
                isActiveDamagePhase = false;
                ActiveDamage(false);
            }

            if (isAttacking)
            {
                isAttacking = false;
                if (mFighter != null)
                    mFighter.OnDisableAttack();
            }
            
            if (mFighter != null && resetAttackTrigger)
                mFighter.ResetAttackTriggers();

            if (debug) Debug.Log(animator.name + " attack " + damageType + " stateExit");
        }

        // Activate or deactivate the damage
        protected virtual void ActiveDamage(bool isActive)
        {
            Debug.Log($"[vMeleeAttackControl] ActiveDamage: {isActive}");
            if (_meleeManager) {
                Debug.Log($"[vMeleeAttackControl] (MeleeManager)ActiveDamage: {isActive}");
                _meleeManager.SetActiveAttack(
                    bodyParts, 
                    meleeAttackType, 
                    isActive, 
                    damageMultiplier, 
                    recoilID, 
                    reactionID, 
                    ignoreDefense, 
                    activeRagdoll, 
                    senselessTime, 
                    damageType
                );
            }
        }
    }
} 

// Assets\Invector-3rdPersonController\Melee Combat\Scripts\MeleeWeapon\vMeleeAttackObject.cs:
 using System.Collections.Generic;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishnetInvector;
using UnityEngine;
using UnityEngine.Events;

namespace Invector.vMelee
{
    using vEventSystems;
    [vClassHeader("Melee Object", openClose = false)]
    public class vMeleeAttackObject : vMonoBehaviour
    {
        [vReadOnly(false)] public string attackObjectName;
        public vDamage damage;
        public int itemID;
        public Transform overrideDamageSender;
        public List<vHitBox> hitBoxes;
        public int damageModifier;
        [HideInInspector]
        public bool canApplyDamage;
        /// <summary>
        /// Event called when attack was successful
        /// </summary>
        [vHelpBox("Event called when attack was successful")]
        public OnHitEnter onDamageHit;
        /// <summary>
        /// Event called when the attack causes recoil
        /// </summary>
        [vHelpBox("Event called when the attack causes recoil")]
        public OnHitEnter onRecoilHit;
        /// <summary>
        /// Event called when causes damage 
        /// </summary>
        [vHelpBox("Event called when causes damage ")]
        public OnReceiveDamage onPassDamage;
        [vHelpBox("Events called when  Damage applier (HitBoxes) is enabled or disabled ")]
        public UnityEvent onEnableDamage;
        public UnityEvent onDisableDamage;
        protected Dictionary<vHitBox, List<GameObject>> targetColliders;
        public vMeleeManager meleeManager;

        /// <summary>
        /// Attack Object name is used to be selected from the <see cref="vMelee.vMeleeManager.Members"/> list
        /// </summary>

        protected virtual void Start()
        {
            // init list of targetColliders
            targetColliders = new Dictionary<vHitBox, List<GameObject>>();

            if (hitBoxes.Count > 0)
            {
                // initialize hitBox properties
                foreach (vHitBox hitBox in hitBoxes)
                {
                    try
                    {
                        if (hitBox.attackObject == null)
                        {
                            Debug.LogError($"[vMeleeAttackObject] {gameObject.name} on {meleeManager} is missing a MeleeAttackObject reference", gameObject);
                        }
                    }
                    catch (System.Exception e)
                    {
                        Debug.LogError($"[vMeleeAttackObject] {e.Message} ");
                    }
                    hitBox.attackObject = this;
                    targetColliders.Add(hitBox, new List<GameObject>());
                }
            }
            else
            {
                this.enabled = false;
            }
        }

        /// <summary>
        /// Set Active all hitBoxes of the MeleeAttackObject
        /// </summary>
        /// <param name="value"> active value</param>  
        public virtual void SetActiveDamage(bool value)
        {
            canApplyDamage = value;
            foreach (var hitCollider in hitBoxes)
            {
                if (value)
                {
                    hitCollider.ActivateTrigger();
                }
                else
                {
                    hitCollider.DeactivateTrigger();
                }
                Debug.Log($"[vMeleeAttackObject] {hitCollider.trigger.name} on {meleeManager} enabled = {value}", gameObject);
                if (value == false && targetColliders != null)
                {
                    if (targetColliders.ContainsKey(hitCollider))
                    {
                        targetColliders[hitCollider].Clear();
                    }
                }
            }
            
            if (value)
            {
                onEnableDamage.Invoke();
            }
            else
            {
                onDisableDamage.Invoke();
            }
        }

        /// <summary>
        /// Hitboxes Call Back
        /// </summary>
        /// <param name="hitBox">vHitBox object</param>
        /// <param name="other">target Collider</param>
        public virtual void OnHit(vHitBox hitBox, Collider other)
        {
            // check first condition for hit 
            if (canApplyDamage && !targetColliders[hitBox].Contains(other.gameObject) && (meleeManager != null && other.gameObject != meleeManager.gameObject))
            {
                var inDamage = false;
                var inRecoil = false;
                
                if (meleeManager == null)
                {
                    meleeManager = GetComponent<vMeleeManager>();
                }

                //check if meleeManager exists and apply his hitProperties to this
                HitProperties _hitProperties = meleeManager.hitProperties;

                // damage conditions
                if ((hitBox.triggerType & vHitBoxType.Damage) != 0)
                {
                    bool noTags = _hitProperties.hitDamageTags == null || _hitProperties.hitDamageTags.Count == 0;
                    bool isTargetTagCompatible = _hitProperties.hitDamageTags.Contains(other.tag);
                    
                    if (noTags) {
                        inDamage = true;
                    } else if (isTargetTagCompatible) {
                        inDamage = true;
                    }
                } else if ((hitBox.triggerType & vHitBoxType.Recoil) != 0) {
                    bool isTargetLayerCompatible = _hitProperties.hitRecoilLayer == (_hitProperties.hitRecoilLayer | (1 << other.gameObject.layer));
                    if (isTargetLayerCompatible)
                    {
                        inRecoil = true;
                    }
                }

                if (inDamage || inRecoil)
                {
                    // add target collider in the list to control the frequency of hit
                    targetColliders[hitBox].Add(other.gameObject);
                    vHitInfo hitInfo = new vHitInfo(this, hitBox, other, hitBox.transform.position);

                    if (inDamage)
                    {
                        // If there is a meleeManager then call onDamageHit to control damage values
                        // and it will call the ApplyDamage after filter the damage
                        // if meleeManager is null the damage will be directly applied
                        // Finally the OnDamageHit event is called
                        if (meleeManager)
                        {
                            FNvMeleeManager fnMeleeManager = (FNvMeleeManager)meleeManager;
                            fnMeleeManager.OnDamageHit(ref hitInfo);
                        }
                        else
                        {
                            damage.Sender = overrideDamageSender ? overrideDamageSender : transform;
                            // ApplyDamage(hitBox, other, damage);
                        }

                        if (!hitInfo.targetIsBlocking)
                        {
                            onDamageHit.Invoke(hitInfo);
                        }
                    }

                    // recoil just work with OnRecoilHit event and meleeManger
                    if (inRecoil == true)
                    {
                        if (meleeManager)
                        {
                            meleeManager.OnRecoilHit(hitInfo);
                        }

                        onRecoilHit.Invoke(hitInfo);
                    }
                }
            }
        }

        /// <summary>
        /// Apply damage to target collider (TakeDamage, damage))
        /// </summary>
        /// <param name="hitBox">vHitBox object</param>
        /// <param name="other">collider target</param>
        /// <param name="damage"> damage</param>
        public bool ApplyDamage(vHitBox hitBox, Collider other, vDamage damage)
        {
            vDamage _damage = new vDamage(damage);
            _damage.receiver = other.transform;
            _damage.damageValue = Mathf.RoundToInt(((damage.damageValue + damageModifier) * (hitBox.damagePercentage * 0.01f)));
            _damage.hitPosition = hitBox.transform.position;
            other.gameObject.ApplyDamage(_damage, meleeManager.fighter);
            if (_damage.hitReaction && _damage.damageValue > 0)
            {                
                onPassDamage.Invoke(_damage);
            }            

            return _damage.hitReaction;
        }
    }
}

namespace Invector.vMelee
{
    #region Secundary Class
    [System.Serializable]
    public class OnHitEnter : UnityEvent<vHitInfo> { }

    public class vHitInfo
    {
        public vMeleeAttackObject attackObject;
        public vHitBox hitBox;
        public Vector3 hitPoint;
        public Collider targetCollider;
        public bool targetIsBlocking;
        public vHitInfo(vMeleeAttackObject attackObject, vHitBox hitBox, Collider targetCollider, Vector3 hitPoint)
        {
            this.attackObject = attackObject;
            this.hitBox = hitBox;
            this.targetCollider = targetCollider;
            this.hitPoint = hitPoint;
        }
    }

    [System.Serializable]
    public class HitProperties
    {
        [Tooltip("Tag to receive Damage")]
        public List<string> hitDamageTags = new List<string>() { "Enemy", "Player" };
        [Tooltip("Trigger a HitRecoil animation if the character attacks a obstacle")]
        public bool useRecoil = true;
        public bool drawRecoilGizmos;
        [Range(0, 180f)]
        public float recoilRange = 90f;
        [Tooltip("layer to Recoil Damage")]
        public LayerMask hitRecoilLayer = 1 << 0;
    }
    #endregion
} 

// Assets\FishNet Invector\Scripts\Non-networked\FNvMeleeWeapon.cs:
 using System.Collections;
using System.Collections.Generic;
using Custom.Scripts.Melee;
using DungeonScrollerCore;
using Invector.vMelee;
using UnityEngine;

namespace FishnetInvector
{
    public class FNvMeleeWeapon : vMeleeWeapon
    {
        private FNvMeleeManager _fnmeleeManager;
        public List<MeleeAttackData> MeleeAttackDatas => meleeAttackDatas;
        [SerializeField] private List<MeleeAttackData> meleeAttackDatas;
        
        protected virtual void Start()
        {
            base.Start();
            _fnmeleeManager = (FNvMeleeManager)meleeManager;
        }
    }
} 

// Assets\FishNet Invector\Scripts\Non-networked\FNvMeleeWeapon.cs:
 using System.Collections;
using System.Collections.Generic;
using Custom.Scripts.Melee;
using DungeonScrollerCore;
using Invector.vMelee;
using UnityEngine;

namespace FishnetInvector
{
    public class FNvMeleeWeapon : vMeleeWeapon
    {
        private FNvMeleeManager _fnmeleeManager;
        public List<MeleeAttackData> MeleeAttackDatas => meleeAttackDatas;
        [SerializeField] private List<MeleeAttackData> meleeAttackDatas;
        
        protected virtual void Start()
        {
            base.Start();
            _fnmeleeManager = (FNvMeleeManager)meleeManager;
        }
    }
} 

// Assets\Invector-3rdPersonController\Melee Combat\Scripts\MeleeWeapon\vMeleeWeapon.cs:
 using UnityEngine;

namespace Invector.vMelee
{
    [vClassHeader("Melee Weapon", openClose = false)]
    public class vMeleeWeapon : vMeleeAttackObject
    {
        [Header("Melee Weapon Settings")]
        public vMeleeType meleeType = vMeleeType.OnlyAttack;
        [Header("Attack Settings")]
        public bool useStrongAttack = true;
        [Tooltip("Simple AI Only")]
        public float distanceToAttack = 1;
        [Tooltip("Trigger a Attack Animation")]
        public int attackID;
        [Tooltip("Change the MoveSet when using this Weapon")]
        public int movesetID;
        [Header("* Third Person Controller Only *")]
        [Tooltip("How much stamina will be consumed when attack")]
        public float staminaCost;
        [Tooltip("How much time the stamina will wait to start recover")]
        public float staminaRecoveryDelay;
        [Header("Defense Settings")]
        [Range(0, 100)]
        public int defenseRate = 100;
        [Range(0, 180)]
        public float defenseRange = 90;
        [Tooltip("Trigger a Defense Animation")]
        public int defenseID;
        [Tooltip("What recoil animatil will trigger")]
        public int recoilID;
        [Tooltip("Can break the oponent attack, will trigger a recoil animation")]
        public bool breakAttack;

        [HideInInspector]
        public UnityEngine.Events.UnityEvent onDefense;      
      
        public void OnDefense()
        {
            onDefense.Invoke();
        }
    }

    public enum vMeleeType
    {
        OnlyDefense, OnlyAttack, AttackAndDefense
    }
} 

// Assets\Invector-3rdPersonController\Basic Locomotion\Scripts\ObjectDamage\vDamage.cs:
 using System;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet;
using UnityEngine;
namespace Invector
{
    [System.Serializable]
    public class vDamage
    {
        [Tooltip("Apply damage to the Character Health")]
        public int damageValue = 15;
        [Tooltip("How much stamina the target will lost when blocking this attack")]
        public float staminaBlockCost = 5;
        [Tooltip("How much time the stamina of the target will wait to recovery")]
        public float staminaRecoveryDelay = 1;
        [Tooltip("Apply damage even if the Character is blocking")]
        public bool ignoreDefense;
        [Tooltip("Activated Ragdoll when hit the Character")]
        public bool activeRagdoll;
        [vHideInInspector("activeRagdoll"),Tooltip("Time to keep Ragdoll active")]
        public float senselessTime;

        [Tooltip("0 - for body, 1 - for head, 2 - for heavy")]
        public float hitHeight;
        [NonSerialized] public Transform Sender;
        public int senderNetworkObjectID;
        [NonSerialized]
        public Transform receiver;
        [HideInInspector]
        public Vector3 hitPosition = Vector3.zero;
        public bool IsCriticalDamage;
        public bool hitReaction = true;
        public bool IsShowDamage = true;
        [HideInInspector]
        public int recoil_id = 0;
        [HideInInspector]
        public int reaction_id = 0;
        public string damageType;
        public DamageType type;
        [HideInInspector] public byte SwingCounter;
        [HideInInspector] public Vector3 force;
        public int abilityId;
        public int weaponItemId;
        public enum DamageType {
            Melee,
            Arrow,
            Fire,
            Ice,
            Lightning,
            Poison,
            Bleeding,
            Magic,
            Fall,
            Shockwave,
            Explosion,
            Custom,
            Trap,
            Blood,
            Electric
        }

        public vDamage()
        {
            this.damageValue = 15;
            this.staminaBlockCost = 5;
            this.staminaRecoveryDelay = 1;
            this.hitReaction = true;
        }

        public void Copy (vDamage source)
        {
            this.damageValue = source.damageValue;
            this.hitPosition = source.hitPosition;
            this.Sender = source.Sender;
            this.senderNetworkObjectID = source.senderNetworkObjectID;
            this.staminaBlockCost = source.staminaBlockCost;
            this.staminaRecoveryDelay = source.staminaRecoveryDelay;
            this.ignoreDefense = source.ignoreDefense;
            this.reaction_id = source.reaction_id;
            this.recoil_id = source.recoil_id;
        }

        public vDamage(int value)
        {
            this.damageValue = value;
            this.hitReaction = true;
        }

        public vDamage(float value, int senderNetworkObjectID, Transform senderTrans, string damageType)
        {
            this.senderNetworkObjectID = senderNetworkObjectID;
            this.Sender = senderTrans;
            this.damageType = damageType;
            this.damageValue = (int)value;
            this.hitReaction = true;
        }

        public vDamage(int value, bool ignoreReaction)
        {
            this.damageValue = value;
            this.hitReaction = !ignoreReaction;
            if (ignoreReaction)
            {
                this.recoil_id = -1;
                this.reaction_id = -1;
            }                
        }

        public vDamage(vDamage damage)
        {
            this.damageValue = damage.damageValue;
            this.staminaBlockCost = damage.staminaBlockCost;
            this.staminaRecoveryDelay = damage.staminaRecoveryDelay;
            this.ignoreDefense = damage.ignoreDefense;
            this.activeRagdoll = damage.activeRagdoll;
            this.Sender = damage.Sender;
            this.receiver = damage.receiver;
            this.recoil_id = damage.recoil_id;
            this.reaction_id = damage.reaction_id;
            this.damageType = damage.damageType;
            this.hitPosition = damage.hitPosition;
            this.senselessTime = damage.senselessTime;
            this.force = damage.force;
            this.weaponItemId = damage.weaponItemId;
        }

        /// <summary>
        /// Calc damage Resuction percentage
        /// </summary>
        /// <param name="damageReduction"></param>
        public void ReduceDamage(float damageReduction)
        {
            int result = (int)(this.damageValue - ((this.damageValue * damageReduction) / 100));
            this.damageValue = result;
        }

        public FNvDamage ToFNvDamage()
        {
            FNvDamage damage = new FNvDamage();
            damage.damageValue = this.damageValue;
            damage.staminaBlockCost = this.staminaBlockCost;
            damage.ignoreDefense = this.ignoreDefense;
            damage.hitPosition = this.hitPosition;
            damage.force = this.force;
            damage.damageType = this.type;
            damage.senderNetworkObjectId = this.senderNetworkObjectID;
            damage.weaponItemId = this.weaponItemId;
            return damage;
        }

        public void SetDamage(float newValue)
        {
            string senderName = Sender == null ? "null" : Sender.name;
            string receiverName = receiver == null ? "null" : receiver.name;
            #if UNITY_EDITOR
            senderName = $"<color=green>{senderName}</color>";
            receiverName = $"<color=red>{receiverName}</color>";
            #endif
            Debug.Log($"[vDamage] SetDamage {senderName} {damageValue}->{newValue} {receiverName}");
            this.damageValue = (int)newValue;
        }
    }

    public class FNvDamage
    {
        public int senderNetworkObjectId;
        public int damageValue;
        public float staminaBlockCost;
        public bool ignoreDefense;
        public float hitHeight;
        public Vector3 hitPosition;
        public Vector3 force;
        public vDamage.DamageType damageType;
        public byte SwingCounter;
        public int abilityId;
        public int weaponItemId;
        
        public FNvDamage() { }
        
        public vDamage ToVDamage()
        {
            vDamage damage = new vDamage();
            if (InstanceFinder.ServerManager.Objects.Spawned.ContainsKey(senderNetworkObjectId))
                damage.Sender = InstanceFinder.ServerManager.Objects.Spawned[senderNetworkObjectId].transform;
            else
            {
                var nob = UnitComponentsManager.GetUnitComponentsServerAndClient(senderNetworkObjectId);
                if (nob == null)
                    Debug.LogError($"[vDamage] Sender with network object id {senderNetworkObjectId} not found.");
                else
                    damage.Sender = nob.HealthController.transform;
            }
            damage.damageValue = this.damageValue;
            damage.staminaBlockCost = this.staminaBlockCost;
            damage.ignoreDefense = this.ignoreDefense;
            damage.hitPosition = this.hitPosition;
            damage.force = this.force;
            damage.type = this.damageType;
            damage.senderNetworkObjectID = this.senderNetworkObjectId;
            damage.SwingCounter = SwingCounter;
            damage.abilityId = abilityId;
            damage.weaponItemId = weaponItemId;
            return damage;
        }
    }
} 

// Assets\-ZombieRoyale\Scripts\Core\VFXEntity.cs:
 using UnityEngine;

public class VFXEntity : MonoBehaviour
{
    private int effectId;
    private float duration;
    private float startTime;

    public void Initialize(int id, float duration)
    {
        this.effectId = id;
        this.duration = duration;
        this.startTime = Time.time;
    }

    public bool ShouldDestroy()
    {
        if (duration > 0 && Time.time - startTime >= duration)
        {
            return true;
        }
        return false;
    }

    public void Destroy()
    {
        Destroy(gameObject);
    }

    private void OnTriggerEnter(Collider other)
    {
        // Handle collision here
        Debug.Log($"VFX Effect {effectId} collided with {other.gameObject.name}");
    }
} 

// Assets\-ZombieRoyale\Scripts\Core\VFXManager.cs:
 using UnityEngine;
using System.Collections.Generic;

public class VFXManager : MonoBehaviour
{
    public static VFXManager Instance { get; private set; }

    private Dictionary<int, VFXEntity> activeEffects = new Dictionary<int, VFXEntity>();
    private int nextEffectId = 0;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public int SpawnEffect(GameObject effectPrefab, Vector3 position, Quaternion rotation, float duration = -1f)
    {
        GameObject effectObject = Instantiate(effectPrefab, position, rotation);
        VFXEntity vfxEntity = effectObject.AddComponent<VFXEntity>();
        
        int effectId = nextEffectId++;
        vfxEntity.Initialize(effectId, duration);
        activeEffects.Add(effectId, vfxEntity);

        return effectId;
    }

    public void DestroyEffect(int effectId)
    {
        if (activeEffects.TryGetValue(effectId, out VFXEntity vfxEntity))
        {
            vfxEntity.Destroy();
            activeEffects.Remove(effectId);
        }
    }

    public void Update()
    {
        List<int> effectsToRemove = new List<int>();

        foreach (var kvp in activeEffects)
        {
            if (kvp.Value.ShouldDestroy())
            {
                effectsToRemove.Add(kvp.Key);
            }
        }

        foreach (int effectId in effectsToRemove)
        {
            DestroyEffect(effectId);
        }
    }
} 

// Assets\FishNet Invector\Scripts\Networked\FishnetInvectorManager.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using Character;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Clients;
using FishNet.Component.Animating;
using FishNet.Component.Transforming;
using FishNet.Connection;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using FishNet.Observing;
using Invector.vCharacterController;
using Invector.vItemManager;
using NHance.Assets.Scripts;
using PixelCrushers;
using UnityEngine;
using UnityEngine.UI;
using Zomb.Creatures.Helpers;
using PixelCrushers.DialogueSystem.Wrappers;
using Backend;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

namespace FishnetInvector{
    
    public struct TorchActivationJob : IJobParallelFor
    {
        [ReadOnly] public float3 PlayerPosition;
        [ReadOnly] public NativeArray<float3> TorchPositions;
        [ReadOnly] public float ActivationDistanceSquared;
        public NativeArray<bool> TorchActivationStates;

        public void Execute(int index)
        {
            float3 torchPosition = TorchPositions[index];
            float sqrDist = math.distancesq(PlayerPosition, torchPosition);
            TorchActivationStates[index] = sqrDist < ActivationDistanceSquared;
        }
    }
    
    
[RequireComponent(typeof(NetworkTransform))]
[RequireComponent(typeof(NetworkObserver))]
[RequireComponent(typeof(NetworkAnimator))]
[RequireComponent(typeof(BehavioursSwitcher))]
public class FishnetInvectorManager : Unit {
    private static string DEBG_LOG_PREFIX = "<color=orange>[FishnetInvectorManager]</color>";
    #region Camera
    private FNvThirdPersonCamera _fishnetThirdPersonCamera;
    [SerializeField] private GameObject _inventoryCamera;
    #endregion

    #region Client-specific GOs
    [SerializeField] private GameObject inventory_CameraPreview;
    [SerializeField] private GameObject ui;
    [SerializeField] private GameObject shooterUIGO;
    [SerializeField] private GameObject _gOFishnetThirdPersonCamera;
    [SerializeField] private GameObject[] _hiddenOnServer;
    #endregion

    private List<Behaviour> _componentsToDisable = new List<Behaviour>();
    [SerializeField] private Rigidbody _rb;
    private vThirdPersonInput tpInput;
    private GameObject currentCamera;
    [SerializeField] private vInventory _inventory;
    [SerializeField] private vShooterMeleeInput _shooterMeleeInput;
    public AnimatorDecorator AnimatorDecorator => _animatorDecorator;
    [SerializeField] private AnimatorDecorator _animatorDecorator;
    [SerializeField] private FNvMeleeManager _meleeManager;
    [SerializeField] private FNvThirdPersonController _thirdPersonController;
    [SerializeField] private vChangeAnimatorUpdateMode _vChangeAnimatorUpdateMode;
    [Tooltip("Optional canvas group, for example to play fade animations.")]
    public CanvasGroup canvasGroup = null;
    [Tooltip("UI text control for bark text.")]
    public UITextField barkText = null;
    [Tooltip("Optional UI text control for barker's name if Include Name is ticked. If unassigned and Include Name is ticked, name is prepended to Bark Text.")]
    public UITextField nameText = null;
    [field:SerializeField] public List<RendererColor> rendererColor { get; protected set; }

    [SerializeField] private GameObject dashEffect;
    public FNvThirdPersonController ThirdPersonController => _thirdPersonController;
    public vInventory Inventory => _inventory;
    public CharacterSkin CharacterSkin => _characterSkin;
    [SerializeField] private CharacterSkin _characterSkin;
    public NHAvatar Avatar => avatar;
    [SerializeField] private NHAvatar avatar;
    public int ObjectId => NetworkObject.ObjectId;
    [SerializeField] private CapsuleCollider _capsuleCollider;
    public static Action<FishnetInvectorManager> OnPlayerInRangeDetected;
    public static Action<FishnetInvectorManager> OnPlayerLeftFromRangeDetected;
    public static Action OnOwnerInitialized;
    public Action OnThisOwnerInitialized;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;
    #region Client-specific Components
    public static FishnetInvectorManager LocalPlayer;
    private GameplayManager _gameplayManager;
    public GameplayManager GameplayManager => _gameplayManager;
    private Vector3 _lastPosition;
    
    
    public static Action OnLocalPlayerInitialized;
    public static bool IsLocalPlayerInitialized { get; private set; }
    public ClientInstance ClientInstance { get; private set; }

    public Action OnObservingPlayerInitialized;
    public Action<NetworkObject, Vector3> OnPlayerPositionChanged;
    private bool _isDebug = true;
    [SyncVar] private Vector3 _spawnedPosition = Vector3.zero;
    
    
    private NativeArray<float3> _torchPositions;
    private NativeArray<bool> _torchActivationStates;
    private JobHandle _torchActivationJobHandle;
    private const float ActivationDistance = 30f; // Equivalent to sqrt(900)

    #endregion
    
    protected override void OnValidate() {
        base.OnValidate();
        _characterSkin ??= GetComponentInChildren<CharacterSkin>();
        _inventory ??= GetComponentInChildren<vInventory>();
        _inventoryCamera ??= GetComponentInChildren<vInventory>().gameObject;
        _rb ??= GetComponent<Rigidbody>();
        _capsuleCollider ??= GetComponent<CapsuleCollider>();
        _shooterMeleeInput ??= GetComponent<vShooterMeleeInput>();
        _meleeManager ??= GetComponent<FNvMeleeManager>();
        _thirdPersonController ??= GetComponent<FNvThirdPersonController>();
        _animatorDecorator ??= GetComponent<AnimatorDecorator>();
        _vChangeAnimatorUpdateMode ??= GetComponentInChildren<vChangeAnimatorUpdateMode>();
        _inventory ??= GetComponentInChildren<vInventory>();
    }

    private void Awake()
    {
        if (CharacterSkin != null)
            CharacterSkin.OnGenderChanged += UpdateGenderVoices;
        RoomLODDetector.OnLocalPlayerDetected += ActivateRB;
    }

    public override void OnStartNetwork() {
        base.OnStartNetwork();
        ChangeGOName(base.Owner.IsLocalClient);
        int clientId = IsHost ? 0 : Owner.ClientId;
        if (IsHost)
        {
            //NetworkConnection conn = InstanceFinder.ServerManager.Clients[clientId];
            //ClientInstance = ClientInstance.ClientInstances[conn];
        }
        else
        {
            ClientInstance = ClientInstance.ClientInstances[Owner];
        }
        
        if (!base.IsHost && !base.Owner.IsLocalClient) {
            _rb.isKinematic = true;
        }
    }

    private void InitServerAndOwner()
    {
        if (UnitComps != null)
            return;
        
        if (!(base.IsHost || base.Owner.IsLocalClient)) {
            _vChangeAnimatorUpdateMode.gameObject.SetActive(false);
        }
    }
    
    IEnumerator DelayedRigidBodyActivator(float delay)
    {
        _rb.isKinematic = true;
        yield return new WaitForSeconds(delay);
        ActivateRB();
    }
    
    private void ActivateRB()
    {
        Debug.Log($"[FishnetInvectorManager] ActivateRB for {gameObject} at {transform.position}", gameObject);
        _rb.isKinematic = false;
    }
    
    public override void OnStartClient()
    {
        base.OnStartClient();
        InitServerAndOwner();
        if (IsOwner) {
            Init();
            _spawnedPosition = transform.position;
            if (_characterSkin != null)
                _characterSkin.SetSkinData(CharacterDataController.Instance.CharacterSkinData);
            else if (avatar != null)
                avatar.SetSkinData(CharacterDataController.Instance.CharacterSkinData);
            OnOwnerInitialized?.Invoke();
            OnThisOwnerInitialized?.Invoke();
            //StandardBarkUI.OnBarkUIInit += AssignMyBarkUI;
            _thirdPersonController.OnRoll.AddListener(CmdTryRoll);
            var torchesArray = GameplayManager.Instance.DungeonHolder.LoadTorches();
            for (int i = 0; i < torchesArray.Length; i++)
            {
                torchesArray[i].TorchController.InitForLocalPlayer(gameObject, _fishnetThirdPersonCamera);
            }
            //TODO: change to JOBs system
            StartCoroutine(TorchesActivator(torchesArray));
            StartCoroutine(DelayedRigidBodyActivator(5f));
        }
    
        if (!IsOwner)
        {
            OnObservingPlayerInitialized?.Invoke();
            DebugWrite.Log($"[OnStartClient] Player #{NetworkObject.OwnerId} OnPlayerInRangeDetected, OnObservingPlayerInitialized", gameObject, _isDebug);
            OnPlayerInRangeDetected?.Invoke(this);
            ObserversUpdateSkin();
            UnitComps.AnimatorDecorator.TurnOffRootMotion();
        }
    }

    private IEnumerator TorchesActivator(TorchGlobalManager.TorchStatus[] torches)
    {
        int torchCount = torches.Length;
        _torchPositions = new NativeArray<float3>(torchCount, Allocator.Persistent);
        _torchActivationStates = new NativeArray<bool>(torchCount, Allocator.Persistent);

        for (int i = 0; i < torchCount; i++)
        {
            _torchPositions[i] = torches[i].TorchController.transform.position;
        }

        var waitForSeconds = new WaitForSeconds(1f);
        var lastPosition = transform.position;

        while (true)
        {
            yield return waitForSeconds;

            bool hasMoved = (transform.position - lastPosition).sqrMagnitude > 0.01f;
            if (hasMoved)
            {
                lastPosition = transform.position;

                // Schedule the job
                var job = new TorchActivationJob
                {
                    PlayerPosition = transform.position,
                    TorchPositions = _torchPositions,
                    ActivationDistanceSquared = ActivationDistance * ActivationDistance,
                    TorchActivationStates = _torchActivationStates
                };

                _torchActivationJobHandle = job.Schedule(torchCount, 64);

                // Wait for the job to complete
                _torchActivationJobHandle.Complete();

                // Update torch VFX based on job results
                for (int i = 0; i < torchCount; i++)
                {
                    if (torches[i].TorchController != null)
                    {
                        torches[i].TorchController.SetVFXOnOff(_torchActivationStates[i]);
                    }
                }
            }
        }
    }

    private void AssignMyBarkUI(StandardBarkUI barkUI)
    {
        barkUI.InitLocalPlayer(canvasGroup, barkText, nameText);
    }

    private void ObserversUpdateSkin() {
        Debug.Log($"[FishnetInvectorManager] UpdateSkin for {gameObject}");
        //get owners PlayerSettings
        ClientInstance ownerClientInstance = ClientInstance.ClientInstances[Owner];
        if (CharacterSkin != null)
            BackendReadWrites.GetCharacterSkin(ownerClientInstance.PlayerSettings.CharacterSkinData.Id, CharacterSkin.SetSkinData);
        else if (avatar != null)
            BackendReadWrites.GetCharacterSkin(ownerClientInstance.PlayerSettings.CharacterSkinData.Id, Avatar.SetSkinData);
    }

    public override void OnStopClient()
    {
        base.OnStopClient();
        if (IsOwner)
        {
            IsLocalPlayerInitialized = false;
            LocalPlayer = null;
        }
        else
        {
            DebugWrite.Log($"[OnStopClient] Player #{NetworkObject.OwnerId} OnPlayerLeftFromRangeDetected", gameObject, _isDebug);
            OnPlayerLeftFromRangeDetected?.Invoke(this);
        }
    }

    public override void OnStartServer()
    {
        base.OnStartServer();
        InitServerAndOwner();
        //_capsuleCollider.isTrigger = true;
        for (int i = 0; i < _hiddenOnServer.Length; i++)
        {
            _hiddenOnServer[i].SetActive(false);
        }
        StartCoroutine(PlayerPositionsUpdater());
    }
    
    public void SetupGameplayManager(GameplayManager gameplayManager)
    {
        _gameplayManager = gameplayManager;
    }

    [Server]
    private IEnumerator PlayerPositionsUpdater()
    {
        var time = new WaitForSeconds(.5f);
        while (true)
        {
            Vector3 currentPosition = transform.position;
            if (_lastPosition == null || currentPosition != _lastPosition)
            {
                _lastPosition = currentPosition;
                OnPlayerPositionChanged?.Invoke(NetworkObject, currentPosition);
            }

            yield return time;
        }
    }

    private void ChangeGOName(bool isOwner) {
        string local = isOwner ? "(Local)" : "";
        string oldName = gameObject.name;
        gameObject.name = $"{gameObject.name.Substring(0,oldName.Length-7)} #{NetworkObject.ObjectId} - Player #{NetworkObject.OwnerId}{local}";
    }

    private void Init() {
        ActivateClientSpecificGOs();
        SpawnCamera();
        InitEvents();
        LocalPlayer = this;
        //ActivateCamera();
        IsLocalPlayerInitialized = true;
        OnLocalPlayerInitialized?.Invoke();
        Debug.Log($"{ClassName} OnLocalPlayerInitialized Invoke IsLocalPlayerInitialized: {IsLocalPlayerInitialized}");
        _shooterMeleeInput.OnAnimatorTriggerSet += OnAnimatorTriggerSet;
        _thirdPersonController.OnAnimatorTriggerSet += OnAnimatorTriggerSet;
        StartCoroutine(CheckIfFallingDown());
        Debug.Log($"Object: {base.ObjectId}; Owner: {base.OwnerId}; name: {gameObject.name}; IsOwner: {base.IsOwner}");
    }

    private IEnumerator CheckIfFallingDown()
    {
        var time = new WaitForSeconds(1f);
        while (true)
        {
            if (transform.position.y < -200)
            {
                Debug.Log($"[FishnetInvectorManager] CheckIfFallingDown: {gameObject.name} is falling down. Teleporting to {_spawnedPosition}");
                transform.position = _spawnedPosition + 2*Vector3.up;
            }
            yield return time;
        }
    }

    private void OnAnimatorTriggerSet(int hash)
    {
        _animatorDecorator.SetTrigger(hash);
    }

    private void ActivateClientSpecificGOs() {
        //ActivateLocalClientInventory();
        //inventory_CameraPreview.SetActive(true);
        //ui.SetActive(true);
        //shooterUIGO.SetActive(true);
    }

    private void ActivateLocalClientInventory() {
        Canvas canvas = _inventory.GetComponent<Canvas>();
        CanvasScaler canvasScaler = _inventory.GetComponent<CanvasScaler>();
        GraphicRaycaster graphicRaycaster = _inventory.GetComponent<GraphicRaycaster>();
        //vJoystickMouseInput joystickMouseInput = _inventory.GetComponent<vJoystickMouseInput>();
        canvas.enabled = true;
        canvasScaler.enabled = true;
        graphicRaycaster.enabled = true;
        _inventory.enabled = true;
        //joystickMouseInput.enabled = true;
        string[] goNamesToActivate = new[] { "ItemCollectionDisplay", "EquipmentDisplayWindow", "Inventory_UI", "OpenInventory" };
        StringBuilder sbLog = new StringBuilder();
        sbLog.AppendLine($"Activating inventory for {gameObject.name} client id #{base.OwnerId}");
        foreach (Transform Child in _inventory.transform) {
            foreach (string goName in goNamesToActivate) {
                if (goName == Child.name) {
                    Child.gameObject.SetActive(true);
                    sbLog.AppendLine($"Activating {goName}; ");
                }
            }
        }
        Debug.Log($"{sbLog}", _inventory);
    }

    private void ActivateClientSpecificComponents() {
        vInventory inventory = GetComponentInChildren<vInventory>();
        vJoystickMouseInput joystickMouseInput = GetComponentInChildren<vJoystickMouseInput>();
    }

    private void OnDisable() {
        Debug.Log($"[FishnetInvectorManager] OnDisable: {base.ObjectId}; Owner: {base.OwnerId}; name: {gameObject.name}; IsOwner: {base.IsOwner}");
    }

    private void SpawnCamera() {
         currentCamera = Instantiate(_gOFishnetThirdPersonCamera);
         Debug.Log($"[FishnetInvectorManager] SpawnCamera: {currentCamera.name}", currentCamera);
        _gOFishnetThirdPersonCamera = currentCamera;// mainCameraGO.transform.parent.gameObject;
        _fishnetThirdPersonCamera = _gOFishnetThirdPersonCamera.GetComponent<FNvThirdPersonCamera>();
        _fishnetThirdPersonCamera.mainTarget = transform;
        _fishnetThirdPersonCamera.Init(this);
    }

    private void ActivateInventoryView()
    {
        _fishnetThirdPersonCamera.gameObject.SetActive(false);
        _inventoryCamera.SetActive(true);
    }

    private void DeactivateInventoryView()
    {
        _fishnetThirdPersonCamera.gameObject.SetActive(true);
        _inventoryCamera.SetActive(false);
    }

    public void ChangeCameraInventoryState(bool value)
    {
        if (value)
        {
            _fishnetThirdPersonCamera.ChangeState("Default");
        }
        else
        {
            _fishnetThirdPersonCamera.ChangeState("InventoryMode");
        }
    }

    private void InitEvents() // add listeners to basic invector events
    {
        //TCGGameManager.GameManager.GetInstance().OnLockInput += LockInputs;
    }

    private void OnDestroy()
    {
        //TCGGameManager.GameManager.GetInstance().OnLockInput -= LockInputs;
        Destroy(currentCamera);
        if (_torchPositions.IsCreated)
            _torchPositions.Dispose();
        if (_torchActivationStates.IsCreated)
            _torchActivationStates.Dispose();
    }

    public void ServerTeleportPlayer(Vector3 position)
    {
        TeleportPlayerDecorator(Owner, position);
    }

    public void OwnerTeleport(Vector3 position)
    {
        transform.position = position;
    }

        public void OwnerSmoothTeleport(Vector3 position , float duration)
        {
            StartCoroutine(SmoothMoveCoroutine(position, duration));
        }

        private IEnumerator SmoothMoveCoroutine(Vector3 destination, float duration)
        {
            float elapsedTime = 0;

            while (elapsedTime < duration)
            {
                transform.position = Vector3.Lerp(transform.position, destination, elapsedTime / duration);
                elapsedTime += Time.deltaTime;
                yield return null;
            }

          //  transform.position = destination; // Ensure the object reaches the target position
        }

        [TargetRpc]
    public void TeleportPlayerDecorator(NetworkConnection conn, Vector3 position) {
        transform.position = position;
    }

    public void SwitchCamera()
    {
        //_fishnetThirdPersonCamera.SwitchCamera();
    }

    public void StoreRendererColors()
    {
        
    }

    [ServerRpc]
    public void CmdTryRoll()
    {
        //TODO: stamina antihack check
        bool isStaminaOk = true;
        if (isStaminaOk)
        {
            _thirdPersonController.SetIsRolling(true);
        }
    }

    private float _testForce = 100f;
    public void TestForce()
    {
        #if UNITY_EDITOR
        _thirdPersonController.AddForce(Vector3.forward, _testForce);
        _testForce += 100f;
#endif
    }

    [ServerRpc]
    public void SpawnDashEffect(Vector3 oldPos, Vector3 destination)
    {
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        SpawnDashEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnDashEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalDashEffect(middlePoint, directionRotation);
    }

    public void InternalDashEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        if (dashEffect != null)
        {
            GameObject fxInstance = Instantiate(dashEffect, middlePoint, directionRotation);
            Destroy(fxInstance, .5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }
}
} 



# TASK: change the code of VFXManager and VFXEntity to use unity DOTS system like JOBS and entities