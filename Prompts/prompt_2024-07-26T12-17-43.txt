# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
# CODE: // Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Ability.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using DuloGames.UI;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using Invector;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class Ability: NetworkBehaviour
{
    protected int _rank;
    [SerializeField] protected AbilityDefinition _abilityDefinition;
    public Buff Buff => _buff;
    [SerializeField] protected Buff _buff;
    [SerializeField] protected bool isPassiveSkill;
    public static Dictionary<NetworkConnection, uint> StacksCounter { get; private set; } = new ();
    public static Dictionary<NetworkConnection, uint> RankCounter { get; private set; } = new ();
    public AbilityDefinition AbilityDefinition => _abilityDefinition;
    public static Action OnAbilityLearned;
    public Action<NetworkConnection, byte, uint> OnRankLevelUp;
    protected string _abilityName => _abilityDefinition.Name;
    protected GameplayManager _gameplayManager;
    protected bool _isDebug = true;
    protected readonly string COLOR_DURATION = "#00F0FF";
    protected readonly string COLOR_AFFECTING_STAT = "#00F0FF";
    protected readonly string COLOR_DAMAGE = "#ff3517";
    protected readonly string COLOR_HEAL = "#0ec949";
    protected readonly string COLOR_STAT = "#96e33d";
    protected readonly string COLOR_XP = "#c3eb34";
    protected readonly string COLOR_COOLDOWN = "#c8e609";

    protected readonly Color DEBUG_SPHERE_DEFAULT_COLOR = new Color(1f, 0f, 0f, 0.5f);
    protected readonly Color DEBUG_SPHERE_ACTIVATE_COLOR = new Color(1f, 0f, 1f, 0.5f);
    protected Color _debugSphereColor;
    protected bool _showDebugSphere;
    protected Vector3 _debugSpherePos;
    protected float _debugSphereRadius = 1f;

    public virtual void InitAbility()
    {
        if (_buff != null) 
        {
            _buff.Init(GameplayManager.Instance);
        }
        else
        {
            Debug.LogWarning($"Buff is null during ability {_abilityName} initialization.");
        }
    }

    public virtual float CalculateValueBasedOnStacks(uint stacks) => .01f;
    
    public virtual int CalculateRankBasedOnStacks(uint stacks) => 1;
    
    public virtual float CalculateDamageBasedOnRank(int rank) => 1;
    
    public virtual uint GetStacksForRank() => 1;
    
    public uint AddRank(NetworkConnection connection)
    {
        if (RankCounter.ContainsKey(connection))
        {
            RankCounter[connection]++;
        }
        else
        {
            RankCounter.Add(connection, 1);
        }
        OnRankLevelUp?.Invoke(connection, _abilityDefinition.Id, RankCounter[connection]);
        return RankCounter[connection];
    }

    public uint ServerAddStack(FNAbilityController abilityController, uint amount)
    {
        if (!abilityController.LearnedAbilityDict.ContainsKey(AbilityDefinition.Id))
        {
            Debug.LogError($"Ability {AbilityDefinition.Name} is not learned by player {abilityController.gameObject.name}. Cannot add stacks.");
            return 0;
        }
        
        AbilityInfo targetsAbilityStats = abilityController.LearnedAbilityDict[AbilityDefinition.Id];
        targetsAbilityStats.Stacks = Math.Max(0, targetsAbilityStats.Stacks + amount);
        abilityController.AddOrSetAbility(targetsAbilityStats);
        return targetsAbilityStats.Stacks;
    }
    
    public uint AddStack(NetworkConnection connection)
    {
        if (StacksCounter.ContainsKey(connection))
        {
            StacksCounter[connection]++;
        }
        else
        {
            StacksCounter.Add(connection, 1);
        }
        
        if (EnoughStacksToLevelup(connection))
        {
            StacksCounter[connection] = 0;
            AddRank(connection);
            return 1;
        }
        else
        {
            return 0;
        }
        
        return StacksCounter[connection];
    }
    
    public UISpellInfo GetUISpellInfo(byte abilityId, uint stacks)
    {
        UISpellInfo spellInfo = new UISpellInfo();
        spellInfo.ID = _abilityDefinition.Id;
        uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId);
        int abilityRankBasedOnStacks = CalculateRankBasedOnStacks(abilityStacksForPlayer);
        spellInfo.Name = GetAbilityName(abilityRankBasedOnStacks);
        spellInfo.Icon = _abilityDefinition.Icon;
        spellInfo.Description = GetAbilityDescription(abilityRankBasedOnStacks, abilityStacksForPlayer);
        if (_abilityDefinition.IsPassive)
        {
            spellInfo.Flags = UISpellInfo_Flags.Passive;
        }
        else
        {
            AbilityDefinition.RPGAbilityRankData rankData = _abilityDefinition.RanksDatas[0];

            if (rankData != null)
            {
                switch (rankData.activationType)
                {
                    case AbilityDefinition.AbilityActivationType.Instant:
                        spellInfo.Flags = UISpellInfo_Flags.InstantCast;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCircle:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCircle;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedCone:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastCone;
                        break;
                    case AbilityDefinition.AbilityActivationType.PreCastedAim:
                        spellInfo.Flags = UISpellInfo_Flags.PreCastAim;
                        break;
                    default:
                        spellInfo.Flags = UISpellInfo_Flags.PowerCostInPct;
                        break;

                }

                spellInfo.Range = rankData.maxRange;
                spellInfo.Cooldown = rankData.cooldown;
                if (rankData.castTime > 0)
                {
                    spellInfo.CastTime = rankData.castTime;
                }
                spellInfo.PowerCost = rankData.manaCost;
            }
            else
            {
                Debug.LogError($"Ability {spellInfo.Name} does not have rank {abilityId}. Setting default values.");
            }
        }
        return spellInfo;
    }

    private bool EnoughStacksToLevelup(NetworkConnection connection)
    {
        return StacksCounter[connection] >= GetStacksForRank();
    }

    public virtual string GetAbilityName(int rank) => _abilityDefinition.Name;
    public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description;
    public virtual string GetAbilityDescription(int rank, FNStatsController statsController) => _abilityDefinition.persistDescription;
    
    public virtual float GetAbilityCastingTime(int rank, FNStatsController statsController)
    {
        float castingTime = _abilityDefinition.RanksDatas[rank].castTime;
        return castingTime;
    }

    public virtual IEnumerator Activate(AbilityCastingData data)
    {
        yield return null;
    }

    [Server]
    protected virtual void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f)
    {
        Debug.Log($"{_abilityName} Applying caster buff.");
        _buff.Activate(casterBuffData, new int[]{}, duration:duration);
    }
    
    [Server]
    public virtual void CasterRemoveBuff(Buff.BuffData casterBuffData)
    {
        Debug.Log($"{_abilityName} Removing caster buff.");
        _buff.RemoveBuff(casterBuffData.ObjectId, casterBuffData.ObjectId);
    }

    protected virtual List<Collider> TargetsSelection(Transform caster) 
    {
        Debug.LogWarning($"{_abilityName} TargetsSelection method has not been implemented yet.");
        throw new NotImplementedException();
    }

    [Server]
    protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage, bool isExcludeSelf = false)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        var targets = TargetsInSphereSelection(playerComps, radius);
        for (int i = 0; i < targets.Count; i++) 
        {
            if (isExcludeSelf && targets[i] == playerComps.HealthController)
            {
                continue;
            }
            damage.receiver = targets[i].transform;
            targets[i].TakeDamage(damage);

            Debug.Log($"[{_abilityDefinition.Name}] Damage applied to {targets[i].name}");
        }
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, Buff.BuffData caster, float radius)
    {
        //Debug.Log($"{_abilityName} Selecting targets in sphere.");
        List<FishnetInvectorHealthController> targets = EnemyTargetsInRadius(pos, caster, radius);
        //Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");
        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsExcludingTagsInSphereSelection(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = TargetsInRadiusExcludingTags(tags, pos, caster, radius);
        return targets;
    }
    
    public static List<FishnetInvectorHealthController> TargetsInRadiusExcludingTags(string[] tags, Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            for (int i = 0; i < tags.Length; i++)
            {
                if (targetNob.CompareTag(tags[i]))
                {
                    continue;
                }
            }
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            targets.Add(targetComps.HealthController);
        }
        return targets;
    }

    public static List<FishnetInvectorHealthController> EnemyTargetsInRadius(Vector3 pos, Buff.BuffData caster, float radius)
    {
        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            if (targetNob == null)
                continue;
            
            if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
                continue;
            
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (targetComps == null)
                continue;
            
            Buff.BuffData targetData = new Buff.BuffData(targetComps.HealthController.ObjectId, targetComps.HealthController.gameObject.tag, 0f, caster.abilityId, 0, null, null, 0);
            if (IsNotValidTargetEnemy(caster, targetData))
                continue;
            
            targets.Add(targetComps.HealthController);
        }

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(possibleTarget);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [Server]
    protected List<FishnetInvectorHealthController> TargetsInSphereSelection(UnitComponents caster, float radius)
    {
        Debug.Log($"{_abilityName} Selecting targets in sphere.");

        List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>();
        
        //check targets
        foreach (var target in GameplayManager.Instance.UnitCharacters)
        {
            var targetNob = UnitComponentsManager.GetUnitComponentsServerAndClient(target).NetworkObject;
            var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNob.ObjectId);
            if (IsNotValidTargetEnemy(targetComps, caster))
            {
                continue;
            }
            if (CommonMath.Math.IsWithinRange(caster.HealthController.transform.position, targetNob.transform.position, radius))
            {
                var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(target);
                targets.Add(unitComps.HealthController);
            }
        }

        Debug.Log($"{_abilityName} {targets.Count} targets found in sphere.");

        return targets;
    }
    
    [ObserversRpc]
    protected void RpcShowEffectForObservers(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect for observers.");

        GameplayManager.Instance.StartCoroutine(ShowEffectOnTarget(targetNetId, abilityId, rank, timeout));
    }
    
    protected virtual IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if(targetComps == null)
        {
            Debug.LogError($"{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        List<GameObject> effects = new List<GameObject>(); 
        foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints)
        {
            Assert.IsNotNull(_abilityDefinition.RanksDatas[rank].hitEffect, $"Hit effect is null for {_abilityName}.");
            Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint);
            GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position + Vector3.up, Quaternion.identity, GameplayManager.Instance.transform);
            effect.transform.SetParent(pointTransform);
            effects.Add(effect);
        }

        yield return new WaitForSeconds(timeout);
        foreach (var effect in effects)
        {
            Destroy(effect, timeout);
        }
    }
    
    public static bool IsNotValidTargetEnemy(Buff.BuffData casterData, Buff.BuffData targetData)
    {
        if (casterData.ObjectId == targetData.ObjectId)
        {
            return true;
        }

        int casterTeam = GameplayManager.Instance.GetUnitTeamId(casterData.ObjectId);
        int targetTeam = GameplayManager.Instance.GetUnitTeamId(targetData.ObjectId);
        if (casterData.Tag == GameplayManager.TAG_PLAYER)
        {
            if (casterTeam == targetTeam)
            {
                return true;
            }
            return false;
        }else if (targetData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
        {
            if (casterData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID])
            {
                return true;
            }
            return false;
        }

        return false;
    }

    protected bool IsNotValidTargetEnemy(UnitComponents target, UnitComponents caster)
    {
        //Debug.Log($"{_abilityName} Checking if target is valid.");
        if (target == null)
            return true;
        
        if (target == caster)
        {
            //Debug.Log($"{_abilityName} Target is the same as caster. Invalid target.");
            return true;
        }

        var targetHealthController = target.HealthController;
        if (targetHealthController == null)
        {
            return true;
        }
        if (targetHealthController.CompareTag(GameplayManager.TAG_PLAYER))
        {
            //Debug.Log($"{_abilityName} Target is a player. Valid target.");
            return false;
        }else if (targetHealthController.CompareTag("Enemy"))
        {
            //Debug.Log($"{_abilityName} Target is an enemy. Valid target.");
            if (caster.HealthController.CompareTag("Enemy"))
            {
                return true;
            }
            return false;
        }

        //Debug.Log($"{_abilityName} Target does not have a Player or Enemy tag. Invalid target.");

        return false;
    }
    
    protected void DrawDebugSphere(Vector3 pos, float radius)
    {
        _debugSpherePos = pos;
        _debugSphereRadius = radius;
        _showDebugSphere = true;
        _debugSphereColor = DEBUG_SPHERE_ACTIVATE_COLOR;
        StartCoroutine(ResetDebugSphereColorAfterDelay(0.3f));
    }
    
    protected IEnumerator ResetDebugSphereColorAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        _debugSphereColor = DEBUG_SPHERE_DEFAULT_COLOR;
        _showDebugSphere = false;
    }
    
    public virtual float CalcAmount(FNStatsController statsController) {
        return 1f;
    }
    
    public virtual float CalcDuration(FNStatsController statsController) {
        return 1f;
    }
    
#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        if (_showDebugSphere)
        {
            Gizmos.color = _debugSphereColor;
            Gizmos.DrawSphere(_debugSpherePos, _debugSphereRadius);
        }
    }
#endif
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\ElectricBall.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;
using Invector.vCharacterController;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class ElectricBall: Ability
{
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE = .1f;

    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Lightning;

    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        var healthController = casterComps.HealthController;
        var casterPos = healthController.transform;

        var bullRotate = Camera.main.GetComponentInParent<Transform>().rotation;

        NetworkObject nps = Instantiate(networkedParticleSystem, casterComps.AbilityController.FirePoint.transform.position, bullRotate);

        vDamage damage = new(CalculateDamage(casterComps.StatsController), data.casterNetId, casterPos, "Lightning");

        damage.type = DAMAGE_TYPE;

        nps.GetComponent<ProjectileMoveScript>().BallDamage = damage;

        Spawn(nps);
        yield return null;
    }

    IEnumerator DelayDestroy(NetworkObject nps, float timeout)
    {
        yield return new WaitForSeconds(timeout);
        Despawn(nps);
    }

    private float CalculateDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\ElectricBall.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;
using Invector.vCharacterController;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class ElectricBall: Ability
{
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE = .1f;

    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Lightning;

    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        var healthController = casterComps.HealthController;
        var casterPos = healthController.transform;

        var bullRotate = Camera.main.GetComponentInParent<Transform>().rotation;

        NetworkObject nps = Instantiate(networkedParticleSystem, casterComps.AbilityController.FirePoint.transform.position, bullRotate);

        vDamage damage = new(CalculateDamage(casterComps.StatsController), data.casterNetId, casterPos, "Lightning");

        damage.type = DAMAGE_TYPE;

        nps.GetComponent<ProjectileMoveScript>().BallDamage = damage;

        Spawn(nps);
        yield return null;
    }

    IEnumerator DelayDestroy(NetworkObject nps, float timeout)
    {
        yield return new WaitForSeconds(timeout);
        Despawn(nps);
    }

    private float CalculateDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateDamage(statsController);

        string mainEdited = _abilityDefinition.mainDescription.Replace("@@@", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\PoisonNova.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;

public class PoisonNova : Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float POISON_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_TICK = .018890456f;
    private readonly float BASE_DURATION = 5f;
    private const string DESCRIPTION = "Unleashes a wave of toxic energy, poisoning all enemies in its radius upon activation. The poison inflicts [damage] damage over time.";
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison;
    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private float GetPoisonFeildDuration()
    {
        return POISON_FIELD_DURATION;
    }    
    private float CalculateTickDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE_PER_TICK * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition);
        var healthController = casterComps.HealthController;
        NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity);
        Spawn(nps);
        RpcShowEffectForObservers(data.casterNetId, abilityId, _rank, GetPoisonFeildDuration());

        Debug.Log($"{ClassName} Activated for unit #{data.casterNetId} with abilityId #{abilityId} and rank {data.rank}");
        float currentDuration = 0f;
        float tickTime = 1f;
        float radius = 1f;
        Buff.BuffData casterData = new Buff.BuffData(data.casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, 
            CalculateTickDamage(casterComps.StatsController));

        vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE);
        Vector3 poisonCloudPos = healthController.transform.position;
        while (currentDuration < GetPoisonFeildDuration())
        {
            currentDuration += tickTime;
            InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS);
            yield return new WaitForSeconds(tickTime);
        }
        Despawn(nps);
    }
    
    
    [Server]
    private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius)
    {
        DrawDebugSphere(pos, radius);
        var caster = UnitComponentsManager.GetUnitComponentsServerAndClient(casterData.ObjectId);
        if (caster != null)
        {
            damage = UpdateDamage(ref casterData, caster);
        }
        var targets = EnemyTargetsInSphereSelection(pos, casterData, radius);
        //remove duplicates
        var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray();
        if (targetCleared.Length == 0)
        {
            //Debug.Log($"{ClassName} No targets in sphere.");
            return;
        }
        else
        {
            _buff.Activate(casterData, targetCleared, BASE_DURATION, damage);
            //Debug.Log($"[{ClassName}] Buff activated for {targetCleared.Length} targets.");
        }
    }

    private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster)
    {
        vDamage damage;
        casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null,
            CalculateTickDamage(caster.StatsController));
        damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE);
        return damage;
    }

    protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if (targetComps == null)
        {
            Debug.LogError($"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        Vector3 pos = targetComps.HealthController.transform.position;
        GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity);
        VisualEffect vfxGraph = effect.GetComponent<VisualEffect>();
        float cloudCurrentSize = vfxGraph.GetFloat("SmokeSize");
        float timeElapsed = 0f;
        while (timeElapsed < TIME_TO_REACH_END_SIZE)
        {
            cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE);
            vfxGraph.SetFloat("SmokeSize", cloudCurrentSize);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        Destroy(effect, timeout);
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController);
        string mainEdited = DESCRIPTION.Replace("[damage]", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\PoisonNova.cs:
 using System.Collections;
using System.Linq;
using _ZombieRoyale.Scripts.Core;
using FishNet.Object;
using Invector;
using UnityEngine;
using SingletonsExtension;
using UnityEngine.VFX;

public class PoisonNova : Ability
{
    public static readonly float NOVA_RADIUS = 3.6f;
    private static readonly float POISON_FIELD_DURATION = 10f;
    private readonly float SMOKE_END_SIZE = 20f;
    private readonly float TIME_TO_REACH_END_SIZE = 1f;
    private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.POWER;
    private readonly float BASE_DAMAGE_PER_TICK = .018890456f;
    private readonly float BASE_DURATION = 5f;
    private const string DESCRIPTION = "Unleashes a wave of toxic energy, poisoning all enemies in its radius upon activation. The poison inflicts [damage] damage over time.";
    private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison;
    [SerializeField] private NetworkObject networkedParticleSystem;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private float GetPoisonFeildDuration()
    {
        return POISON_FIELD_DURATION;
    }    
    private float CalculateTickDamage(FNStatsController statsController)
    {
        return BASE_DAMAGE_PER_TICK * statsController.GetStatByType(AFFECTING_STAT).CurrentAmount;
    }

    public override IEnumerator Activate(AbilityCastingData data)
    {
        var casterComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);
        int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition);
        var healthController = casterComps.HealthController;
        NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity);
        Spawn(nps);
        RpcShowEffectForObservers(data.casterNetId, abilityId, _rank, GetPoisonFeildDuration());

        Debug.Log($"{ClassName} Activated for unit #{data.casterNetId} with abilityId #{abilityId} and rank {data.rank}");
        float currentDuration = 0f;
        float tickTime = 1f;
        float radius = 1f;
        Buff.BuffData casterData = new Buff.BuffData(data.casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, 
            CalculateTickDamage(casterComps.StatsController));

        vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE);
        Vector3 poisonCloudPos = healthController.transform.position;
        while (currentDuration < GetPoisonFeildDuration())
        {
            currentDuration += tickTime;
            InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS);
            yield return new WaitForSeconds(tickTime);
        }
        Despawn(nps);
    }
    
    
    [Server]
    private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius)
    {
        DrawDebugSphere(pos, radius);
        var caster = UnitComponentsManager.GetUnitComponentsServerAndClient(casterData.ObjectId);
        if (caster != null)
        {
            damage = UpdateDamage(ref casterData, caster);
        }
        var targets = EnemyTargetsInSphereSelection(pos, casterData, radius);
        //remove duplicates
        var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray();
        if (targetCleared.Length == 0)
        {
            //Debug.Log($"{ClassName} No targets in sphere.");
            return;
        }
        else
        {
            _buff.Activate(casterData, targetCleared, BASE_DURATION, damage);
            //Debug.Log($"[{ClassName}] Buff activated for {targetCleared.Length} targets.");
        }
    }

    private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster)
    {
        vDamage damage;
        casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null,
            CalculateTickDamage(caster.StatsController));
        damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE);
        return damage;
    }

    protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout)
    {
        Debug.Log($"{_abilityName} Showing effect on target.");

        var targetComps = UnitComponentsManager.GetUnitComponentsServerAndClient(targetNetId);

        if (targetComps == null)
        {
            Debug.LogError($"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.");
            yield break;
        }

        Vector3 pos = targetComps.HealthController.transform.position;
        GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity);
        VisualEffect vfxGraph = effect.GetComponent<VisualEffect>();
        float cloudCurrentSize = vfxGraph.GetFloat("SmokeSize");
        float timeElapsed = 0f;
        while (timeElapsed < TIME_TO_REACH_END_SIZE)
        {
            cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE);
            vfxGraph.SetFloat("SmokeSize", cloudCurrentSize);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        Destroy(effect, timeout);
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        float damage = CalculateTickDamage(statsController);
        string mainEdited = DESCRIPTION.Replace("[damage]", $"<color={COLOR_DAMAGE}>{damage.ToString("F2")}</color>");
        mainEdited += I2.Loc.LocalizationManager.GetTermTranslation("Affecting stat") + $": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>";

        return $"{mainEdited}";
    }
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Blink.cs:
 using System.Collections;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

public class Blink : Ability
{
    private static float BLINK_DISTANCE = 6.0f;

    public override IEnumerator Activate(AbilityCastingData data) 
    {
        Debug.Log("Blink ability activated.");

        var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if(unitComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = unitComps.HealthController.Owner;
        TargetBlinkForward(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetBlinkForward(NetworkConnection conn, int casterNetId) 
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("[Blink][TargetBlinkForward]");

        RaycastHit hit;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;
        
        //get desired position with same y + forward + distance
        var lookRotation = Quaternion.LookRotation(hero.forward);
        sb.Append($" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}");
        Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f);
        sb.Append($" rotationNormalized: {rotationNormalized}; ");
        
        Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE;
        sb.Append($" destination: {destination}; ");

        var defaultLayerMask = LayerMask.GetMask("Default");
        if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask))
        {
            destination = hero.position + hero.forward * (hit.distance-.5f);
        }

        // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) 
        // {
        //     destination = hit.point;
        //     destination.y += .5f;
        // }
        destination.y += .2f;
        if (hit.transform != null)
        {
            sb.Append($" hit: {hit.transform}, hit pos: {hit.transform.position}; ");
        }
        sb.Append($"result destination: {destination}, after pos: {transform.position}");
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        Vector3 oldPos = hero.position;
        playerFim.OwnerTeleport(destination);
        BlinkForwardServerRpc(oldPos, destination);
        Vector3 middlePoint = (oldPos + destination) / 2;
    }

    [ServerRpc(RequireOwnership = false)]
    private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) 
    {
        Debug.Log("Blink forward on server.");
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        Debug.Log($"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}");
        SpawnEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalBlinkEffect(middlePoint, directionRotation);
    }
    
    private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        Debug.Log("Spawning blink effect.");

        var fx = _abilityDefinition.RanksDatas[0].hitEffect;

        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation);
            Destroy(fxInstance, 1.5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        string mainEdited = _abilityDefinition.mainDescription;
        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityScripts\Blink.cs:
 using System.Collections;
using System.Text;
using _ZombieRoyale.Scripts.Core;
using DungeonScrollerCore;
using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill;
using FishNet.Connection;
using FishNet.Object;
using FishnetInvector;
using UnityEngine;

public class Blink : Ability
{
    private static float BLINK_DISTANCE = 6.0f;

    public override IEnumerator Activate(AbilityCastingData data) 
    {
        Debug.Log("Blink ability activated.");

        var unitComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if(unitComps == null)
        {
            Debug.LogError("Failed to retrieve Unit Components.");
            yield break;
        }

        NetworkConnection conn = unitComps.HealthController.Owner;
        TargetBlinkForward(conn, data.casterNetId);
        yield return null;
    }

    [TargetRpc]
    private void TargetBlinkForward(NetworkConnection conn, int casterNetId) 
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("[Blink][TargetBlinkForward]");

        RaycastHit hit;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);
        FishnetInvectorManager playerFim = playerComps.InvectorManager;
        Transform hero = playerFim.transform;
        
        //get desired position with same y + forward + distance
        var lookRotation = Quaternion.LookRotation(hero.forward);
        sb.Append($" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}");
        Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f);
        sb.Append($" rotationNormalized: {rotationNormalized}; ");
        
        Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE;
        sb.Append($" destination: {destination}; ");

        var defaultLayerMask = LayerMask.GetMask("Default");
        if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask))
        {
            destination = hero.position + hero.forward * (hit.distance-.5f);
        }

        // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) 
        // {
        //     destination = hit.point;
        //     destination.y += .5f;
        // }
        destination.y += .2f;
        if (hit.transform != null)
        {
            sb.Append($" hit: {hit.transform}, hit pos: {hit.transform.position}; ");
        }
        sb.Append($"result destination: {destination}, after pos: {transform.position}");
        DebugWrite.Log($"{sb}", gameObject, _isDebug);
        Vector3 oldPos = hero.position;
        playerFim.OwnerTeleport(destination);
        BlinkForwardServerRpc(oldPos, destination);
        Vector3 middlePoint = (oldPos + destination) / 2;
    }

    [ServerRpc(RequireOwnership = false)]
    private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) 
    {
        Debug.Log("Blink forward on server.");
        var directionRotation = Quaternion.LookRotation(destination - oldPos);
        Vector3 middlePoint = (oldPos + destination) / 2;
        Debug.Log($"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}");
        SpawnEffectOnObservers(middlePoint, directionRotation);
    }

    [ObserversRpc(ExcludeOwner = true)]
    private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation)
    {
        InternalBlinkEffect(middlePoint, directionRotation);
    }
    
    private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation)
    {
        Debug.Log("Spawning blink effect.");

        var fx = _abilityDefinition.RanksDatas[0].hitEffect;

        if (fx != null)
        {
            GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation);
            Destroy(fxInstance, 1.5f);
        }
        else
        {
            Debug.LogError("Failed to retrieve hit effect.");
        }
    }

    public override string GetAbilityDescription(int rank, FNStatsController statsController)
    {
        string mainEdited = _abilityDefinition.mainDescription;
        return $"{mainEdited}";
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityManager.cs:
 using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using FishNet;
using FishNet.Managing.Timing;
using FishNet.Object;
using SingletonsExtension;
using UnityEngine;

public class AbilityManager : RoomManager 
{
    public static AbilityManager Instance { get; private set; }

    public static readonly float GLOBAL_COOLDOWN_TIME = 1.5f;
    [SerializeField] private Ability[] _abilities;
    public Buff[] Buffs => _buffs;
    [SerializeField] private Buff[] _buffs;
    [field:SerializeField] public bool IsInitialized { get; private set; }
    private Dictionary<int, Ability> _abilitiesDictionary = new Dictionary<int, Ability>();

    public void Init(bool asServer)
    {
        // Checking for other instances of AbilityManager.
        if (Instance != null)
        {
            Debug.LogWarning($"{ClassAndRoomName} There is more than one instance of AbilityManager in the scene.");
            return;
        }

        Instance = this;
        _abilities = GetComponents<Ability>();
        _buffs = GetComponents<Buff>();
        Debug.Log($"[AbilityManager] Ability Manager instantiated with " + _abilities.Length + " abilities.");

        // Initializing abilities.
        for (int i = 0; i < _abilities.Length; i++) 
        {
            int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilities[i].AbilityDefinition);

            if (abilityId > -1)
            {
                _abilitiesDictionary.Add(abilityId, _abilities[i]);
                _abilities[i].InitAbility();
                _abilities[i].OnRankLevelUp += GameplayManager.RewardAbilityManager.SetRankToAbility;
                Debug.Log($"{ClassAndRoomName} Initialized ability " + _abilities[i].AbilityDefinition.name + " with ID: " + abilityId);
            }
            else
            {
                Debug.LogWarning($"{ClassAndRoomName} Invalid ability ID: {abilityId}. Skipping ability initialization.");
            }
        }
        IsInitialized = true;
    }

    public BuffDefinition GetBuffDefinition(Buff.BuffType buffType)
    {
        for (int i = 0; i < _buffs.Length; i++)
        {
            if (_buffs[i].BuffDefinition.buffType == buffType)
            {
                return _buffs[i].BuffDefinition;
            }
        }
        return null;
    }

    public Ability GetAbility(int id)
    {
        for (int i = 0; i < _abilities.Length; i++)
        {
            if (_abilities[i].AbilityDefinition.Id == id)
            {
                return _abilities[i];
            }
        }
        return null;
    }
    
    [ServerRpc(RequireOwnership = false)]
    public void InitAbility(AbilityCastingData data)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if (!playerComps.AbilityController.IsEligibleToCast(data.abilityId)) 
        {
            Debug.Log($"{ClassAndRoomName} Player {data.casterNetId} is not eligible to cast ability {data.abilityId}.");
            return;
        }
        
        Ability ability = GetAbility(data.abilityId);
        float abilityCastingTime = ability.GetAbilityCastingTime(data.rank, playerComps.StatsController);
        bool isInstantCast = abilityCastingTime < float.Epsilon;
        if (isInstantCast)
        {
            playerComps.AbilityController.StartGlobalCooldown(GLOBAL_COOLDOWN_TIME);
        }
        
        Debug.Log($"{ClassAndRoomName} Initiating ability {data.abilityId} for player {data.casterNetId} with rank {data.rank}.");
        StartCoroutine(InitCooldown(data.casterNetId, data.abilityId, data.rank));
        StartCoroutine(_abilitiesDictionary[data.abilityId].Activate(data));
    }

    [Server]
    private IEnumerator InitCooldown(int casterNetId, int abilityId, int rank)
    {
        Ability ability = GetAbility(abilityId);
        AbilityDefinition abilityDefinition = ability.AbilityDefinition;
        float cooldown = abilityDefinition.RanksDatas[0].cooldown;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);

        FNAbilityController.CooldownData cooldownData = new FNAbilityController.CooldownData();
        cooldownData.IsOnCooldown = true;
        cooldownData.cooldownFinishTime = (float)InstanceFinder.TimeManager.TicksToTime(InstanceFinder.TimeManager.Tick) + cooldown;
        Debug.Log($"{ClassAndRoomName} Setting ability {abilityId} cooldown for player {casterNetId}; cooldownFinishTime: {cooldownData.cooldownFinishTime}.");
        playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData);

        yield return new WaitForSeconds(cooldown);

        Debug.Log($"{ClassAndRoomName} Resetting ability {abilityId} cooldown for player {casterNetId}.");
        cooldownData.IsOnCooldown = false;
        playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData);
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityManager.cs:
 using System.Collections;
using System.Collections.Generic;
using _ZombieRoyale.Scripts.Core;
using FishNet;
using FishNet.Managing.Timing;
using FishNet.Object;
using SingletonsExtension;
using UnityEngine;

public class AbilityManager : RoomManager 
{
    public static AbilityManager Instance { get; private set; }

    public static readonly float GLOBAL_COOLDOWN_TIME = 1.5f;
    [SerializeField] private Ability[] _abilities;
    public Buff[] Buffs => _buffs;
    [SerializeField] private Buff[] _buffs;
    [field:SerializeField] public bool IsInitialized { get; private set; }
    private Dictionary<int, Ability> _abilitiesDictionary = new Dictionary<int, Ability>();

    public void Init(bool asServer)
    {
        // Checking for other instances of AbilityManager.
        if (Instance != null)
        {
            Debug.LogWarning($"{ClassAndRoomName} There is more than one instance of AbilityManager in the scene.");
            return;
        }

        Instance = this;
        _abilities = GetComponents<Ability>();
        _buffs = GetComponents<Buff>();
        Debug.Log($"[AbilityManager] Ability Manager instantiated with " + _abilities.Length + " abilities.");

        // Initializing abilities.
        for (int i = 0; i < _abilities.Length; i++) 
        {
            int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilities[i].AbilityDefinition);

            if (abilityId > -1)
            {
                _abilitiesDictionary.Add(abilityId, _abilities[i]);
                _abilities[i].InitAbility();
                _abilities[i].OnRankLevelUp += GameplayManager.RewardAbilityManager.SetRankToAbility;
                Debug.Log($"{ClassAndRoomName} Initialized ability " + _abilities[i].AbilityDefinition.name + " with ID: " + abilityId);
            }
            else
            {
                Debug.LogWarning($"{ClassAndRoomName} Invalid ability ID: {abilityId}. Skipping ability initialization.");
            }
        }
        IsInitialized = true;
    }

    public BuffDefinition GetBuffDefinition(Buff.BuffType buffType)
    {
        for (int i = 0; i < _buffs.Length; i++)
        {
            if (_buffs[i].BuffDefinition.buffType == buffType)
            {
                return _buffs[i].BuffDefinition;
            }
        }
        return null;
    }

    public Ability GetAbility(int id)
    {
        for (int i = 0; i < _abilities.Length; i++)
        {
            if (_abilities[i].AbilityDefinition.Id == id)
            {
                return _abilities[i];
            }
        }
        return null;
    }
    
    [ServerRpc(RequireOwnership = false)]
    public void InitAbility(AbilityCastingData data)
    {
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(data.casterNetId);

        if (!playerComps.AbilityController.IsEligibleToCast(data.abilityId)) 
        {
            Debug.Log($"{ClassAndRoomName} Player {data.casterNetId} is not eligible to cast ability {data.abilityId}.");
            return;
        }
        
        Ability ability = GetAbility(data.abilityId);
        float abilityCastingTime = ability.GetAbilityCastingTime(data.rank, playerComps.StatsController);
        bool isInstantCast = abilityCastingTime < float.Epsilon;
        if (isInstantCast)
        {
            playerComps.AbilityController.StartGlobalCooldown(GLOBAL_COOLDOWN_TIME);
        }
        
        Debug.Log($"{ClassAndRoomName} Initiating ability {data.abilityId} for player {data.casterNetId} with rank {data.rank}.");
        StartCoroutine(InitCooldown(data.casterNetId, data.abilityId, data.rank));
        StartCoroutine(_abilitiesDictionary[data.abilityId].Activate(data));
    }

    [Server]
    private IEnumerator InitCooldown(int casterNetId, int abilityId, int rank)
    {
        Ability ability = GetAbility(abilityId);
        AbilityDefinition abilityDefinition = ability.AbilityDefinition;
        float cooldown = abilityDefinition.RanksDatas[0].cooldown;
        var playerComps = UnitComponentsManager.GetUnitComponentsServerAndClient(casterNetId);

        FNAbilityController.CooldownData cooldownData = new FNAbilityController.CooldownData();
        cooldownData.IsOnCooldown = true;
        cooldownData.cooldownFinishTime = (float)InstanceFinder.TimeManager.TicksToTime(InstanceFinder.TimeManager.Tick) + cooldown;
        Debug.Log($"{ClassAndRoomName} Setting ability {abilityId} cooldown for player {casterNetId}; cooldownFinishTime: {cooldownData.cooldownFinishTime}.");
        playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData);

        yield return new WaitForSeconds(cooldown);

        Debug.Log($"{ClassAndRoomName} Resetting ability {abilityId} cooldown for player {casterNetId}.");
        cooldownData.IsOnCooldown = false;
        playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData);
    }
}
 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityDefinition.cs:
 using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

[CreateAssetMenu(fileName = "New Ability", menuName = "ScriptableObjects/Ability")]
public class AbilityDefinition : ScriptableObject
{
    public byte Id => _id;
    
    [Header("-----BASE DATA-----")] 
    [SerializeField] private byte _id;
    [SerializeField] private string _name;
    [SerializeField] [TextArea(3, 10)] private string _description;
    [field:SerializeField, TextArea(2,10)] public string mainDescription { get; private set; }
    [field:SerializeField, TextArea(2,10)] public string questDescription { get; private set; }
    [field:SerializeField, TextArea(2,10)] public string persistDescription { get; private set; }
    [SerializeField] private Sprite _icon;
    [field:SerializeField] public int CastID { get; private set; }
    [SerializeField] private RPGAbilityRankData[] _ranksDatas;
    [SerializeField] private Ability ability;
    [field:SerializeField] public bool IsPassive { get; private set; }
    [field: SerializeField] public bool IsHide { get; private set; }
    public bool canBeUsedIfDead = false;

    public Ability AbilityInstance => ability;
    public RPGAbilityRankData[] RanksDatas => _ranksDatas;
    #region Accessors
    public string Name => _name;
    public string Description => _description;
    public Sprite Icon => _icon;
    #endregion
    
    public enum CastType
    {
        Stationary,
        Mobile
    }

    public enum AbilityType
    {
        Normal,
        PlayerAutoAttack,
        PlayerActionAbility
    }
    public enum TARGET_TYPES
    {
        SELF,
        CONE,
        AOE,
        LINEAR,
        PROJECTILE,
        SQUARE,
        GROUND,
        GROUND_LEAP,
        TARGET_PROJECTILE,
        TARGET_INSTANT
    }
    public enum ABILITY_TAGS
    {
        onHit,
        onKill,
        shapeshifting,
        stealth
    }


    public enum AbilityActivationType
    {
        Instant,
        Casted,
        Channeled,
        Charged,
        PreCastedCircle,
        PreCastedCone,
        PreCastedAim
    }
    
    public enum COST_TYPES
    {
        FLAT,
        PERCENT_OF_MAX,
        PERCENT_OF_CURRENT
    }
    
    [Serializable]
    public class RPGAbilityRankData
    {
        public CastType castType;
        public AbilityActivationType activationType;
        public float manaCost;
        public float castTime;
        public bool castInRun;
        public bool canBeUsedStunned;
        public bool cancelStealth = true;

        public TARGET_TYPES targetType;
        public float minRange;
        public float maxRange;
        
        public float projectileSpeed;
        public float projectileDistance;
        public float projectileAngleSpread;
        public int projectileCount = 1;
        public float firstProjectileDelay;
        public float projectileDelay;
        public float projectileDuration = 5;
        public float projectileComeBackTime;
        public float projectileComeBackSpeed;
        public bool isProjectileComeBack;
        public float projectileNearbyUnitDistanceMax;
        public float projectileNearbyUnitMaxHit;
        public bool isProjectileNearbyUnit;
        public bool projectileDestroyedByEnvironment = true;
        public LayerMask projectileDestroyLayers;
        public bool projectileAffectedByGravity;
        public bool projectileShootOnClickPosition;
        
        public bool CanHitPlayer, CanHitAlly, CanHitNeutral = true, CanHitEnemy = true, CanHitSelf, CanHitPet, CanHitOwner;

        public bool UsedOnALly;
        public GameObject projectileEffect;
        public GameObject groundVisualEffect;
        public GameObject hitEffect;

        public float channelTime;

        public bool isAttackSpeedCooldown;
        public bool isAttackSpeedGCD;
        public float cooldown;
        public bool isGCD;
        public bool startCDOnActivate = true;
        public bool CanUseDuringGCD;
        public bool isSharingCooldown;
        [HideInInspector] public string cooldownTag;

        public List<BuffDefinition> targetEffectsApplied = new List<BuffDefinition>();
        public List<float> targetEffectsAppliedDuration;
        public List<BuffDefinition> casterEffectsApplied = new List<BuffDefinition>();
        public List<float> casterEffectsAppliedDuration;
        
        public List<AttachmentPoints.Point> FXattachmentPoints = new List<AttachmentPoints.Point>();

    }

    public void SetId(byte id)
    {
        _id = id;
    }

    public string GetJsonRepresentation()
    {
        StringBuilder jsonBuilder = new StringBuilder();
        jsonBuilder.Append("{\n");
        if (IsPassive)
            jsonBuilder.AppendFormat("  \"Name\": \"{0}\"(Passive),\n", _name);
        else
            jsonBuilder.AppendFormat("  \"Name\": \"{0}\",\n", _name);
        jsonBuilder.AppendFormat("  \"Description\": \"{0}\",\n", mainDescription.ToString());
        jsonBuilder.AppendFormat("  \"QuestDescription\": \"{0}\",\n", questDescription.ToString());
        // Add other necessary fields in the same pattern
        jsonBuilder.Append("}");
        return jsonBuilder.ToString();
    }
} 

// Assets\-ZombieRoyale\Scripts\Abilities\AbilityDefinition.cs:
 using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

[CreateAssetMenu(fileName = "New Ability", menuName = "ScriptableObjects/Ability")]
public class AbilityDefinition : ScriptableObject
{
    public byte Id => _id;
    
    [Header("-----BASE DATA-----")] 
    [SerializeField] private byte _id;
    [SerializeField] private string _name;
    [SerializeField] [TextArea(3, 10)] private string _description;
    [field:SerializeField, TextArea(2,10)] public string mainDescription { get; private set; }
    [field:SerializeField, TextArea(2,10)] public string questDescription { get; private set; }
    [field:SerializeField, TextArea(2,10)] public string persistDescription { get; private set; }
    [SerializeField] private Sprite _icon;
    [field:SerializeField] public int CastID { get; private set; }
    [SerializeField] private RPGAbilityRankData[] _ranksDatas;
    [SerializeField] private Ability ability;
    [field:SerializeField] public bool IsPassive { get; private set; }
    [field: SerializeField] public bool IsHide { get; private set; }
    public bool canBeUsedIfDead = false;

    public Ability AbilityInstance => ability;
    public RPGAbilityRankData[] RanksDatas => _ranksDatas;
    #region Accessors
    public string Name => _name;
    public string Description => _description;
    public Sprite Icon => _icon;
    #endregion
    
    public enum CastType
    {
        Stationary,
        Mobile
    }

    public enum AbilityType
    {
        Normal,
        PlayerAutoAttack,
        PlayerActionAbility
    }
    public enum TARGET_TYPES
    {
        SELF,
        CONE,
        AOE,
        LINEAR,
        PROJECTILE,
        SQUARE,
        GROUND,
        GROUND_LEAP,
        TARGET_PROJECTILE,
        TARGET_INSTANT
    }
    public enum ABILITY_TAGS
    {
        onHit,
        onKill,
        shapeshifting,
        stealth
    }


    public enum AbilityActivationType
    {
        Instant,
        Casted,
        Channeled,
        Charged,
        PreCastedCircle,
        PreCastedCone,
        PreCastedAim
    }
    
    public enum COST_TYPES
    {
        FLAT,
        PERCENT_OF_MAX,
        PERCENT_OF_CURRENT
    }
    
    [Serializable]
    public class RPGAbilityRankData
    {
        public CastType castType;
        public AbilityActivationType activationType;
        public float manaCost;
        public float castTime;
        public bool castInRun;
        public bool canBeUsedStunned;
        public bool cancelStealth = true;

        public TARGET_TYPES targetType;
        public float minRange;
        public float maxRange;
        
        public float projectileSpeed;
        public float projectileDistance;
        public float projectileAngleSpread;
        public int projectileCount = 1;
        public float firstProjectileDelay;
        public float projectileDelay;
        public float projectileDuration = 5;
        public float projectileComeBackTime;
        public float projectileComeBackSpeed;
        public bool isProjectileComeBack;
        public float projectileNearbyUnitDistanceMax;
        public float projectileNearbyUnitMaxHit;
        public bool isProjectileNearbyUnit;
        public bool projectileDestroyedByEnvironment = true;
        public LayerMask projectileDestroyLayers;
        public bool projectileAffectedByGravity;
        public bool projectileShootOnClickPosition;
        
        public bool CanHitPlayer, CanHitAlly, CanHitNeutral = true, CanHitEnemy = true, CanHitSelf, CanHitPet, CanHitOwner;

        public bool UsedOnALly;
        public GameObject projectileEffect;
        public GameObject groundVisualEffect;
        public GameObject hitEffect;

        public float channelTime;

        public bool isAttackSpeedCooldown;
        public bool isAttackSpeedGCD;
        public float cooldown;
        public bool isGCD;
        public bool startCDOnActivate = true;
        public bool CanUseDuringGCD;
        public bool isSharingCooldown;
        [HideInInspector] public string cooldownTag;

        public List<BuffDefinition> targetEffectsApplied = new List<BuffDefinition>();
        public List<float> targetEffectsAppliedDuration;
        public List<BuffDefinition> casterEffectsApplied = new List<BuffDefinition>();
        public List<float> casterEffectsAppliedDuration;
        
        public List<AttachmentPoints.Point> FXattachmentPoints = new List<AttachmentPoints.Point>();

    }

    public void SetId(byte id)
    {
        _id = id;
    }

    public string GetJsonRepresentation()
    {
        StringBuilder jsonBuilder = new StringBuilder();
        jsonBuilder.Append("{\n");
        if (IsPassive)
            jsonBuilder.AppendFormat("  \"Name\": \"{0}\"(Passive),\n", _name);
        else
            jsonBuilder.AppendFormat("  \"Name\": \"{0}\",\n", _name);
        jsonBuilder.AppendFormat("  \"Description\": \"{0}\",\n", mainDescription.ToString());
        jsonBuilder.AppendFormat("  \"QuestDescription\": \"{0}\",\n", questDescription.ToString());
        // Add other necessary fields in the same pattern
        jsonBuilder.Append("}");
        return jsonBuilder.ToString();
    }
} 



# TASK: create new ability it will trigger when player will do sword attacking. When player will do swing a box collider will flow from player direction +1f in front will flow 10m and fade slowly, enemies that will stay further should receive lower damage in the end of it's path they should receive 0% damage, so ability should calculate this proportionally