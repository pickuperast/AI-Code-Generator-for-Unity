# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
include file path as first row for example(without quotes): "// Assets\-ZombieRoyale\Scripts\LLM AI\Personality\Personality.cs"
# CODE: // Assets\Sanat\CodeGenerator\ApiGemini\ApiGemini.cs:
 using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;

namespace Sanat.ApiGemini
{
    public static class Gemini
    {
        public static string BaseURL { get; set; } = "https://us-central1-aiplatform.googleapis.com/v1/";
        public static string BaseURL2 { get; set; } = "https://generativelanguage.googleapis.com/v1beta/models/";
        public const string PREFS_GEMINI_PROJECT_NAME = "GeminiProjectName";
        public static string TextToSpeechURL = "https://texttospeech.googleapis.com/v1/text:synthesize";
        public static string GetGeminiProjectName()
        {
            return PlayerPrefs.GetString(PREFS_GEMINI_PROJECT_NAME, "");
        }

        public static UnityWebRequestAsyncOperation SubmitChatAsync(
            string apiKey, 
            string model, 
            float temperature, 
            int maxTokens,
            List<ChatMessage> messages, 
            Action<string> callback)
        {
            var chatRequest = new ChatRequest(messages[0].content, temperature);
            string jsonData = JsonUtility.ToJson(chatRequest);
            string generatedUrl = $"{BaseURL2}{model}:generateContent?key={apiKey}";
            UnityWebRequest webRequest = CreateWebRequest(apiKey, generatedUrl, jsonData);

            UnityWebRequestAsyncOperation asyncOp = webRequest.SendWebRequest();
            asyncOp.completed += (op) =>
            {
                var success = webRequest.result == UnityWebRequest.Result.Success;
                var text = success ? webRequest.downloadHandler.text : string.Empty;
                if (!success) Debug.Log($"{webRequest.error} {apiKey}\n{webRequest.downloadHandler.text}");
                webRequest.Dispose();

                if (!string.IsNullOrEmpty(text))
                {
                    var responseData = JsonUtility.FromJson<ChatResponse>(text);
                    text = responseData.candidates[0].content.parts[0].text.Trim();
                    var tokensPrompt = responseData.usageMetadata.promptTokenCount;
                    var tokensCompletion = responseData.usageMetadata.candidatesTokenCount;
                    var tokensTotal = responseData.usageMetadata.totalTokenCount;

                    Debug.Log($"{model} Usage: prompt_tokens: {tokensPrompt}; completion_tokens: {tokensCompletion}; total_tokens: {tokensTotal}");
                }
                callback?.Invoke(text);
            };

            return asyncOp;
        }

        public static UnityWebRequest CreateWebRequest(string apiKey, string url, string jsonData)
        {
            byte[] postData = System.Text.Encoding.UTF8.GetBytes(jsonData);
            UnityWebRequest webRequest = new UnityWebRequest(url, "POST")
            {
                uploadHandler = new UploadHandlerRaw(postData),
                downloadHandler = new DownloadHandlerBuffer(),
                disposeUploadHandlerOnDispose = true,
                disposeDownloadHandlerOnDispose = true
            };
            webRequest.SetRequestHeader("Content-Type", "application/json");

            return webRequest;
        }

        public static void GenerateTextToSpeech(string text, string languageCode, string name, string ssmlGender, Action<AudioClip> callback)
        {
            var request = new TextToSpeechRequest(text, languageCode, name, ssmlGender);
            string jsonData = JsonUtility.ToJson(request);
            UnityWebRequest webRequest = CreateWebRequest(GetGeminiProjectName(), TextToSpeechURL, jsonData);

            UnityWebRequestAsyncOperation asyncOp = webRequest.SendWebRequest();
            asyncOp.completed += (op) =>
            {
                var success = webRequest.result == UnityWebRequest.Result.Success;
                if (!success)
                {
                    Debug.Log($"{webRequest.error} {GetGeminiProjectName()}\n{webRequest.downloadHandler.text}");
                    callback?.Invoke(null);
                    return;
                }
                
                var audioData = webRequest.downloadHandler.data;
                float[] floatData = ConvertByteToFloatArray(audioData);
                AudioClip audioClip = AudioClip.Create("TextToSpeech", floatData.Length, 1, 44100, false);
                audioClip.SetData(floatData, 0);
                callback?.Invoke(audioClip);
            };
        }

        private static float[] ConvertByteToFloatArray(byte[] byteArray)
        {
            int floatArrayLength = byteArray.Length / 4;
            float[] floatArray = new float[floatArrayLength];
            for (int i = 0; i < floatArrayLength; i++)
            {
                floatArray[i] = BitConverter.ToSingle(byteArray, i * 4);
            }
            return floatArray;
        }
    }

    [Serializable]
    public class TextToSpeechRequest
    {
        public Input input;
        public Voice voice;
        public AudioConfig audioConfig;

        public TextToSpeechRequest(string text, string languageCode, string name, string ssmlGender)
        {
            input = new Input { text = text };
            voice = new Voice { languageCode = languageCode, name = name, ssmlGender = ssmlGender };
            audioConfig = new AudioConfig { audioEncoding = "MP3" };
        }
    }

    [Serializable]
    public class Input
    {
        public string text;
    }

    [Serializable]
    public class Voice
    {
        public string languageCode;
        public string name;
        public string ssmlGender;
    }

    [Serializable]
    public class AudioConfig
    {
        public string audioEncoding;
    }

    [Serializable]
    public class ChatRequest
    {
        public Contents contents;
        public SafetySettings safety_settings;
        public GenerationConfig generation_config;

        public ChatRequest(string message, float temperature)
        {
            contents = new Contents
            {
                role = "user",
                parts = new Parts { text = message }
            };
            safety_settings = new SafetySettings
            {
                category = "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                threshold = "BLOCK_LOW_AND_ABOVE"
            };
            generation_config = new GenerationConfig
            {
                temperature = temperature,
                topP = 0.8f,
                topK = 40
            };
        }
    }

    [Serializable]
    public class Contents
    {
        public string role;
        public Parts parts;
    }

    [Serializable]
    public class Parts
    {
        public string text;
    }

    [Serializable]
    public class SafetySettings
    {
        public string category;
        public string threshold;
    }

    [Serializable]
    public class GenerationConfig
    {
        public float temperature;
        public float topP;
        public int topK;
    }

    [Serializable]
    public class ChatMessage
    {
        public string role;
        public string content;

        public ChatMessage(string role, string content)
        {
            this.role = role;
            this.content = content;
        }
    }

    [Serializable]
    public class ChatResponse
    {
        public List<Candidate> candidates;
        public UsageMetadata usageMetadata;
    }

    [Serializable]
    public class Candidate
    {
        public Content content;
        public string finishReason;
        public List<SafetyRating> safetyRatings;
    }

    [Serializable]
    public class Content
    {
        public List<Part> parts;
        public string role;
    }

    [Serializable]
    public class Part
    {
        public string text;
    }

    [Serializable]
    public class SafetyRating
    {
        public string category;
        public string probability;
    }

    [Serializable]
    public class UsageMetadata
    {
        public int promptTokenCount;
        public int candidatesTokenCount;
        public int totalTokenCount;
    }
}  



# TASK: insert this classes into gemini api for later usage: 
import { FunctionCallingMode } from "./enums";

/**
 * Structured representation of a function declaration as defined by the
 * [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included
 * in this declaration are the function name and parameters. This
 * FunctionDeclaration is a representation of a block of code that can be used
 * as a Tool by the model and executed by the client.
 * @public
 */
export declare interface FunctionDeclaration {
  /**
   * The name of the function to call. Must start with a letter or an
   * underscore. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with
   * a max length of 64.
   */
  name: string;
  /**
   * Optional. Description and purpose of the function. Model uses it to decide
   * how and whether to call the function.
   */
  description?: string;
  /**
   * Optional. Describes the parameters to this function in JSON Schema Object
   * format. Reflects the Open API 3.03 Parameter Object. string Key: the name
   * of the parameter. Parameter names are case sensitive. Schema Value: the
   * Schema defining the type used for the parameter. For function with no
   * parameters, this can be left unset.
   *
   * @example with 1 required and 1 optional parameter: type: OBJECT properties:
   * ```
   * param1:
   *
   *   type: STRING
   * param2:
   *
   *  type: INTEGER
   * required:
   *
   *   - param1
   * ```
   */
  parameters?: FunctionDeclarationSchema;
}

/**
 * A FunctionDeclarationsTool is a piece of code that enables the system to
 * interact with external systems to perform an action, or set of actions,
 * outside of knowledge and scope of the model.
 * @public
 */
export declare interface FunctionDeclarationsTool {
  /**
   * Optional. One or more function declarations
   * to be passed to the model along with the current user query. Model may
   * decide to call a subset of these functions by populating
   * [FunctionCall][content.part.functionCall] in the response. User should
   * provide a [FunctionResponse][content.part.functionResponse] for each
   * function call in the next turn. Based on the function responses, Model will
   * generate the final response back to the user. Maximum 64 function
   * declarations can be provided.
   */
  functionDeclarations?: FunctionDeclaration[];
}

/**
 * Contains the list of OpenAPI data types
 * as defined by https://swagger.io/docs/specification/data-models/data-types/
 * @public
 */
export enum FunctionDeclarationSchemaType {
  /** String type. */
  STRING = "STRING",
  /** Number type. */
  NUMBER = "NUMBER",
  /** Integer type. */
  INTEGER = "INTEGER",
  /** Boolean type. */
  BOOLEAN = "BOOLEAN",
  /** Array type. */
  ARRAY = "ARRAY",
  /** Object type. */
  OBJECT = "OBJECT",
}

/**
 * Schema is used to define the format of input/output data.
 * Represents a select subset of an OpenAPI 3.0 schema object.
 * More fields may be added in the future as needed.
 * @public
 */
export interface Schema {
  /**
   * Optional. The type of the property. {@link
   * FunctionDeclarationSchemaType}.
   */
  type?: FunctionDeclarationSchemaType;
  /** Optional. The format of the property. */
  format?: string;
  /** Optional. The description of the property. */
  description?: string;
  /** Optional. Whether the property is nullable. */
  nullable?: boolean;
  /** Optional. The items of the property. {@link FunctionDeclarationSchema} */
  items?: FunctionDeclarationSchema;
  /** Optional. The enum of the property. */
  enum?: string[];
  /** Optional. Map of {@link FunctionDeclarationSchema}. */
  properties?: { [k: string]: FunctionDeclarationSchema };
  /** Optional. Array of required property. */
  required?: string[];
  /** Optional. The example of the property. */
  example?: unknown;
}

/**
 * Schema for parameters passed to {@link FunctionDeclaration.parameters}.
 * @public
 */
export interface FunctionDeclarationSchema {
  /** The type of the parameter. */
  type: FunctionDeclarationSchemaType;
  /** The format of the parameter. */
  properties: { [k: string]: FunctionDeclarationSchemaProperty };
  /** Optional. Description of the parameter. */
  description?: string;
  /** Optional. Array of required parameters. */
  required?: string[];
}

/**
 * Schema for top-level function declaration
 * @public
 */
export interface FunctionDeclarationSchemaProperty extends Schema {}

/**
 * Schema passed to `GenerationConfig.responseSchema`
 * @public
 */
export interface ResponseSchema extends Schema {}

/**
 * Tool config. This config is shared for all tools provided in the request.
 * @public
 */
export interface ToolConfig {
  functionCallingConfig: FunctionCallingConfig;
}

/**
 * @public
 */
export interface FunctionCallingConfig {
  mode?: FunctionCallingMode;
  allowedFunctionNames?: string[];
}
