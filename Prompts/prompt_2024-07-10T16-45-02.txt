# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
# CODE: // Copyright (c) Sanat. All rights reserved.using UnityEngine;using UnityEditor;using System.Collections.Generic;using System.IO;using System.Linq;using System;using System.Text.RegularExpressions;using Sanat.CodeGenerator.Agents;using Sanat.CodeGenerator.Extensions;namespace Sanat.CodeGenerator {public class CodeGenerator : EditorWindow{ private List<string> selectedClassNames = new (); private Vector2 scrollPosition; private Dictionary<string, string> classToPath = new (); private string classNameInput = ""; private string generatedPrompt = ""; private string taskInput = ""; private float buttonAnimationTime = 1f; private float buttonAnimationProgress = 0f; private bool isButtonAnimating = false; private Color buttonColor = Color.green; private bool isSettingsVisible = false; private string geminiApiKey = ""; private string openaiApiKey = ""; private string antrophicApiKey = ""; private string groqApiKey = ""; public static string GeminiProjectName = ""; private bool _isAwaitingReply; private List<string> _ignoredFolders = new (); private bool isGeneratingCode = false; private float generationProgress = 0f; private float lastProgressUpdateTime = 0f; private float targetProgress = 0f; private float progressSpeed = 0.00001f; private const string PLUGIN_NAME = "<color=#FFD700>Code Generator</color> "; private const string PROMPTS_SAVE_FOLDER = "Sanat/CodeGenerator/Prompts"; public const string PREFS_GEMINI_PROJECT_NAME = "GeminiProjectName"; private List<IncludedFolder> includedFolders = new (); private const string INCLUDED_FOLDERS_PREFS_KEY = "IncludedFolders"; [System.Serializable] private class IncludedFolder { public string path; public bool isEnabled; } [MenuItem("Tools/Sanat/CodeGenerator")] public static void ShowWindow() { GetWindow<CodeGenerator>("Code Generator"); } private void OnGUI() { GUILayout.Space(10); EditorGUILayout.LabelField("Task Description", EditorStyles.boldLabel); taskInput = EditorGUILayout.TextArea(taskInput, GUILayout.Height(5 * EditorGUIUtility.singleLineHeight)); GUILayout.Space(20); if (isSettingsVisible) { DrawSettingsFields(); } EditorGUILayout.LabelField("Select Class Names:", EditorStyles.boldLabel); if (GUILayout.Button("Refresh Class List")) { RefreshClassList(); } string settingsButtonLabel = isSettingsVisible ? "Close Settings" : "Settings"; if (GUILayout.Button(settingsButtonLabel)) { isSettingsVisible = !isSettingsVisible; } EditorGUILayout.Space(); classNameInput = EditorGUILayout.TextField("Class Name", classNameInput); if (!string.IsNullOrEmpty(classNameInput)) { List<string> filteredSuggestions = new List<string>(); foreach (var kv in classToPath) { if (!kv.Key.StartsWith(classNameInput, StringComparison.CurrentCultureIgnoreCase)) continue; if (_ignoredFolders.Any(ignoredFolder => kv.Value.Contains(ignoredFolder))) continue; filteredSuggestions.Add(kv.Key); } string[] suggestions = filteredSuggestions.OrderBy(c => c).ToArray(); if (suggestions.Length > 0) { scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(200)); foreach (var suggestion in suggestions) { if (GUILayout.Button(suggestion)) { if (!selectedClassNames.Contains(suggestion)) { selectedClassNames.Add(suggestion); } classNameInput = ""; GUI.FocusControl(null); } } EditorGUILayout.EndScrollView(); } } EditorGUILayout.Space(); if (selectedClassNames.Count > 0) { if (GUILayout.Button("Clear all selected classes")) { selectedClassNames.Clear(); } GUILayout.Space(10); } if (selectedClassNames.Count > 4) { scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(200)); } for (int i = 0; i < selectedClassNames.Count; i++) { EditorGUILayout.BeginHorizontal(); if (GUILayout.Button("x", GUILayout.Width(40))) { selectedClassNames.RemoveAt(i); i--; continue; } EditorGUILayout.LabelField(selectedClassNames[i]); EditorGUILayout.EndHorizontal(); } if (selectedClassNames.Count > 4) { EditorGUILayout.EndScrollView(); } EditorGUILayout.Space(); EditorGUILayout.BeginHorizontal(); if (GUILayout.Button("Clear Prompt")) { generatedPrompt = ""; } GUI.backgroundColor = buttonColor; if (GUILayout.Button("Generate Prompt")) { ExecGeneratePrompt(); } if (isGeneratingCode) { Rect progressRect = GUILayoutUtility.GetRect(100, 20); EditorGUI.ProgressBar(progressRect, generationProgress, $"Generating... {generationProgress * 100:F0}%"); } else { if (GUILayout.Button("Generate Code")) { ExecGenerateCode(); } } GUI.backgroundColor = Color.white; EditorGUILayout.EndHorizontal(); if (!string.IsNullOrEmpty(generatedPrompt)) { GUILayout.Label("Generated Prompt:", EditorStyles.boldLabel); scrollPosition = GUILayout.BeginScrollView(scrollPosition, GUILayout.Height(Screen.height * 0.4f)); generatedPrompt = EditorGUILayout.TextArea(generatedPrompt, GUILayout.Height(20 * EditorGUIUtility.singleLineHeight)); GUILayout.EndScrollView(); } if (isButtonAnimating) { Repaint(); } } #region Generation private void ExecGeneratePrompt() { Dictionary<string, string> projectCode = new Dictionary<string, string>(); foreach (string className in selectedClassNames) { if (classToPath.TryGetValue(className, out string filePath)) { projectCode[filePath] = File.ReadAllText(filePath); } } GeneratePrompt(projectCode, 3); SavePromptToFile(); CopyPromptToClipboard(); StartButtonAnimation(); } private void ExecGenerateCode() { isGeneratingCode = true; generationProgress = 0f; targetProgress = .33f; lastProgressUpdateTime = (float)EditorApplication.timeSinceStartup; EditorApplication.update += UpdateProgressBar; Dictionary<string, string> projectCode = new Dictionary<string, string>(); foreach (string className in selectedClassNames) { if (classToPath.TryGetValue(className, out string filePath)) { projectCode[filePath] = File.ReadAllText(filePath); } } string[] projectCodePathes = projectCode.Keys.ToArray(); GeneratePrompt(projectCode); SavePromptToFile(); CopyPromptToClipboard(); StartButtonAnimation(); var includedCode = GenerateIncludedCode(projectCode, "", ref generatedPrompt); AbstractAgentHandler.ApiKeys apiKeys = new AbstractAgentHandler.ApiKeys(openaiApiKey, antrophicApiKey, groqApiKey, geminiApiKey); AbstractAgentHandler agentCodeArchitector = new AgentCodeArchitector(apiKeys, taskInput, includedCode); AbstractAgentHandler agentSolutionToDicts = new AgentSolutionToDict(apiKeys, projectCodePathes); AbstractAgentHandler agentCodeMerger = new AgentCodeMerger(apiKeys, projectCode); agentCodeArchitector.OnComplete += () => UpdateProgress(0.33f); agentSolutionToDicts.OnComplete += () => UpdateProgress(0.66f); agentCodeMerger.OnComplete += () => { UpdateProgress(1f); isGeneratingCode = false; Repaint(); }; agentCodeArchitector.SetNext(agentSolutionToDicts).SetNext(agentCodeMerger); agentCodeArchitector.Handle(""); } private string GeneratePrompt(Dictionary<string, string> projectCode, int rowsToRemove = 0) { string includedCode = ""; string includedCodeRaw = ""; includedCodeRaw = GenerateIncludedCode(projectCode, includedCodeRaw, ref includedCode); includedCode = Regex.Replace(includedCode, @"\s+", " ").Trim(); string clearedCodeScriptForLLM = includedCodeRaw; string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/Unity code architector.md"; string loadedPrompt = AbstractAgentHandler.LoadPrompt(promptLocation); string newPrompt = CodeGeneratorExtensions.RemoveLastNRows(loadedPrompt, rowsToRemove); string prompt = newPrompt + $"\n# CODE: {includedCode}\n\n# TASK: {taskInput}"; generatedPrompt = prompt; return clearedCodeScriptForLLM; } private string GenerateIncludedCode(Dictionary<string, string> projectCode, string includedCodeRaw, ref string includedCode) { foreach (var kvPathToCode in projectCode) { foreach (string className in selectedClassNames) { if (kvPathToCode.Key.Contains(className)) { includedCodeRaw += $"// {kvPathToCode.Key}:\n {kvPathToCode.Value} \n\n"; includedCode += File.ReadAllText(kvPathToCode.Key).Replace("\n", "").Replace("\r", "") + "\n\n"; } } } return includedCodeRaw; } #endregion #region Progress Bar private void UpdateProgress(float progress) { targetProgress = progress; if (progress >= 1f) { isGeneratingCode = false; EditorApplication.update -= UpdateProgressBar; Repaint(); } } private void UpdateProgressBar() { float currentTime = (float)EditorApplication.timeSinceStartup; if (currentTime - lastProgressUpdateTime >= 0.02f) { if (generationProgress < targetProgress) { generationProgress = Mathf.Min(generationProgress + progressSpeed, targetProgress); lastProgressUpdateTime = currentTime; Repaint(); } } } #endregion #region Settings private void DrawSettingsFields() { EditorGUILayout.BeginVertical(EditorStyles.helpBox); EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel); EditorGUILayout.BeginHorizontal(); InsertApiKeyRow("Gemini API Key", "GeminiApiKey", "https://aistudio.google.com/app/apikey", ref geminiApiKey); EditorGUILayout.EndHorizontal(); EditorGUILayout.BeginHorizontal(); InsertApiKeyRow("OpenAI API Key", "OpenaiApiKey", "https://platform.openai.com/api-keys", ref openaiApiKey); EditorGUILayout.EndHorizontal(); EditorGUILayout.BeginHorizontal(); InsertApiKeyRow("Groq API Key", "GroqApiKey", "https://console.groq.com/keys", ref groqApiKey); EditorGUILayout.EndHorizontal(); EditorGUILayout.BeginHorizontal(); InsertApiKeyRow("Antrophic API Key", "AntrophicApiKey", "https://console.anthropic.com/settings/keys", ref antrophicApiKey); EditorGUILayout.EndHorizontal(); EditorGUILayout.Space(); EditorGUILayout.LabelField("Ignored Folders:", EditorStyles.boldLabel); if (GUILayout.Button("Add Ignored Folder")) { _ignoredFolders.Add(""); } for (int i = 0; i < _ignoredFolders.Count; i++) { EditorGUILayout.BeginHorizontal(); _ignoredFolders[i] = EditorGUILayout.TextField("Folder Path (Ex.: Assets\\Test)", _ignoredFolders[i], GUILayout.ExpandWidth(true)); if (GUILayout.Button("x", GUILayout.Width(20))) { _ignoredFolders.RemoveAt(i); } EditorGUILayout.EndHorizontal(); } EditorGUILayout.BeginHorizontal(); EditorGUILayout.LabelField("Gemini Project Name", GUILayout.Width(150)); GeminiProjectName = EditorGUILayout.TextField(GeminiProjectName); PlayerPrefs.SetString("GeminiProjectName", GeminiProjectName); EditorGUILayout.EndHorizontal(); EditorGUILayout.Space(); EditorGUILayout.LabelField("Ignored Folders:", EditorStyles.boldLabel); EditorGUILayout.EndVertical(); PlayerPrefs.Save(); } #endregion private void InsertApiKeyRow(string fieldName, string playerPrefsKey, string url, ref string apiKeyVariable) { EditorGUILayout.LabelField(fieldName, GUILayout.Width(150)); apiKeyVariable = EditorGUILayout.PasswordField(apiKeyVariable); PlayerPrefs.SetString(playerPrefsKey, apiKeyVariable); if (GUILayout.Button("Get Key", GUILayout.Width(70))) { Application.OpenURL(url); } } private void RefreshClassList() { Debug.Log($"{PLUGIN_NAME}Refreshing class list..."); classToPath.Clear(); Debug.Log($"{PLUGIN_NAME}Current ignored folders count: {_ignoredFolders.Count}"); foreach (var ignoredFolder in _ignoredFolders) { Debug.Log($"{PLUGIN_NAME}Ignored folder path: {ignoredFolder}"); } string[] csFiles = Directory.GetFiles("Assets", "*.cs", SearchOption.AllDirectories) .Concat(Directory.GetFiles("Packages", "*.cs", SearchOption.AllDirectories)) .Where(filePath => !_ignoredFolders.Any(ignoredFolder => filePath.Contains(ignoredFolder))) .ToArray(); Debug.Log($"{PLUGIN_NAME}Found {csFiles.Length} .cs files."); foreach (string filePath in csFiles) { string className = Path.GetFileNameWithoutExtension(filePath); classToPath[className] = filePath; } Debug.Log($"{PLUGIN_NAME}Class to path dictionary populated with {classToPath.Count} entries."); } private void SavePromptToFile() { string directoryPath = Path.Combine(Application.dataPath, PROMPTS_SAVE_FOLDER); if (!Directory.Exists(directoryPath)) { Directory.CreateDirectory(directoryPath); } string fileName = $"prompt_{DateTime.Now:yyyy-MM-ddTHH-mm-ss}.txt"; string filePath = Path.Combine(directoryPath, fileName); File.WriteAllText(filePath, generatedPrompt); Debug.Log($"{PLUGIN_NAME}Prompt saved to {filePath}"); } private void CopyPromptToClipboard() { TextEditor te = new TextEditor(); te.text = generatedPrompt; te.SelectAll(); te.Copy(); } private void StartButtonAnimation() { isButtonAnimating = true; buttonAnimationProgress = 0f; buttonColor = Color.yellow; EditorApplication.update += UpdateButtonAnimation; } private void UpdateButtonAnimation() { buttonAnimationProgress += Time.deltaTime / buttonAnimationTime; buttonColor = Color.Lerp(Color.red, Color.green, Mathf.PingPong(buttonAnimationProgress * 2, 1)); if (buttonAnimationProgress >= 1f) { isButtonAnimating = false; EditorApplication.update -= UpdateButtonAnimation; } } private void OnEnable() { selectedClassNames = new List<string>(PlayerPrefs.GetString("SelectedClassNames", "").Split(',').Where(s => !string.IsNullOrEmpty(s))); geminiApiKey = PlayerPrefs.GetString("GeminiApiKey", ""); openaiApiKey = PlayerPrefs.GetString("OpenaiApiKey", ""); groqApiKey = PlayerPrefs.GetString("GroqApiKey", ""); antrophicApiKey = PlayerPrefs.GetString("AntrophicApiKey", ""); GeminiProjectName = PlayerPrefs.GetString(PREFS_GEMINI_PROJECT_NAME, ""); _ignoredFolders = PlayerPrefs.GetString("IgnoredFolders", "").Split(',').Where(s => !string.IsNullOrEmpty(s)).ToList(); isGeneratingCode = false; RefreshClassList(); CheckAndHandleFirstLaunch(); } private void OnDisable() { PlayerPrefs.SetString("SelectedClassNames", string.Join(",", selectedClassNames)); PlayerPrefs.SetString("GeminiApiKey", geminiApiKey); PlayerPrefs.SetString("GroqApiKey", groqApiKey); PlayerPrefs.SetString("OpenaiApiKey", openaiApiKey); PlayerPrefs.SetString("GeminiProjectName", GeminiProjectName); PlayerPrefs.SetString("IgnoredFolders", string.Join(",", _ignoredFolders)); PlayerPrefs.Save(); } private void CheckAndHandleFirstLaunch() { if (!IsFirstLaunch()) { return; } Debug.Log($"{PLUGIN_NAME}First launch detected. Adding prompt save folder to .gitignore and ignore.conf files."); string assetsParentPath = Directory.GetParent(Application.dataPath).FullName; string gitignorePath = Path.Combine(assetsParentPath, ".gitignore"); string ignoreConfPath = Path.Combine(assetsParentPath, "ignore.conf"); string folderPathToAdd = Environment.NewLine + "/Assets/" + PROMPTS_SAVE_FOLDER + Environment.NewLine; if (File.Exists(gitignorePath)) { File.AppendAllText(gitignorePath, folderPathToAdd); } if (File.Exists(ignoreConfPath)) { File.AppendAllText(ignoreConfPath, folderPathToAdd); } } private bool IsFirstLaunch() { const string key = "CODE_GENERATOR_FIRST_LAUNCH"; bool isFirstLaunch = PlayerPrefs.GetInt(key, 1) == 1; if (isFirstLaunch) { PlayerPrefs.SetInt(key, 0); PlayerPrefs.Save(); } return isFirstLaunch; }}} using System;using System.Linq;using System.Text.RegularExpressions;namespace Sanat.CodeGenerator.Extensions{ public static class CodeGeneratorExtensions { public static string RemoveLastNRows(string input, int n) { if (string.IsNullOrEmpty(input) || n <= 0) { return input; } string[] lines = input.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None); if (lines.Length <= n) { return string.Empty; } return string.Join(Environment.NewLine, lines.Take(lines.Length - n)); } public static string RemoveComments(string code) { var blockComments = @"/\*(.*?)\*/"; var lineComments = @"//.*?$"; var strings = @"""(?:\\.|[^""\\])*"""; var verbatimStrings = @"@""(?:""""|[^""])*"""; string noComments = Regex.Replace(code, blockComments + "|" + lineComments + "|" + strings + "|" + verbatimStrings, me => { if (me.Value.StartsWith("/*") || me.Value.StartsWith("//")) return me.Value.StartsWith("//") ? Environment.NewLine : ""; // Return the matched string literal unchanged return me.Value; }, RegexOptions.Multiline); return noComments; } }} using System;using System.Linq;using System.Text.RegularExpressions;namespace Sanat.CodeGenerator.Extensions{ public static class CodeGeneratorExtensions { public static string RemoveLastNRows(string input, int n) { if (string.IsNullOrEmpty(input) || n <= 0) { return input; } string[] lines = input.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None); if (lines.Length <= n) { return string.Empty; } return string.Join(Environment.NewLine, lines.Take(lines.Length - n)); } public static string RemoveComments(string code) { var blockComments = @"/\*(.*?)\*/"; var lineComments = @"//.*?$"; var strings = @"""(?:\\.|[^""\\])*"""; var verbatimStrings = @"@""(?:""""|[^""])*"""; string noComments = Regex.Replace(code, blockComments + "|" + lineComments + "|" + strings + "|" + verbatimStrings, me => { if (me.Value.StartsWith("/*") || me.Value.StartsWith("//")) return me.Value.StartsWith("//") ? Environment.NewLine : ""; // Return the matched string literal unchanged return me.Value; }, RegexOptions.Multiline); return noComments; } }}

# TASK: add logic in settings to be able to always include code from some folders list in some new field also near each folder add on/off box, also that list should be saved in player prefs, when user types fodler name it should automatically appear as recommended path, for this feature create new script file, that will be connected with CodeGenerator