# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
# CODE: // Assets\-ZombieRoyale\Scripts\Clients\MainMenuInventoryController.cs:
 using System;
using System.Collections.Generic;
using System.Linq;
using _ZombieRoyale.Scripts.Clients;
using DuloGames.UI;
using Invector.vItemManager;
using SingletonsExtension;
using UnityEngine;
using Object = UnityEngine.Object;
using Backend;

public class MainMenuInventoryController : MonoBehaviour
{
    [SerializeField] private UIItemSlot[] _slots;
    public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType());
    private string _className;

    private void Start()
    {
        RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded;
    }

    private void OnValidate()
    {
        CorrectSlotIds();
    }

    private void CorrectSlotIds()
    {
        for (int i = 0; i < _slots.Length; i++)
        {
            _slots[i].ID = i;
        }
    }

    private void InitSubscription()
    {
        for (int i = 0; i < _slots.Length; i++)
        {
            UIItemSlot currentSlot = _slots[i];
            int slotId = currentSlot.ID;
            currentSlot.onAssign.AddListener((currentSlot) => OnSlotAssigned(currentSlot, slotId));
            currentSlot.onAssignWithSource.AddListener((item, source) => OnSlotAssignedWithSource(currentSlot, item));
            currentSlot.onUnassign.AddListener(OnSlotUnassigned);
        }
    }

    private void OnSlotUnassigned(UIItemSlot slot)
    {
        Debug.Log($"{ClassName} OnSlotUnassigned() => {slot.ID}");
    }

    private void OnSlotAssignedWithSource(UIItemSlot currentSlot, Object source)
    {
        Debug.Log($"{ClassName} OnSlotAssignedWithSource() => {currentSlot.ID}; source: {source.name}");
    }
    
    private void OnSlotAssigned(UIItemSlot slot, int slotId)
    {
        Debug.Log($"{ClassName} OnSlotAssigned() => assigned itemId #{slot.ItemInfo.ID} to slotId #{slotId}");
        vItem item = MasterManager.Instance.ItemListData.GetItem(slot.ItemInfo.ID);
        if (BackendInventory.HasItem(item, slot.ItemInfo.Amount))
        {
            // Proceed with assignment
        }
        else
        {
            Debug.LogWarning($"Player doesn't have item {item.name} in sufficient quantity.");
            slot.Unassign();
        }
    }

    private List<UIItemSlot> GetNFreeSlot(int howMany)
    {
        List<UIItemSlot> freeSlots = new List<UIItemSlot>();
        for (int i = 0; i < _slots.Length; i++)
        {
            if (_slots[i].IsAssigned())
                continue;
            
            freeSlots.Add(_slots[i]);
            if (freeSlots.Count == howMany)
                break;
        }
        Debug.Log($"{ClassName} GetNFreeSlot({howMany}) => {freeSlots.Count} available free slots");
        return freeSlots;
    }

    private void OnCharacterLoaded(CharacterData charData)
    {
        if (charData.inventory_items == null)
        {
            Debug.Log($"{ClassName} OnCharacterLoaded() => charData.inventory_items is null");
            return;
        }
        List<UIItemSlot> freeSlots = GetNFreeSlot(charData.inventory_items.Length);

        foreach (var slotItem in charData.inventory_items)
        {
            int itemId = slotItem.itemId;
            vItem vItem = MasterManager.Instance.ItemListData.GetItem(itemId);
            UIItemInfo item = vItem.ToUIItemInfo();
            UIItemSlot slot = slotItem.slotId == -1 ? freeSlots.First() : _slots[slotItem.slotId];
            slot.Assign(item);
            Debug.Log($"{ClassName} OnCharacterLoaded() => Assigned {item.Name} to slot #{slot.ID}");
            freeSlots.Remove(slot);
        }

        InitSubscription();
    }
} 

// Assets\Bullet UI\Scripts\UI\Icon Slot System\UIItemSlot.cs:
 using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using System;
using System.Collections.Generic;
using System.Text;
using Invector.vItemManager;
using SingletonsExtension;
using TMPro;
using Object = UnityEngine.Object;

namespace DuloGames.UI
{
	[AddComponentMenu("UI/Icon Slots/Item Slot", 12)]
	public class UIItemSlot : UISlotBase, IUIItemSlot, IUISlotHasCooldown
    {
        [Serializable] public class OnRightClickEvent : UnityEvent<UIItemSlot> { }
        [Serializable] public class OnDoubleClickEvent : UnityEvent<UIItemSlot> { }
		[Serializable] public class OnAssignEvent : UnityEvent<UIItemSlot> { }
        [Serializable] public class OnAssignWithSourceEvent : UnityEvent<UIItemSlot, Object> { }
		[Serializable] public class OnUnassignEvent : UnityEvent<UIItemSlot> { }
		
		[SerializeField] private UIItemSlot_Group m_SlotGroup = UIItemSlot_Group.None;
		[SerializeField] private int m_ID = 0;
		[SerializeField] private TMProDecorator textAmount;
		public UISlotCooldown cooldownComponent
		{
			get { return this.m_Cooldown; }
		}
		private UISlotCooldown m_Cooldown;
		
		/// <summary>
		/// Gets or sets the slot group.
		/// </summary>
		/// <value>The slot group.</value>
		public UIItemSlot_Group slotGroup
		{
			get { return this.m_SlotGroup; }
			set { this.m_SlotGroup = value; }
		}
		
		/// <summary>
		/// Gets or sets the slot ID.
		/// </summary>
		/// <value>The I.</value>
		public int ID
		{
			get { return this.m_ID; }
			set { this.m_ID = value; }
		}
		
		public UIItemInfo ItemInfo => m_ItemInfo;
		/// <summary>
		/// The assigned item info.
		/// </summary>
		private UIItemInfo m_ItemInfo;

        /// <summary>
        /// The right click event delegate.
        /// </summary>
        public OnRightClickEvent onRightClick = new OnRightClickEvent();

        /// <summary>
        /// The double click event delegate.
        /// </summary>
        public OnDoubleClickEvent onDoubleClick = new OnDoubleClickEvent();

        /// <summary>
        /// The assign event delegate.
        /// </summary>
        public OnAssignEvent onAssign = new OnAssignEvent();

        /// <summary>
        /// The assign with source event delegate.
        /// </summary>
        public OnAssignWithSourceEvent onAssignWithSource = new OnAssignWithSourceEvent();

        /// <summary>
        /// The unassign event delegate.
        /// </summary>
        public OnUnassignEvent onUnassign = new OnUnassignEvent();
		
		/// <summary>
		/// Gets the item info of the item assigned to this slot.
		/// </summary>
		/// <returns>The spell info.</returns>
		public UIItemInfo GetItemInfo()
		{
			return this.m_ItemInfo;
		}

		/// <summary>
		/// Determines whether this slot is assigned.
		/// </summary>
		/// <returns><c>true</c> if this instance is assigned; otherwise, <c>false</c>.</returns>
		public override bool IsAssigned()
		{
			return (this.m_ItemInfo != null);
		}

        /// <summary>
        /// Assign the slot by new item info while refering to the source.
        /// </summary>
        /// <param name="itemInfo">The item info.</param>
        /// <param name="source">The source slot (Could be null).</param>
        /// <returns><c>true</c> if this instance is assigned; otherwise, <c>false</c>.</returns>
        public bool Assign(UIItemInfo itemInfo, Object source)
        {
            if (itemInfo == null)
                return false;

            // Make sure we unassign first, so the event is called before new assignment
            this.Unassign();
			
            StringBuilder sb = new StringBuilder($"[UIItemSlot] Assign: {itemInfo.Name}");
            // Use the base class assign to set the icon
            this.Assign(itemInfo.Icon);
            if (itemInfo.Amount > 1)
            {
	            sb.Append($" x{itemInfo.Amount}");
	            textAmount.SetText(itemInfo.Amount.ToString());
            }

            // Set the spell info
            this.m_ItemInfo = itemInfo;
			
            Debug.Log(sb.ToString(), gameObject);
            // Invoke the on assign event
            if (this.onAssign != null)
                this.onAssign.Invoke(this);

            // Invoke the on assign event
            if (this.onAssignWithSource != null)
                this.onAssignWithSource.Invoke(this, source);

            // Success
            return true;
        }

		/// <summary>
		/// Assign the slot by item info.
		/// </summary>
		/// <param name="itemInfo">The item info.</param>
		public bool Assign(UIItemInfo itemInfo)
		{
            return this.Assign(itemInfo, null);
		}
		
		/// <summary>
		/// Assign the slot by the passed source slot.
		/// </summary>
		/// <param name="source">Source.</param>
		public override bool Assign(Object source)
		{
			if (source is IUIItemSlot)
			{
                IUIItemSlot sourceSlot = source as IUIItemSlot;
				
				if (sourceSlot != null)
					return this.Assign(sourceSlot.GetItemInfo(), source);
			}
			
			// Default
			return false;
		}
		
		/// <summary>
		/// Unassign this slot.
		/// </summary>
		public override void Unassign()
		{
			// Remove the icon
			base.Unassign();
			
			// Clear the spell info
			this.m_ItemInfo = null;
			
			// Invoke the on unassign event
			if (this.onUnassign != null)
				this.onUnassign.Invoke(this);
		}
		
		/// <summary>
		/// Determines whether this slot can swap with the specified target slot.
		/// </summary>
		/// <returns><c>true</c> if this instance can swap with the specified target; otherwise, <c>false</c>.</returns>
		/// <param name="target">Target.</param>
		public override bool CanSwapWith(Object target)
		{
			if (target is IUIItemSlot)
			{
				// Check if the equip slot accpets this item
				if (target is UIEquipSlot)
				{
					return (target as UIEquipSlot).CheckEquipType(this.GetItemInfo());
				}
				
				// It's an item slot
				return true;
			}
			
			// Default
			return false;
		}
		
		// <summary>
		/// Performs a slot swap.
		/// </summary>
		/// <returns><c>true</c>, if slot swap was performed, <c>false</c> otherwise.</returns>
		/// <param name="sourceSlot">Source slot.</param>
		public override bool PerformSlotSwap(Object sourceObject)
		{
            // Get the source slot
            IUIItemSlot sourceSlot = (sourceObject as IUIItemSlot);
			
			// Get the source item info
			UIItemInfo sourceItemInfo = sourceSlot.GetItemInfo();

            // Assign the source slot by this slot
			bool assign1 = sourceSlot.Assign(this.GetItemInfo(), this);

			// Assign this slot by the source slot
			bool assign2 = this.Assign(sourceItemInfo, sourceObject);
			
			// Return the status
			return (assign1 && assign2);
		}
		
		/// <summary>
		/// Raises the tooltip event.
		/// </summary>
		/// <param name="show">If set to <c>true</c> show.</param>
		public override void OnTooltip(bool show)
		{
			// Make sure we have spell info, otherwise game might crash
			if (this.m_ItemInfo == null)
				return;
			
			// If we are showing the tooltip
			if (show)
			{
                UITooltip.InstantiateIfNecessary(this.gameObject);

                // Prepare the tooltip
                UIItemSlot.PrepareTooltip(this.m_ItemInfo);
				
				// Anchor to this slot
				UITooltip.AnchorToRect(this.transform as RectTransform);
				
				// Show the tooltip
				UITooltip.Show();
			}
			else
			{
				// Hide the tooltip
				UITooltip.Hide();
			}
		}

        /// <summary>
		/// Raises the pointer click event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
        public override void OnPointerClick(PointerEventData eventData)
        {
            base.OnPointerClick(eventData);

            // Make sure the slot is assigned
            if (!this.IsAssigned())
                return;

            // Check for left double click
            if (eventData.button == PointerEventData.InputButton.Left && eventData.clickCount == 2)
            {
                // Reset the click count
                eventData.clickCount = 0;

                // Invoke the double click event
                if (this.onDoubleClick != null)
                    this.onDoubleClick.Invoke(this);
            }

            // Check for right click
            if (eventData.button == PointerEventData.InputButton.Right)
            {
                // Invoke the double click event
                if (this.onRightClick != null)
                    this.onRightClick.Invoke(this);
            }
        }

        /// <summary>
		/// This method is raised when the slot is denied to be thrown away and returned to it's source.
		/// </summary>
        protected override void OnThrowAwayDenied()
        {
            if (!this.IsAssigned())
                return;

            if (UIModalBoxManager.Instance == null)
            {
                Debug.LogWarning("Could not load the modal box manager while creating a modal box.");
                return;
            }

            UIModalBox box = UIModalBoxManager.Instance.Create(this.gameObject);
            if (box != null)
            {
                box.SetText1("Do you really want to destroy \"" + this.m_ItemInfo.Name + "\"?");
                box.SetText2("You wont be able to reverse this operation and your item will be permamently removed.");
                box.SetConfirmButtonText("DESTROY");
                box.onConfirm.AddListener(Unassign);
                box.Show();
            }
        }
        
        /// <summary>
        /// Unassign this slot.
        /// </summary>
        public void UnassignNoEvent()
        {
	        // Remove the icon
	        base.Unassign();
			
	        // Clear the spell info
	        this.m_ItemInfo = null;
        }
        
        public UISpellInfo GetSpellInfo()
        {
	        return null;
	        //TODO: Implement this
	        //return this.m_SpellInfo;
        }
        
        public void SetCooldownComponent(UISlotCooldown cooldown)
        {
	        this.m_Cooldown = cooldown;
        }

        #region Static Methods
        /// <summary>
        /// Gets all the item slots.
        /// </summary>
        /// <returns>The slots.</returns>
        public static List<UIItemSlot> GetSlots()
		{
			List<UIItemSlot> slots = new List<UIItemSlot>();
			UIItemSlot[] sl = Resources.FindObjectsOfTypeAll<UIItemSlot>();
			
			foreach (UIItemSlot s in sl)
			{
				// Check if the slow is active in the hierarchy
				if (s.gameObject.activeInHierarchy)
					slots.Add(s);
			}
			
			return slots;
		}
		
		/// <summary>
		/// Gets all the item slots with the specified ID.
		/// </summary>
		/// <returns>The slots.</returns>
		/// <param name="ID">The slot ID.</param>
		public static List<UIItemSlot> GetSlotsWithID(int ID)
		{
			List<UIItemSlot> slots = new List<UIItemSlot>();
			UIItemSlot[] sl = Resources.FindObjectsOfTypeAll<UIItemSlot>();
			
			foreach (UIItemSlot s in sl)
			{
				// Check if the slow is active in the hierarchy
				if (s.gameObject.activeInHierarchy && s.ID == ID)
					slots.Add(s);
			}
			
			return slots;
		}
		
		/// <summary>
		/// Gets all the item slots in the specified group.
		/// </summary>
		/// <returns>The slots.</returns>
		/// <param name="group">The item slot group.</param>
		public static List<UIItemSlot> GetSlotsInGroup(UIItemSlot_Group group)
		{
			List<UIItemSlot> slots = new List<UIItemSlot>();
			UIItemSlot[] sl = Resources.FindObjectsOfTypeAll<UIItemSlot>();
			
			foreach (UIItemSlot s in sl)
			{
				// Check if the slow is active in the hierarchy
				if (s.gameObject.activeInHierarchy && s.slotGroup == group)
					slots.Add(s);
			}

            // Sort the slots by id
            slots.Sort(delegate (UIItemSlot a, UIItemSlot b)
            {
                return a.ID.CompareTo(b.ID);
            });

			return slots;
		}
		
		/// <summary>
		/// Gets the slot with the specified ID and Group.
		/// </summary>
		/// <returns>The slot.</returns>
		/// <param name="ID">The slot ID.</param>
		/// <param name="group">The slot Group.</param>
		public static UIItemSlot GetSlot(int ID, UIItemSlot_Group group)
		{
			UIItemSlot[] sl = Resources.FindObjectsOfTypeAll<UIItemSlot>();
			
			foreach (UIItemSlot s in sl)
			{
				// Check if the slow is active in the hierarchy
				if (s.gameObject.activeInHierarchy && s.ID == ID && s.slotGroup == group)
					return s;
			}
			
			return null;
		}

        /// <summary>
		/// Prepares the tooltip with the specified item info.
		/// </summary>
		/// <param name="itemInfo">Item info.</param>
		public static void PrepareTooltip(UIItemInfo itemInfo)
        {
            if (itemInfo == null)
                return;

            // Set the tooltip width
            if (UITooltipManager.Instance != null)
                UITooltip.SetWidth(UITooltipManager.Instance.itemTooltipWidth);

            // Set the title and description
            UITooltip.AddTitle("<color=#" + UIItemQualityColor.GetHexColor(itemInfo.Quality) + ">" + itemInfo.Name + "</color>");

            // Spacer
            UITooltip.AddSpacer();

            // Item types
            UITooltip.AddLineColumn(itemInfo.EquipType.ToString(), "ItemAttribute");
            UITooltip.AddLineColumn(itemInfo.Subtype, "ItemAttribute");

            if (itemInfo.ItemType == (int)vItemType.MeleeWeapon || itemInfo.ItemType == (int)vItemType.ShooterWeapon)
            {
                UITooltip.AddLineColumn(itemInfo.Damage.ToString() + " Damage", "ItemAttribute");
                UITooltip.AddLineColumn(itemInfo.AttackSpeed.ToString("0.0") + " Attack speed", "ItemAttribute");

                UITooltip.AddLine("(" + ((float)itemInfo.Damage / itemInfo.AttackSpeed).ToString("0.0") + " damage per second)", "ItemAttribute");
            }
            else if (itemInfo.ItemType == (int)vItemType.Armor)
            {
				if (itemInfo.Power > 0)
					UITooltip.AddLine(itemInfo.Power.ToString("F2") + " Power", "ItemAttribute");
				
				if (itemInfo.PhysicalArmorRating > 0)
					UITooltip.AddLine(itemInfo.PhysicalArmorRating.ToString("F2") + " Physical armor", "ItemAttribute");

				if (itemInfo.MagicalArmorRating > 0)
					UITooltip.AddLine(itemInfo.MagicalArmorRating.ToString("F2") + " Magical armor", "ItemAttribute");

				if (itemInfo.Block > 0)
					UITooltip.AddLineColumn(itemInfo.Block.ToString() + " Block", "ItemAttribute");
            }

            UITooltip.AddSpacer();
			DrawStats(itemInfo);
			UITooltip.AddSpacer();
			
			if (itemInfo.Durability > 0)
				UITooltip.AddLine("Durability " + itemInfo.Durability + "/" + itemInfo.Durability, "ItemAttribute");

            if (itemInfo.RequiredLevel > 0)
                UITooltip.AddLine("Requires Level " + itemInfo.RequiredLevel, "ItemAttribute");

            // Set the item description if not empty
            if (!string.IsNullOrEmpty(itemInfo.Description))
            {
                UITooltip.AddSpacer();
                UITooltip.AddLine(itemInfo.Description, "ItemDescription");
            }
        }
			
        private static void DrawStats(UIItemInfo itemInfo)
        {
			if (itemInfo.ConstitutionRating > 0)
				UITooltip.AddLine($"+{itemInfo.ConstitutionRating:F2} Constitution", "ItemStat");
			
			if (itemInfo.HealthRegenRating > 0)
		        UITooltip.AddLine($"+{itemInfo.HealthRegenRating:F2} Health regen", "ItemStat");

	        if (itemInfo.CriticalStrikeChanceRating > 0)
		        UITooltip.AddLine("+" + itemInfo.CriticalStrikeChanceRating.ToString("F2") + " Critical strike chance", "ItemStat");
	        
	        if (itemInfo.CriticalStrikePowerRating > 0)
		        UITooltip.AddLine("+" + itemInfo.CriticalStrikePowerRating.ToString("F2") + " Critical strike power", "ItemStat");
	        
	        if (itemInfo.MoveSpeedRating > 0)
		        UITooltip.AddLine("+" + itemInfo.MoveSpeedRating.ToString("F2") + " Move speed", "ItemStat");
	        
	        if (itemInfo.LeechRating > 0)
		        UITooltip.AddLine("+" + itemInfo.LeechRating.ToString("F2") + " Leech", "ItemStat");
	        
	        if (itemInfo.CooldownReductionRating > 0)
		        UITooltip.AddLine("+" + itemInfo.CooldownReductionRating.ToString("F2") + " Cooldown reduction", "ItemStat");
	        
	        if (itemInfo.HasteRating > 0)
		        UITooltip.AddLine("+" + itemInfo.HasteRating.ToString("F2") + " Haste", "ItemStat");
        }

        #endregion

        public void UpdateAmount(int itemAmount)
        {
	        if (itemAmount > 1)
	        {
		        textAmount.SetText(itemAmount.ToString());
	        }
	        else
	        {
		        textAmount.SetText("");
	        }
        }
    }
}
 

// Assets\Bullet UI\Scripts\UI\Icon Slot System\UISlotBase.cs:
 using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Collections;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace DuloGames.UI
{
	[AddComponentMenu("UI/Icon Slots/Base Slot"), ExecuteInEditMode, DisallowMultipleComponent]
	public class UISlotBase : UIBehaviour, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler, IPointerClickHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler {
		
		public enum Transition
		{
			None,
			ColorTint,
			SpriteSwap,
			Animation
		}
		
		public enum DragKeyModifier
		{
			None,
			Control,
			Alt,
			Shift
		}
		
		/// <summary>
		/// The current dragged object.
		/// </summary>
		protected GameObject m_CurrentDraggedObject;
		
		/// <summary>
		/// The current dragging plane.
		/// </summary>
		protected RectTransform m_CurrentDraggingPlane;
		
		/// <summary>
		/// The target icon graphic.
		/// </summary>
		public Graphic iconGraphic;

		[SerializeField] private GameObject m_EmptyIcon;
        [SerializeField, Tooltip("The game object that should be cloned on drag.")]
        private GameObject m_CloneTarget;

		[SerializeField, Tooltip("Should the drag and drop functionallty be enabled.")]
		private bool m_DragAndDropEnabled = true;

		[SerializeField, Tooltip("If set to static the slot won't be unassigned when drag and drop is preformed.")]
		private bool m_IsStatic = false;
		
		[SerializeField, Tooltip("Should the icon assigned to the slot be throwable.")]
		private bool m_AllowThrowAway = true;
		
		[SerializeField, Tooltip("The key which should be held down in order to begin the drag.")]
		private DragKeyModifier m_DragKeyModifier = DragKeyModifier.None;
		
		[SerializeField, Tooltip("Should the tooltip functionallty be enabled.")]
		private bool m_TooltipEnabled = true;
		
		[SerializeField, Tooltip("How long of a delay to expect before showing the tooltip.")]
		private float m_TooltipDelay = .1f;

		public Transition hoverTransition = Transition.None;
		public Graphic hoverTargetGraphic;
		public Color hoverNormalColor = Color.white;
		public Color hoverHighlightColor = Color.white;
		public float hoverTransitionDuration = 0.15f;
		public Sprite hoverOverrideSprite;
		public string hoverNormalTrigger = "Normal";
		public string hoverHighlightTrigger = "Highlighted";
		
		public Transition pressTransition = Transition.None;
		public Graphic pressTargetGraphic;
		public Color pressNormalColor = Color.white;
		public Color pressPressColor = new Color(0.6117f, 0.6117f, 0.6117f, 1f);
		public float pressTransitionDuration = 0.15f;
		public Sprite pressOverrideSprite;
		public string pressNormalTrigger = "Normal";
		public string pressPressTrigger = "Pressed";
		
		[SerializeField, Tooltip("Should the pressed state transition to normal state instantly.")]
		private bool m_PressTransitionInstaOut = true;
		
		[SerializeField, Tooltip("Should the pressed state force normal state transition on the hover target.")]
		private bool m_PressForceHoverNormal = true;
		
		private bool isPointerDown = false;
		private bool isPointerInside = false;
		private bool m_DragHasBegan = false;
		private bool m_DropPreformed = false;
		private bool m_IsTooltipShown = false;
		
		/// <summary>
		/// Gets or sets a value indicating whether this <see cref="UISlotBase"/> drag and drop is enabled.
		/// </summary>
		/// <value><c>true</c> if drag and drop enabled; otherwise, <c>false</c>.</value>
		public bool dragAndDropEnabled
		{
			get
			{
				return this.m_DragAndDropEnabled;
			}
			set
			{
				this.m_DragAndDropEnabled = value;
			}
		}
		
		/// <summary>
		/// Gets or sets a value indicating whether this <see cref="UISlotBase"/> is static.
		/// </summary>
		/// <value><c>true</c> if is static; otherwise, <c>false</c>.</value>
		public bool isStatic
		{
			get
			{
				return this.m_IsStatic;
			}
			set
			{
				this.m_IsStatic = value;
			}
		}
		
		/// <summary>
		/// Gets or sets a value indicating whether this <see cref="UISlotBase"/> can be throw away.
		/// </summary>
		/// <value><c>true</c> if allow throw away; otherwise, <c>false</c>.</value>
		public bool allowThrowAway
		{
			get
			{
				return this.m_AllowThrowAway;
			}
			set
			{
				this.m_AllowThrowAway = value;
			}
		}
		
		/// <summary>
		/// Gets or sets the drag key modifier.
		/// </summary>
		/// <value>The drag key modifier.</value>
		public DragKeyModifier dragKeyModifier
		{
			get
			{
				return this.m_DragKeyModifier;
			}
			set
			{
				this.m_DragKeyModifier = value;
			}
		}
		
		/// <summary>
		/// Gets or sets a value indicating whether this <see cref="UISlotBase"/> tooltip should be enabled.
		/// </summary>
		/// <value><c>true</c> if tooltip enabled; otherwise, <c>false</c>.</value>
		public bool tooltipEnabled
		{
			get
			{
				return this.m_TooltipEnabled;
			}
			set
			{
				this.m_TooltipEnabled = value;
			}
		}
		
		/// <summary>
		/// Gets or sets the tooltip delay.
		/// </summary>
		/// <value>The tooltip delay.</value>
		public float tooltipDelay
		{
			get
			{
				return this.m_TooltipDelay;
			}
			set
			{
				this.m_TooltipDelay = value;
			}
		}
		
		/// <summary>
		/// Gets or sets a value indicating whether this <see cref="UISlotBase"/> pressed state should transition out instantly.
		/// </summary>
		/// <value><c>true</c> if press transition insta out; otherwise, <c>false</c>.</value>
		public bool pressTransitionInstaOut
		{
			get
			{
				return this.m_PressTransitionInstaOut;
			}
			set
			{
				this.m_PressTransitionInstaOut = value;
			}
		}
		
		/// <summary>
		/// Gets or sets a value indicating whether this <see cref="UISlotBase"/> pressed state should force normal state transition on the hover target.
		/// </summary>
		/// <value><c>true</c> if press force hover normal; otherwise, <c>false</c>.</value>
		public bool pressForceHoverNormal
		{
			get
			{
				return this.m_PressForceHoverNormal;
			}
			set
			{
				this.m_PressForceHoverNormal = value;
			}
		}

		/// <summary>
		/// Gets or sets a value indicating whether this <see cref="UISlotBase"/> drop was preformed.
		/// </summary>
		/// <value><c>true</c> if drop preformed; otherwise, <c>false</c>.</value>
		public bool dropPreformed
		{
			get
			{
				return this.m_DropPreformed;
			}
			set
			{
				this.m_DropPreformed = value;
			}
		}
		
		protected override void Start()
		{
			// Check if the slot is not assigned but the icon graphic is active
			if (!this.IsAssigned() && this.iconGraphic != null && this.iconGraphic.gameObject.activeSelf)
			{
				// Disable the icon graphic object
				this.iconGraphic.gameObject.SetActive(false);
				if (m_EmptyIcon != null)
					m_EmptyIcon.SetActive(true);
			}		
		}
		
		protected override void OnEnable()
		{
			base.OnEnable();

			// Instant transition
			this.EvaluateAndTransitionHoveredState(true);
			this.EvaluateAndTransitionPressedState(true);
		}
		
		protected override void OnDisable()
		{
			base.OnDisable();
			
			this.isPointerInside = false;
			this.isPointerDown = false;
			
			// Instant transition
			this.EvaluateAndTransitionHoveredState(true);
			this.EvaluateAndTransitionPressedState(true);
		}
		
#if UNITY_EDITOR
		protected override void OnValidate()
		{
			this.hoverTransitionDuration = Mathf.Max(this.hoverTransitionDuration, 0f);
			this.pressTransitionDuration = Mathf.Max(this.pressTransitionDuration, 0f);
			
			if (this.isActiveAndEnabled)
			{
				this.DoSpriteSwap(this.hoverTargetGraphic, null);
				this.DoSpriteSwap(this.pressTargetGraphic, null);
				
				if (!EditorApplication.isPlayingOrWillChangePlaymode)
				{
					// Instant transition
					this.EvaluateAndTransitionHoveredState(true);
					this.EvaluateAndTransitionPressedState(true);
				}
				else
				{
					// Regular transition
					this.EvaluateAndTransitionHoveredState(false);
					this.EvaluateAndTransitionPressedState(false);
				}
			}
		}
#endif
		
		/// <summary>
		/// Raises the pointer enter event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnPointerEnter(PointerEventData eventData)
		{
			//Debug.Log($"[UISlotBase][OnPointerEnter] {gameObject.name}");
			this.isPointerInside = true;
			this.EvaluateAndTransitionHoveredState(false);
			
			// Check if tooltip is enabled
			if (this.enabled && this.IsActive() && this.m_TooltipEnabled)
			{
				// Start the tooltip delayed show coroutine
				// If delay is set at all
				if (this.m_TooltipDelay > 0f)
				{
					this.StartCoroutine("TooltipDelayedShow");
				}
				else
				{
					this.InternalShowTooltip();
				}
			}
		}
		
		/// <summary>
		/// Raises the pointer exit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnPointerExit(PointerEventData eventData)
		{
			//Debug.Log($"[UISlotBase][OnPointerExit] {gameObject.name}");
			this.isPointerInside = false;
			this.EvaluateAndTransitionHoveredState(false);
			this.InternalHideTooltip();
		}
		
		/// <summary>
		/// Raises the tooltip event.
		/// </summary>
		/// <param name="show">If set to <c>true</c> show.</param>
		public virtual void OnTooltip(bool show)
		{
		}
		
		/// <summary>
		/// Raises the pointer down event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnPointerDown(PointerEventData eventData)
		{
			this.isPointerDown = true;
			this.EvaluateAndTransitionPressedState(false);
			
			// Hide the tooltip
			this.InternalHideTooltip();
		}
		
		/// <summary>
		/// Raises the pointer up event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnPointerUp(PointerEventData eventData)
		{
			this.isPointerDown = false;
			this.EvaluateAndTransitionPressedState(this.m_PressTransitionInstaOut);
		}
		
		/// <summary>
		/// Raises the pointer click event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnPointerClick(PointerEventData eventData) { }
		
		/// <summary>
		/// Determines whether this slot is highlighted based on the specified eventData.
		/// </summary>
		/// <returns><c>true</c> if this instance is highlighted the specified eventData; otherwise, <c>false</c>.</returns>
		/// <param name="eventData">Event data.</param>
		protected bool IsHighlighted(BaseEventData eventData)
		{
			if (!this.IsActive())
				return false;

			if (eventData is PointerEventData)
			{
				PointerEventData pointerEventData = eventData as PointerEventData;
				return ((this.isPointerDown && !this.isPointerInside && pointerEventData.pointerPress == base.gameObject) || (!this.isPointerDown && this.isPointerInside && pointerEventData.pointerPress == base.gameObject) || (!this.isPointerDown && this.isPointerInside && pointerEventData.pointerPress == null));
			}
			
			return false;
		}
		
		/// <summary>
		/// Determines whether this slot is pressed based on the specified eventData.
		/// </summary>
		/// <returns><c>true</c> if this instance is pressed the specified eventData; otherwise, <c>false</c>.</returns>
		/// <param name="eventData">Event data.</param>
		protected bool IsPressed(BaseEventData eventData)
		{
			return this.IsActive() && this.isPointerInside && this.isPointerDown;
		}
		
		/// <summary>
		/// Evaluates and transitions the hovered state.
		/// </summary>
		/// <param name="instant">If set to <c>true</c> instant.</param>
		protected virtual void EvaluateAndTransitionHoveredState(bool instant)
		{
			if (!this.IsActive() || this.hoverTargetGraphic == null || !this.hoverTargetGraphic.gameObject.activeInHierarchy)
				return;
			
			// Determine what should the state of the hover target be
			bool highlighted = (this.m_PressForceHoverNormal ? (this.isPointerInside && !this.isPointerDown) : this.isPointerInside);
			
			// Do the transition
			switch (this.hoverTransition)
			{
				case Transition.ColorTint:
				{
					this.StartColorTween(this.hoverTargetGraphic, (highlighted ? this.hoverHighlightColor : this.hoverNormalColor), (instant ? 0f : this.hoverTransitionDuration));
					break;
				}
				case Transition.SpriteSwap:
				{
					this.DoSpriteSwap(this.hoverTargetGraphic, (highlighted ? this.hoverOverrideSprite : null));
					break;
				}
				case Transition.Animation:
				{
					this.TriggerHoverStateAnimation(highlighted ? this.hoverHighlightTrigger : this.hoverNormalTrigger);
					break;
				}
			}
		}
		
		/// <summary>
		/// Evaluates and transitions the pressed state.
		/// </summary>
		/// <param name="instant">If set to <c>true</c> instant.</param>
		protected virtual void EvaluateAndTransitionPressedState(bool instant)
		{
			if (!this.IsActive() || this.pressTargetGraphic == null || !this.pressTargetGraphic.gameObject.activeInHierarchy)
				return;
			
			// Do the transition
			switch (this.pressTransition)
			{
				case Transition.ColorTint:
				{
					this.StartColorTween(this.pressTargetGraphic, (this.isPointerDown ? this.pressPressColor : this.pressNormalColor), (instant ? 0f : this.pressTransitionDuration));
					break;
				}
				case Transition.SpriteSwap:
				{
					this.DoSpriteSwap(this.pressTargetGraphic, (this.isPointerDown ? this.pressOverrideSprite : null));
					break;
				}
				case Transition.Animation:
				{
					this.TriggerPressStateAnimation(this.isPointerDown ? this.pressPressTrigger : this.pressNormalTrigger);
					break;
				}
			}
			
			// If we should force normal state transition on the hover target
			if (this.m_PressForceHoverNormal)
				this.EvaluateAndTransitionHoveredState(false);
		}
		
		/// <summary>
		/// Starts a color tween.
		/// </summary>
		/// <param name="target">Target.</param>
		/// <param name="targetColor">Target color.</param>
		/// <param name="duration">Duration.</param>
		protected virtual void StartColorTween(Graphic target, Color targetColor, float duration)
		{
			if (target == null)
				return;
			
			target.CrossFadeColor(targetColor, duration, true, true);
		}
		
		/// <summary>
		/// Does a sprite swap.
		/// </summary>
		/// <param name="target">Target.</param>
		/// <param name="newSprite">New sprite.</param>
		protected virtual void DoSpriteSwap(Graphic target, Sprite newSprite)
		{
			if (target == null)
				return;
			
			Image image = target as Image;
			
			if (image == null)
				return;
			
			image.overrideSprite = newSprite;
		}
		
		/// <summary>
		/// Triggers the hover state animation.
		/// </summary>
		/// <param name="triggername">Triggername.</param>
		private void TriggerHoverStateAnimation(string triggername)
		{
			if (this.hoverTargetGraphic == null)
				return;
			
			// Get the animator on the target game object
			Animator animator = this.hoverTargetGraphic.gameObject.GetComponent<Animator>();
			
			if (animator == null || !animator.enabled || !animator.isActiveAndEnabled || animator.runtimeAnimatorController == null || !animator.hasBoundPlayables || string.IsNullOrEmpty(triggername))
				return;
			
			animator.ResetTrigger(this.hoverNormalTrigger);
			animator.ResetTrigger(this.hoverHighlightTrigger);
			animator.SetTrigger(triggername);
		}
		
		/// <summary>
		/// Triggers the pressed state animation.
		/// </summary>
		/// <param name="triggername">Triggername.</param>
		private void TriggerPressStateAnimation(string triggername)
		{
			if (this.pressTargetGraphic == null)
				return;
			
			// Get the animator on the target game object
			Animator animator = this.pressTargetGraphic.gameObject.GetComponent<Animator>();
			
			if (animator == null || !animator.enabled || !animator.isActiveAndEnabled || animator.runtimeAnimatorController == null || !animator.hasBoundPlayables || string.IsNullOrEmpty(triggername))
				return;
			
			animator.ResetTrigger(this.pressNormalTrigger);
			animator.ResetTrigger(this.pressPressTrigger);
			animator.SetTrigger(triggername);
		}
		
		/// <summary>
		/// Determines whether this slot is assigned.
		/// </summary>
		/// <returns><c>true</c> if this instance is assigned; otherwise, <c>false</c>.</returns>
		public virtual bool IsAssigned()
		{
			return (this.GetIconSprite() != null || this.GetIconTexture() != null);
		}
		
		/// <summary>
		/// Assign the specified slot by icon sprite.
		/// </summary>
		/// <param name="icon">Icon.</param>
		public bool Assign(Sprite icon)
		{
			if (icon == null)
				return false;
			
			// Set the icon
			this.SetIcon(icon);

			return true;
		}
		
		/// <summary>
		/// Assign the specified slot by icon texture.
		/// </summary>
		/// <param name="icon">Icon.</param>
		public bool Assign(Texture icon)
		{
			if (icon == null)
				return false;
			
			// Set the icon
			this.SetIcon(icon);

			return true;
		}
		
		/// <summary>
		/// Assign the specified slot by object.
		/// </summary>
		/// <param name="source">Source.</param>
		public virtual bool Assign(Object source)
		{
			if (source is UISlotBase)
			{
				UISlotBase sourceSlot = source as UISlotBase;
				
				if (sourceSlot != null)
				{
					// Assign by sprite or texture
					if (sourceSlot.GetIconSprite() != null)
					{
						return this.Assign(sourceSlot.GetIconSprite());
					}
					else if (sourceSlot.GetIconTexture() != null)
					{
						return this.Assign(sourceSlot.GetIconTexture());
					}
				}
			}
			
			return false;
		}
		
		/// <summary>
		/// Unassign this slot.
		/// </summary>
		public virtual void Unassign()
		{
			// Remove the icon
			this.ClearIcon();
		}
		
		/// <summary>
		/// Gets the icon sprite of this slot if it's set and the icon graphic is <see cref="UnityEngine.UI.Image"/>.
		/// </summary>
		/// <returns>The icon.</returns>
		public Sprite GetIconSprite()
		{	
			// Check if the icon graphic valid image
			if (this.iconGraphic == null || !(this.iconGraphic is Image))
				return null;

			return (this.iconGraphic as Image).sprite;
		}
		
		/// <summary>
		/// Gets the icon texture of this slot if it's set and the icon graphic is <see cref="UnityEngine.UI.RawImage"/>.
		/// </summary>
		/// <returns>The icon.</returns>
		public Texture GetIconTexture()
		{
			// Check if the icon graphic valid image
			if (this.iconGraphic == null || !(this.iconGraphic is RawImage))
				return null;
				
			return (this.iconGraphic as RawImage).texture;
		}
		
		/// <summary>
		/// Gets the icon as object.
		/// </summary>
		/// <returns>The icon as object.</returns>
		public Object GetIconAsObject()
		{
			if (this.iconGraphic == null)
				return null;
			
			if (this.iconGraphic is Image)
			{
				return this.GetIconSprite();
			}
			else if (this.iconGraphic is RawImage)
			{
				return this.GetIconTexture();
			}
			
			// Default
			return null;
		}
		
		/// <summary>
		/// Sets the icon of this slot.
		/// </summary>
		/// <param name="iconSprite">The icon sprite.</param>
		public void SetIcon(Sprite iconSprite)
		{
			// Check if the icon graphic valid image
			if (this.iconGraphic == null || !(this.iconGraphic is Image))
				return;
			
			// Set the sprite
			(this.iconGraphic as Image).sprite = iconSprite;
			
			// Enable or disabled the icon graphic game object
			if (iconSprite != null && !this.iconGraphic.gameObject.activeSelf) this.iconGraphic.gameObject.SetActive(true);
			if (iconSprite == null && this.iconGraphic.gameObject.activeSelf) this.iconGraphic.gameObject.SetActive(false);
		}
		
		/// <summary>
		/// Sets the icon of this slot.
		/// </summary>
		/// <param name="iconTex">The icon texture.</param>
		public void SetIcon(Texture iconTex)
		{
			// Check if the icon graphic valid raw image
			if (this.iconGraphic == null || !(this.iconGraphic is RawImage))
				return;
			
			// Set the sprite
			(this.iconGraphic as RawImage).texture = iconTex;
			if (m_EmptyIcon != null)
				m_EmptyIcon.SetActive(false);
			
			// Enable or disabled the icon graphic game object
			if (iconTex != null && !this.iconGraphic.gameObject.activeSelf) this.iconGraphic.gameObject.SetActive(true);
			if (iconTex == null && this.iconGraphic.gameObject.activeSelf) this.iconGraphic.gameObject.SetActive(false);
		}
		
		/// <summary>
		/// Clears the icon of this slot.
		/// </summary>
		public void ClearIcon()
		{
			// Check if the icon graphic valid
			if (this.iconGraphic == null)
				return;
			
			// In case of image
			if (this.iconGraphic is Image)
				(this.iconGraphic as Image).sprite = null;
			
			// In case of raw image
			if (this.iconGraphic is RawImage)
				(this.iconGraphic as RawImage).texture = null;
			
			if (m_EmptyIcon != null)
				m_EmptyIcon.SetActive(true);
			// Disable the game object
			this.iconGraphic.gameObject.SetActive(false);
		}
		
		/// <summary>
		/// Raises the begin drag event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnBeginDrag(PointerEventData eventData)
		{
			if (!this.enabled || !this.IsAssigned() || !this.m_DragAndDropEnabled)
			{
				eventData.Reset();
				return;
			}
			
			// Check if we have a key modifier and if it's held down
			if (!this.DragKeyModifierIsDown())
			{
				eventData.Reset();
				return;
			}
			
			// Start the drag
			this.m_DragHasBegan = true;

			// Create the temporary icon for dragging
			this.CreateTemporaryIcon(eventData);
				
			// Prevent event propagation
			eventData.Use();
		}
		
		/// <summary>
		/// Is the drag key modifier down.
		/// </summary>
		/// <returns><c>true</c>, if key modifier is down, <c>false</c> otherwise.</returns>
		public virtual bool DragKeyModifierIsDown()
		{
			switch (this.m_DragKeyModifier)
			{
				case DragKeyModifier.Control:
					return (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl));
				case DragKeyModifier.Alt:
					return (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt));
				case DragKeyModifier.Shift:
					return (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift));
			}
			
			// Default should be true
			return true;
		}
		
		/// <summary>
		/// Raises the drag event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnDrag(PointerEventData eventData)
		{
			// Check if the dragging has been started
			if (this.m_DragHasBegan)
			{
				// Update the dragged object's position
				if (this.m_CurrentDraggedObject != null)
					this.UpdateDraggedPosition(eventData);
			}
		}
		
		/// <summary>
		/// Raises the drop event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnDrop(PointerEventData eventData)
		{
			// Get the source slot
			UISlotBase source = (eventData.pointerPress != null) ? eventData.pointerPress.GetComponent<UISlotBase>() : null;
			
			// Make sure we have the source slot
			if (source == null || !source.IsAssigned() || !source.dragAndDropEnabled)
				return;
			
			// Notify the source that a drop was performed so it does not unassign
			source.dropPreformed = true;
			
			// Check if this slot is enabled and it's drag and drop feature is enabled
			if (!this.enabled || !this.m_DragAndDropEnabled)
				return;
			
			// Prepare a variable indicating whether the assign process was successful
			bool assignSuccess = false;
			
			// Normal empty slot assignment
			if (!this.IsAssigned())
			{
				// Assign the target slot with the info from the source
				assignSuccess = this.Assign(source);
				
				// Unassign the source on successful assignment and the source is not static
				if (assignSuccess && !source.isStatic)
					source.Unassign();
			}
			// The target slot is assigned
			else
			{
				// If the target slot is not static
				// and we have a source slot that is not static
				if (!this.isStatic && !source.isStatic)
				{
					// Check if we can swap
					if (this.CanSwapWith(source) && source.CanSwapWith(this))
					{
						// Swap the slots
						assignSuccess = source.PerformSlotSwap(this);
					}
				}
				// If the target slot is not static
				// and the source slot is a static one
				else if (!this.isStatic && source.isStatic)
				{
					assignSuccess = this.Assign(source);
				}
			}
			
			// If this slot failed to be assigned
			if (!assignSuccess)
			{
				this.OnAssignBySlotFailed(source);
			}
		}
		
		/// <summary>
		/// Raises the end drag event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnEndDrag(PointerEventData eventData)
		{
			// Check if a drag was initialized at all
			if (!this.m_DragHasBegan)
				return;
			
			// Reset the drag begin bool
			this.m_DragHasBegan = false;
			
			// Destroy the dragged icon object
			if (this.m_CurrentDraggedObject != null)
			{
				Destroy(this.m_CurrentDraggedObject);
			}
			
			// Reset the variables
			this.m_CurrentDraggedObject = null;
			this.m_CurrentDraggingPlane = null;
			
			// Check if we are returning the icon to the same slot
			// By checking if the slot is highlighted
			if (this.IsHighlighted(eventData))
				return;
			
			// Check if no drop was preformed
			if (!this.m_DropPreformed)
			{
				// Try to throw away the assigned content
				this.OnThrowAway();
			}
			else
			{
				// Reset the drop preformed variable
				this.m_DropPreformed = false;
			}
		}
		
		/// <summary>
		/// Determines whether this slot can swap with the specified target slot.
		/// </summary>
		/// <returns><c>true</c> if this instance can swap with the specified target; otherwise, <c>false</c>.</returns>
		/// <param name="target">Target.</param>
		public virtual bool CanSwapWith(Object target)
		{
			return (target is UISlotBase);
		}
		
		/// <summary>
		/// Performs a slot swap.
		/// </summary>
		/// <param name="targetObject">Target slot.</param>
		public virtual bool PerformSlotSwap(Object targetObject)
		{
			// Get the source slot
			UISlotBase targetSlot = (targetObject as UISlotBase);
			
			// Get the target slot icon
			Object targetIcon = targetSlot.GetIconAsObject();
			
			// Assign the target slot with this one
			bool assign1 = targetSlot.Assign(this);
			
			// Assign this slot by the target slot icon
			bool assign2 = this.Assign(targetIcon);
			
			// Return the status
			return (assign1 && assign2);
		}
		
		/// <summary>
		/// Called when the slot fails to assign by another slot.
		/// </summary>
		protected virtual void OnAssignBySlotFailed(Object source)
		{
			Debug.Log("UISlotBase (" + this.gameObject.name + ") failed to get assigned by (" + (source as UISlotBase).gameObject.name + ").");
		}
		
		/// <summary>
		/// This method is raised to confirm throwing away the slot.
		/// </summary>
		protected virtual void OnThrowAway()
		{
			// Check if throwing away is allowed
			if (this.m_AllowThrowAway)
			{
				// Throw away successful, unassign the slot
				this.Unassign();
			}
			else
			{
				// Throw away was denied
				this.OnThrowAwayDenied();
			}
		}
		
		/// <summary>
		/// This method is raised when the slot is denied to be thrown away and returned to it's source.
		/// </summary>
		protected virtual void OnThrowAwayDenied() { }

		/// <summary>
		/// Creates the temporary icon.
		/// </summary>
		/// <returns>The temporary icon.</returns>
		protected virtual void CreateTemporaryIcon(PointerEventData eventData)
		{
			Canvas canvas = UIUtility.FindInParents<Canvas>(this.gameObject);

			if (canvas == null || this.iconGraphic == null)
				return;

			// Create temporary panel
			GameObject iconObj = (GameObject)Instantiate((this.m_CloneTarget == null) ? this.iconGraphic.gameObject : this.m_CloneTarget);

			iconObj.transform.localScale = new Vector3(1f, 1f, 1f);
			iconObj.transform.SetParent(canvas.transform, false);
			iconObj.transform.SetAsLastSibling();
			(iconObj.transform as RectTransform).anchorMin = new Vector2(0.5f, 0.5f);
			(iconObj.transform as RectTransform).anchorMax = new Vector2(0.5f, 0.5f);
			(iconObj.transform as RectTransform).pivot = new Vector2(0.5f, 0.5f);
			(iconObj.transform as RectTransform).sizeDelta = new Vector2(84f, 84f);

			// The icon will be under the cursor.
			// We want it to be ignored by the event system.
			iconObj.AddComponent<UIIgnoreRaycast>();

			// Save the dragging plane
			this.m_CurrentDraggingPlane = canvas.transform as RectTransform;

			// Set as the current dragging object
			this.m_CurrentDraggedObject = iconObj;

			// Update the icon position
			this.UpdateDraggedPosition(eventData);
		}
		
		/// <summary>
		/// Updates the dragged icon position.
		/// </summary>
		/// <param name="data">Data.</param>
		private void UpdateDraggedPosition(PointerEventData data)
		{
			var rt = this.m_CurrentDraggedObject.GetComponent<RectTransform>();
			Vector3 globalMousePos;
			
			if (RectTransformUtility.ScreenPointToWorldPointInRectangle(this.m_CurrentDraggingPlane, data.position, data.pressEventCamera, out globalMousePos))
			{
				rt.position = globalMousePos;
				rt.rotation = this.m_CurrentDraggingPlane.rotation;
			}
		}
		
		/// <summary>
		/// Internal call for show tooltip.
		/// </summary>
		protected void InternalShowTooltip()
		{
			// Call the on tooltip only if it's currently not shown
			if (!this.m_IsTooltipShown)
			{
				this.m_IsTooltipShown = true;
				this.OnTooltip(true);
			}
		}
		
		/// <summary>
		/// Internal call for hide tooltip.
		/// </summary>
		protected void InternalHideTooltip()
		{
			// Cancel the delayed show coroutine
			this.StopCoroutine("TooltipDelayedShow");
			
			// Call the on tooltip only if it's currently shown
			if (this.m_IsTooltipShown)
			{
				this.m_IsTooltipShown = false;
				this.OnTooltip(false);
			}
		}
		
		protected IEnumerator TooltipDelayedShow()
		{
			yield return new WaitForSeconds(this.m_TooltipDelay);
			this.InternalShowTooltip();
		}
	}
}
 

// Assets\Bullet UI\Scripts\UI\Icon Slot System\Interfaces\IUIItemSlot.cs:
 using UnityEngine;
using Object = UnityEngine.Object;

namespace DuloGames.UI
{
    public interface IUIItemSlot
    {
        UIItemInfo GetItemInfo();
        bool Assign(UIItemInfo itemInfo, Object source);
        void Unassign();
    }
}
 

// Assets\Bullet UI\Scripts\UI\Icon Slot System\Interfaces\IUIItemSlot.cs:
 using UnityEngine;
using Object = UnityEngine.Object;

namespace DuloGames.UI
{
    public interface IUIItemSlot
    {
        UIItemInfo GetItemInfo();
        bool Assign(UIItemInfo itemInfo, Object source);
        void Unassign();
    }
}
 

// Assets\Bullet UI\Scripts\UI\Icon Slot System\Interfaces\IUISlotHasCooldown.cs:
 namespace DuloGames.UI
{
    using UnityEngine.Events;

    public interface IUISlotHasCooldown
    {
        UISpellInfo GetSpellInfo();
        UISlotCooldown cooldownComponent { get; }
        void SetCooldownComponent(UISlotCooldown cooldown);
    }
}
 

// Assets\-ZombieRoyale\Scripts\Clients\CharacterData.cs:
 using System;
using System.Collections.Generic;
using Backend;
using UnityEngine.Serialization;

namespace _ZombieRoyale.Scripts.Clients {
[Serializable]
public class CharacterData
{
	public int id;
	public int genderId;
	public int skinColorId;
	public int beardId;
	public int bodyArtId;
	public int faceId;
	public int hairId;
	public int hairColorId;
	public int xp;
	public int level;
	public int gold;
	public List<AbilityInfo> abiliyInfo;
	public int[] skill_ids;
	public BackendReadWrites.SlotItem[] bank_items;
	public BackendReadWrites.SlotItem[] inventory_items;
	public BackendReadWrites.SlotItem[] equipment_items;
	public Action<byte, uint> OnAbilityInfoUpdated;

	public CharacterSkinData GetSkinData()
	{
		CharacterSkinData skinData = new CharacterSkinData();
		skinData.Id = id;
		skinData.genderId = genderId;
		skinData.skinColorId = skinColorId;
		skinData.beardId = beardId;
		skinData.bodyArtId = bodyArtId;
		skinData.faceId = faceId;
		skinData.hairId = hairId;
		skinData.hairColorId = hairColorId;
		return skinData;
	}

	public int GetAbilityRank(byte abilityId)
	{
		if (abiliyInfo == null)
			return 0;
		
		for (int i = 0; i < abiliyInfo.Count; i++)
		{
			if (abiliyInfo[i].Id == abilityId)
			{
				return abiliyInfo[i].Rank;
			}
		}
		return 0;
	}
	
	public uint GetAbilityStacks(byte abilityId)
	{
		if (abiliyInfo == null)
			return 0;
		
		for (int i = 0; i < abiliyInfo.Count; i++)
		{
			if (abiliyInfo[i].Id == abilityId)
			{
				return abiliyInfo[i].Stacks;
			}
		}
		return 0;
	}
	
	public uint SetAbilityStacks(byte abilityId, uint stacks)
	{
		if (abiliyInfo == null)
		{
			abiliyInfo = new List<AbilityInfo>{new AbilityInfo(abilityId, 1, 0)};
		}
		
		for (int i = 0; i < abiliyInfo.Count; i++)
		{
			if (abiliyInfo[i].Id == abilityId)
			{
				abiliyInfo[i].Stacks = stacks;
				OnAbilityInfoUpdated?.Invoke(abilityId, stacks);
				return abiliyInfo[i].Stacks;
			}
		}

		abiliyInfo.Add(new AbilityInfo(abilityId, 1, stacks));
		OnAbilityInfoUpdated?.Invoke(abilityId, stacks);
		return 0;
	}
}
} 

// Assets\Invector-3rdPersonController\ItemManager\Scripts\vItem.cs:
 using System.Collections.Generic;
using DuloGames.UI;
using FishnetInvector;
using UnityEngine;
using UnityEngine.Serialization;

namespace Invector.vItemManager
{
    [System.Serializable]
    public partial class vItem : ScriptableObject
    {
        #region SerializedProperties in customEditor
        public string Name => name;
        public int id;
        public string description = "Item Description";
        public int Price;
        public vItemType type;
        //[System.NonSerialized] - causes icons not to be saved
        public Sprite icon;
        public bool stackable = true;
        public int maxStack;
        public int amount = 1;
        public GameObject originalObject;
        public GameObject dropObject;
        public List<vItemAttribute> attributes = new List<vItemAttribute>();
        public bool isInEquipArea;
        public bool isEquiped;
        public bool isArmorItem;
        public int ArmorId;
        public int durability;
        public Rarity rarity = Rarity.Trash;
        public AbilityDefinition[] ActiveAbilities;
        #endregion

        public vItem(vItem item)
        {
            name = item.name;
            id = item.id;
            description = item.description;
            type = item.type;
            icon = item.icon;
            stackable = item.stackable;
            maxStack = item.maxStack;
            amount = item.amount;
            originalObject = item.originalObject;
            dropObject = item.dropObject;
            attributes = item.attributes;
            isInEquipArea = item.isInEquipArea;
            isEquiped = item.isEquiped;
            isArmorItem = item.isArmorItem;
            ArmorId = item.ArmorId;
            durability = item.durability;
            rarity = item.rarity;
        }
        
        public enum EquipAreaNames { mainHand, offHand, helmet, amulet, shoulders, chest, wrist, elbow, gloves, belt, pants, boots, ring, potions, cape, empty}
        public enum Rarity {Trash, Common, Uncommon, Rare, Epic, Legendary, Mythic, Unique, Default}
        #region Properties in defaultInspector

        public bool destroyAfterUse = true;
        public bool canBeUsed = true;
        public bool canBeDroped = true;
        public bool canBeDestroyed = true;

        [Header("Animation Settings")]
        [vHelpBox("Triggers a animation when Equipping a Weapon or enabling item.\nYou can also trigger an animation if the ItemType is a Consumable")]
        public string EnableAnim = "LowBack";
        [vHelpBox("Triggers a animation when Unequipping a Weapon or disable item")]
        public string DisableAnim = "LowBack";
        [vHelpBox("Delay to enable the Weapon/Item object when Equipping\n If ItemType is a Consumable use this to delay the item usage.")]
        public float enableDelayTime = 0.5f;
        [vHelpBox("Delay to hide the Weapon/Item object when Unequipping")]
        public float disableDelayTime = 0.5f;
        [vHelpBox("If the item is equippable use this to set a custom handler to instantiate the SpawnObject")]
        public string customHandler;
        [vHelpBox("If the item is equippable and need to use two hand\n<color=yellow><b>This option makes it impossible to equip two items</b></color>")]
        public bool twoHandWeapon;
        public EquipAreaNames equipArea;
     
        [HideInInspector]
        public OnHandleItemEvent onDestroy;
        #endregion

        public ItemReference ToItemReference()
        {
            ItemReference itemReference = new ItemReference(id, amount, attributes);
            itemReference.amount = amount == 0 ? 1 : amount;
            itemReference.autoEquip = isEquiped;
            itemReference.addToEquipArea = isInEquipArea;
            return itemReference;
        }

        public void OnDestroy()
        {
            onDestroy.Invoke(this);
        }

        public bool IsItemHaveAbility(int id)
        {
            if (ActiveAbilities == null || ActiveAbilities.Length == 0) return false;
            return System.Array.Exists(ActiveAbilities, ability => ability.Id == id);
        }
        
        public string GetHolderAreaNameForBack()
        {
            switch (equipArea)
            {
                case EquipAreaNames.mainHand:
                    return "RightArmBack";
                case EquipAreaNames.offHand:
                    return "LeftArmBack";
            }

            Debug.LogError($"[vItem] GetHolderAreaNameForBack - equipArea: {equipArea} not found.");
            return "";
        }
        
        public string GetHolderAreaName()
        {
            switch (equipArea)
            {
                case EquipAreaNames.mainHand:
                    return "RightArm";
                case EquipAreaNames.offHand:
                    return "LeftArm";
            }

            Debug.LogError($"[vItem] GetHolderAreaName() - equipArea: {equipArea} not found.");
            return "";
        }

        /// <summary>
        /// Convert Sprite icon to texture
        /// </summary>
        public Texture2D iconTexture
        {
            get
            {
                if (!icon) return null;
                try
                {
                    if (icon.rect.width != icon.texture.width || icon.rect.height != icon.texture.height)
                    {
                        Texture2D newText = new Texture2D((int)icon.textureRect.width, (int)icon.textureRect.height);
                        newText.name = icon.name;
                        Color[] newColors = icon.texture.GetPixels((int)icon.textureRect.x, (int)icon.textureRect.y, (int)icon.textureRect.width, (int)icon.textureRect.height);
                        newText.SetPixels(newColors);
                        newText.Apply();
                        return newText;
                    }
                    else
                        return icon.texture;
                }
                catch
                {
                    Debug.LogWarning("Icon texture of the " + name + " is not Readable", icon.texture);
                    return icon.texture;
                }
            }
        }

        /// <summary>
        /// Get the Item Attribute via <seealso cref="vItemAttribute"/>
        /// </summary>
        /// <param name="attribute"></param>
        /// <returns></returns>
        public vItemAttribute GetItemAttribute(Stat.STAT_TYPE attribute)
        {
            if (attributes != null) return attributes.Find(_attribute => _attribute.StatType == attribute);
            return null;
        }

        public UIItemInfo ToUIItemInfo()
        {
            UIItemInfo uiItem = new UIItemInfo();
            uiItem.ID = id;
            uiItem.Amount = amount;
            uiItem.Name = name;
            uiItem.Icon = icon;
            uiItem.Description = description;
            uiItem.rarity = rarity;
            uiItem.equipArea = equipArea;
            uiItem.ItemType = (int)type;
            uiItem.Subtype = type.ToString();

            if (equipArea != EquipAreaNames.potions)
                uiItem.EquipType = GetEquipmentType();
            if (GetItemAttribute(Stat.STAT_TYPE.DAMAGE) != null)
                uiItem.Damage = (int)GetItemAttribute(Stat.STAT_TYPE.DAMAGE).value;
            if (GetItemAttribute(Stat.STAT_TYPE.POWER) != null)
                uiItem.Power = GetItemAttribute(Stat.STAT_TYPE.POWER).value;
            if (GetItemAttribute(Stat.STAT_TYPE.PHYSICAL_ARMOR_RATING) != null)
                uiItem.PhysicalArmorRating = GetItemAttribute(Stat.STAT_TYPE.PHYSICAL_ARMOR_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.MAGICAL_ARMOR_RATING) != null)
                uiItem.MagicalArmorRating = GetItemAttribute(Stat.STAT_TYPE.MAGICAL_ARMOR_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.CONSTITUTION_RATING) != null)
                uiItem.ConstitutionRating = GetItemAttribute(Stat.STAT_TYPE.CONSTITUTION_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.HEALTH_REGEN_RATING) != null)
                uiItem.HealthRegenRating = GetItemAttribute(Stat.STAT_TYPE.HEALTH_REGEN_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.CRITICAL_STRIKE_CHANCE_RATING) != null)
                uiItem.CriticalStrikeChanceRating = GetItemAttribute(Stat.STAT_TYPE.CRITICAL_STRIKE_CHANCE_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.CRITICAL_STRIKE_POWER_RATING) != null)
                uiItem.CriticalStrikePowerRating = GetItemAttribute(Stat.STAT_TYPE.CRITICAL_STRIKE_POWER_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.MOVE_SPEED_RATING) != null)
                uiItem.MoveSpeedRating = GetItemAttribute(Stat.STAT_TYPE.MOVE_SPEED_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.LEECH_RATING) != null)
                uiItem.LeechRating = GetItemAttribute(Stat.STAT_TYPE.LEECH_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.COOLDOWN_REDUCTION_RATING) != null)
                uiItem.CooldownReductionRating = GetItemAttribute(Stat.STAT_TYPE.COOLDOWN_REDUCTION_RATING).value;
            if (GetItemAttribute(Stat.STAT_TYPE.HASTE_RATING) != null)
                uiItem.HasteRating = GetItemAttribute(Stat.STAT_TYPE.HASTE_RATING).value;
            return uiItem;
        }

        /// <summary>
        /// Get the Item Attribute via string
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public vItemAttribute GetItemAttribute(string name)
        {
            if (attributes != null)
                return attributes.Find(attribute => attribute.StatType.ToString().Equals(name));
            return null;
        }

        /// <summary>
        /// Get Selected Item Attributes via <seealso cref="vItemAttribute"/> by ignoring the ones you don't want
        /// </summary>
        /// <param name="ignore"></param>
        /// <returns></returns>
        public string GetItemAttributesText(List<Stat.STAT_TYPE> ignore = null)
        {
            System.Text.StringBuilder text = new System.Text.StringBuilder();
            for (int i = 0; i < attributes.Count; i++)
            {
                if (attributes[i].value == 0) continue;
                if (ignore == null || !ignore.Contains(attributes[i].StatType))
                    text.AppendLine(GetItemAttributeText(i));
            }
            return text.ToString();
        }

        /// <summary>
        /// Get Item Attribute Text 
        /// </summary>
        /// <param name="i"></param>
        /// <returns></returns>
        protected string GetItemAttributeText(int i)
        {
            if (attributes.Count > 0 && i < attributes.Count)
            {
                if (attributes.Count > 0 && i < attributes.Count)
                {
                    return attributes[i].GetDisplayText();
                }
            }
            return string.Empty;
        }

        /// <summary>
        /// Get Item Attribut Text with a custom Format to display
        /// </summary>
        /// <param name="i"></param>
        /// <param name="customFormat"></param>
        /// <returns></returns>
        protected string GetItemAttributeText(int i, string customFormat)
        {
            if (attributes.Count > 0 && i < attributes.Count)
            {
                return attributes[i].GetDisplayText(customFormat);
            }
            return string.Empty;
        }

        /// <summary>
        /// Get Default Item type text  
        /// </summary>
        /// <returns></returns>
        public string ItemTypeText()
        {
            return ItemTypeText(type.DisplayFormat());
        }

        /// <summary>
        /// Get Custom Item type text
        /// </summary>
        /// <param name="format"> Custom format for text </param>
        /// <returns></returns>
        public string ItemTypeText(string format)
        {
            var _text = format;
            var value = type.ToString().InsertSpaceBeforeUpperCase().RemoveUnderline();
            if (string.IsNullOrEmpty(_text))
                return value;
            else if (_text.Contains("(NAME)")) _text.Replace("(NAME)", value);
            return _text;
        }

        /// <summary>
        /// Get Item Full Description text including item Name, Type, Description and Attributes
        /// </summary>
        /// <param name="format">Custom format</param>
        /// <param name="ignoreAttributes">Attributes to ignore</param>
        /// <returns></returns>
        public string GetFullItemDescription(string format = null, List<Stat.STAT_TYPE> ignoreAttributes = null)
        {
            string text = "";
            if (string.IsNullOrEmpty(format))
            {
                text += (name);
                text += "\n" + (ItemTypeText());
                text += "\n" + (description);
                text += "\n" + (GetItemAttributesText());
            }
            else
            {
                text = format;
                if (text.Contains("(NAME)")) text = text.Replace("(NAME)", name);
                if (text.Contains("(TYPE)")) text = text.Replace("(TYPE)", ItemTypeText());
                if (text.Contains("(DESC)")) text = text.Replace("(DESC)", description);
                if (text.Contains("(ATTR)")) text = text.Replace("(ATTR)", GetItemAttributesText(ignoreAttributes));
            }
            return text;
        }
		
        public FNvItemManager.ItemReferenceBackend ToItemReferenceBackend() {
            return new FNvItemManager.ItemReferenceBackend(this.id, this.amount, this.attributes, this.type);
        }
        
        public static string GetRarityHexColorCode(Rarity rarity) {
            switch (rarity) {
                case Rarity.Trash:
                    return "#9d9d9d";
                case Rarity.Default:
                    return "#808080";
                case Rarity.Common:
                    return "#FFFFFF";
                case Rarity.Uncommon:
                    return "#1eff00";
                case Rarity.Rare:
                    return "#0070dd";
                case Rarity.Epic:
                    return "#a335ee";
                case Rarity.Legendary:
                    return "#ff8000";
                case Rarity.Mythic:
                    return "#dd0000";
                case Rarity.Unique:
                    return "#3fc7eb";
                default:
                    return "#FFFFFF";
            }
        }

        public UIEquipmentType GetEquipmentType()
        {
            switch (equipArea)
            {
                case EquipAreaNames.helmet:
                    return UIEquipmentType.Head;
                case EquipAreaNames.amulet:
                    return UIEquipmentType.Necklace;
                case EquipAreaNames.shoulders:
                    return UIEquipmentType.Shoulders;
                case EquipAreaNames.chest:
                    return UIEquipmentType.Chest;
                case EquipAreaNames.ring:
                    return UIEquipmentType.Finger;           
                case EquipAreaNames.gloves:
                    return UIEquipmentType.Gloves;
                case EquipAreaNames.wrist:
                    return UIEquipmentType.Bracers;
                case EquipAreaNames.pants:
                    return UIEquipmentType.Pants;
                case EquipAreaNames.boots:
                    return UIEquipmentType.Boots;
                case EquipAreaNames.belt:
                    return UIEquipmentType.Belt;
                case EquipAreaNames.mainHand:
                    return UIEquipmentType.Weapon_MainHand;
                case EquipAreaNames.offHand:
                    return UIEquipmentType.Weapon_OffHand;
                case EquipAreaNames.empty:
                    return UIEquipmentType.None;
            }
            Debug.LogError($"[vItem] GetEquipmentType() - equipArea: {equipArea} not found.");
            return UIEquipmentType.None;
        }
        
        public static EquipAreaNames GetEquipAreaNames(UIEquipmentType type)
        {
            switch (type)
            {
                case UIEquipmentType.Head:
                    return EquipAreaNames.helmet;
                case UIEquipmentType.Necklace:
                    return EquipAreaNames.amulet;
                case UIEquipmentType.Shoulders:
                    return EquipAreaNames.shoulders;
                case UIEquipmentType.Chest:
                    return EquipAreaNames.chest;
                case UIEquipmentType.Finger:
                    return EquipAreaNames.ring;
                case UIEquipmentType.Gloves:
                    return EquipAreaNames.gloves;
                case UIEquipmentType.Bracers:
                    return EquipAreaNames.wrist;
                case UIEquipmentType.Pants:
                    return EquipAreaNames.pants;
                case UIEquipmentType.Boots:
                    return EquipAreaNames.boots;
                case UIEquipmentType.Belt:
                    return EquipAreaNames.belt;
                case UIEquipmentType.Weapon_MainHand:
                    return EquipAreaNames.mainHand;
                case UIEquipmentType.Weapon_OffHand:
                    return EquipAreaNames.offHand;
            }
            Debug.LogError($"[vItem] GetEquipAreaNames() - type: {type} not found.");
            return EquipAreaNames.potions;
        }
        
        public float GetAttributeValue(Stat.STAT_TYPE type)
        {
            foreach (var attribute in attributes)
            {
                if (attribute.StatType == type)
                {
                    return attribute.value;
                }
            }
            return 0;
        }
    }
} 

// Assets\-ZombieRoyale\Scripts\Backend\BackendReadWrites.cs:
 using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using _ZombieRoyale.Scripts.Clients;
using Newtonsoft.Json;
using Proyecto26;
using SingletonsExtension;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.Serialization;
using Debug = UnityEngine.Debug;

namespace Backend
{

public static class BackendReadWrites
{	
	#region open data

	public static readonly string BACKEND_URL = "http://127.0.0.1:3000/";//"https://astanagames.online/api/";
	private static readonly string GET_ABILITY_STACKS = "character/get_ability_stacks/";
	private static readonly string REGISTER_CHARACTER = "character/new-character";
	private static readonly string CHARACTER_GET_SKIN = "character/get_skin/";
	private static readonly string CHARACTER_GET_PLAYER_NAME = "character/get_player_name/";
	private static readonly string GET_CHARACTER = "character/0";
	private static readonly string GET_FIRST_CHARACTER = "character/server_get_first_character";
	private static readonly string CHANGE_EMAIL_PASSWORD = "player/change_email_password/";
	private static readonly string REGISTER_USER = "player/register/";
	private static readonly string LOGIN_USER = "auth/login/";
	private static readonly string GET_ALL_SERVERS = "server/get_all_servers";
	private static readonly string GET_AVAILABLE_SERVERS = "server/get_servers_by_version/";
	
#if UNITY_EDITOR || UNITY_SERVER || UNITY_STANDALONE_LINUX
	private static readonly string HATHORA_GET_ROOM_ID = "https://api.hathora.dev/rooms/v2/";//"https://api.hathora.dev/rooms/v2/app-60bc431b-e9b7-4139-845d-2b9899e026cd/list/";
	private static readonly string HATHORA_GET_CONNECTION_INFO = "https://api.hathora.dev/rooms/v2/";//"https://api.hathora.dev/rooms/v2/app-60bc431b-e9b7-4139-845d-2b9899e026cd/connectioninfo/";
	private static readonly string HATHORA_TOKEN = "_Chky51qPZz-q7wz7YPcPZZrEeI8UoayOhnkG2CsSZdXf";//"jlZ-xwlRF8_3BufxnI1MEwHr57Mgm4G-wN3WGXJ6RMWDu";
	private static readonly string SET_CHARACTER_ABILITY_STACKS = "character/set_ability_stacks/";
	private static readonly string ADD_CHARACTER_INVENTORY = "character/add_inventory";
	private static readonly string DELETE_CHARACTER_INVENTORY = "character/remove_inventory";
#endif
	private static string GetMyProcessID()
	{
		// Gets the current process
		var currentProcess = Process.GetCurrentProcess();
		// Returns the process ID as a string
		return currentProcess.Id.ToString();
	}
	public static Action<CharacterSkinData> OnCharacterCreated;

	#endregion
		
	#region closed data

#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX
	private static readonly string SAVE_USER_DATA_TO_BACKEND = "character/";
	private static readonly string POST_REGISTER_SERVER = "server/register_server";
	private static readonly string POST_UNREGISTER_SERVER = "server/unregister_server";
#endif
	#endregion

	public static void GetPlayerNameBasedOnCharacterId(int id, Action<string> callback)
	{
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{CHARACTER_GET_PLAYER_NAME}{id}"
		};
		DefaultGetRequest(requestHelper, (exception, response, body) => {
			if (exception != null)
			{
				Debug.LogError("Error geting character: " + exception.Message);
				return;
			}
			Debug.Log($"[BackendReadWrites] GetPlayerNameBasedOnCharacterId for id #{id}: {body}");
			callback?.Invoke(body);
		});
	}
	
	public static void GetCharacterSkin(int id, Action<CharacterSkinData> callback)
	{
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{CHARACTER_GET_SKIN}{id}"
		};
		CharacterSkinData skinData = new CharacterSkinData();
		DefaultGetRequest(requestHelper, (exception, response, body) => {
			if (exception != null)
			{
				Debug.LogError("Error geting character: " + exception.Message);
				return;
			}
			Debug.Log($"[BackendReadWrites] GetCharacterSkin for id #{id}: {body}");
			skinData = JsonConvert.DeserializeObject<CharacterSkinData>(body);
			Debug.Log($"[BackendReadWrites] GetCharacterSkin check class: {skinData.ToString()}");
			StringBuilder sb = new StringBuilder($"[BackendReadWrites] GetCharacterSkin for id #{id}: {skinData}");
			callback?.Invoke(skinData);
			if (skinData.Id == 0)
			{
				sb.Append($"Character not found");
				Debug.LogError(sb);
			}
			else
			{
				Debug.Log(sb);
			}
		});
	}

	public static void SetAbilityStacks(string token, AbilityInfo[] abilityInfos, Action<int> callback)
	{
#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX
		RequestHelper request = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{SET_CHARACTER_ABILITY_STACKS}",
			BodyString = JsonConvert.SerializeObject(abilityInfos),
			Headers = new Dictionary<string, string>()
			{
				["authorization"] = "Bearer " + token
			}
		};
		RestClient.Post(request).Then(response =>
			{
				int responseInt = int.Parse(response.Text);
				string result = responseInt > 0 ? "success" : "Character not found!";
				Debug.Log($"[BackendReadWrites.SetCharacterAbilityStacks] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}");
				callback?.Invoke(responseInt);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}");
				var requestException = new RequestException(error.Message);
			});
#endif
	}
	
	public static void AddInventory(CharacterDataDTO characterData, Action<int> callback)
	{
#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX
		string secretKey = "SanatMadina";//Environment.GetEnvironmentVariable
		characterData.serverKey = secretKey;
		//async addInventory(@Body() characterData: CharacterDataDTO, secretKey: string): Promise<number>
		RequestHelper request = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{ADD_CHARACTER_INVENTORY}",
			BodyString = JsonConvert.SerializeObject(characterData)
		};
		RestClient.Post(request).Then(response =>
			{
				int responseInt = int.Parse(response.Text);
				string result = responseInt > 0 ? "success" : "Character not found!";
				Debug.Log($"[BackendReadWrites.AddInventory] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}");
				callback?.Invoke(responseInt);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.AddInventory] {request.Uri} response error: {error.Message} {error.StackTrace}");
				var requestException = new RequestException(error.Message);
			});
#endif
	}
	
	public static void DeleteInventory(CharacterDataDTO characterData, Action<int> callback)
	{
#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX
		string secretKey = "SanatMadina";//Environment.GetEnvironmentVariable
		//async addInventory(@Body() characterData: CharacterDataDTO, secretKey: string): Promise<number>
		RequestHelper request = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{DELETE_CHARACTER_INVENTORY}",
			BodyString = JsonConvert.SerializeObject(characterData),
			Headers = new Dictionary<string, string>()
			{
				["authorization"] = "Bearer " + secretKey
			}
		};
		RestClient.Post(request).Then(response =>
			{
				int responseInt = int.Parse(response.Text);
				string result = responseInt > 0 ? "success" : "Character not found!";
				Debug.Log($"[BackendReadWrites.DeleteInventory] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}");
				callback?.Invoke(responseInt);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.DeleteInventory] {request.Uri} response error: {error.Message} {error.StackTrace}");
				var requestException = new RequestException(error.Message);
			});
#endif
	}
	
	public static void GetAbilityStacksForCharacter(int characterId, byte abilityId, Action<AbilityInfo> callback)
	{
		string url = $"{BACKEND_URL}{GET_ABILITY_STACKS}{characterId}/{abilityId}";
		Debug.Log($"[BackendReadWrites] GetAbilityStacksForCharacter {url} for character #{characterId} and ability #{abilityId}");
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{url}"
		};
		DefaultGetRequest(requestHelper, (exception, response, body) =>
		{
			AbilityInfo abilityInfo = new AbilityInfo();
			abilityInfo.Id = abilityId;
			abilityInfo.Rank = 1;
			if (exception != null)
			{
				Debug.LogError("Error geting ability rank: " + exception.Message);
				callback?.Invoke(abilityInfo);
				return;
			}
			Debug.Log($"[BackendReadWrites] GetAbilityRankForPlayer for ability #{abilityId}: {body}");
			abilityInfo = JsonConvert.DeserializeObject<AbilityInfo>(body);
			abilityInfo.Id = abilityId;
			abilityInfo.Rank = 1;
			callback?.Invoke(abilityInfo);
		});
	}
	
	public static string RegisterCharacter(CharacterSkinData skinData)
	{
		string jsonBody = JsonConvert.SerializeObject(skinData);
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{REGISTER_CHARACTER}",
			BodyString = jsonBody,
			EnableDebug = true,
			Headers = new Dictionary<string, string>()
			{
				//authorization bearer token
				["authorization"] = "Bearer " + PlayerData.Instance.Token
				// ["unique_user_id"] = playerRegisterData.unique_user_id,
				// ["password_hash"] = playerRegisterData.password_hash
			},// + WebsiteRestConfig.Profile.token
		};
		DefaultPostRequest(requestHelper, (exception, response, body) => {
			if (exception != null)
			{
				Debug.LogError("Error registering character: " + exception.Message);
				return;
			}

			int responseInt = int.Parse(body);
			if (responseInt > 0)
			{
				Debug.Log("Character registered with id:" + body);
				skinData.Id = responseInt;
				OnCharacterCreated?.Invoke(skinData);
			}else
			{
				Debug.Log("Character not registered. Code #" + body);
			}
		});
		return "";
	}

	//https://hathora.dev/api#tag/RoomV2/operation/GetActiveRoomsForProcess
	public static void GetHathoraRoomId(Action<RequestException, ResponseHelper, string> callback) {
#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX
		string currentProcessHathoraId = Environment.GetEnvironmentVariable("HATHORA_PROCESS_ID");
		string appId = Environment.GetEnvironmentVariable("HATHORA_APP_ID");
		string token = Environment.GetEnvironmentVariable("HATHORA_APP_SECRET");
		Debug.Log($"[BackendReadWrites] GetHathoraRoomId for process #{currentProcessHathoraId}; token: {token}");
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{HATHORA_GET_ROOM_ID}{appId}/list/{currentProcessHathoraId}/active",
			Headers = new Dictionary<string, string>() { ["Authorization"] = "Bearer " + HATHORA_TOKEN},
		};
		RestClient.Get(requestHelper).Then(response =>
			{
				Debug.Log($"[BackendReadWrites.GetHathoraRoomId] {requestHelper.Uri} response success: {response.Text}");
				callback?.Invoke(null, response, response.Text);
			});
		#endif
	}
	
	public static void GetHathoraConnectionInfo(string roomId, Action<RequestException, ResponseHelper, string> callback) {
#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX
		Debug.Log($"[BackendReadWrites] GetHathoraConnectionInfo");
		string appId = Environment.GetEnvironmentVariable("HATHORA_APP_ID");
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{HATHORA_GET_CONNECTION_INFO}{appId}/connectioninfo/{roomId}",
		};
		RestClient.Get(requestHelper).Then(response => {
			Debug.Log($"[BackendReadWrites.GetHathoraConnectionInfo] {requestHelper.Uri} response success: {response.Text}");
			callback?.Invoke(null, response, response.Text);
		})
		.Catch(error =>
		{
			Debug.Log($"[BackendReadWrites.GetHathoraConnectionInfo] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}");
			//callback?.Invoke(null, null, "error");
		});
		#endif
	}
	
	#region PlayerData
	public static void RegisterUser(Player playerData, Action<RequestException, ResponseHelper, string> callback)
	{
		string jsonBody = JsonConvert.SerializeObject(playerData);
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{REGISTER_USER}",
			BodyString = jsonBody,
			EnableDebug = true
			//Headers = new Dictionary<string, string>() { ["Authorization"] = "Bearer "},// + WebsiteRestConfig.Profile.token
		};
		DefaultPostRequest(requestHelper, callback);
	}
	
	public static void Login(Player playerData, Action<RequestException, ResponseHelper, string> callback)
	{
		string jsonBody = JsonConvert.SerializeObject(playerData);
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{LOGIN_USER}",
			BodyString = jsonBody,
			EnableDebug = true
			//Headers = new Dictionary<string, string>() { ["Authorization"] = "Bearer "},// + WebsiteRestConfig.Profile.token
		};
		RestClient.Post(requestHelper).Then(response =>
			{
				Debug.Log($"[BackendReadWrites.Login] {requestHelper.Uri} response success: {response.Text}");
				callback?.Invoke(null, response, response.Text);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.Login] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}");
				RequestException requestException = new RequestException(error.Message);
				callback?.Invoke(requestException, null, "error");
			})
			.Finally(() =>
			{
				
			});
	}

	public static void ChangePlayerData(string token, string newUsername, string newEmail, string newPassword, Action<RequestException, ResponseHelper, string> callback)
	{
		string jsonBody = JsonConvert.SerializeObject(new { username = newUsername, email = newEmail, password = newPassword });

		RequestHelper request = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{CHANGE_EMAIL_PASSWORD}",
			BodyString = jsonBody,
			Headers = new Dictionary<string, string>()
			{
				["authorization"] = "Bearer " + token
			}
		};
		RestClient.Post(request).Then(response =>
			{
				Debug.Log($"[BackendReadWrites.ChangePlayerData] {response.StatusCode} {request.Uri} response success: {response.Text}");
				callback?.Invoke(null, response, response.Text);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}");
				RequestException requestException = new RequestException(error.Message);
				callback?.Invoke(requestException, null, "error");
			})
			.Finally(() =>
			{
				
			});
	}
	#endregion
	//TODO: Create GetCharacterData to load several characters with several included tokens
	public static void GetCharacterData(string token, Action<RequestException, ResponseHelper, string> callback)
	{
		RequestHelper request = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{GET_FIRST_CHARACTER}",
			Headers = new Dictionary<string, string>()
			{
				["Authorization"] = "Bearer " + token
			}
		};
		RestClient.Get(request).Then(response =>
			{
				Debug.Log($"[BackendReadWrites.GetCharacterData] {response.StatusCode} {request.Uri} response success: {response.Text}");
				callback?.Invoke(null, response, response.Text);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}");
				//callback?.Invoke(null, null, "error");
			})
			.Finally(() =>
			{
				
			});
	}

	public static void GetCharacterData(PlayerData.PlayerRegisterData playerRegisterData, Action<RequestException, ResponseHelper, string> callback)
	{
		RequestHelper request = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{GET_CHARACTER}",
			BodyString = JsonConvert.SerializeObject(playerRegisterData),
			Headers = new Dictionary<string, string>
			{
				["Authorization"] = "Bearer " + PlayerData.Instance.Token
			}
		};
		RestClient.Get(request).Then(response =>
			{
				Debug.Log($"[BackendReadWrites.GetCharacterData] {response.StatusCode} {request.Uri} response success: {response.Text}");
				callback?.Invoke(null, response, response.Text);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}");
				var requestException = new RequestException(error.Message);
				callback?.Invoke(requestException, null, error.Message);
			})
			.Finally(() =>
			{
				
			});
	}
	
	public static void AiDoDialog(string m_question, int m_asker, int m_answerer, Action<RequestException, ResponseHelper, string> callback)
	{
		string jsonBody = JsonConvert.SerializeObject(new { question = m_question, asker = m_asker, answerer = m_answerer });
		Debug.Log($"[BackendReadWrites.AiDoDialog] url: {BACKEND_URL}ai/do-dialog; jsonBody: {jsonBody}");
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{BACKEND_URL}ai/do-dialog",
			BodyString = jsonBody,
			EnableDebug = true
			//Headers = new Dictionary<string, string>() { ["Authorization"] = "Bearer "},// + WebsiteRestConfig.Profile.token
		};
		DefaultPostRequest(requestHelper, callback);
	}
	
	public static void GetAudioFile(string audioFilePath, string audioFileName, Action<AudioClip> onSuccess, Action<string> onError)
	{
		string url = $"{BACKEND_URL}audio";
		var audioData = new { path = audioFilePath, filename = audioFileName + ".mp3" };
		Debug.Log($"[BackendReadWrites.GetAudioFile] url: {url}, audioData: {audioData}");
		string jsonBody = JsonConvert.SerializeObject(audioData);
		RestClient.Get(new RequestHelper
		{
			Uri = url,
			BodyString = jsonBody,
			DownloadHandler = new DownloadHandlerAudioClip(url, AudioType.MPEG) // Adjust AudioType based on your file format
		}).Then(response =>
		{
			AudioClip audioClip = ((DownloadHandlerAudioClip)response.Request.downloadHandler).audioClip;
			onSuccess?.Invoke(audioClip);
		}).Catch(error =>
		{
			onError?.Invoke(error.Message);
		});
	}


	#region ServerData

	public static void RegisterServer(string JSON, Action<RequestException, ResponseHelper, string> callback)
	{
#if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX
		RequestHelper request = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{POST_REGISTER_SERVER}",
			BodyString = JSON
		};
		DefaultPostRequest(request, callback);
#endif
	}
	
	public static void UnregisterServer(string JSON, Action<RequestException, ResponseHelper, string> callback)
	{
#if UNITY_SERVER || UNITY_EDITOR
		RequestHelper request = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{POST_REGISTER_SERVER}",
			BodyString = JSON
		};
		DefaultPostRequest(request, callback);
#endif
	}
	
	public static void GetServersByVersion(string version, Action<RequestException, ResponseHelper, string> callback)
	{
		RequestHelper requestHelper = new RequestHelper
		{
			Uri = $"{BACKEND_URL}{GET_AVAILABLE_SERVERS}{version}",
			Timeout = 50,
		};
		RestClient.Get(requestHelper).Then(response =>
			{
				Debug.Log($"[BackendReadWrites.DefaultGetRequest] {requestHelper.Uri} response success: {response.Text}");
				callback?.Invoke(null, response, response.Text);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.DefaultGetRequest] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}");
				RequestException requestException = new RequestException(error.Message);
				callback?.Invoke(requestException, null, "error");
			});
	}

	#endregion

	#region Default Post/Get 

	public static void DefaultPostRequestNoLogs(RequestHelper request, Action<RequestException, ResponseHelper, string> callback)
	{
		RestClient.Post(request).Then(response =>
			{
				callback?.Invoke(null, response, response.Text);
			})
			.Catch(error =>
			{
			});
	}
	
	public static void DefaultPostRequest(RequestHelper request, Action<RequestException, ResponseHelper, string> callback)
	{
		RestClient.Post(request).Then(response =>
			{
				Debug.Log($"[BackendReadWrites.Post] {request.Uri}  response success: {response.Text}");
				callback?.Invoke(null, response, response.Text);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.Post] {request.Uri} response error: {error.Message} {error.StackTrace}");
				//callback?.Invoke(null, null, "error");
			})
			.Finally(() =>
			{
				
			});
	}
	
	public static void DefaultGetRequest(RequestHelper request, Action<RequestException, ResponseHelper, string> callback)
	{
		RestClient.Get(request).Then(response =>
			{
				Debug.Log($"[BackendReadWrites.DefaultGetRequest] {request.Uri} response success: {response.Text}");
				callback?.Invoke(null, response, response.Text);
			})
			.Catch(error =>
			{
				Debug.Log($"[BackendReadWrites.DefaultGetRequest] {request.Uri} response error: {error.Message} {error.StackTrace}");
				RequestException requestException = new RequestException(error.Message);
				callback?.Invoke(requestException, null, "error");
			})
			.Finally(() =>
			{
				
			});
	}

	#endregion

	
	
	[Serializable]
	public class Player
	{
		public string username;
		public string password;
		public string email;
	}

	[Serializable]
	public class Token
	{
		public string username;
		public string access_token;
	}

	public class CharacterDataDTO
	{
		public int id;
		public SlotItem[] bank_items = new SlotItem[0];
		public SlotItem[] backpack_items = new SlotItem[0];
		public SlotItem[] equipment_items = new SlotItem[0];
		public string serverKey;
	}
	
	[Serializable]
	public class SlotItem{
		public int slotId;
		public int itemId;
		public int amount;
	}
}	
} 

// Assets\-ZombieRoyale\Scripts\Backend\BackendAuction.cs:
 using System;
using System.Collections.Generic;
using System.Linq;
using _ZombieRoyale.Scripts.Clients;
using Newtonsoft.Json;
using Proyecto26;

namespace Backend
{
    
public static class BackendAuction
{
    private static readonly string LIST_AUCTION_ITEM = "auction/list";
    private static readonly string GET_AUCTIONED_ITEMS = "auction/items";
    private static readonly string GET_AUCTION_ITEM_DETAILS = "auction/item/";
    private static readonly string PLACE_BID = "auction/bid";
    private static readonly string BUYOUT_ITEM = "auction/buyout";
    private static readonly string GET_USER_AUCTIONED_ITEMS = "auction/user-items";
    private static readonly string CANCEL_AUCTION = "auction/cancel";
    private static readonly string GET_USER_BIDDING_HISTORY = "auction/bids";
    private static readonly string GET_USER_PURCHASE_HISTORY = "auction/purchases";
    private static readonly string SEARCH_AUCTION_ITEMS = "auction/search";
    private static readonly string GET_MARKET_PRICES = "auction/market-prices";
    private static readonly string BUY_MULTIPLE_ITEMS = "auction/buy-multiple";

    public static void ListAuctionItem(AuctionListItemData data, Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{LIST_AUCTION_ITEM}",
            BodyString = JsonConvert.SerializeObject(data),
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultPostRequest(request, callback);
    }
    
    public static string ToQueryString(AuctionQueryData queryData)
    {
        var properties = from p in queryData.GetType().GetProperties()
            where p.GetValue(queryData, null) != null
            select p.Name + "=" + System.Web.HttpUtility.UrlEncode(p.GetValue(queryData, null).ToString());

        return String.Join("&", properties.ToArray());
    }

    public static void GetAuctionedItems(AuctionQueryData query, Action<RequestException, ResponseHelper, string> callback)
    {
        string queryString = ToQueryString(query);
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{GET_AUCTIONED_ITEMS}?{queryString}",
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultGetRequest(request, callback);
    }

    public static void GetAuctionItemDetails(string auctionId, Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{GET_AUCTION_ITEM_DETAILS}{auctionId}",
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultGetRequest(request, callback);
    }

    public static void PlaceBid(AuctionBidData data, Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{PLACE_BID}",
            BodyString = JsonConvert.SerializeObject(data),
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultPostRequest(request, callback);
    }

    public static void BuyoutItem(AuctionBuyoutData data, Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{BUYOUT_ITEM}",
            BodyString = JsonConvert.SerializeObject(data),
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultPostRequest(request, callback);
    }

    public static void GetUserAuctionedItems(Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{GET_USER_AUCTIONED_ITEMS}",
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultGetRequest(request, callback);
    }

    public static void CancelAuction(AuctionCancelData data, Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{CANCEL_AUCTION}",
            BodyString = JsonConvert.SerializeObject(data),
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultPostRequest(request, callback);
    }

    public static void GetUserBiddingHistory(Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{GET_USER_BIDDING_HISTORY}",
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultGetRequest(request, callback);
    }

    public static void GetUserPurchaseHistory(Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{GET_USER_PURCHASE_HISTORY}",
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultGetRequest(request, callback);
    }

    public static void SearchAuctionItems(AuctionSearchData data, Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{SEARCH_AUCTION_ITEMS}",
            BodyString = JsonConvert.SerializeObject(data),
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultPostRequest(request, callback);
    }

    public static void GetMarketPrices(MarketPricesData data, Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{GET_MARKET_PRICES}",
            BodyString = JsonConvert.SerializeObject(data),
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultPostRequest(request, callback);
    }

    public static void BuyMultipleItems(BuyMultipleItemsData data,
        Action<RequestException, ResponseHelper, string> callback)
    {
        RequestHelper request = new RequestHelper
        {
            Uri = $"{BackendReadWrites.BACKEND_URL}{BUY_MULTIPLE_ITEMS}",
            BodyString = JsonConvert.SerializeObject(data),
            Headers = new Dictionary<string, string>()
            {
                ["authorization"] = "Bearer " + PlayerData.Instance.Token
            }
        };
        BackendReadWrites.DefaultPostRequest(request, callback);
    }

    // New data classes for auction API

    [Serializable]
    public class AuctionListItemData
    {
        public int itemId;
        public int amount;
        public float startingBid;
        public float buyoutPrice;
        public int duration;
    }

    [Serializable]
    public class AuctionQueryData
    {
        public int page;
        public string category;
        public string searchQuery;
    }

    [Serializable]
    public class AuctionBidData
    {
        public string auctionId;
        public float amount;
    }

    [Serializable]
    public class AuctionBuyoutData
    {
        public string auctionId;
        public int amount;
    }

    [Serializable]
    public class AuctionCancelData
    {
        public string auctionId;
        public int amount;
    }

    [Serializable]
    public class AuctionSearchData
    {
        public string searchQuery;
        public string itemType;
        public string slot;
        public string quality;
        public int level;
        public string[] stats;
        public int page;
    }

    [Serializable]
    public class MarketPricesData
    {
        public int itemId;
    }

    [Serializable]
    public class BuyMultipleItemsData
    {
        public List<AuctionBuyoutData> purchases;
    }
}
} 

// Assets\-ZombieRoyale\Scripts\Clients\CharacterDataController.cs:
 using _ZombieRoyale.Scripts.Clients;
using Backend;
using Character;
using NHance.Assets.Scripts;
using UnityEngine;

public class CharacterDataController : MonoBehaviour
{
    public static CharacterDataController Instance { get; private set; }
    public CharacterData CharacterData => characterData;
    [SerializeField] private CharacterData characterData;
    public CharacterSkinData CharacterSkinData => _characterSkinData;
    [SerializeField] private CharacterSkinData _characterSkinData;
    [SerializeField] private CharacterSkin _characterSkin;
    [SerializeField] protected NHAvatar maleAvatar;
    [SerializeField] protected NHAvatar femaleAvatar;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            BackendReadWrites.OnCharacterCreated += OnCharacterCreated;
            RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded;
            RegistrationController.Instance.SwitchMainMenuElements(false);
        }else if (Instance != this)
        {
            Destroy(gameObject);
        }
    }

    private void OnCharacterLoaded(CharacterData charData)
    {
        Debug.Log($"[CharacterDataController] OnCharacterLoaded");
        characterData = charData;
        _characterSkinData = charData.GetSkinData();
        LoadAvatar(_characterSkinData);
    }

    private void LoadAvatar(CharacterSkinData charskinData)
    {
        if (_characterSkin != null && _characterSkin.gameObject.activeSelf)
        {
            _characterSkin.SetSkinData(charskinData);
        }
        else
        {
            if (charskinData.genderId == (int)CharacterSkinData.Gender.Male)
            {
                femaleAvatar.gameObject.SetActive(false);
                maleAvatar.gameObject.SetActive(true);
                maleAvatar.SetSkinData(charskinData);
            }
            else
            {
                maleAvatar.gameObject.SetActive(false);
                femaleAvatar.gameObject.SetActive(true);
                femaleAvatar.SetSkinData(charskinData);
            }
        }
    }

    private void OnCharacterCreated(CharacterSkinData backendSkinData)
    {
        Debug.Log($"[CharacterDataController] OnCharacterCreated {(CharacterSkinData.Gender)backendSkinData.genderId}");
        _characterSkinData = backendSkinData;
        RegistrationController.Instance.SwitchMainMenuElements(true);
        LoadAvatar(_characterSkinData);
    }
} 

// Assets\-ZombieRoyale\Scripts\Clients\CharacterDataController.cs:
 using _ZombieRoyale.Scripts.Clients;
using Backend;
using Character;
using NHance.Assets.Scripts;
using UnityEngine;

public class CharacterDataController : MonoBehaviour
{
    public static CharacterDataController Instance { get; private set; }
    public CharacterData CharacterData => characterData;
    [SerializeField] private CharacterData characterData;
    public CharacterSkinData CharacterSkinData => _characterSkinData;
    [SerializeField] private CharacterSkinData _characterSkinData;
    [SerializeField] private CharacterSkin _characterSkin;
    [SerializeField] protected NHAvatar maleAvatar;
    [SerializeField] protected NHAvatar femaleAvatar;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            BackendReadWrites.OnCharacterCreated += OnCharacterCreated;
            RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded;
            RegistrationController.Instance.SwitchMainMenuElements(false);
        }else if (Instance != this)
        {
            Destroy(gameObject);
        }
    }

    private void OnCharacterLoaded(CharacterData charData)
    {
        Debug.Log($"[CharacterDataController] OnCharacterLoaded");
        characterData = charData;
        _characterSkinData = charData.GetSkinData();
        LoadAvatar(_characterSkinData);
    }

    private void LoadAvatar(CharacterSkinData charskinData)
    {
        if (_characterSkin != null && _characterSkin.gameObject.activeSelf)
        {
            _characterSkin.SetSkinData(charskinData);
        }
        else
        {
            if (charskinData.genderId == (int)CharacterSkinData.Gender.Male)
            {
                femaleAvatar.gameObject.SetActive(false);
                maleAvatar.gameObject.SetActive(true);
                maleAvatar.SetSkinData(charskinData);
            }
            else
            {
                maleAvatar.gameObject.SetActive(false);
                femaleAvatar.gameObject.SetActive(true);
                femaleAvatar.SetSkinData(charskinData);
            }
        }
    }

    private void OnCharacterCreated(CharacterSkinData backendSkinData)
    {
        Debug.Log($"[CharacterDataController] OnCharacterCreated {(CharacterSkinData.Gender)backendSkinData.genderId}");
        _characterSkinData = backendSkinData;
        RegistrationController.Instance.SwitchMainMenuElements(true);
        LoadAvatar(_characterSkinData);
    }
} 

// Assets\-ZombieRoyale\Scripts\Backend\BackendInventory.cs:
 using System;
using System.Collections.Generic;
using UnityEngine;
using Invector.vItemManager;
using _ZombieRoyale.Scripts.Clients;

namespace Backend
{
    public class BackendInventory
    {
        public static void MoveItemToInventory(vItem item, int amount, Action<bool> callback)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            BackendReadWrites.CharacterDataDTO dto = new BackendReadWrites.CharacterDataDTO
            {
                id = characterData.id,
                backpack_items = new BackendReadWrites.SlotItem[]
                {
                    new BackendReadWrites.SlotItem
                    {
                        slotId = -1,
                        itemId = item.id,
                        amount = amount
                    }
                }
            };

            BackendReadWrites.AddInventory(dto, (result) =>
            {
                bool success = result > 0;
                if (success)
                {
                    UpdateLocalInventory(item, amount);
                }

                callback?.Invoke(success);
            });
        }

        public static void MoveItemToBank(vItem item, int amount, Action<bool> callback)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            BackendReadWrites.CharacterDataDTO dto = new BackendReadWrites.CharacterDataDTO
            {
                id = characterData.id,
                bank_items = new BackendReadWrites.SlotItem[]
                {
                    new BackendReadWrites.SlotItem
                    {
                        slotId = -1,
                        itemId = item.id,
                        amount = amount
                    }
                }
            };

            BackendReadWrites.AddInventory(dto, (result) =>
            {
                bool success = result > 0;
                if (success)
                {
                    UpdateLocalBank(item, amount);
                }

                callback?.Invoke(success);
            });
        }

        public static void MoveItemToEquipment(vItem item, int slotId, Action<bool> callback)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            BackendReadWrites.CharacterDataDTO dto = new BackendReadWrites.CharacterDataDTO
            {
                id = characterData.id,
                equipment_items = new BackendReadWrites.SlotItem[]
                {
                    new BackendReadWrites.SlotItem
                    {
                        slotId = slotId,
                        itemId = item.id,
                        amount = 1
                    }
                }
            };

            BackendReadWrites.AddInventory(dto, (result) =>
            {
                bool success = result > 0;
                if (success)
                {
                    UpdateLocalEquipment(item, slotId);
                }

                callback?.Invoke(success);
            });
        }

        public static void RemoveItemFromInventory(vItem item, int amount, Action<bool> callback)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            BackendReadWrites.CharacterDataDTO dto = new BackendReadWrites.CharacterDataDTO
            {
                id = characterData.id,
                backpack_items = new BackendReadWrites.SlotItem[]
                {
                    new BackendReadWrites.SlotItem
                    {
                        slotId = -1,
                        itemId = item.id,
                        amount = amount
                    }
                }
            };

            BackendReadWrites.DeleteInventory(dto, (result) =>
            {
                bool success = result > 0;
                if (success)
                {
                    UpdateLocalInventory(item, -amount);
                }

                callback?.Invoke(success);
            });
        }

        public static void RemoveItemFromBank(vItem item, int amount, Action<bool> callback)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            BackendReadWrites.CharacterDataDTO dto = new BackendReadWrites.CharacterDataDTO
            {
                id = characterData.id,
                bank_items = new BackendReadWrites.SlotItem[]
                {
                    new BackendReadWrites.SlotItem
                    {
                        slotId = -1,
                        itemId = item.id,
                        amount = amount
                    }
                }
            };

            BackendReadWrites.DeleteInventory(dto, (result) =>
            {
                bool success = result > 0;
                if (success)
                {
                    UpdateLocalBank(item, -amount);
                }

                callback?.Invoke(success);
            });
        }

        public static void RemoveItemFromEquipment(vItem item, int slotId, Action<bool> callback)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            BackendReadWrites.CharacterDataDTO dto = new BackendReadWrites.CharacterDataDTO
            {
                id = characterData.id,
                equipment_items = new BackendReadWrites.SlotItem[]
                {
                    new BackendReadWrites.SlotItem
                    {
                        slotId = slotId,
                        itemId = item.id,
                        amount = 1
                    }
                }
            };

            BackendReadWrites.DeleteInventory(dto, (result) =>
            {
                bool success = result > 0;
                if (success)
                {
                    UpdateLocalEquipment(item, slotId, true);
                }

                callback?.Invoke(success);
            });
        }

        private static void UpdateLocalInventory(vItem item, int amountChange)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            var existingItem = Array.Find(characterData.inventory_items, x => x.itemId == item.id);
            if (existingItem != null)
            {
                existingItem.amount += amountChange;
                if (existingItem.amount <= 0)
                {
                    characterData.inventory_items =
                        Array.FindAll(characterData.inventory_items, x => x.itemId != item.id);
                }
            }
            else if (amountChange > 0)
            {
                Array.Resize(ref characterData.inventory_items, characterData.inventory_items.Length + 1);
                characterData.inventory_items[characterData.inventory_items.Length - 1] = new BackendReadWrites.SlotItem
                {
                    slotId = -1,
                    itemId = item.id,
                    amount = amountChange
                };
            }
        }

        private static void UpdateLocalBank(vItem item, int amountChange)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            var existingItem = Array.Find(characterData.bank_items, x => x.itemId == item.id);
            if (existingItem != null)
            {
                existingItem.amount += amountChange;
                if (existingItem.amount <= 0)
                {
                    characterData.bank_items = Array.FindAll(characterData.bank_items, x => x.itemId != item.id);
                }
            }
            else if (amountChange > 0)
            {
                Array.Resize(ref characterData.bank_items, characterData.bank_items.Length + 1);
                characterData.bank_items[characterData.bank_items.Length - 1] = new BackendReadWrites.SlotItem
                {
                    slotId = -1,
                    itemId = item.id,
                    amount = amountChange
                };
            }
        }

        private static void UpdateLocalEquipment(vItem item, int slotId, bool remove = false)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            if (remove)
            {
                characterData.equipment_items = Array.FindAll(characterData.equipment_items, x => x.slotId != slotId);
            }
            else
            {
                var existingItem = Array.Find(characterData.equipment_items, x => x.slotId == slotId);
                if (existingItem != null)
                {
                    existingItem.itemId = item.id;
                }
                else
                {
                    Array.Resize(ref characterData.equipment_items, characterData.equipment_items.Length + 1);
                    characterData.equipment_items[characterData.equipment_items.Length - 1] =
                        new BackendReadWrites.SlotItem
                        {
                            slotId = slotId,
                            itemId = item.id,
                            amount = 1
                        };
                }
            }
        }

        public static bool HasItem(vItem item, int amount)
        {
            CharacterData characterData = CharacterDataController.Instance.CharacterData;
            var inventoryItem = Array.Find(characterData.inventory_items, x => x.itemId == item.id);
            var bankItem = Array.Find(characterData.bank_items, x => x.itemId == item.id);
            var equipmentItem = Array.Find(characterData.equipment_items, x => x.itemId == item.id);

            int totalAmount =
                (inventoryItem?.amount ?? 0) +
                (bankItem?.amount ?? 0) +
                (equipmentItem != null ? 1 : 0);

            return totalAmount >= amount;
        }
    }
} 



# TASK: BackendInventory should only have logic to do GET/POST requests on specified addresses. MainMenuInventoryController is on client side, so to prevent client from cheating, when client is moving item between slots, we need to do check requests to backend