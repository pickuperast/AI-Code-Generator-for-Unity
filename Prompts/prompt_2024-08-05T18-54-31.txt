
# CODE: // Assets\Sanat\CodeGenerator\ApiGemini\ApiGemini.cs:
 // Assets\Sanat\CodeGenerator\ApiGemini\ApiGemini.cs
 using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;

namespace Sanat.ApiGemini
{
    public static class Gemini
    {
        public static string BaseURL { get; set; } = "https://us-central1-aiplatform.googleapis.com/v1/";
        public static string BaseURL2 { get; set; } = "https://generativelanguage.googleapis.com/v1beta/models/";
        public const string PREFS_GEMINI_PROJECT_NAME = "GeminiProjectName";
        public static string TextToSpeechURL = "https://texttospeech.googleapis.com/v1/text:synthesize";
        public static string GetGeminiProjectName()
        {
            return PlayerPrefs.GetString(PREFS_GEMINI_PROJECT_NAME, "");
        }

        public static UnityWebRequestAsyncOperation SubmitChatAsync(
            string apiKey, 
            string model, 
            float temperature, 
            int maxTokens,
            List<ChatMessage> messages, 
            Action<string> callback)
        {
            var chatRequest = new ChatRequest(messages[0].content, temperature);
            string jsonData = JsonUtility.ToJson(chatRequest);
            string generatedUrl = $"{BaseURL2}{model}:generateContent?key={apiKey}";
            UnityWebRequest webRequest = CreateWebRequest(apiKey, generatedUrl, jsonData);

            UnityWebRequestAsyncOperation asyncOp = webRequest.SendWebRequest();
            asyncOp.completed += (op) =>
            {
                var success = webRequest.result == UnityWebRequest.Result.Success;
                var text = success ? webRequest.downloadHandler.text : string.Empty;
                if (!success) Debug.Log($"{webRequest.error} {apiKey}\n{webRequest.downloadHandler.text}");
                webRequest.Dispose();

                if (!string.IsNullOrEmpty(text))
                {
                    var responseData = JsonUtility.FromJson<ChatResponse>(text);
                    if (responseData.candidates != null && responseData.candidates.Count > 0)
                    {
                        text = responseData.candidates[0].content.parts[0].text.Trim();
                    }
                    else
                    {
                        text = "No candidates found in response.";
                    }

                    var tokensPrompt = responseData.usageMetadata.promptTokenCount;
                    var tokensCompletion = responseData.usageMetadata.candidatesTokenCount;
                    var tokensTotal = responseData.usageMetadata.totalTokenCount;

                    Debug.Log($"{model} Usage: prompt_tokens: {tokensPrompt}; completion_tokens: {tokensCompletion}; total_tokens: {tokensTotal}");
                }
                callback?.Invoke(text);
            };

            return asyncOp;
        }

        public static UnityWebRequest CreateWebRequest(string apiKey, string url, string jsonData)
        {
            byte[] postData = System.Text.Encoding.UTF8.GetBytes(jsonData);
            UnityWebRequest webRequest = new UnityWebRequest(url, "POST")
            {
                uploadHandler = new UploadHandlerRaw(postData),
                downloadHandler = new DownloadHandlerBuffer(),
                disposeUploadHandlerOnDispose = true,
                disposeDownloadHandlerOnDispose = true
            };
            webRequest.SetRequestHeader("Content-Type", "application/json");

            return webRequest;
        }

        public static void GenerateTextToSpeech(string text, string languageCode, string name, string ssmlGender, Action<AudioClip> callback)
        {
            var request = new TextToSpeechRequest(text, languageCode, name, ssmlGender);
            string jsonData = JsonUtility.ToJson(request);
            UnityWebRequest webRequest = CreateWebRequest(GetGeminiProjectName(), TextToSpeechURL, jsonData);

            UnityWebRequestAsyncOperation asyncOp = webRequest.SendWebRequest();
            asyncOp.completed += (op) =>
            {
                var success = webRequest.result == UnityWebRequest.Result.Success;
                if (!success)
                {
                    Debug.Log($"{webRequest.error} {GetGeminiProjectName()}\n{webRequest.downloadHandler.text}");
                    callback?.Invoke(null);
                    return;
                }
                
                var audioData = webRequest.downloadHandler.data;
                float[] floatData = ConvertByteToFloatArray(audioData);
                AudioClip audioClip = AudioClip.Create("TextToSpeech", floatData.Length, 1, 44100, false);
                audioClip.SetData(floatData, 0);
                callback?.Invoke(audioClip);
            };
        }

        private static float[] ConvertByteToFloatArray(byte[] byteArray)
        {
            int floatArrayLength = byteArray.Length / 4;
            float[] floatArray = new float[floatArrayLength];
            for (int i = 0; i < floatArrayLength; i++)
            {
                floatArray[i] = BitConverter.ToSingle(byteArray, i * 4);
            }
            return floatArray;
        }
    }

    [Serializable]
    public class TextToSpeechRequest
    {
        public Input input;
        public Voice voice;
        public AudioConfig audioConfig;

        public TextToSpeechRequest(string text, string languageCode, string name, string ssmlGender)
        {
            input = new Input { text = text };
            voice = new Voice { languageCode = languageCode, name = name, ssmlGender = ssmlGender };
            audioConfig = new AudioConfig { audioEncoding = "MP3" };
        }
    }

    [Serializable]
    public class Input
    {
        public string text;
    }

    [Serializable]
    public class Voice
    {
        public string languageCode;
        public string name;
        public string ssmlGender;
    }

    [Serializable]
    public class AudioConfig
    {
        public string audioEncoding;
    }

    [Serializable]
    public class ChatRequest
    {
        public Contents contents;
        public SafetySettings safety_settings;
        public GenerationConfig generation_config;

        public ChatRequest(string message, float temperature)
        {
            contents = new Contents
            {
                role = "user",
                parts = new Parts { text = message }
            };
            safety_settings = new SafetySettings
            {
                category = "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                threshold = "BLOCK_LOW_AND_ABOVE"
            };
            generation_config = new GenerationConfig
            {
                temperature = temperature,
                topP = 0.8f,
                topK = 40
            };
        }
    }
} 

// Assets\Sanat\CodeGenerator\ApiGemini\ApiGemini.cs:
 // Assets\Sanat\CodeGenerator\ApiGemini\ApiGemini.cs
 using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;

namespace Sanat.ApiGemini
{
    public static class Gemini
    {
        public static string BaseURL { get; set; } = "https://us-central1-aiplatform.googleapis.com/v1/";
        public static string BaseURL2 { get; set; } = "https://generativelanguage.googleapis.com/v1beta/models/";
        public const string PREFS_GEMINI_PROJECT_NAME = "GeminiProjectName";
        public static string TextToSpeechURL = "https://texttospeech.googleapis.com/v1/text:synthesize";
        public static string GetGeminiProjectName()
        {
            return PlayerPrefs.GetString(PREFS_GEMINI_PROJECT_NAME, "");
        }

        public static UnityWebRequestAsyncOperation SubmitChatAsync(
            string apiKey, 
            string model, 
            float temperature, 
            int maxTokens,
            List<ChatMessage> messages, 
            Action<string> callback)
        {
            var chatRequest = new ChatRequest(messages[0].content, temperature);
            string jsonData = JsonUtility.ToJson(chatRequest);
            string generatedUrl = $"{BaseURL2}{model}:generateContent?key={apiKey}";
            UnityWebRequest webRequest = CreateWebRequest(apiKey, generatedUrl, jsonData);

            UnityWebRequestAsyncOperation asyncOp = webRequest.SendWebRequest();
            asyncOp.completed += (op) =>
            {
                var success = webRequest.result == UnityWebRequest.Result.Success;
                var text = success ? webRequest.downloadHandler.text : string.Empty;
                if (!success) Debug.Log($"{webRequest.error} {apiKey}\n{webRequest.downloadHandler.text}");
                webRequest.Dispose();

                if (!string.IsNullOrEmpty(text))
                {
                    var responseData = JsonUtility.FromJson<ChatResponse>(text);
                    if (responseData.candidates != null && responseData.candidates.Count > 0)
                    {
                        text = responseData.candidates[0].content.parts[0].text.Trim();
                    }
                    else
                    {
                        text = "No candidates found in response.";
                    }

                    var tokensPrompt = responseData.usageMetadata.promptTokenCount;
                    var tokensCompletion = responseData.usageMetadata.candidatesTokenCount;
                    var tokensTotal = responseData.usageMetadata.totalTokenCount;

                    Debug.Log($"{model} Usage: prompt_tokens: {tokensPrompt}; completion_tokens: {tokensCompletion}; total_tokens: {tokensTotal}");
                }
                callback?.Invoke(text);
            };

            return asyncOp;
        }

        public static UnityWebRequest CreateWebRequest(string apiKey, string url, string jsonData)
        {
            byte[] postData = System.Text.Encoding.UTF8.GetBytes(jsonData);
            UnityWebRequest webRequest = new UnityWebRequest(url, "POST")
            {
                uploadHandler = new UploadHandlerRaw(postData),
                downloadHandler = new DownloadHandlerBuffer(),
                disposeUploadHandlerOnDispose = true,
                disposeDownloadHandlerOnDispose = true
            };
            webRequest.SetRequestHeader("Content-Type", "application/json");

            return webRequest;
        }

        public static void GenerateTextToSpeech(string text, string languageCode, string name, string ssmlGender, Action<AudioClip> callback)
        {
            var request = new TextToSpeechRequest(text, languageCode, name, ssmlGender);
            string jsonData = JsonUtility.ToJson(request);
            UnityWebRequest webRequest = CreateWebRequest(GetGeminiProjectName(), TextToSpeechURL, jsonData);

            UnityWebRequestAsyncOperation asyncOp = webRequest.SendWebRequest();
            asyncOp.completed += (op) =>
            {
                var success = webRequest.result == UnityWebRequest.Result.Success;
                if (!success)
                {
                    Debug.Log($"{webRequest.error} {GetGeminiProjectName()}\n{webRequest.downloadHandler.text}");
                    callback?.Invoke(null);
                    return;
                }
                
                var audioData = webRequest.downloadHandler.data;
                float[] floatData = ConvertByteToFloatArray(audioData);
                AudioClip audioClip = AudioClip.Create("TextToSpeech", floatData.Length, 1, 44100, false);
                audioClip.SetData(floatData, 0);
                callback?.Invoke(audioClip);
            };
        }

        private static float[] ConvertByteToFloatArray(byte[] byteArray)
        {
            int floatArrayLength = byteArray.Length / 4;
            float[] floatArray = new float[floatArrayLength];
            for (int i = 0; i < floatArrayLength; i++)
            {
                floatArray[i] = BitConverter.ToSingle(byteArray, i * 4);
            }
            return floatArray;
        }
    }

    [Serializable]
    public class TextToSpeechRequest
    {
        public Input input;
        public Voice voice;
        public AudioConfig audioConfig;

        public TextToSpeechRequest(string text, string languageCode, string name, string ssmlGender)
        {
            input = new Input { text = text };
            voice = new Voice { languageCode = languageCode, name = name, ssmlGender = ssmlGender };
            audioConfig = new AudioConfig { audioEncoding = "MP3" };
        }
    }

    [Serializable]
    public class Input
    {
        public string text;
    }

    [Serializable]
    public class Voice
    {
        public string languageCode;
        public string name;
        public string ssmlGender;
    }

    [Serializable]
    public class AudioConfig
    {
        public string audioEncoding;
    }

    [Serializable]
    public class ChatRequest
    {
        public Contents contents;
        public SafetySettings safety_settings;
        public GenerationConfig generation_config;

        public ChatRequest(string message, float temperature)
        {
            contents = new Contents
            {
                role = "user",
                parts = new Parts { text = message }
            };
            safety_settings = new SafetySettings
            {
                category = "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                threshold = "BLOCK_LOW_AND_ABOVE"
            };
            generation_config = new GenerationConfig
            {
                temperature = temperature,
                topP = 0.8f,
                topK = 40
            };
        }
    }
} 

// Assets\Sanat\CodeGenerator\ApiGemini\ApiGeminiClasses.cs:
 using System;
using System.Collections.Generic;
using UnityEngine.Serialization;

namespace Sanat.ApiGemini
{
    [Serializable]
    public class ChatMessage
    {
        public string role;
        public string content;

        public ChatMessage(string role, string content)
        {
            this.role = role;
            this.content = content;
        }
    }

    [Serializable]
    public class ChatResponse
    {
        public List<Candidate> candidates;
        public UsageMetadata usageMetadata;
    }

    [Serializable]
    public class Candidate
    {
        public Content content;
        public string finishReason;
        public List<SafetyRating> safetyRatings;
    }

    [Serializable]
    public class Contents
    {
        public string role;
        public Parts parts;
    }

    [Serializable]
    public class Parts
    {
        public string text;
    }

    [Serializable]
    public class SafetySettings
    {
        public string category;
        public string threshold;
    }

    public enum BlockReason
    {
        BLOCKED_REASON_UNSPECIFIED,
        OTHER,
        SAFETY
    }

    public enum ExecutableCodeLanguage
    {
        LANGUAGE_UNSPECIFIED,
        PYTHON
    }

    public enum FinishReason
    {
        FINISH_REASON_UNSPECIFIED,
        LANGUAGE,
        MAX_TOKENS,
        OTHER,
        RECITATION,
        SAFETY,
        STOP
    }

    public enum FunctionCallingMode
    {
        ANY,
        AUTO,
        MODE_UNSPECIFIED,
        NONE
    }

    public enum FunctionDeclarationSchemaType
    {
        ARRAY,
        BOOLEAN,
        INTEGER,
        NUMBER,
        OBJECT,
        STRING
    }

    public enum HarmBlockThreshold
    {
        BLOCK_LOW_AND_ABOVE,
        BLOCK_MEDIUM_AND_ABOVE,
        BLOCK_NONE,
        BLOCK_ONLY_HIGH,
        HARM_BLOCK_THRESHOLD_UNSPECIFIED
    }

    public enum HarmCategory
    {
        HARM_CATEGORY_DANGEROUS_CONTENT,
        HARM_CATEGORY_HARASSMENT,
        HARM_CATEGORY_HATE_SPEECH,
        HARM_CATEGORY_SEXUALLY_EXPLICIT,
        HARM_CATEGORY_UNSPECIFIED
    }

    public enum HarmProbability
    {
        HARM_PROBABILITY_UNSPECIFIED,
        HIGH,
        LOW,
        MEDIUM,
        NEGLIGIBLE
    }

    public enum Outcome
    {
        OUTCOME_DEADLINE_EXCEEDED,
        OUTCOME_FAILED,
        OUTCOME_OK,
        OUTCOME_UNSPECIFIED
    }

    public enum TaskType
    {
        CLASSIFICATION,
        CLUSTERING,
        RETRIEVAL_DOCUMENT,
        RETRIEVAL_QUERY,
        SEMANTIC_SIMILARITY,
        TASK_TYPE_UNSPECIFIED
    }

    public class BaseParams
    {
        public GenerationConfig GenerationConfig;
        public List<SafetySetting> SafetySettings;
    }

    public class BatchEmbedContentsRequest
    {
        public List<EmbedContentRequest> Requests;
    }

    public class BatchEmbedContentsResponse
    {
        public List<ContentEmbedding> Embeddings;
    }

    public class CachedContent : CachedContentBase
    {
        public string CreateTime;
        public string Name;
        public string Ttl;
        public string UpdateTime;
    }

    public class CachedContentBase
    {
        public List<Content> contents;
        public string DisplayName;
        public string ExpireTime;
        public string Model;
        public string SystemInstruction;
        public ToolConfig ToolConfig;
        public List<Tool> tools;
    }

    public class CitationMetadata
    {
        public List<CitationSource> CitationSources;
    }

    public class CitationSource
    {
        public int EndIndex;
        public string License;
        public int StartIndex;
        public string Uri;
    }

    public class CodeExecutionResult
    {
        public Outcome Outcome;
        public string Output;
    }

    public class Content
    {
        public List<Part> parts;
        public string role;
    }

    public class ContentEmbedding
    {
        public List<float> Values;
    }

    public class CountTokensRequest
    {
        public List<Content> Contents;
        public GenerateContentRequest GenerateContentRequest;
    }

    public class CountTokensResponse
    {
        public int TotalTokens;
    }

    public class EmbedContentRequest
    {
        public Content Content;
        public TaskType TaskType;
        public string Title;
    }

    public class EmbedContentResponse
    {
        public ContentEmbedding Embedding;
    }

    public class ExecutableCode
    {
        public string Code;
        public ExecutableCodeLanguage Language;
    }

    public class FileData
    {
        public string FileUri;
        public string MimeType;
    }

    public class FunctionCall
    {
        public object args;
        public string name;
    }

    public class FunctionCallingConfig
    {
        public List<string> AllowedFunctionNames;
        public FunctionCallingMode Mode;
    }

    public class FunctionDeclaration
    {
        public string name;
        public string description;
        public FunctionDeclarationSchema parameters;
    }

    public class FunctionDeclarationSchema
    {
        public FunctionDeclarationSchemaType type;
        public Dictionary<string, FunctionDeclarationSchemaProperty> properties;
        public List<string> required;
    }

    public class FunctionDeclarationSchemaProperty : Schema
    {
    }

    public class FunctionResponse
    {
        public string Name;
        public object Response;
    }

    public class GenerateContentCandidate
    {
        public CitationMetadata CitationMetadata;
        public Content Content;
        public string FinishMessage;
        public FinishReason FinishReason;
        public int Index;
        public List<SafetyRating> SafetyRatings;
    }

    public class GenerateContentRequest : BaseParams
    {
        public string CachedContent;
        public List<Content> Contents;
        public string SystemInstruction;
        public ToolConfig ToolConfig;
        public List<Tool> tools;
    }

    public class GenerateContentResponse
    {
        public List<GenerateContentCandidate> Candidates;
        public PromptFeedback PromptFeedback;
        public UsageMetadata UsageMetadata;
    }

    public class GenerationConfig
    {
        public int candidateCount = 1;
        public int maxOutputTokens = 8192;
        public string responseMimeType;
        public ResponseSchema responseSchema;
        public List<string> stopSequences;
        public float temperature;
        public int topK;
        public float topP;
    }

    [Serializable]
    public class GenerativeContentBlob
    {
        public string Data;
        public string MimeType;
    }

    [Serializable]
    public class PromptFeedback
    {
        public BlockReason BlockReason;
        public string BlockReasonMessage;
        public List<SafetyRating> SafetyRatings;
    }

    public class ResponseSchema : Schema
    {
    }

    [Serializable]
    public class SafetyRating
    {
        public HarmCategory Category;
        public HarmProbability Probability;
    }

    [Serializable]
    public class SafetySetting
    {
        public HarmCategory Category;
        public HarmBlockThreshold Threshold;
    }

    [Serializable]
    public class Schema
    {
        public string description;
        public FunctionDeclarationSchemaType type;
    }

    [Serializable]
    public class ToolConfig
    {
        public FunctionCallingConfig FunctionCallingConfig;
    }

    [Serializable]
    public class UsageMetadata
    {
        public int cachedContentTokenCount;
        public int candidatesTokenCount;
        public int promptTokenCount;
        public int totalTokenCount;
    }

    [Serializable]
    public class Part
    {
        public string text;
        public GenerativeContentBlob inlineData;
        public FunctionCall functionCall;
        public FunctionResponse functionResponse;
        public FileData fileData;
        public ExecutableCode executableCode;
        public CodeExecutionResult codeExecutionResult;
    }
    
    [Serializable]
    public class ToolRequest
    {
        public List<Content> contents;
        public List<Tool> tools;
    }

    [Serializable]
    public class Tool
    {
        public List<FunctionDeclaration> function_declarations;
    }
} 

// Assets\Sanat\CodeGenerator\ApiGemini\ApiGeminiClasses.cs:
 using System;
using System.Collections.Generic;
using UnityEngine.Serialization;

namespace Sanat.ApiGemini
{
    [Serializable]
    public class ChatMessage
    {
        public string role;
        public string content;

        public ChatMessage(string role, string content)
        {
            this.role = role;
            this.content = content;
        }
    }

    [Serializable]
    public class ChatResponse
    {
        public List<Candidate> candidates;
        public UsageMetadata usageMetadata;
    }

    [Serializable]
    public class Candidate
    {
        public Content content;
        public string finishReason;
        public List<SafetyRating> safetyRatings;
    }

    [Serializable]
    public class Contents
    {
        public string role;
        public Parts parts;
    }

    [Serializable]
    public class Parts
    {
        public string text;
    }

    [Serializable]
    public class SafetySettings
    {
        public string category;
        public string threshold;
    }

    public enum BlockReason
    {
        BLOCKED_REASON_UNSPECIFIED,
        OTHER,
        SAFETY
    }

    public enum ExecutableCodeLanguage
    {
        LANGUAGE_UNSPECIFIED,
        PYTHON
    }

    public enum FinishReason
    {
        FINISH_REASON_UNSPECIFIED,
        LANGUAGE,
        MAX_TOKENS,
        OTHER,
        RECITATION,
        SAFETY,
        STOP
    }

    public enum FunctionCallingMode
    {
        ANY,
        AUTO,
        MODE_UNSPECIFIED,
        NONE
    }

    public enum FunctionDeclarationSchemaType
    {
        ARRAY,
        BOOLEAN,
        INTEGER,
        NUMBER,
        OBJECT,
        STRING
    }

    public enum HarmBlockThreshold
    {
        BLOCK_LOW_AND_ABOVE,
        BLOCK_MEDIUM_AND_ABOVE,
        BLOCK_NONE,
        BLOCK_ONLY_HIGH,
        HARM_BLOCK_THRESHOLD_UNSPECIFIED
    }

    public enum HarmCategory
    {
        HARM_CATEGORY_DANGEROUS_CONTENT,
        HARM_CATEGORY_HARASSMENT,
        HARM_CATEGORY_HATE_SPEECH,
        HARM_CATEGORY_SEXUALLY_EXPLICIT,
        HARM_CATEGORY_UNSPECIFIED
    }

    public enum HarmProbability
    {
        HARM_PROBABILITY_UNSPECIFIED,
        HIGH,
        LOW,
        MEDIUM,
        NEGLIGIBLE
    }

    public enum Outcome
    {
        OUTCOME_DEADLINE_EXCEEDED,
        OUTCOME_FAILED,
        OUTCOME_OK,
        OUTCOME_UNSPECIFIED
    }

    public enum TaskType
    {
        CLASSIFICATION,
        CLUSTERING,
        RETRIEVAL_DOCUMENT,
        RETRIEVAL_QUERY,
        SEMANTIC_SIMILARITY,
        TASK_TYPE_UNSPECIFIED
    }

    public class BaseParams
    {
        public GenerationConfig GenerationConfig;
        public List<SafetySetting> SafetySettings;
    }

    public class BatchEmbedContentsRequest
    {
        public List<EmbedContentRequest> Requests;
    }

    public class BatchEmbedContentsResponse
    {
        public List<ContentEmbedding> Embeddings;
    }

    public class CachedContent : CachedContentBase
    {
        public string CreateTime;
        public string Name;
        public string Ttl;
        public string UpdateTime;
    }

    public class CachedContentBase
    {
        public List<Content> contents;
        public string DisplayName;
        public string ExpireTime;
        public string Model;
        public string SystemInstruction;
        public ToolConfig ToolConfig;
        public List<Tool> tools;
    }

    public class CitationMetadata
    {
        public List<CitationSource> CitationSources;
    }

    public class CitationSource
    {
        public int EndIndex;
        public string License;
        public int StartIndex;
        public string Uri;
    }

    public class CodeExecutionResult
    {
        public Outcome Outcome;
        public string Output;
    }

    public class Content
    {
        public List<Part> parts;
        public string role;
    }

    public class ContentEmbedding
    {
        public List<float> Values;
    }

    public class CountTokensRequest
    {
        public List<Content> Contents;
        public GenerateContentRequest GenerateContentRequest;
    }

    public class CountTokensResponse
    {
        public int TotalTokens;
    }

    public class EmbedContentRequest
    {
        public Content Content;
        public TaskType TaskType;
        public string Title;
    }

    public class EmbedContentResponse
    {
        public ContentEmbedding Embedding;
    }

    public class ExecutableCode
    {
        public string Code;
        public ExecutableCodeLanguage Language;
    }

    public class FileData
    {
        public string FileUri;
        public string MimeType;
    }

    public class FunctionCall
    {
        public object args;
        public string name;
    }

    public class FunctionCallingConfig
    {
        public List<string> AllowedFunctionNames;
        public FunctionCallingMode Mode;
    }

    public class FunctionDeclaration
    {
        public string name;
        public string description;
        public FunctionDeclarationSchema parameters;
    }

    public class FunctionDeclarationSchema
    {
        public FunctionDeclarationSchemaType type;
        public Dictionary<string, FunctionDeclarationSchemaProperty> properties;
        public List<string> required;
    }

    public class FunctionDeclarationSchemaProperty : Schema
    {
    }

    public class FunctionResponse
    {
        public string Name;
        public object Response;
    }

    public class GenerateContentCandidate
    {
        public CitationMetadata CitationMetadata;
        public Content Content;
        public string FinishMessage;
        public FinishReason FinishReason;
        public int Index;
        public List<SafetyRating> SafetyRatings;
    }

    public class GenerateContentRequest : BaseParams
    {
        public string CachedContent;
        public List<Content> Contents;
        public string SystemInstruction;
        public ToolConfig ToolConfig;
        public List<Tool> tools;
    }

    public class GenerateContentResponse
    {
        public List<GenerateContentCandidate> Candidates;
        public PromptFeedback PromptFeedback;
        public UsageMetadata UsageMetadata;
    }

    public class GenerationConfig
    {
        public int candidateCount = 1;
        public int maxOutputTokens = 8192;
        public string responseMimeType;
        public ResponseSchema responseSchema;
        public List<string> stopSequences;
        public float temperature;
        public int topK;
        public float topP;
    }

    [Serializable]
    public class GenerativeContentBlob
    {
        public string Data;
        public string MimeType;
    }

    [Serializable]
    public class PromptFeedback
    {
        public BlockReason BlockReason;
        public string BlockReasonMessage;
        public List<SafetyRating> SafetyRatings;
    }

    public class ResponseSchema : Schema
    {
    }

    [Serializable]
    public class SafetyRating
    {
        public HarmCategory Category;
        public HarmProbability Probability;
    }

    [Serializable]
    public class SafetySetting
    {
        public HarmCategory Category;
        public HarmBlockThreshold Threshold;
    }

    [Serializable]
    public class Schema
    {
        public string description;
        public FunctionDeclarationSchemaType type;
    }

    [Serializable]
    public class ToolConfig
    {
        public FunctionCallingConfig FunctionCallingConfig;
    }

    [Serializable]
    public class UsageMetadata
    {
        public int cachedContentTokenCount;
        public int candidatesTokenCount;
        public int promptTokenCount;
        public int totalTokenCount;
    }

    [Serializable]
    public class Part
    {
        public string text;
        public GenerativeContentBlob inlineData;
        public FunctionCall functionCall;
        public FunctionResponse functionResponse;
        public FileData fileData;
        public ExecutableCode executableCode;
        public CodeExecutionResult codeExecutionResult;
    }
    
    [Serializable]
    public class ToolRequest
    {
        public List<Content> contents;
        public List<Tool> tools;
    }

    [Serializable]
    public class Tool
    {
        public List<FunctionDeclaration> function_declarations;
    }
} 

// Assets\Sanat\CodeGenerator\ApiGemini\ApiGeminiClasses.cs:
 using System;
using System.Collections.Generic;
using UnityEngine.Serialization;

namespace Sanat.ApiGemini
{
    [Serializable]
    public class ChatMessage
    {
        public string role;
        public string content;

        public ChatMessage(string role, string content)
        {
            this.role = role;
            this.content = content;
        }
    }

    [Serializable]
    public class ChatResponse
    {
        public List<Candidate> candidates;
        public UsageMetadata usageMetadata;
    }

    [Serializable]
    public class Candidate
    {
        public Content content;
        public string finishReason;
        public List<SafetyRating> safetyRatings;
    }

    [Serializable]
    public class Contents
    {
        public string role;
        public Parts parts;
    }

    [Serializable]
    public class Parts
    {
        public string text;
    }

    [Serializable]
    public class SafetySettings
    {
        public string category;
        public string threshold;
    }

    public enum BlockReason
    {
        BLOCKED_REASON_UNSPECIFIED,
        OTHER,
        SAFETY
    }

    public enum ExecutableCodeLanguage
    {
        LANGUAGE_UNSPECIFIED,
        PYTHON
    }

    public enum FinishReason
    {
        FINISH_REASON_UNSPECIFIED,
        LANGUAGE,
        MAX_TOKENS,
        OTHER,
        RECITATION,
        SAFETY,
        STOP
    }

    public enum FunctionCallingMode
    {
        ANY,
        AUTO,
        MODE_UNSPECIFIED,
        NONE
    }

    public enum FunctionDeclarationSchemaType
    {
        ARRAY,
        BOOLEAN,
        INTEGER,
        NUMBER,
        OBJECT,
        STRING
    }

    public enum HarmBlockThreshold
    {
        BLOCK_LOW_AND_ABOVE,
        BLOCK_MEDIUM_AND_ABOVE,
        BLOCK_NONE,
        BLOCK_ONLY_HIGH,
        HARM_BLOCK_THRESHOLD_UNSPECIFIED
    }

    public enum HarmCategory
    {
        HARM_CATEGORY_DANGEROUS_CONTENT,
        HARM_CATEGORY_HARASSMENT,
        HARM_CATEGORY_HATE_SPEECH,
        HARM_CATEGORY_SEXUALLY_EXPLICIT,
        HARM_CATEGORY_UNSPECIFIED
    }

    public enum HarmProbability
    {
        HARM_PROBABILITY_UNSPECIFIED,
        HIGH,
        LOW,
        MEDIUM,
        NEGLIGIBLE
    }

    public enum Outcome
    {
        OUTCOME_DEADLINE_EXCEEDED,
        OUTCOME_FAILED,
        OUTCOME_OK,
        OUTCOME_UNSPECIFIED
    }

    public enum TaskType
    {
        CLASSIFICATION,
        CLUSTERING,
        RETRIEVAL_DOCUMENT,
        RETRIEVAL_QUERY,
        SEMANTIC_SIMILARITY,
        TASK_TYPE_UNSPECIFIED
    }

    public class BaseParams
    {
        public GenerationConfig GenerationConfig;
        public List<SafetySetting> SafetySettings;
    }

    public class BatchEmbedContentsRequest
    {
        public List<EmbedContentRequest> Requests;
    }

    public class BatchEmbedContentsResponse
    {
        public List<ContentEmbedding> Embeddings;
    }

    public class CachedContent : CachedContentBase
    {
        public string CreateTime;
        public string Name;
        public string Ttl;
        public string UpdateTime;
    }

    public class CachedContentBase
    {
        public List<Content> contents;
        public string DisplayName;
        public string ExpireTime;
        public string Model;
        public string SystemInstruction;
        public ToolConfig ToolConfig;
        public List<Tool> tools;
    }

    public class CitationMetadata
    {
        public List<CitationSource> CitationSources;
    }

    public class CitationSource
    {
        public int EndIndex;
        public string License;
        public int StartIndex;
        public string Uri;
    }

    public class CodeExecutionResult
    {
        public Outcome Outcome;
        public string Output;
    }

    public class Content
    {
        public List<Part> parts;
        public string role;
    }

    public class ContentEmbedding
    {
        public List<float> Values;
    }

    public class CountTokensRequest
    {
        public List<Content> Contents;
        public GenerateContentRequest GenerateContentRequest;
    }

    public class CountTokensResponse
    {
        public int TotalTokens;
    }

    public class EmbedContentRequest
    {
        public Content Content;
        public TaskType TaskType;
        public string Title;
    }

    public class EmbedContentResponse
    {
        public ContentEmbedding Embedding;
    }

    public class ExecutableCode
    {
        public string Code;
        public ExecutableCodeLanguage Language;
    }

    public class FileData
    {
        public string FileUri;
        public string MimeType;
    }

    public class FunctionCall
    {
        public object args;
        public string name;
    }

    public class FunctionCallingConfig
    {
        public List<string> AllowedFunctionNames;
        public FunctionCallingMode Mode;
    }

    public class FunctionDeclaration
    {
        public string name;
        public string description;
        public FunctionDeclarationSchema parameters;
    }

    public class FunctionDeclarationSchema
    {
        public FunctionDeclarationSchemaType type;
        public Dictionary<string, FunctionDeclarationSchemaProperty> properties;
        public List<string> required;
    }

    public class FunctionDeclarationSchemaProperty : Schema
    {
    }

    public class FunctionResponse
    {
        public string Name;
        public object Response;
    }

    public class GenerateContentCandidate
    {
        public CitationMetadata CitationMetadata;
        public Content Content;
        public string FinishMessage;
        public FinishReason FinishReason;
        public int Index;
        public List<SafetyRating> SafetyRatings;
    }

    public class GenerateContentRequest : BaseParams
    {
        public string CachedContent;
        public List<Content> Contents;
        public string SystemInstruction;
        public ToolConfig ToolConfig;
        public List<Tool> tools;
    }

    public class GenerateContentResponse
    {
        public List<GenerateContentCandidate> Candidates;
        public PromptFeedback PromptFeedback;
        public UsageMetadata UsageMetadata;
    }

    public class GenerationConfig
    {
        public int candidateCount = 1;
        public int maxOutputTokens = 8192;
        public string responseMimeType;
        public ResponseSchema responseSchema;
        public List<string> stopSequences;
        public float temperature;
        public int topK;
        public float topP;
    }

    [Serializable]
    public class GenerativeContentBlob
    {
        public string Data;
        public string MimeType;
    }

    [Serializable]
    public class PromptFeedback
    {
        public BlockReason BlockReason;
        public string BlockReasonMessage;
        public List<SafetyRating> SafetyRatings;
    }

    public class ResponseSchema : Schema
    {
    }

    [Serializable]
    public class SafetyRating
    {
        public HarmCategory Category;
        public HarmProbability Probability;
    }

    [Serializable]
    public class SafetySetting
    {
        public HarmCategory Category;
        public HarmBlockThreshold Threshold;
    }

    [Serializable]
    public class Schema
    {
        public string description;
        public FunctionDeclarationSchemaType type;
    }

    [Serializable]
    public class ToolConfig
    {
        public FunctionCallingConfig FunctionCallingConfig;
    }

    [Serializable]
    public class UsageMetadata
    {
        public int cachedContentTokenCount;
        public int candidatesTokenCount;
        public int promptTokenCount;
        public int totalTokenCount;
    }

    [Serializable]
    public class Part
    {
        public string text;
        public GenerativeContentBlob inlineData;
        public FunctionCall functionCall;
        public FunctionResponse functionResponse;
        public FileData fileData;
        public ExecutableCode executableCode;
        public CodeExecutionResult codeExecutionResult;
    }
    
    [Serializable]
    public class ToolRequest
    {
        public List<Content> contents;
        public List<Tool> tools;
    }

    [Serializable]
    public class Tool
    {
        public List<FunctionDeclaration> function_declarations;
    }
} 

// Assets\Sanat\CodeGenerator\Editor\CodeGenerator.cs:
 // Copyright (c) Sanat. All rights reserved.
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System;
using System.Text.RegularExpressions;
using Sanat.CodeGenerator.Agents;
using Sanat.CodeGenerator.Extensions;

namespace Sanat.CodeGenerator
{
    public class CodeGenerator : EditorWindow
    {
        private List<string> selectedClassNames = new();
        private Vector2 scrollPosition;
        private Dictionary<string, string> classToPath = new();
        private string classNameInput = "";
        private string generatedPrompt = "";
        private string taskInput = "";
        private float buttonAnimationTime = 1f;
        private float buttonAnimationProgress = 0f;
        private bool isButtonAnimating = false;
        private Color buttonColor = Color.green;
        private bool isSettingsVisible = false;
        private string geminiApiKey = "";
        private string openaiApiKey = "";
        private string antrophicApiKey = "";
        private string groqApiKey = "";
        public static string GeminiProjectName = "";
        private bool _isAwaitingReply;
        private List<string> _ignoredFolders = new();
        private bool isGeneratingCode = false;
        private float generationProgress = 0f;
        private float lastProgressUpdateTime = 0f;
        private float targetProgress = 0f;
        private float progressSpeed = 0.00001f;
        private const string PLUGIN_NAME = "<color=#FFD700>Code Generator</color> ";
        private const string PROMPTS_SAVE_FOLDER = "Sanat/CodeGenerator/Prompts";
        public const string PREFS_GEMINI_PROJECT_NAME = "GeminiProjectName";
        private const string PREFS_KEY_TASK = "Task";
        private List<IncludedFolder> includedFolders = new();
        private const string INCLUDED_FOLDERS_PREFS_KEY = "IncludedFolders";
        public static IncludedFoldersManager IncludedFoldersManager;

        [System.Serializable]
        private class IncludedFolder
        {
            public string path;
            public bool isEnabled;
        }

        [MenuItem("Tools/Sanat/CodeGenerator")]
        public static void ShowWindow()
        {
            GetWindow<CodeGenerator>("Code Generator");
        }

        private void OnGUI()
        {
            GUILayout.Space(10);
            EditorGUILayout.LabelField("Task Description", EditorStyles.boldLabel);
            taskInput = EditorGUILayout.TextArea(taskInput, GUILayout.Height(5 * EditorGUIUtility.singleLineHeight));
            GUILayout.Space(20);
            if (isSettingsVisible)
            {
                DrawSettingsFields();
            }
            EditorGUILayout.LabelField("Select Class Names:", EditorStyles.boldLabel);
            if (GUILayout.Button("Refresh Class List"))
            {
                RefreshClassList();
            }
            string settingsButtonLabel = isSettingsVisible ? "Close Settings" : "Settings";
            if (GUILayout.Button(settingsButtonLabel))
            {
                isSettingsVisible = !isSettingsVisible;
            }
            EditorGUILayout.Space();
            classNameInput = EditorGUILayout.TextField("Class Name", classNameInput);
            if (!string.IsNullOrEmpty(classNameInput))
            {
                List<string> filteredSuggestions = new List<string>();
                foreach (var kv in classToPath)
                {
                    if (!kv.Key.StartsWith(classNameInput, StringComparison.CurrentCultureIgnoreCase))
                        continue;

                    if (_ignoredFolders.Any(ignoredFolder => kv.Value.Contains(ignoredFolder)))
                        continue;

                    filteredSuggestions.Add(kv.Key);
                }
                string[] suggestions = filteredSuggestions.OrderBy(c => c).ToArray();
                if (suggestions.Length > 0)
                {
                    scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(200));
                    foreach (var suggestion in suggestions)
                    {
                        if (GUILayout.Button(suggestion))
                        {
                            if (!selectedClassNames.Contains(suggestion))
                            {
                                selectedClassNames.Add(suggestion);
                            }
                            classNameInput = "";
                            GUI.FocusControl(null);
                        }
                    }
                    EditorGUILayout.EndScrollView();
                }
            }
            EditorGUILayout.Space();
            if (selectedClassNames.Count > 0)
            {
                if (GUILayout.Button("Clear all selected classes"))
                {
                    selectedClassNames.Clear();
                }
                GUILayout.Space(10);
            }
            if (selectedClassNames.Count > 4)
            {
                scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(200));
            }
            for (int i = 0; i < selectedClassNames.Count; i++)
            {
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button("x", GUILayout.Width(40)))
                {
                    selectedClassNames.RemoveAt(i);
                    i--;
                    continue;
                }
                EditorGUILayout.LabelField(selectedClassNames[i]);
                EditorGUILayout.EndHorizontal();
            }
            if (selectedClassNames.Count > 4)
            {
                EditorGUILayout.EndScrollView();
            }
            EditorGUILayout.Space();
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Clear Prompt"))
            {
                generatedPrompt = "";
            }
            GUI.backgroundColor = buttonColor;
            if (GUILayout.Button("Generate Prompt"))
            {
                ExecGeneratePrompt();
            }

            if (isGeneratingCode)
            {
                Rect progressRect = GUILayoutUtility.GetRect(100, 20);
                EditorGUI.ProgressBar(progressRect, generationProgress, $"Generating... {generationProgress * 100:F0}%");
            }
            
            if (GUILayout.Button("Generate Code"))
            {
                ExecGenerateCode();
            }
            GUI.backgroundColor = Color.white;
            EditorGUILayout.EndHorizontal();
            if (!string.IsNullOrEmpty(generatedPrompt))
            {
                GUILayout.Label("Generated Prompt:", EditorStyles.boldLabel);
                scrollPosition = GUILayout.BeginScrollView(scrollPosition, GUILayout.Height(Screen.height * 0.4f));
                generatedPrompt = EditorGUILayout.TextArea(generatedPrompt, GUILayout.Height(20 * EditorGUIUtility.singleLineHeight));
                GUILayout.EndScrollView();
            }
            if (isButtonAnimating)
            {
                Repaint();
            }
        }

        #region Generation
        private void ExecGeneratePrompt()
        {
            Dictionary<string, string> projectCode = new Dictionary<string, string>();
            foreach (string className in selectedClassNames)
            {
                if (classToPath.TryGetValue(className, out string filePath))
                {
                    projectCode[filePath] = File.ReadAllText(filePath);
                }
            }
            
            var includedFolders = IncludedFoldersManager.GetEnabledFolders();
            foreach (var folder in includedFolders)
            {
                string[] files = Directory.GetFiles(folder, "*.cs", SearchOption.AllDirectories);
                foreach (var file in files)
                {
                    projectCode[file] = File.ReadAllText(file);
                }
            }
            
            SaveTaskToPrefs();
            GeneratePrompt(projectCode, 3);
            SavePromptToFile();
            CopyPromptToClipboard();
            StartButtonAnimation();
        }

        private void SaveTaskToPrefs()
        {
            PlayerPrefs.SetString(PREFS_KEY_TASK, taskInput);
            PlayerPrefs.Save();
        }

        private void ExecGenerateCode()
        {
            isGeneratingCode = true;
            generationProgress = 0f;
            targetProgress = .33f;
            lastProgressUpdateTime = (float)EditorApplication.timeSinceStartup;
            EditorApplication.update += UpdateProgressBar;
            Dictionary<string, string> projectCode = new Dictionary<string, string>();
            foreach (string className in selectedClassNames)
            {
                if (classToPath.TryGetValue(className, out string filePath))
                {
                    projectCode[filePath] = File.ReadAllText(filePath);
                }
            }
            SaveTaskToPrefs();
            string[] projectCodePathes = projectCode.Keys.ToArray();
            GeneratePrompt(projectCode);
            SavePromptToFile();
            CopyPromptToClipboard();
            StartButtonAnimation();
            var includedCode = GenerateIncludedCode(projectCode, "", ref generatedPrompt);
            AbstractAgentHandler.ApiKeys apiKeys = new AbstractAgentHandler.ApiKeys(openaiApiKey, antrophicApiKey, groqApiKey, geminiApiKey);
            AgentCodeStrategyArchitector agentCodeStrategyArchitector = new AgentCodeStrategyArchitector(apiKeys, taskInput, includedCode);
            AbstractAgentHandler agentCodeArchitector = new AgentCodeArchitector(apiKeys, taskInput, includedCode);
            AbstractAgentHandler agentSolutionToDicts = new AgentSolutionToDict(apiKeys, projectCodePathes);
            AbstractAgentHandler agentCodeMerger = new AgentCodeMerger(apiKeys, projectCode);
            
            // agentCodeStrategyArchitector.OnComplete += (string result) =>
            // {
            //     Debug.Log($"{agentCodeStrategyArchitector.Name} OnComplete: {result.Substring(0,500)}");
            //     //agentCodeArchitector.Handle(result);
            // };
            // agentCodeStrategyArchitector.Handle("");
            // return;
            agentCodeMerger.OnComplete += (string result) =>
            {
                UpdateProgress(1f);
                isGeneratingCode = false;
                Repaint();
            };
            
            agentCodeArchitector.OnComplete += (string result) =>
            {
                Debug.Log($"{agentCodeArchitector.Name} OnComplete: {result.Substring(0,500)}");
                AbstractAgentHandler agentValidator = new AgentCodeValidator(apiKeys, taskInput, includedCode, result);
                agentValidator.OnComplete += (string validationResult) =>
                {
                    Debug.Log($"Validation result: {validationResult}");
                    NextStepsAfterArchitector(validationResult, agentCodeMerger, apiKeys, result, agentSolutionToDicts);
                };
                agentValidator.Handle(result);
                UpdateProgress(0.33f);
            };
            agentCodeArchitector.SetNext(null);
            agentCodeArchitector.Handle(generatedPrompt);
        }

        private static AbstractAgentHandler NextStepsAfterArchitector(string validationResult,
            AbstractAgentHandler agentCodeMerger, AbstractAgentHandler.ApiKeys apiKeys, string result, AbstractAgentHandler agentSolutionToDicts)
        {
            AgentCodeMerger agentCodeMergerDirect = agentCodeMerger as AgentCodeMerger;
            if (validationResult == "VALID")
            {
                Debug.Log($"Validation successful. Proceeding with code merging. validationResult: {validationResult}");
                agentCodeMergerDirect.InsertCode(result);
            }
            else
            {
                Debug.Log($"Validation failed. Proceeding with code splitting. validationResult: {validationResult}");
                agentSolutionToDicts.OnComplete += (string result) =>
                {
                    Debug.Log($"{agentSolutionToDicts.Name} result({result} chars): {result}");
                    agentCodeMergerDirect.Handle(result);
                };
                agentSolutionToDicts.Handle(result);
            }

            return agentCodeMerger;
        }

        private string GeneratePrompt(Dictionary<string, string> projectCode, int rowsToRemove = 0)
        {
            string includedCode = "";
            string includedCodeRaw = "";
            includedCodeRaw = GenerateIncludedCode(projectCode, includedCodeRaw, ref includedCode);
            includedCode = Regex.Replace(includedCode, @"\s+", " ").Trim();
            string clearedCodeScriptForLLM = includedCodeRaw;
            string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/Unity code architector.md";
            string loadedPrompt = AbstractAgentHandler.LoadPrompt(promptLocation);
            string newPrompt = CodeGeneratorExtensions.RemoveLastNRows(loadedPrompt, rowsToRemove);
            string prompt = newPrompt + $"\n# CODE: {clearedCodeScriptForLLM}\n\n# TASK: {taskInput}";
            generatedPrompt = prompt;
            return clearedCodeScriptForLLM;
        }

        private string GenerateIncludedCode(Dictionary<string, string> projectCode, string includedCodeRaw, ref string includedCode)
        {
            foreach (var kvPathToCode in projectCode)
            {
                foreach (string className in selectedClassNames)
                {
                    if (kvPathToCode.Key.Contains(className))
                    {
                        includedCodeRaw += $"// {kvPathToCode.Key}:\n {kvPathToCode.Value} \n\n";
                        includedCode += File.ReadAllText(kvPathToCode.Key).Replace("\n", "").Replace("\r", "") + "\n\n";
                    }
                }
            }
            
            var includedFolders = IncludedFoldersManager.GetEnabledFolders();
            foreach (var folder in includedFolders)
            {
                string[] files = Directory.GetFiles(folder, "*.cs", SearchOption.AllDirectories);
                foreach (var file in files)
                {
                    includedCodeRaw += $"// {file}:\n {File.ReadAllText(file)} \n\n";
                    includedCode += File.ReadAllText(file).Replace("\n", "").Replace("\r", "") + "\n\n";
                }
            }
            
            return includedCodeRaw;
        }

        #endregion

        #region Progress Bar
        private void UpdateProgress(float progress)
        {
            targetProgress = progress;
            if (progress >= 1f)
            {
                isGeneratingCode = false;
                EditorApplication.update -= UpdateProgressBar;
                Repaint();
            }
        }

        private void UpdateProgressBar()
        {
            float currentTime = (float)EditorApplication.timeSinceStartup;
            if (currentTime - lastProgressUpdateTime >= 0.02f)
            {
                if (generationProgress < targetProgress)
                {
                    generationProgress = Mathf.Min(generationProgress + progressSpeed, targetProgress);
                    lastProgressUpdateTime = currentTime;
                    Repaint();
                }
            }
        }

        #endregion

        #region Settings
        private void DrawSettingsFields()
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel);
            EditorGUILayout.BeginHorizontal();
            InsertApiKeyRow("Gemini API Key", "GeminiApiKey", "https://aistudio.google.com/app/apikey", ref geminiApiKey);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.BeginHorizontal();
            InsertApiKeyRow("OpenAI API Key", "OpenaiApiKey", "https://platform.openai.com/api-keys", ref openaiApiKey);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.BeginHorizontal();
            InsertApiKeyRow("Groq API Key", "GroqApiKey", "https://console.groq.com/keys", ref groqApiKey);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.BeginHorizontal();
            InsertApiKeyRow("Antrophic API Key", "AntrophicApiKey", "https://console.anthropic.com/settings/keys", ref antrophicApiKey);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Ignored Folders:", EditorStyles.boldLabel);
            if (GUILayout.Button("Add Ignored Folder"))
            {
                _ignoredFolders.Add("");
            }
            for (int i = 0; i < _ignoredFolders.Count; i++)
            {
                EditorGUILayout.BeginHorizontal();
                _ignoredFolders[i] = EditorGUILayout.TextField("Folder Path (Ex.: Assets\\Test)", _ignoredFolders[i], GUILayout.ExpandWidth(true));
                if (GUILayout.Button("x", GUILayout.Width(20)))
                {
                    _ignoredFolders.RemoveAt(i);
                }
                EditorGUILayout.EndHorizontal();
            }

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Gemini Project Name", GUILayout.Width(150));
            GeminiProjectName = EditorGUILayout.TextField(GeminiProjectName);
            PlayerPrefs.SetString("GeminiProjectName", GeminiProjectName);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space();
            IncludedFoldersManager.DrawIncludedFoldersUI();
            EditorGUILayout.EndVertical();
            PlayerPrefs.Save();
        }
        #endregion

        private void InsertApiKeyRow(string fieldName, string playerPrefsKey, string url, ref string apiKeyVariable)
        {
            EditorGUILayout.LabelField(fieldName, GUILayout.Width(150));
            apiKeyVariable = EditorGUILayout.PasswordField(apiKeyVariable);
            PlayerPrefs.SetString(playerPrefsKey, apiKeyVariable);
            if (GUILayout.Button("Get Key", GUILayout.Width(70)))
            {
                Application.OpenURL(url);
            }
        }

        private void RefreshClassList()
        {
            Debug.Log($"{PLUGIN_NAME}Refreshing class list...");
            classToPath.Clear();
            Debug.Log($"{PLUGIN_NAME}Current ignored folders count: {_ignoredFolders.Count}");
            foreach (var ignoredFolder in _ignoredFolders)
            {
                Debug.Log($"{PLUGIN_NAME}Ignored folder path: {ignoredFolder}");
            }

            string[] csFiles = Directory.GetFiles("Assets", "*.cs", SearchOption.AllDirectories)
                .Concat(Directory.GetFiles("Packages", "*.cs", SearchOption.AllDirectories))
                .Where(filePath => !_ignoredFolders.Any(ignoredFolder => filePath.Contains(ignoredFolder)))
                .ToArray();
            Debug.Log($"{PLUGIN_NAME}Found {csFiles.Length} .cs files.");
            foreach (string filePath in csFiles)
            {
                string className = Path.GetFileNameWithoutExtension(filePath);
                classToPath[className] = filePath;
            }
            Debug.Log($"{PLUGIN_NAME}Class to path dictionary populated with {classToPath.Count} entries.");
        }

        private void SavePromptToFile()
        {
            string directoryPath = Path.Combine(Application.dataPath, PROMPTS_SAVE_FOLDER);
            if (!Directory.Exists(directoryPath))
            {
                Directory.CreateDirectory(directoryPath);
            }
            string fileName = $"prompt_{DateTime.Now:yyyy-MM-ddTHH-mm-ss}.txt";
            string filePath = Path.Combine(directoryPath, fileName);
            File.WriteAllText(filePath, generatedPrompt);
            Debug.Log($"{PLUGIN_NAME}Prompt of Length = {generatedPrompt.Length} chars   saved to {filePath}");
        }

        private void CopyPromptToClipboard()
        {
            TextEditor te = new TextEditor();
            te.text = generatedPrompt;
            te.SelectAll();
            te.Copy();
        }

        private void StartButtonAnimation()
        {
            isButtonAnimating = true;
            buttonAnimationProgress = 0f;
            buttonColor = Color.yellow;
            EditorApplication.update += UpdateButtonAnimation;
        }

        private void UpdateButtonAnimation()
        {
            buttonAnimationProgress += Time.deltaTime / buttonAnimationTime;
            buttonColor = Color.Lerp(Color.red, Color.green, Mathf.PingPong(buttonAnimationProgress * 2, 1));
            if (buttonAnimationProgress >= 1f)
            {
                isButtonAnimating = false;
                EditorApplication.update -= UpdateButtonAnimation;
            }
        }

        private void OnEnable()
        {
            selectedClassNames = new List<string>(PlayerPrefs.GetString("SelectedClassNames", "").Split(',').Where(s => !string.IsNullOrEmpty(s)));
            geminiApiKey = PlayerPrefs.GetString("GeminiApiKey", "");
            openaiApiKey = PlayerPrefs.GetString("OpenaiApiKey", "");
            groqApiKey = PlayerPrefs.GetString("GroqApiKey", "");
            antrophicApiKey = PlayerPrefs.GetString("AntrophicApiKey", "");
            GeminiProjectName = PlayerPrefs.GetString(PREFS_GEMINI_PROJECT_NAME, "");
            _ignoredFolders = PlayerPrefs.GetString("IgnoredFolders", "").Split(',').Where(s => !string.IsNullOrEmpty(s)).ToList();
            includedFolders = JsonUtility.FromJson<List<IncludedFolder>>(PlayerPrefs.GetString(INCLUDED_FOLDERS_PREFS_KEY, "[]"));
            taskInput = PlayerPrefs.GetString(PREFS_KEY_TASK, "");
            isGeneratingCode = false;
            
            IncludedFoldersManager = new IncludedFoldersManager();
            RefreshClassList();
            CheckAndHandleFirstLaunch();
        }

        private void OnDisable()
        {
            PlayerPrefs.SetString("SelectedClassNames", string.Join(",", selectedClassNames));
            PlayerPrefs.SetString("GeminiApiKey", geminiApiKey);
            PlayerPrefs.SetString("OpenaiApiKey", openaiApiKey);
            PlayerPrefs.SetString("GroqApiKey", groqApiKey);
            PlayerPrefs.SetString("AntrophicApiKey", antrophicApiKey);
            PlayerPrefs.SetString("GeminiProjectName", GeminiProjectName);
            PlayerPrefs.SetString("IgnoredFolders", string.Join(",", _ignoredFolders));
            PlayerPrefs.SetString(INCLUDED_FOLDERS_PREFS_KEY, JsonUtility.ToJson(includedFolders));
            PlayerPrefs.Save();
        }

        private void CheckAndHandleFirstLaunch()
        {
            if (!IsFirstLaunch())
            {
                return;
            }

            Debug.Log($"{PLUGIN_NAME}First launch detected. Adding prompt save folder to .gitignore and ignore.conf files.");
            string assetsParentPath = Directory.GetParent(Application.dataPath).FullName;
            string gitignorePath = Path.Combine(assetsParentPath, ".gitignore");
            string ignoreConfPath = Path.Combine(assetsParentPath, "ignore.conf");
            string folderPathToAdd = Environment.NewLine + "/Assets/" + PROMPTS_SAVE_FOLDER + Environment.NewLine;
            string resultsPathToAdd = Environment.NewLine + "/Assets/" + AbstractAgentHandler.RESULTS_SAVE_FOLDER + Environment.NewLine;
            if (File.Exists(gitignorePath))
            {
                File.AppendAllText(gitignorePath, folderPathToAdd);
                File.AppendAllText(gitignorePath, resultsPathToAdd);
            }
            if (File.Exists(ignoreConfPath))
            {
                File.AppendAllText(ignoreConfPath, folderPathToAdd);
                File.AppendAllText(ignoreConfPath, resultsPathToAdd);
            }
        }

        private bool IsFirstLaunch()
        {
            const string key = "CODE_GENERATOR_FIRST_LAUNCH";
            bool isFirstLaunch = PlayerPrefs.GetInt(key, 1) == 1;
            if (isFirstLaunch)
            {
                PlayerPrefs.SetInt(key, 0);
                PlayerPrefs.Save();
            }
            return isFirstLaunch;
        }
    }
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AbstractAgentHandler.cs:
 // Copyright (c) Sanat. All rights reserved.
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using Sanat.ApiOpenAI;
using Sanat.ApiAnthropic;
using Sanat.ApiGemini;
using Sanat.ApiGroq;
using UnityEngine;
using UnityEngine.Networking;

namespace Sanat.CodeGenerator.Agents
{
    public abstract class AbstractAgentHandler
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public string[] Tools { get; set; }
        public float Temperature { get; set; }
        public string Instructions { get; set; }
        public ApiProviders SelectedApiProvider = ApiProviders.Anthropic;
        public ApiKeys Apikeys;
        public Action<string> OnComplete;
        public Action OnUnsuccessfull;
        public const string RESULTS_SAVE_FOLDER = "Sanat/CodeGenerator/Results";
        public const string KEY_FIGURE_OPEN = "[figureOpen]";
        public const string KEY_FIGURE_CLOSE = "[figureClose]";
        public enum ApiProviders { OpenAI, Anthropic, Groq, Gemini }

        protected void SaveResultToFile(string result)
        {
            string directoryPath = Path.Combine(Application.dataPath, RESULTS_SAVE_FOLDER);
            if (!Directory.Exists(directoryPath))
            {
                Directory.CreateDirectory(directoryPath);
            }
            string fileName = $"result_{Name}_{DateTime.Now:yyyy-MM-ddTHH-mm-ss}.txt";
            string filePath = Path.Combine(directoryPath, fileName);
            File.WriteAllText(filePath, result);
            Debug.Log($"Result saved to: {filePath}");
        }
        
        public AbstractAgentHandler SetNext(AbstractAgentHandler handler)
        {
            _nextHandler = handler;
            return handler;
        }

        protected AbstractAgentHandler _nextHandler;

        protected abstract string PromptFilename();

        protected void StoreOpenAIKey(string key)
        {
            Apikeys.openAI = key;
        }
        
        public void StoreKeys(ApiKeys keys)
        {
            Apikeys = keys;
        }

        protected virtual Model GetModel()
        {
            return Model.GPT4omini;
        }
        
        public static string LoadPrompt(string path)
        {
            if (File.Exists(path))
            {
                try
                {
                    //Debug.Log($"Successfully loaded instructions from: {path}");
                    return File.ReadAllText(path);
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error reading .md file: {e.Message}");
                }
            }
            else
            {
                Debug.LogError("The .md file does not exist in the specified path.");
            }
            return String.Empty;
        }

        public virtual void Handle(string input)
        {
            if (input.Contains("HTTP/1.1 400 Bad Request"))
            {
                OnUnsuccessfull?.Invoke();
                return;
            }
            
            if (input.Contains("HTTP/1.1 401 Unauthorized"))
            {
                OnUnsuccessfull?.Invoke();
                return;
            }
            OnComplete?.Invoke(input);
            // if (_nextHandler != null)
            //     _nextHandler.Handle(input);
        }

        public class BotParameters
        {
            public string prompt;
            public ApiProviders apiProvider;
            public float temp;
            public Action<string> onComplete;
            public ToolRequest geminiToolRequest;
            
            public BotParameters(string prompt, ApiProviders apiProvider, float temp, Action<string> onComplete)
            {
                this.prompt = prompt;
                this.apiProvider = apiProvider;
                this.temp = temp;
                this.onComplete = onComplete;
            }
        }
        
        public void AskBot(BotParameters botParameters) {
            switch (botParameters.apiProvider)
            {
                case ApiProviders.OpenAI:
                    AskChatGpt(botParameters.prompt, botParameters.temp, botParameters.onComplete);
                    break;
                case ApiProviders.Anthropic:
                    AskAntrophic(botParameters.prompt, botParameters.temp, botParameters.onComplete);
                    break;
                case ApiProviders.Groq:
                    AskGroq(botParameters.prompt, botParameters.temp, botParameters.onComplete);
                    break;
                case ApiProviders.Gemini:
                    AskGemini(botParameters.prompt, botParameters.temp, botParameters.onComplete);
                    break;
            }
        }
        
        public void AskChatGpt(string prompt, float temp, Action<string> onComplete) {
            List<ApiOpenAI.ChatMessage> messages = new List<ApiOpenAI.ChatMessage>();
            messages.Add(new ApiOpenAI.ChatMessage("user", prompt));
            var model = GetModel();
            
            UnityWebRequestAsyncOperation request = OpenAI.SubmitChatAsync(
                Apikeys.openAI,
                model,
                temp,
                model.MaxOutput,
                messages,
                onComplete
            );
        }
        
        public void AskAntrophic(string prompt, float temp, Action<string> onComplete) {
            List<ApiAnthropic.ChatMessage> messages = new List<ApiAnthropic.ChatMessage>();
            messages.Add(new ApiAnthropic.ChatMessage("user", prompt));

            UnityWebRequestAsyncOperation request = Anthropic.SubmitChatAsync(
                Apikeys.antrophic,
                ApiAnthropicModels.Claude35,
                temp,
                4000,
                messages,
                onComplete
            );
        }
        
        public void AskGroq(string prompt, float temp, Action<string> onComplete) {
            List<ApiGroq.ChatMessage> messages = new List<ApiGroq.ChatMessage>();
            messages.Add(new ApiGroq.ChatMessage("user", prompt));

            UnityWebRequestAsyncOperation request = Groq.SubmitChatAsync(
                Apikeys.groq,
                ApiGroqModels.Llama3_70b_8192,
                temp,
                4095,
                messages,
                onComplete
            );
        }
        
        protected virtual string GetGeminiModel()
        {
            return ApiGeminiModels.Flash;
        }
        
        public void AskGemini(string prompt, float temp, Action<string> onComplete) {
            List<ApiGemini.ChatMessage> messages = new List<ApiGemini.ChatMessage>();
            messages.Add(new ApiGemini.ChatMessage("user", prompt));

            UnityWebRequestAsyncOperation request = Gemini.SubmitChatAsync(
                Apikeys.gemini,
                GetGeminiModel(), // or whatever model you're using
                temp,
                4095,
                messages,
                onComplete
            );
        }

        public enum Brackets { round, square, curly, angle }
        
        public static string ClearResult(string input, Brackets bracket = Brackets.square)
        {
            string pattern = @"(\[.*\])";
            switch (bracket)
            {
                case Brackets.round:
                    pattern = @"(\(.*\))";
                    break;
                case Brackets.curly:
                    pattern = @"(\{.*\})";
                    break;
                case Brackets.angle:
                    pattern = @"(\<.*\>)";
                    break;
            }
            Match match = Regex.Match(input, pattern, RegexOptions.Singleline);
    
            if (match.Success)
            {
                return match.Groups[1].Value;
            }
            Debug.LogError("No match found");
            return input;
        }

        public struct ApiKeys
        {
            public string openAI;
            public string antrophic;
            public string groq;
            public string gemini;
            
            public ApiKeys(string openAI, string antrophic, string groq, string gemini)
            {
                this.openAI = openAI;
                this.antrophic = antrophic;
                this.groq = groq;
                this.gemini = gemini;
            }
        }
    }
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AbstractAgentHandler.cs:
 // Copyright (c) Sanat. All rights reserved.
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using Sanat.ApiOpenAI;
using Sanat.ApiAnthropic;
using Sanat.ApiGemini;
using Sanat.ApiGroq;
using UnityEngine;
using UnityEngine.Networking;

namespace Sanat.CodeGenerator.Agents
{
    public abstract class AbstractAgentHandler
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public string[] Tools { get; set; }
        public float Temperature { get; set; }
        public string Instructions { get; set; }
        public ApiProviders SelectedApiProvider = ApiProviders.Anthropic;
        public ApiKeys Apikeys;
        public Action<string> OnComplete;
        public Action OnUnsuccessfull;
        public const string RESULTS_SAVE_FOLDER = "Sanat/CodeGenerator/Results";
        public const string KEY_FIGURE_OPEN = "[figureOpen]";
        public const string KEY_FIGURE_CLOSE = "[figureClose]";
        public enum ApiProviders { OpenAI, Anthropic, Groq, Gemini }

        protected void SaveResultToFile(string result)
        {
            string directoryPath = Path.Combine(Application.dataPath, RESULTS_SAVE_FOLDER);
            if (!Directory.Exists(directoryPath))
            {
                Directory.CreateDirectory(directoryPath);
            }
            string fileName = $"result_{Name}_{DateTime.Now:yyyy-MM-ddTHH-mm-ss}.txt";
            string filePath = Path.Combine(directoryPath, fileName);
            File.WriteAllText(filePath, result);
            Debug.Log($"Result saved to: {filePath}");
        }
        
        public AbstractAgentHandler SetNext(AbstractAgentHandler handler)
        {
            _nextHandler = handler;
            return handler;
        }

        protected AbstractAgentHandler _nextHandler;

        protected abstract string PromptFilename();

        protected void StoreOpenAIKey(string key)
        {
            Apikeys.openAI = key;
        }
        
        public void StoreKeys(ApiKeys keys)
        {
            Apikeys = keys;
        }

        protected virtual Model GetModel()
        {
            return Model.GPT4omini;
        }
        
        public static string LoadPrompt(string path)
        {
            if (File.Exists(path))
            {
                try
                {
                    //Debug.Log($"Successfully loaded instructions from: {path}");
                    return File.ReadAllText(path);
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error reading .md file: {e.Message}");
                }
            }
            else
            {
                Debug.LogError("The .md file does not exist in the specified path.");
            }
            return String.Empty;
        }

        public virtual void Handle(string input)
        {
            if (input.Contains("HTTP/1.1 400 Bad Request"))
            {
                OnUnsuccessfull?.Invoke();
                return;
            }
            
            if (input.Contains("HTTP/1.1 401 Unauthorized"))
            {
                OnUnsuccessfull?.Invoke();
                return;
            }
            OnComplete?.Invoke(input);
            // if (_nextHandler != null)
            //     _nextHandler.Handle(input);
        }

        public class BotParameters
        {
            public string prompt;
            public ApiProviders apiProvider;
            public float temp;
            public Action<string> onComplete;
            public ToolRequest geminiToolRequest;
            
            public BotParameters(string prompt, ApiProviders apiProvider, float temp, Action<string> onComplete)
            {
                this.prompt = prompt;
                this.apiProvider = apiProvider;
                this.temp = temp;
                this.onComplete = onComplete;
            }
        }
        
        public void AskBot(BotParameters botParameters) {
            switch (botParameters.apiProvider)
            {
                case ApiProviders.OpenAI:
                    AskChatGpt(botParameters.prompt, botParameters.temp, botParameters.onComplete);
                    break;
                case ApiProviders.Anthropic:
                    AskAntrophic(botParameters.prompt, botParameters.temp, botParameters.onComplete);
                    break;
                case ApiProviders.Groq:
                    AskGroq(botParameters.prompt, botParameters.temp, botParameters.onComplete);
                    break;
                case ApiProviders.Gemini:
                    AskGemini(botParameters.prompt, botParameters.temp, botParameters.onComplete);
                    break;
            }
        }
        
        public void AskChatGpt(string prompt, float temp, Action<string> onComplete) {
            List<ApiOpenAI.ChatMessage> messages = new List<ApiOpenAI.ChatMessage>();
            messages.Add(new ApiOpenAI.ChatMessage("user", prompt));
            var model = GetModel();
            
            UnityWebRequestAsyncOperation request = OpenAI.SubmitChatAsync(
                Apikeys.openAI,
                model,
                temp,
                model.MaxOutput,
                messages,
                onComplete
            );
        }
        
        public void AskAntrophic(string prompt, float temp, Action<string> onComplete) {
            List<ApiAnthropic.ChatMessage> messages = new List<ApiAnthropic.ChatMessage>();
            messages.Add(new ApiAnthropic.ChatMessage("user", prompt));

            UnityWebRequestAsyncOperation request = Anthropic.SubmitChatAsync(
                Apikeys.antrophic,
                ApiAnthropicModels.Claude35,
                temp,
                4000,
                messages,
                onComplete
            );
        }
        
        public void AskGroq(string prompt, float temp, Action<string> onComplete) {
            List<ApiGroq.ChatMessage> messages = new List<ApiGroq.ChatMessage>();
            messages.Add(new ApiGroq.ChatMessage("user", prompt));

            UnityWebRequestAsyncOperation request = Groq.SubmitChatAsync(
                Apikeys.groq,
                ApiGroqModels.Llama3_70b_8192,
                temp,
                4095,
                messages,
                onComplete
            );
        }
        
        protected virtual string GetGeminiModel()
        {
            return ApiGeminiModels.Flash;
        }
        
        public void AskGemini(string prompt, float temp, Action<string> onComplete) {
            List<ApiGemini.ChatMessage> messages = new List<ApiGemini.ChatMessage>();
            messages.Add(new ApiGemini.ChatMessage("user", prompt));

            UnityWebRequestAsyncOperation request = Gemini.SubmitChatAsync(
                Apikeys.gemini,
                GetGeminiModel(), // or whatever model you're using
                temp,
                4095,
                messages,
                onComplete
            );
        }

        public enum Brackets { round, square, curly, angle }
        
        public static string ClearResult(string input, Brackets bracket = Brackets.square)
        {
            string pattern = @"(\[.*\])";
            switch (bracket)
            {
                case Brackets.round:
                    pattern = @"(\(.*\))";
                    break;
                case Brackets.curly:
                    pattern = @"(\{.*\})";
                    break;
                case Brackets.angle:
                    pattern = @"(\<.*\>)";
                    break;
            }
            Match match = Regex.Match(input, pattern, RegexOptions.Singleline);
    
            if (match.Success)
            {
                return match.Groups[1].Value;
            }
            Debug.LogError("No match found");
            return input;
        }

        public struct ApiKeys
        {
            public string openAI;
            public string antrophic;
            public string groq;
            public string gemini;
            
            public ApiKeys(string openAI, string antrophic, string groq, string gemini)
            {
                this.openAI = openAI;
                this.antrophic = antrophic;
                this.groq = groq;
                this.gemini = gemini;
            }
        }
    }
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AgentCodeArchitector.cs:
 // Copyright (c) Sanat. All rights reserved.

using Sanat.ApiGemini;
using UnityEngine;

namespace Sanat.CodeGenerator.Agents
{
    public class AgentCodeArchitector : AbstractAgentHandler
    {
        private string _prompt;

        protected override string PromptFilename()
        {
            return "Unity code architector.md";
        }
        
        public AgentCodeArchitector(ApiKeys apiKeys, string task, string includedCode)
        {
            Name = "Agent Unity3D Architect";
            Description = "Writes code for agents";
            Temperature = .2f;
            StoreKeys(apiKeys);
            string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
            Instructions = LoadPrompt(promptLocation);
            _prompt = $"{Instructions} # TASK: {task}. # CODE: " + includedCode;
            SelectedApiProvider = ApiProviders.Gemini;
        }
        
        protected override string GetGeminiModel()
        {
            return ApiGeminiModels.Pro;
        }

        public override void Handle(string input)
        {
            Debug.Log($"<color=purple>{Name}</color> asking: {_prompt}");
            BotParameters botParameters = new BotParameters(_prompt, SelectedApiProvider, Temperature, delegate(string result)
            {
                Debug.Log($"<color=purple>{Name}</color> result: {result}");
                OnComplete?.Invoke(result);
                SaveResultToFile(result);
            });
            AskBot(botParameters);
        }
    }
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AgentCodeArchitector.cs:
 // Copyright (c) Sanat. All rights reserved.

using Sanat.ApiGemini;
using UnityEngine;

namespace Sanat.CodeGenerator.Agents
{
    public class AgentCodeArchitector : AbstractAgentHandler
    {
        private string _prompt;

        protected override string PromptFilename()
        {
            return "Unity code architector.md";
        }
        
        public AgentCodeArchitector(ApiKeys apiKeys, string task, string includedCode)
        {
            Name = "Agent Unity3D Architect";
            Description = "Writes code for agents";
            Temperature = .2f;
            StoreKeys(apiKeys);
            string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
            Instructions = LoadPrompt(promptLocation);
            _prompt = $"{Instructions} # TASK: {task}. # CODE: " + includedCode;
            SelectedApiProvider = ApiProviders.Gemini;
        }
        
        protected override string GetGeminiModel()
        {
            return ApiGeminiModels.Pro;
        }

        public override void Handle(string input)
        {
            Debug.Log($"<color=purple>{Name}</color> asking: {_prompt}");
            BotParameters botParameters = new BotParameters(_prompt, SelectedApiProvider, Temperature, delegate(string result)
            {
                Debug.Log($"<color=purple>{Name}</color> result: {result}");
                OnComplete?.Invoke(result);
                SaveResultToFile(result);
            });
            AskBot(botParameters);
        }
    }
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AgentCodeMerger.cs:
 // Copyright (c) Sanat. All rights reserved.
using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Sanat.ApiGemini;
using Sanat.ApiOpenAI;

namespace Sanat.CodeGenerator.Agents
{
	public class AgentCodeMerger : AbstractAgentHandler
	{
		private Dictionary<string, string> _projectCode = new ();
		private const string PROMPT_FILE_PATH_EXTRACT = "PromptAgentCodeMergerFilePathExtract.md";
		
		protected override string PromptFilename() => 
			"AgentCodeMerger.md";
		
		protected override Model GetModel() => 
			Model.GPT4omini;
        
		protected override string GetGeminiModel() => 
			ApiGeminiModels.Flash;

		public AgentCodeMerger(ApiKeys apiKeys, Dictionary<string, string> projectCode)
		{
			Name = "Agent Code Merger";
			Description = "Merges code snippets";
			Temperature = .0f;
			string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
			Instructions = LoadPrompt(promptLocation);
			StoreKeys(apiKeys);
			_projectCode = projectCode;
			SelectedApiProvider = ApiProviders.Gemini;
		}

		public AgentCodeMerger(ApiKeys apiKeys, string singelFileSolution)
		{
			Name = "Agent Code Merger";
			Description = "Merges code snippets";
			Temperature = .0f;
			string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
			Instructions = LoadPrompt(promptLocation);
			StoreKeys(apiKeys);
			SelectedApiProvider = ApiProviders.Gemini;
		}
		
		public void InsertCode(string solutionInput)
		{
			GetFilePath(solutionInput, (result) =>
			{
				DirectInsertion(result, solutionInput);
			});
		}

		private void GetFilePath(string solutionInput, Action<string> callback)
		{
			string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PROMPT_FILE_PATH_EXTRACT}";
			string prompt = LoadPrompt(promptLocation);
			string question = prompt + solutionInput;
			BotParameters botParameters = new BotParameters(question, ApiProviders.Groq, .0f, callback);
			AskBot(botParameters);
		}

		public override void Handle(string input)
		{
			string clearedJson = ClearResult(input);
			Debug.Log($"<color=cyan>{Name}</color> working with this solution({clearedJson.Length} chars): {clearedJson}");
			List<FileContent> codeSnippets;
			try
			{
				string convertedJson = TranslateToValidJson(clearedJson);
				var settings = new JsonSerializerSettings { StringEscapeHandling = StringEscapeHandling.EscapeHtml };
				codeSnippets = JsonConvert.DeserializeObject<List<FileContent>>(convertedJson, settings);
				foreach (FileContent snippet in codeSnippets)
				{
					string filePath = snippet.FilePath;
					string code = snippet.Content;
				
					Debug.Log("FilePath: " + filePath);
					Debug.Log("Content: " + code);
					if (code == String.Empty)
						continue;
				
					code = TranslateFromValidJson(code);
					DirectInsertion(filePath, code);
				}
			}catch(Exception ex)
			{
				Debug.Log($"<color=cyan>{Name}</color> <color=red>ERROR!</color> Could not parse the solution. Trying different approach. Exception: {ex.Message}");
				codeSnippets = ParseJson(clearedJson);
				foreach (FileContent snippet in codeSnippets)
				{
					string filePath = snippet.FilePath;
					string code = snippet.Content;
				
					Debug.Log("FilePath: " + filePath);
					Debug.Log($"Content({code.Length} chars): " + code);
					if (code == String.Empty)
						continue;
				
					string request = "Pretty print the code for direct insertion to file. Dont say anything, just provide the code. DONT SKIP ANY CODE OR KITTENS WILL DIE PLEASE PLEASE PLEASE. # CODE:";
					string prompt = $"{request}{code}";
					BotParameters botParameters = new BotParameters(prompt, SelectedApiProvider, Temperature, delegate(string result)
					{
						Debug.Log($"<color=purple>{Name}</color> result({result} chars): {result}");
					
						var match = Regex.Match(result, @"```\s*([\s\S]+)```");
						string formattedCode = match.Groups[1].Value;
						DirectInsertion(filePath, formattedCode);
					});
					AskBot(botParameters);
				}
			}

			if (_nextHandler != null)
			{
				_nextHandler.Handle(input);
			}
		}

		private string TranslateToValidJson(string clearedJson)
		{
			string convertedJson = clearedJson.Replace("{", KEY_FIGURE_OPEN);
			convertedJson = convertedJson.Replace("}", KEY_FIGURE_CLOSE);
			return convertedJson;
		}
		
		private string TranslateFromValidJson(string clearedJson)
		{
			string convertedJson = clearedJson.Replace(KEY_FIGURE_OPEN, "{");
			convertedJson = convertedJson.Replace(KEY_FIGURE_CLOSE, "}");
			return convertedJson;
		}

		public List<FileContent> ParseJson(string json)
		{
			string filePathPattern = @"""FilePath"":\s*""([^""]+)""";
			string contentPattern = @"""Content"":\s*""((?:[^""\\]|\\.)*)""";

			var filePathMatches = Regex.Matches(json, filePathPattern);
			var contentMatches = Regex.Matches(json, contentPattern);

			List<FileContent> filePathList = new List<FileContent>();
			
			for (int i = 0; i < filePathMatches.Count; i++)
			{
				string filePath = filePathMatches[i].Groups[1].Value;
				string content = contentMatches[i].Groups[1].Value;
				filePathList.Add(new FileContent { FilePath = filePath, Content = content });
			}

			return filePathList;
		}

		protected void DirectInsertion(string filePath, string code)
		{
			SaveResultToFile(code);
			filePath = filePath.Replace(":", string.Empty);
			// Create the directory if it doesn't exist
			string directoryPath = Path.GetDirectoryName(filePath);
			if (!Directory.Exists(directoryPath))
			{
				Directory.CreateDirectory(directoryPath);
			}
			if (!File.Exists(filePath))
			{
				File.Create(filePath).Dispose();
			}

			File.SetAttributes(filePath, FileAttributes.Normal);
			File.WriteAllText(filePath, code, Encoding.UTF8);
			Debug.Log($"<color=cyan>{Name}</color> <color=green>COMPLETED!</color> [{filePath}] Direct insertion:\n{code}");
		}

		private void MergeCode(string filePath, string solutionInput)
		{
			ParsedCodeData bakedCode = new ParsedCodeData();
			if (_projectCode.ContainsKey(filePath))
			{
				bakedCode = ToCustomJson(filePath, _projectCode[filePath]);
			}
			else
			{
				string slashesFixed = filePath.Replace("/", @"\");
				bakedCode = ToCustomJson(filePath, _projectCode[slashesFixed]);
			}
			string newInstructions = Instructions.Replace("@CODE@", JsonConvert.SerializeObject(bakedCode, Formatting.Indented));
			newInstructions = newInstructions.Replace("@DELTA@", solutionInput);
			Debug.Log($"<color=cyan>{Name}</color> asking: {newInstructions}");
			AskAntrophic(newInstructions, .0f, (jsonResponse) =>
			{
				Debug.Log($"<color=cyan>{Name}</color> result: {jsonResponse}");
        
				string clearedJson = ClearResult(jsonResponse, Brackets.curly);
				ParsedCodeData parsedCodeData = JsonConvert.DeserializeObject<ParsedCodeData>(clearedJson);
        
				string mergedCode = MergeCodeParts(bakedCode, parsedCodeData);

				File.WriteAllText(filePath, mergedCode);
				Debug.Log($"<color=cyan>{Name}</color> <color=green>COMPLETED!</color> {filePath} Merged code:\n{mergedCode}");
				OnComplete?.Invoke(mergedCode);
			});
		}
		
		private string MergeCodeParts(ParsedCodeData oldCode, ParsedCodeData newCode)
		{
			StringBuilder mergedCode = new StringBuilder();
			
			string preparedLibraries = MergeRows(oldCode.Libraries, newCode.Libraries);
			mergedCode.AppendLine(preparedLibraries);
			mergedCode.AppendLine();
			Debug.Log($"<color=cyan>{Name}</color> Merged libraries: \n{mergedCode}");
			
			bool isNamespaceExist = false;
			if (!string.IsNullOrEmpty(oldCode.Namespace))
			{
				mergedCode.AppendLine($"namespace {oldCode.Namespace}");
				mergedCode.AppendLine("{");
				isNamespaceExist = true;
			}
			Debug.Log($"<color=cyan>{Name}</color> Merged namespace: \n{mergedCode}");
			
			mergedCode.AppendLine(oldCode.ClassDeclaration);
			mergedCode.AppendLine("{");
			Debug.Log($"<color=cyan>{Name}</color> Merged class declaration: \n{mergedCode}");
			
			string preparedFields = MergeRows(oldCode.Fields, newCode.Fields);
			mergedCode.AppendLine(preparedFields);
			mergedCode.AppendLine();
			Debug.Log($"<color=cyan>{Name}</color> Merged fields: \n{mergedCode}");
			
			Dictionary<string, string> parsedMethods = newCode.Methods.ToDictionary(m => m.MethodName, m => m.MethodBody);

			UpdateOldCodeMethodsFromNewCode(oldCode, parsedMethods, mergedCode);
			Debug.Log($"<color=cyan>{Name}</color> Merged methods: \n{mergedCode}");
			
			AddOldMethodsNotInNewCode(oldCode, mergedCode);
			Debug.Log($"<color=cyan>{Name}</color> Merged old methods: \n{mergedCode}");
			
			mergedCode.AppendLine("}");
			if (isNamespaceExist)
			{
				mergedCode.AppendLine("}");
			}
			
			return mergedCode.ToString();
		}

		private void AddOldMethodsNotInNewCode(ParsedCodeData oldCode, StringBuilder mergedCode)
		{
			foreach (var method in oldCode.Methods)
			{
				AddMethodToMergedCode(mergedCode, method.MethodBody);
				mergedCode.AppendLine();
			}
		}

		private static void UpdateOldCodeMethodsFromNewCode(ParsedCodeData oldCode, Dictionary<string, string> parsedMethods, StringBuilder mergedCode)
		{
			List<MethodData> updatedMethods = new List<MethodData>(oldCode.Methods);
			foreach (var method in updatedMethods)
			{
				if (parsedMethods.TryGetValue(method.MethodName, out string updatedMethodBody))
				{
					// If the method exists in parsedCodeData, use the updated method body
					AddMethodToMergedCode(mergedCode, updatedMethodBody);
					var foundMethod = oldCode.Methods.Find(m => m.MethodName == method.MethodName);
					if (foundMethod != null)
					{
						oldCode.Methods.Remove(foundMethod);
					}
				}
				else
				{
					// If the method doesn't exist in parsedCodeData, use the original method body
					mergedCode.AppendLine(method.MethodBody);
				}

				mergedCode.AppendLine();
			}
		}

		private static void AddMethodToMergedCode(StringBuilder mergedCode, string updatedMethodBody)
		{
			mergedCode.AppendLine($"\r{updatedMethodBody}");
		}

		private string MergeRows(string rowsA, string rowsB)
		{
			if (rowsB == null || rowsB.Length == 0)
			{
				return rowsA;
			}
			
			string[] bakedLibraries = rowsA.Split('\n');
			string[] newLibraries = rowsB.Split('\n');
			HashSet<string> mergedLibraries = new HashSet<string>(bakedLibraries);
			mergedLibraries.UnionWith(newLibraries);
			string mergedRows = string.Join("\n", mergedLibraries);
			return mergedRows;
		}

		private ParsedCodeData ToCustomJson(string filePath, string codeRaw)
		{
			string libraries = ParseLibraries(codeRaw);
			string nameSpace = ParseNamespace(codeRaw);
			string classDeclaration = ParseClassName(codeRaw);
			string fields = ParseFields(codeRaw);
			List<MethodData> methods = ParseMethods(codeRaw);

			return new ParsedCodeData
			{
				FilePath = filePath,
				Libraries = libraries,
				Namespace = nameSpace,
				ClassDeclaration = classDeclaration,
				Fields = fields,
				Methods = methods
			};
		}

		private string ParseNamespace(string codeRaw)
		{
			string pattern = @"namespace\s+([\w.]+)\s*\{";
			Match match = Regex.Match(codeRaw, pattern);

			if (match.Success)
			{
				return match.Groups[1].Value.Trim();
			}

			return string.Empty;
		}

		#region Parsers
		private string ParseClassName(string codeRaw)
		{
			string pattern = @"(?:public|private|protected|internal)?\s*(sealed|abstract|static)?\s*class\s+(\w+)\s*(:\s*[\w,\s<>]+)?";
			Match match = Regex.Match(codeRaw, pattern);
    
			if (match.Success)
			{
				string modifiers = match.Groups[1].Value.Trim();
				string className = match.Groups[2].Value.Trim();
				string inheritance = match.Groups[3].Value.Trim();

				string fullClassDeclaration = $"public {modifiers} class {className} {inheritance}".Trim();
				return fullClassDeclaration.Replace("  ", " ");
			}
    
			return string.Empty;
		}

		private List<MethodData> ParseMethods(string codeRaw)
		{
			List<MethodData> methods = new List<MethodData>();
			string pattern = @"(?:public|private|protected|internal|static)?\s+(?:void|[\w<>[\]]+)\s+(\w+)\s*\([^)]*\)\s*(?:where\s+[^{]+)?\s*\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}";

			MatchCollection matches = Regex.Matches(codeRaw, pattern, RegexOptions.Singleline);

			foreach (Match match in matches)
			{
				string methodName = match.Groups[1].Value;
				string methodBody = match.Value.Trim();
				methods.Add(new MethodData { MethodName = methodName, MethodBody = methodBody });
			}

			return methods;
		}

		private string ParseFields(string codeRaw)
		{
			List<string> fields = new List<string>();
			string pattern = @"(?:public|private|protected|internal|static)?\s+(?:readonly\s+)?(?!using|return|class|void|enum)[\w<>[\]]+\s+\w+(?:\s*=\s*(?![^;]*\()[^;]+)?;";
			
			MatchCollection matches = Regex.Matches(codeRaw, pattern);
    
			foreach (Match match in matches)
			{
				fields.Add(match.Value.Trim());
			}
    
			return string.Join("\n", fields);
		}

		private string ParseLibraries(string codeRaw)
		{
			List<string> libraries = new List<string>();
			string pattern = @"using\s+[\w.]+;";
    
			MatchCollection matches = Regex.Matches(codeRaw, pattern);
    
			foreach (Match match in matches)
			{
				libraries.Add(match.Value.Trim());
			}
    
			return string.Join("\n", libraries);
		}
		#endregion
		
		public class ParsedCodeData
		{
			public string Namespace { get; set; }
			public string FilePath { get; set; }
			public string Libraries { get; set; }
			public string ClassDeclaration { get; set; }
			public string Fields { get; set; }
			public List<MethodData> Methods { get; set; }
		}
		
		public class MethodData
		{
			public string MethodName { get; set; }
			public string MethodBody { get; set; }
		}
		
		public class FileContent
		{
			public string FilePath { get; set; }
			public string Content { get; set; }
		}
	}
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AgentCodeMerger.cs:
 // Copyright (c) Sanat. All rights reserved.
using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Sanat.ApiGemini;
using Sanat.ApiOpenAI;

namespace Sanat.CodeGenerator.Agents
{
	public class AgentCodeMerger : AbstractAgentHandler
	{
		private Dictionary<string, string> _projectCode = new ();
		private const string PROMPT_FILE_PATH_EXTRACT = "PromptAgentCodeMergerFilePathExtract.md";
		
		protected override string PromptFilename() => 
			"AgentCodeMerger.md";
		
		protected override Model GetModel() => 
			Model.GPT4omini;
        
		protected override string GetGeminiModel() => 
			ApiGeminiModels.Flash;

		public AgentCodeMerger(ApiKeys apiKeys, Dictionary<string, string> projectCode)
		{
			Name = "Agent Code Merger";
			Description = "Merges code snippets";
			Temperature = .0f;
			string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
			Instructions = LoadPrompt(promptLocation);
			StoreKeys(apiKeys);
			_projectCode = projectCode;
			SelectedApiProvider = ApiProviders.Gemini;
		}

		public AgentCodeMerger(ApiKeys apiKeys, string singelFileSolution)
		{
			Name = "Agent Code Merger";
			Description = "Merges code snippets";
			Temperature = .0f;
			string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
			Instructions = LoadPrompt(promptLocation);
			StoreKeys(apiKeys);
			SelectedApiProvider = ApiProviders.Gemini;
		}
		
		public void InsertCode(string solutionInput)
		{
			GetFilePath(solutionInput, (result) =>
			{
				DirectInsertion(result, solutionInput);
			});
		}

		private void GetFilePath(string solutionInput, Action<string> callback)
		{
			string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PROMPT_FILE_PATH_EXTRACT}";
			string prompt = LoadPrompt(promptLocation);
			string question = prompt + solutionInput;
			BotParameters botParameters = new BotParameters(question, ApiProviders.Groq, .0f, callback);
			AskBot(botParameters);
		}

		public override void Handle(string input)
		{
			string clearedJson = ClearResult(input);
			Debug.Log($"<color=cyan>{Name}</color> working with this solution({clearedJson.Length} chars): {clearedJson}");
			List<FileContent> codeSnippets;
			try
			{
				string convertedJson = TranslateToValidJson(clearedJson);
				var settings = new JsonSerializerSettings { StringEscapeHandling = StringEscapeHandling.EscapeHtml };
				codeSnippets = JsonConvert.DeserializeObject<List<FileContent>>(convertedJson, settings);
				foreach (FileContent snippet in codeSnippets)
				{
					string filePath = snippet.FilePath;
					string code = snippet.Content;
				
					Debug.Log("FilePath: " + filePath);
					Debug.Log("Content: " + code);
					if (code == String.Empty)
						continue;
				
					code = TranslateFromValidJson(code);
					DirectInsertion(filePath, code);
				}
			}catch(Exception ex)
			{
				Debug.Log($"<color=cyan>{Name}</color> <color=red>ERROR!</color> Could not parse the solution. Trying different approach. Exception: {ex.Message}");
				codeSnippets = ParseJson(clearedJson);
				foreach (FileContent snippet in codeSnippets)
				{
					string filePath = snippet.FilePath;
					string code = snippet.Content;
				
					Debug.Log("FilePath: " + filePath);
					Debug.Log($"Content({code.Length} chars): " + code);
					if (code == String.Empty)
						continue;
				
					string request = "Pretty print the code for direct insertion to file. Dont say anything, just provide the code. DONT SKIP ANY CODE OR KITTENS WILL DIE PLEASE PLEASE PLEASE. # CODE:";
					string prompt = $"{request}{code}";
					BotParameters botParameters = new BotParameters(prompt, SelectedApiProvider, Temperature, delegate(string result)
					{
						Debug.Log($"<color=purple>{Name}</color> result({result} chars): {result}");
					
						var match = Regex.Match(result, @"```\s*([\s\S]+)```");
						string formattedCode = match.Groups[1].Value;
						DirectInsertion(filePath, formattedCode);
					});
					AskBot(botParameters);
				}
			}

			if (_nextHandler != null)
			{
				_nextHandler.Handle(input);
			}
		}

		private string TranslateToValidJson(string clearedJson)
		{
			string convertedJson = clearedJson.Replace("{", KEY_FIGURE_OPEN);
			convertedJson = convertedJson.Replace("}", KEY_FIGURE_CLOSE);
			return convertedJson;
		}
		
		private string TranslateFromValidJson(string clearedJson)
		{
			string convertedJson = clearedJson.Replace(KEY_FIGURE_OPEN, "{");
			convertedJson = convertedJson.Replace(KEY_FIGURE_CLOSE, "}");
			return convertedJson;
		}

		public List<FileContent> ParseJson(string json)
		{
			string filePathPattern = @"""FilePath"":\s*""([^""]+)""";
			string contentPattern = @"""Content"":\s*""((?:[^""\\]|\\.)*)""";

			var filePathMatches = Regex.Matches(json, filePathPattern);
			var contentMatches = Regex.Matches(json, contentPattern);

			List<FileContent> filePathList = new List<FileContent>();
			
			for (int i = 0; i < filePathMatches.Count; i++)
			{
				string filePath = filePathMatches[i].Groups[1].Value;
				string content = contentMatches[i].Groups[1].Value;
				filePathList.Add(new FileContent { FilePath = filePath, Content = content });
			}

			return filePathList;
		}

		protected void DirectInsertion(string filePath, string code)
		{
			SaveResultToFile(code);
			filePath = filePath.Replace(":", string.Empty);
			// Create the directory if it doesn't exist
			string directoryPath = Path.GetDirectoryName(filePath);
			if (!Directory.Exists(directoryPath))
			{
				Directory.CreateDirectory(directoryPath);
			}
			if (!File.Exists(filePath))
			{
				File.Create(filePath).Dispose();
			}

			File.SetAttributes(filePath, FileAttributes.Normal);
			File.WriteAllText(filePath, code, Encoding.UTF8);
			Debug.Log($"<color=cyan>{Name}</color> <color=green>COMPLETED!</color> [{filePath}] Direct insertion:\n{code}");
		}

		private void MergeCode(string filePath, string solutionInput)
		{
			ParsedCodeData bakedCode = new ParsedCodeData();
			if (_projectCode.ContainsKey(filePath))
			{
				bakedCode = ToCustomJson(filePath, _projectCode[filePath]);
			}
			else
			{
				string slashesFixed = filePath.Replace("/", @"\");
				bakedCode = ToCustomJson(filePath, _projectCode[slashesFixed]);
			}
			string newInstructions = Instructions.Replace("@CODE@", JsonConvert.SerializeObject(bakedCode, Formatting.Indented));
			newInstructions = newInstructions.Replace("@DELTA@", solutionInput);
			Debug.Log($"<color=cyan>{Name}</color> asking: {newInstructions}");
			AskAntrophic(newInstructions, .0f, (jsonResponse) =>
			{
				Debug.Log($"<color=cyan>{Name}</color> result: {jsonResponse}");
        
				string clearedJson = ClearResult(jsonResponse, Brackets.curly);
				ParsedCodeData parsedCodeData = JsonConvert.DeserializeObject<ParsedCodeData>(clearedJson);
        
				string mergedCode = MergeCodeParts(bakedCode, parsedCodeData);

				File.WriteAllText(filePath, mergedCode);
				Debug.Log($"<color=cyan>{Name}</color> <color=green>COMPLETED!</color> {filePath} Merged code:\n{mergedCode}");
				OnComplete?.Invoke(mergedCode);
			});
		}
		
		private string MergeCodeParts(ParsedCodeData oldCode, ParsedCodeData newCode)
		{
			StringBuilder mergedCode = new StringBuilder();
			
			string preparedLibraries = MergeRows(oldCode.Libraries, newCode.Libraries);
			mergedCode.AppendLine(preparedLibraries);
			mergedCode.AppendLine();
			Debug.Log($"<color=cyan>{Name}</color> Merged libraries: \n{mergedCode}");
			
			bool isNamespaceExist = false;
			if (!string.IsNullOrEmpty(oldCode.Namespace))
			{
				mergedCode.AppendLine($"namespace {oldCode.Namespace}");
				mergedCode.AppendLine("{");
				isNamespaceExist = true;
			}
			Debug.Log($"<color=cyan>{Name}</color> Merged namespace: \n{mergedCode}");
			
			mergedCode.AppendLine(oldCode.ClassDeclaration);
			mergedCode.AppendLine("{");
			Debug.Log($"<color=cyan>{Name}</color> Merged class declaration: \n{mergedCode}");
			
			string preparedFields = MergeRows(oldCode.Fields, newCode.Fields);
			mergedCode.AppendLine(preparedFields);
			mergedCode.AppendLine();
			Debug.Log($"<color=cyan>{Name}</color> Merged fields: \n{mergedCode}");
			
			Dictionary<string, string> parsedMethods = newCode.Methods.ToDictionary(m => m.MethodName, m => m.MethodBody);

			UpdateOldCodeMethodsFromNewCode(oldCode, parsedMethods, mergedCode);
			Debug.Log($"<color=cyan>{Name}</color> Merged methods: \n{mergedCode}");
			
			AddOldMethodsNotInNewCode(oldCode, mergedCode);
			Debug.Log($"<color=cyan>{Name}</color> Merged old methods: \n{mergedCode}");
			
			mergedCode.AppendLine("}");
			if (isNamespaceExist)
			{
				mergedCode.AppendLine("}");
			}
			
			return mergedCode.ToString();
		}

		private void AddOldMethodsNotInNewCode(ParsedCodeData oldCode, StringBuilder mergedCode)
		{
			foreach (var method in oldCode.Methods)
			{
				AddMethodToMergedCode(mergedCode, method.MethodBody);
				mergedCode.AppendLine();
			}
		}

		private static void UpdateOldCodeMethodsFromNewCode(ParsedCodeData oldCode, Dictionary<string, string> parsedMethods, StringBuilder mergedCode)
		{
			List<MethodData> updatedMethods = new List<MethodData>(oldCode.Methods);
			foreach (var method in updatedMethods)
			{
				if (parsedMethods.TryGetValue(method.MethodName, out string updatedMethodBody))
				{
					// If the method exists in parsedCodeData, use the updated method body
					AddMethodToMergedCode(mergedCode, updatedMethodBody);
					var foundMethod = oldCode.Methods.Find(m => m.MethodName == method.MethodName);
					if (foundMethod != null)
					{
						oldCode.Methods.Remove(foundMethod);
					}
				}
				else
				{
					// If the method doesn't exist in parsedCodeData, use the original method body
					mergedCode.AppendLine(method.MethodBody);
				}

				mergedCode.AppendLine();
			}
		}

		private static void AddMethodToMergedCode(StringBuilder mergedCode, string updatedMethodBody)
		{
			mergedCode.AppendLine($"\r{updatedMethodBody}");
		}

		private string MergeRows(string rowsA, string rowsB)
		{
			if (rowsB == null || rowsB.Length == 0)
			{
				return rowsA;
			}
			
			string[] bakedLibraries = rowsA.Split('\n');
			string[] newLibraries = rowsB.Split('\n');
			HashSet<string> mergedLibraries = new HashSet<string>(bakedLibraries);
			mergedLibraries.UnionWith(newLibraries);
			string mergedRows = string.Join("\n", mergedLibraries);
			return mergedRows;
		}

		private ParsedCodeData ToCustomJson(string filePath, string codeRaw)
		{
			string libraries = ParseLibraries(codeRaw);
			string nameSpace = ParseNamespace(codeRaw);
			string classDeclaration = ParseClassName(codeRaw);
			string fields = ParseFields(codeRaw);
			List<MethodData> methods = ParseMethods(codeRaw);

			return new ParsedCodeData
			{
				FilePath = filePath,
				Libraries = libraries,
				Namespace = nameSpace,
				ClassDeclaration = classDeclaration,
				Fields = fields,
				Methods = methods
			};
		}

		private string ParseNamespace(string codeRaw)
		{
			string pattern = @"namespace\s+([\w.]+)\s*\{";
			Match match = Regex.Match(codeRaw, pattern);

			if (match.Success)
			{
				return match.Groups[1].Value.Trim();
			}

			return string.Empty;
		}

		#region Parsers
		private string ParseClassName(string codeRaw)
		{
			string pattern = @"(?:public|private|protected|internal)?\s*(sealed|abstract|static)?\s*class\s+(\w+)\s*(:\s*[\w,\s<>]+)?";
			Match match = Regex.Match(codeRaw, pattern);
    
			if (match.Success)
			{
				string modifiers = match.Groups[1].Value.Trim();
				string className = match.Groups[2].Value.Trim();
				string inheritance = match.Groups[3].Value.Trim();

				string fullClassDeclaration = $"public {modifiers} class {className} {inheritance}".Trim();
				return fullClassDeclaration.Replace("  ", " ");
			}
    
			return string.Empty;
		}

		private List<MethodData> ParseMethods(string codeRaw)
		{
			List<MethodData> methods = new List<MethodData>();
			string pattern = @"(?:public|private|protected|internal|static)?\s+(?:void|[\w<>[\]]+)\s+(\w+)\s*\([^)]*\)\s*(?:where\s+[^{]+)?\s*\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}";

			MatchCollection matches = Regex.Matches(codeRaw, pattern, RegexOptions.Singleline);

			foreach (Match match in matches)
			{
				string methodName = match.Groups[1].Value;
				string methodBody = match.Value.Trim();
				methods.Add(new MethodData { MethodName = methodName, MethodBody = methodBody });
			}

			return methods;
		}

		private string ParseFields(string codeRaw)
		{
			List<string> fields = new List<string>();
			string pattern = @"(?:public|private|protected|internal|static)?\s+(?:readonly\s+)?(?!using|return|class|void|enum)[\w<>[\]]+\s+\w+(?:\s*=\s*(?![^;]*\()[^;]+)?;";
			
			MatchCollection matches = Regex.Matches(codeRaw, pattern);
    
			foreach (Match match in matches)
			{
				fields.Add(match.Value.Trim());
			}
    
			return string.Join("\n", fields);
		}

		private string ParseLibraries(string codeRaw)
		{
			List<string> libraries = new List<string>();
			string pattern = @"using\s+[\w.]+;";
    
			MatchCollection matches = Regex.Matches(codeRaw, pattern);
    
			foreach (Match match in matches)
			{
				libraries.Add(match.Value.Trim());
			}
    
			return string.Join("\n", libraries);
		}
		#endregion
		
		public class ParsedCodeData
		{
			public string Namespace { get; set; }
			public string FilePath { get; set; }
			public string Libraries { get; set; }
			public string ClassDeclaration { get; set; }
			public string Fields { get; set; }
			public List<MethodData> Methods { get; set; }
		}
		
		public class MethodData
		{
			public string MethodName { get; set; }
			public string MethodBody { get; set; }
		}
		
		public class FileContent
		{
			public string FilePath { get; set; }
			public string Content { get; set; }
		}
	}
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AgentCodeValidator.cs:
 // Copyright (c) Sanat. All rights reserved.

using Sanat.ApiGemini;
using UnityEngine;

namespace Sanat.CodeGenerator.Agents
{
    public class AgentCodeValidator : AbstractAgentHandler
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public string[] Tools { get; set; }
        public float Temperature { get; set; }
        public string Instructions { get; set; }
        private string _prompt;

        protected override string PromptFilename()
        {
            return "UnityCodeValidatorInstructions.md";
        }
        
        public AgentCodeValidator(ApiKeys apiKeys, string task, string includedCode, string possibleAnswer)
        {
            Name = "Agent Code Validator";
            Description = "Validates code for agents";
            Temperature = .0f;
            StoreKeys(apiKeys);
            string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
            Instructions = LoadPrompt(promptLocation);
            _prompt = $"{Instructions} " +
                      $"# TASK: {task}. " +
                      $"# CODE: {includedCode} " +
                      $"# POSSIBLE ANSWER: {possibleAnswer}";
            SelectedApiProvider = ApiProviders.Gemini;
        }
        
        protected override string GetGeminiModel()
        {
            return ApiGeminiModels.Flash;
        }

        public override void Handle(string input)
        {
            Debug.Log($"<color=purple>{Name}</color> asking: {_prompt}");
            BotParameters botParameters = new BotParameters(_prompt, SelectedApiProvider, Temperature, delegate(string result)
            {
                Debug.Log($"<color=purple>{Name}</color> result: {result}");
                OnComplete?.Invoke(result);
                SaveResultToFile(result);
            });
            AskBot(botParameters);
        }
    }
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AgentCodeValidator.cs:
 // Copyright (c) Sanat. All rights reserved.

using Sanat.ApiGemini;
using UnityEngine;

namespace Sanat.CodeGenerator.Agents
{
    public class AgentCodeValidator : AbstractAgentHandler
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public string[] Tools { get; set; }
        public float Temperature { get; set; }
        public string Instructions { get; set; }
        private string _prompt;

        protected override string PromptFilename()
        {
            return "UnityCodeValidatorInstructions.md";
        }
        
        public AgentCodeValidator(ApiKeys apiKeys, string task, string includedCode, string possibleAnswer)
        {
            Name = "Agent Code Validator";
            Description = "Validates code for agents";
            Temperature = .0f;
            StoreKeys(apiKeys);
            string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
            Instructions = LoadPrompt(promptLocation);
            _prompt = $"{Instructions} " +
                      $"# TASK: {task}. " +
                      $"# CODE: {includedCode} " +
                      $"# POSSIBLE ANSWER: {possibleAnswer}";
            SelectedApiProvider = ApiProviders.Gemini;
        }
        
        protected override string GetGeminiModel()
        {
            return ApiGeminiModels.Flash;
        }

        public override void Handle(string input)
        {
            Debug.Log($"<color=purple>{Name}</color> asking: {_prompt}");
            BotParameters botParameters = new BotParameters(_prompt, SelectedApiProvider, Temperature, delegate(string result)
            {
                Debug.Log($"<color=purple>{Name}</color> result: {result}");
                OnComplete?.Invoke(result);
                SaveResultToFile(result);
            });
            AskBot(botParameters);
        }
    }
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AgentCodeStrategyArchitector.cs:
 // Copyright (c) Sanat. All rights reserved.

using System.Collections.Generic;
using System.Data;
using System.Text;
using Sanat.ApiGemini;
using UnityEngine;

namespace Sanat.CodeGenerator.Agents
{
    public class AgentCodeStrategyArchitector : AbstractAgentHandler
    {
        public string Description { get; set; }
        public string[] Tools { get; set; }
        public float Temperature { get; set; }
        public string Instructions { get; set; }
        private string _prompt;

        protected override string PromptFilename() =>
            "PromptAgentStrategyArchitector.md";
        
        protected override string GetGeminiModel() => 
            ApiGeminiModels.Flash;
        
        public AgentCodeStrategyArchitector(ApiKeys apiKeys, string task, string includedCode)
        {
            Name = "Agent Strategy Architector";
            Description = "Writes task solving strategy for agents";
            Temperature = 1f;
            Tools = new[] { "GetWholeProjectStructure" };
            StoreKeys(apiKeys);
            string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
            Instructions = LoadPrompt(promptLocation);
            _prompt = $"{Instructions} # TASK: {task}. # CODE: " + includedCode;
            SelectedApiProvider = ApiProviders.Gemini;
        }
        
        public override void Handle(string input)
        {
            Debug.Log($"<color=orange>{Name}</color> asking: {_prompt}");
            var tools = ToolRequest();

            BotParameters botParameters = new BotParameters(_prompt, SelectedApiProvider, Temperature, delegate(string result)
            {
                Debug.Log($"<color=orange>{Name}</color> result: {result}");
                
                var responseData = JsonUtility.FromJson<ChatResponse>(result);
                FunctionCall functionCall = responseData?.candidates[0].content?.parts[0]?.functionCall;
                string methodName = functionCall.name;
                var args = functionCall.args;
                LaunchFunction(methodName, args);
                OnComplete?.Invoke(result);
                SaveResultToFile(result);
            });
            botParameters.geminiToolRequest = tools;
            AskBot(botParameters);
        }
        
        private void GenerateSolution(string prompt)
        {
            Debug.Log($"<color=orange>{Name}</color> generating solution for: {prompt}");
            BotParameters botParameters = new BotParameters(prompt, SelectedApiProvider, Temperature, delegate(string result)
            {
                Debug.Log($"<color=orange>{Name}</color> result: {result}");
                OnComplete?.Invoke(result);
                SaveResultToFile(result);
            });
            AskBot(botParameters);
        }

        private ToolRequest ToolRequest()
        {
            Tool toolLibrary = new Tool();
            toolLibrary.function_declarations = new()
            {
                new FunctionDeclaration
                {
                    name = "GetWholeProjectStructure",
                    description = "Attaches all script locations of the project as an additional information for the task",
                },
                new FunctionDeclaration()
                {
                    name = "GenerateSolution",
                    description = "Generates a solution for the task",
                    parameters = new FunctionDeclarationSchema
                    {
                        type = FunctionDeclarationSchemaType.STRING,
                        properties = new Dictionary<string, FunctionDeclarationSchemaProperty>
                        {
                            {
                                "prompt",
                                new FunctionDeclarationSchemaProperty
                                {
                                    type = FunctionDeclarationSchemaType.STRING
                                }
                            }
                        },
                        required = new List<string>
                        {
                            "prompt"
                        }
                    }
                }
            };
            ToolRequest toolRequest = new ToolRequest();
            toolRequest.contents = new()
            {
                new Content
                {
                    role = "user",
                    parts = new()
                    {
                        new Part
                        {
                            text = _prompt
                        }
                    }
                }
            };
            toolRequest.tools = new()
            {
                toolLibrary
            };
            return toolRequest;
        }

        private string LaunchFunction(string methodName, object args)
        {
            switch (methodName)
            {
                case "GetWholeProjectStructure":
                    var filePathes = ToolGetWholeProjectStructure.GetWholeProjectStructure();
                    StringBuilder sb = new StringBuilder();
                    foreach (var filePath in filePathes)
                    {
                        sb.AppendLine(filePath);
                    }
                    return sb.ToString();
                    break;
                case "GenerateSolution":
                    Debug.Log($"<color=orange>{Name}</color> generating solution for: {args}");
                    GenerateSolution(JsonUtility.FromJson<GenerateSolutionRequest>(args.ToString()).prompt);
                    break;
            }
            return string.Empty;
        }
        
        public struct GenerateSolutionRequest
        {
            public string prompt;
        }
    }
} 

// Assets\Sanat\CodeGenerator\Editor\Agents\AgentCodeStrategyArchitector.cs:
 // Copyright (c) Sanat. All rights reserved.

using System.Collections.Generic;
using System.Data;
using System.Text;
using Sanat.ApiGemini;
using UnityEngine;

namespace Sanat.CodeGenerator.Agents
{
    public class AgentCodeStrategyArchitector : AbstractAgentHandler
    {
        public string Description { get; set; }
        public string[] Tools { get; set; }
        public float Temperature { get; set; }
        public string Instructions { get; set; }
        private string _prompt;

        protected override string PromptFilename() =>
            "PromptAgentStrategyArchitector.md";
        
        protected override string GetGeminiModel() => 
            ApiGeminiModels.Flash;
        
        public AgentCodeStrategyArchitector(ApiKeys apiKeys, string task, string includedCode)
        {
            Name = "Agent Strategy Architector";
            Description = "Writes task solving strategy for agents";
            Temperature = 1f;
            Tools = new[] { "GetWholeProjectStructure" };
            StoreKeys(apiKeys);
            string promptLocation = Application.dataPath + $"/Sanat/CodeGenerator/Agents/Prompts/{PromptFilename()}";
            Instructions = LoadPrompt(promptLocation);
            _prompt = $"{Instructions} # TASK: {task}. # CODE: " + includedCode;
            SelectedApiProvider = ApiProviders.Gemini;
        }
        
        public override void Handle(string input)
        {
            Debug.Log($"<color=orange>{Name}</color> asking: {_prompt}");
            var tools = ToolRequest();

            BotParameters botParameters = new BotParameters(_prompt, SelectedApiProvider, Temperature, delegate(string result)
            {
                Debug.Log($"<color=orange>{Name}</color> result: {result}");
                
                var responseData = JsonUtility.FromJson<ChatResponse>(result);
                FunctionCall functionCall = responseData?.candidates[0].content?.parts[0]?.functionCall;
                string methodName = functionCall.name;
                var args = functionCall.args;
                LaunchFunction(methodName, args);
                OnComplete?.Invoke(result);
                SaveResultToFile(result);
            });
            botParameters.geminiToolRequest = tools;
            AskBot(botParameters);
        }
        
        private void GenerateSolution(string prompt)
        {
            Debug.Log($"<color=orange>{Name}</color> generating solution for: {prompt}");
            BotParameters botParameters = new BotParameters(prompt, SelectedApiProvider, Temperature, delegate(string result)
            {
                Debug.Log($"<color=orange>{Name}</color> result: {result}");
                OnComplete?.Invoke(result);
                SaveResultToFile(result);
            });
            AskBot(botParameters);
        }

        private ToolRequest ToolRequest()
        {
            Tool toolLibrary = new Tool();
            toolLibrary.function_declarations = new()
            {
                new FunctionDeclaration
                {
                    name = "GetWholeProjectStructure",
                    description = "Attaches all script locations of the project as an additional information for the task",
                },
                new FunctionDeclaration()
                {
                    name = "GenerateSolution",
                    description = "Generates a solution for the task",
                    parameters = new FunctionDeclarationSchema
                    {
                        type = FunctionDeclarationSchemaType.STRING,
                        properties = new Dictionary<string, FunctionDeclarationSchemaProperty>
                        {
                            {
                                "prompt",
                                new FunctionDeclarationSchemaProperty
                                {
                                    type = FunctionDeclarationSchemaType.STRING
                                }
                            }
                        },
                        required = new List<string>
                        {
                            "prompt"
                        }
                    }
                }
            };
            ToolRequest toolRequest = new ToolRequest();
            toolRequest.contents = new()
            {
                new Content
                {
                    role = "user",
                    parts = new()
                    {
                        new Part
                        {
                            text = _prompt
                        }
                    }
                }
            };
            toolRequest.tools = new()
            {
                toolLibrary
            };
            return toolRequest;
        }

        private string LaunchFunction(string methodName, object args)
        {
            switch (methodName)
            {
                case "GetWholeProjectStructure":
                    var filePathes = ToolGetWholeProjectStructure.GetWholeProjectStructure();
                    StringBuilder sb = new StringBuilder();
                    foreach (var filePath in filePathes)
                    {
                        sb.AppendLine(filePath);
                    }
                    return sb.ToString();
                    break;
                case "GenerateSolution":
                    Debug.Log($"<color=orange>{Name}</color> generating solution for: {args}");
                    GenerateSolution(JsonUtility.FromJson<GenerateSolutionRequest>(args.ToString()).prompt);
                    break;
            }
            return string.Empty;
        }
        
        public struct GenerateSolutionRequest
        {
            public string prompt;
        }
    }
} 



# TASK: Describe what Code Generator does and how  the Gemini API is used in 1500 characters or less.