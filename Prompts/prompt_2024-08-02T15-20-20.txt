# ROLE:
Unity3D code architect.

# GOAL:
Write specific and detailed code for Unity3D projects.

# BACKSTORY:
You are a Unity 3D Code Writer. You write specific and detailed code for Unity 3D projects in C#.
You provide solutions to coding problems, write scripts for game mechanics, and integrate various assets and systems.
You have a deep understanding of Unity 3D, C#, and game development principles.
You follow best practices for performance optimization, code organization, and version control.
You collaborate closely with the Unity 3D Architect to ensure that the codebase aligns with the overall project architecture.
Stick and balance between with Clean code principles and SOLID principles and 'Clean' Code, Horrible Performance - by Casey Muratori.
Make clean and efficient code, remember that focusing exclusively on either aspect can lead to less optimal results.
Maintaining a good understanding of the trade-offs between readability, maintainability, and performance is crucial.
Keep in mind that NetworkBehaviour constructors are not allowed.
Remember that [SyncObject], [SyncVar] are allowed only in NetworkBehaviour classes.
Always provide FULL CODE of the file just to copy paste code and application should run.
DO NOT write explanations for the code.
DO NOT skip showing fully method where code was changed.
DO NOT provide comments in code.
# CODE: // Assets\-ZombieRoyale\Scripts\LLM AI\Personality\Personality.cs:
 using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Text;

public class Personality : MonoBehaviour, IDescribable
{
    [Header("Character Attributes")]

    [Tooltip("The PersonalityDefinition to use for this character.")]
    [SerializeField] private PersonalityDefinition mPersonalityDefinition;
    private string[] mTasks;
    /// <summary>
    /// Controller asset in scene that generates personality prompts for all LLM personalities. 
    /// </summary>
    private PersonalityManager mPersonalityController;

    /// <summary>
    /// Personality descriptions based on parameters.
    /// </summary>
    private string[] mDescriptions;

    /// <summary>
    /// Single string representing all aspects of personality.
    /// </summary>
    private string mPersonalityPrompt;

    /// <summary>
    /// String builder used to build prompt strings efficiently.
    /// </summary>
    private StringBuilder mBuilder;
  
    /// <summary>
    /// Communication interface between the character and GPT.
    /// </summary>
    private GptCommunicator mGpt;

    /// <summary>
    /// Abstract hearing sense to generate prompts from heard "sounds".
    /// </summary>
    private Hearing mHearing;

    /// <summary>
    /// Function delegate to "say" statements to surrounding characters.
    /// </summary>
    /// <param name="speaker">
    /// The Character making the statement.
    /// </param>
    /// The statement being made.
    /// <param name="statment"></param>
    public delegate void SayToOthers(Personality speaker, string statment);

    /// <summary>
    /// Event fired to "say" statements to surrounding characters.
    /// </summary>
    public event SayToOthers onSayToOthers;

    /// <summary>
    /// What the character is "looking at" currently.
    /// </summary>
    private IDescribable mLookingAt;

    /// <summary>
    /// Vision abstraction to describe what the character
    /// can "see" in a written prompt.
    /// </summary>
    private Vision mVision;

    /// <summary>
    /// Text description of Character's role they are playing.
    /// </summary>
    private string mRole;

    /// <summary>
    /// List of GPT Messages sent and received on behalf of this Character.
    /// </summary>
    private List<GptCommunicator.Message> mMessages;

    /// <summary>
    /// Description of Character's surroundings.
    /// </summary>
    private string mSurroundings;

    /// <summary>
    /// How long the character should wait before making another statment,
    /// based on the previous statement.
    /// </summary>
    private float mLastStatementWait;

    /// <summary>
    /// The last time a statement was made.
    /// </summary>
    private float mLastStatementTime;

    /// <summary>
    /// Short description of personality, for data collection purposes.
    /// </summary>
    private string mSummary;

    /** Accessors/Setters **/
    public string CharacterName 
    { 
        get => mPersonalityDefinition.CharacterName; 
        set => mPersonalityDefinition.CharacterName = value; 
    }
    public string BackStory { get => mPersonalityDefinition.BackStory; set => mPersonalityDefinition.BackStory = value; }
    public float Temperature { get => mPersonalityDefinition.Temperature; }
    public float PresencePenalty { get => mPersonalityDefinition.PresencePenalty; }
    public float FrequencyPenalty { get => mPersonalityDefinition.FrequencyPenalty; }
    public int Openness { get => mPersonalityDefinition.Openness; set => mPersonalityDefinition.Openness = value; }
    public int Conscientiousness 
    { 
        get => mPersonalityDefinition.Conscientiousness;
        set => mPersonalityDefinition.Conscientiousness = value;
    }
    public int Extraversion 
    { 
        get => mPersonalityDefinition.Extraversion;
        set => mPersonalityDefinition.Extraversion = value;
    }
    public int Agreeableness 
    { 
        get => mPersonalityDefinition.Agreeableness;
        set => mPersonalityDefinition.Agreeableness = value;
    }
    public int Neroticsm { get => mPersonalityDefinition.Neroticsm; set => mPersonalityDefinition.Neroticsm = value; }
    public int Happiness { get => mPersonalityDefinition.Happiness; set => mPersonalityDefinition.Happiness = value; }
    public int Anger { get => mPersonalityDefinition.Anger; set => mPersonalityDefinition.Anger = value; }
    public int Sarcasm { get => mPersonalityDefinition.Sarcasm; set => mPersonalityDefinition.Sarcasm = value; }
    public string[] Secrets { get => mPersonalityDefinition.Secrets; set => mPersonalityDefinition.Secrets = value; }
    public string[] ShirtSleeve { get => mPersonalityDefinition.ShirtSleeve; set => mPersonalityDefinition.ShirtSleeve = value; }
    public IDescribable LookingAt
    {
        get => mLookingAt;
        set => mLookingAt = value;
    }
    public string[] Descriptions { get => mDescriptions; }
    public List<GptCommunicator.Message> Messages { get => mMessages; }
    public bool Verbose { get => mPersonalityDefinition.Verbose; }
    public string Summary { get => mSummary; }
    public string Tasks { get => TasksDescription(); }
    public string[] TaskList { set => mTasks = value; }
    public string Role { get => BuildRole(); }
    public string Topics { get => TopicsDescription(); }
    public string[] TopicsList { set => mTopics = value; }

    [Tooltip("Subjects this character wants to ask people and talk about.")]
    [SerializeField] private string[] mTopics;

    /// <summary>
    /// This function is called when the object becomes enabled and active.
    /// </summary>
    private void OnEnable()
    {
        Init();
    }

    /// <summary>
    /// Start is called on the frame when a script is enabled just before any
    /// of the Update methods are called the first time.
    /// </summary>
    private void Start()
    {
        if (mPersonalityDefinition.mAutoActivate)
            StartPersonality();
    }

    /// <summary>
    /// Update is called every frame, if the MonoBehaviour is enabled.
    /// </summary>
    private void Update()
    {
        if (mPersonalityDefinition.mMakeManualStatment)
            MakeManualStatement();
    }

    /// <summary>
    /// Starts the Personality.
    /// </summary>
    public void StartPersonality()
    {
        mVision.SetFov(mVision.FovHorizontal, mVision.FovVertical);
    }

    /// <summary>
    /// Initializes (or reinitializes) the Personality.
    /// </summary>
    public void Init()
    {
        mBuilder = new StringBuilder(mPersonalityDefinition.mMaxTokens * 4);
        mMessages = new List<GptCommunicator.Message>();
        mPersonalityController = FindAnyObjectByType<PersonalityManager>();
        if (mPersonalityController == null)
        {
            Debug.LogError($"ERROR: No PersonalityManager found in scene!");
        }
        mDescriptions = mPersonalityController.GenerateNewPersonality(this);
        mBuilder.Clear();
        foreach (string aspect in mDescriptions)
        {
            mBuilder.Append($"{aspect}");
        }
        mPersonalityPrompt = mBuilder.ToString();
        mVision = GetComponentInChildren<Vision>();
        if (mVision == null)
        {
            //Debug.LogError($"ERROR: Character {mCharacterName} has no vision" + $" component!");
        }
        mGpt = FindFirstObjectByType<GptCommunicator>();
        if (mGpt == null)
        {
            //Debug.LogError($"ERROR: Gpt communicator not found in scene!");
        }
        mRole = BuildRole();
        SetSystemPrompt(mRole);
        mHearing = gameObject.GetComponentInChildren<Hearing>();
        mSummary = mPersonalityController.GenerateSummary(this);
    }

    /// <summary>
    /// Builds a role description string from parameter description strings.
    /// </summary>
    /// <returns>
    /// Role description.
    /// </returns>
    private string BuildRole()
    {
        mRole = $" {Defines.ROLE_HEAD} {CharacterName} with this backstory: {BackStory}" +
            $"{Defines.ROLE_MID} {mPersonalityPrompt} " +
            $"{Tasks}{Topics}{Defines.ROLE_TAIL} {Defines.DIALOGUE_RULE}";
        
        //Debug.Log($"{mCharacterName} is using the following role:" + $"\n\"{mRole}\"");
        return mRole;
    }

    /// <summary>
    /// Builds a description of topics this personality wants to talk about.
    /// </summary>
    /// <returns>
    /// Description of topics this perosnality wants to talk about.
    /// </returns>
    private string TopicsDescription()
    {
        // Description of topics.
        string description = "";

        if (mTopics.Length > 0)
        {
            mBuilder.Clear();
            mBuilder.Append($"{Defines.TOPICS_HEAD} ");
            if (mTopics.Length > 1)
            {
                for (int i = 0; i < mTopics.Length; i++)
                {
                    mBuilder.Append(mTopics[i]);
                    if (i < mTopics.Length - 1)
                        mBuilder.Append(Defines.LIST_TAIL);
                    else
                        mBuilder.Append(Defines.END_TAIL);
                }
            }
            else
                mBuilder.Append($"{mTopics[0]}{Defines.END_TAIL}");
            description = mBuilder.ToString();
        }
        return description;
    }

    /// <summary>
    /// Generates a description of current tasks occupied by this character.
    /// </summary>
    /// <returns>
    /// Task desscription string.
    /// </returns>
    private string TasksDescription()
    {
        // Description of tasks.
        string description = "";

        if (mTasks.Length > 0)
        {
            mBuilder.Clear();
            mBuilder.Append($"{Defines.TASKS_HEAD} ");
            for (int i = 0; i < mTasks.Length; i++)
            {
                mBuilder.Append(mTasks[i]);
                if (i < mTasks.Length - 1)
                    mBuilder.Append(Defines.LIST_TAIL);
                else
                    mBuilder.Append(Defines.END_TAIL);
            }
            description = mBuilder.ToString();
        }
        return description;
    }

    /// <summary>
    /// Checks whether the character can see or hear anything.
    /// Only handles vision right now. TO DO: Handle hearing.
    /// </summary>
    public void AssessSurroundings()
    {
        // Text description of Character's environment.
        string assessment = DescribeVisualSurroundings();
        if(!assessment.Equals(string.Empty))
            mGpt.RequestVisualQueuePrompt(assessment, this, SayOutLoud);
        Debug.Log($"{mPersonalityDefinition.mCharacterName} {Defines.ASSESS_MID}{assessment}");
    }

    /// <summary>
    /// Sets the system prompt for the message list.
    /// </summary>
    /// <param name="prompt"></param>
    public void SetSystemPrompt(string prompt)
    {
        // New system prompt message.
        GptCommunicator.Message system = new GptCommunicator.Message
        {
            role = "system",
            content = prompt
        };

        if (mMessages.Count > 0)
            mMessages.RemoveAt(0);
        mMessages.Insert(0, system);
        Debug.Log($"{mPersonalityDefinition.mCharacterName} is using the following role:" +
            $"\n\"{mRole}\"");
    }

    /// <summary>
    /// Checks verbosity.
    /// </summary>
    /// <returns>
    /// True if Character is verbose, false if set otherwise.
    /// </returns>
    public bool IsVerbose()
    {
        return mPersonalityDefinition.Verbose;
    }

    /// <summary>
    /// Character makes a preset statement for debugging.
    /// </summary>
    private void MakeManualStatement()
    {
        if (Verbose)
            Debug.Log($"{mPersonalityDefinition.mCharacterName} is making the manual statement " +
                $"\"{mPersonalityDefinition.mManualStatement}\".");
        if (mPersonalityDefinition.mManualStatement != null && mPersonalityDefinition.mManualStatement.Length > 0)
            onSayToOthers?.Invoke(this, mPersonalityDefinition.mManualStatement);
        mPersonalityDefinition.mMakeManualStatment = false;
    }

    /// <summary>
    /// Makes a statement out loud to surrounding Characters.
    /// </summary>
    /// <param name="statement">
    /// Statement being made.
    /// </param>
    private void SayOutLoud(string statement)
    {
        // Current game time.
        float time = Time.realtimeSinceStartup;

        // Difference between current time and the last dialogue request.
        float delta = time - mLastStatementTime;

        // How long to wait before making another request.
        float waitSeconds = delta > mLastStatementWait ? 
            0 : Mathf.Min(mPersonalityDefinition.mMaxReplyWait, mLastStatementWait - delta);

        StartCoroutine(MakeStatement(statement, waitSeconds));
        mLastStatementTime = time;
        mLastStatementWait = statement.Length * mPersonalityDefinition.mWaitScalar;
    }

    /// <summary>
    /// Makes a reply request from GPT.
    /// </summary>
    /// <param name="statement">
    /// The statement to reply to.
    /// </param>
    /// <param name="waitSeconds">
    /// How long to wait before making the request.
    /// </param>
    /// <returns></returns>
    IEnumerator MakeStatement(string statement, float waitSeconds)
    {
        yield return new WaitForSeconds(waitSeconds);
        onSayToOthers?.Invoke(this, statement);
        Debug.Log($"{mPersonalityDefinition.mCharacterName} said \"{statement}\".");
    }

    /// <summary>
    /// Executes function calls based on text description of intended actions.
    /// </summary>
    /// <param name="instructions">
    /// Text description from which to generate fuction calls.
    /// </param>
    private void FollowInstructions(string instructions)
    {
        // To do.
    }

    /// <summary>
    /// Receives a statement made by another character,
    /// illicits a response if appropriate.
    /// </summary>
    /// <param name="speaker">
    /// Character making the statement.
    /// </param>
    /// <param name="statement">
    /// Statement being made by the spearker.
    /// </param>
    public void HearFromOther(IDescribable speaker, string statement)
    {
        string prompt = $"{speaker.DescribeSelfForOther(this)} " +
            $"{Defines.HEAR_OTHER_MID} \"{statement}\"{Defines.END_TAIL}";
        if (Verbose)
            Debug.Log($"{mPersonalityDefinition.mCharacterName} heard \"{statement}\".");
        mGpt.RequestConversationalReply(prompt, this, SayOutLoud);
    }

    /// <summary>
    /// Recieves a text descritption of a noise made in the vicinity of a
    /// Character, illicits a response if approrpriate.
    /// </summary>
    /// <param name="noiseMaker">
    /// Thing that made the noise.
    /// </param>
    /// <param name="noise">
    /// Text description of the noise.
    /// </param>
    public void HearFromNonAnimate(IDescribable noiseMaker, string noise)
    {
        mBuilder.Clear();
        mBuilder.Append($"{Defines.HEAR_NONANIM_HEAD} {noise} " +
            $"{Defines.HEAR_NONANIM_MID} {noiseMaker.DescribeSelfForOther(this)}" +
            $"{Defines.END_TAIL}");
        mBuilder.Append(DescribeVisualSurroundings());
        mGpt.RequestReactionInstructions(mBuilder.ToString(), this, FollowInstructions);
    }

    /// <summary>
    /// Generates a text description of the Character's visual surroundings.
    /// </summary>
    /// <returns></returns>
    public string DescribeVisualSurroundings()
    {
        // Things seen by Character.
        IDescribable[] seen = mVision.Seen;

        // Iterator variable.
        int i;

        // Description of visual surroundings.
        string description = string.Empty;

        if (seen.Length > 0)
        {
            mBuilder.Clear();
            mBuilder.Append($"{Defines.SEE_HEAD} ");
            for (i = 0; i < seen.Length; i++)
            {
                if (i < seen.Length - 1)
                    mBuilder.Append($"{seen[i].DescribeSelfForOther(this)}" +
                        $"{Defines.LIST_TAIL}");
                else
                    if(seen.Length > 1)
                        mBuilder.Append($"{Defines.LIST_HEAD} " +
                            $"{seen[i].DescribeSelfForOther(this)}{Defines.END_TAIL}");
                    else
                        mBuilder.Append($"{seen[i].DescribeSelfForOther(this)}" +
                            $"{Defines.END_TAIL}");
            }
            description = mBuilder.ToString();
        }
        mSurroundings = description;
        return description;
    }

    /// <summary>
    /// Generates a text description of this character for another character.
    /// </summary>
    /// <param name="caller">
    /// Character the text description is being generated for.
    /// </param>
    /// <returns>
    /// Character the text description os being generated of.
    /// </returns>
    public string DescribeSelfForOther(Personality caller)
    {
        mBuilder.Clear();
        mBuilder.Append($"{BackStory} {Defines.DESC_NAME} {CharacterName}");
        if (LookingAt != null)
            if ((object)LookingAt != caller)
                mBuilder.Append($" {Defines.LOOK_OTHER} {LookingAt}");
            else
                mBuilder.Append($" {Defines.LOOK_YOU}");
        else
            mBuilder.Append($" {Defines.LOOK_NOTH}");
        return mBuilder.ToString();
    }

    public string GetName()
    {
        return CharacterName;
    }
} 

// Assets\-ZombieRoyale\Scripts\LLM AI\Personality\PersonalityDefinition.cs:
 using UnityEngine;
using System.Text;


[CreateAssetMenu(menuName = "ScriptableObjects/PersonalityDefinition", fileName = "NewPersonalityDefinition")]
public class PersonalityDefinition : ScriptableObject
{
    [Header("Character Attributes")]

    [Tooltip("The name of this character.")]
    public string mCharacterName = "Bilbo";

    [Tooltip("Who and what this character is. Short and sweet, use as little" +
        " punctuation as possible."), TextArea(6, 10)]
    public string mBackStory = 
        "a simulated video game character";

    [Tooltip("Integer value, [0-4].\n\"Openness is an overarching concept or" +
        " philosophy that is characterized by an emphasis on transparency and " +
        "collaboration.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mOpenness = 2;

    [Tooltip("Integer value, [0-4].\n\"...the personality trait of being " +
        "careful or diligent.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mConscientiousness = 2;

    [Tooltip("Integer value, [0-4].\n\"Extraversion tends to be manifested in " +
        "outgoing, talkative, energetic behavior.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mExtraversion = 2;

    [Tooltip("Integer value, [0-4].\n\"Agreeableness is a personality trait " +
        "that manifests as behavior that is perceived as kind, sympathetic, " +
        "cooperative, warm, frank, and considerate.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mAgreeableness = 2;

    [Tooltip("Integer value, [0-4].\n\"...individuals with high scores for" +
        " neuroticism are more likely than average to be moody and to" +
        " experience such feelings as anxiety, worry, fear, anger," +
        " frustration, envy, jealousy, pessimism, guilt, depressed mood, and" +
        " loneliness.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mNeuroticsm = 2;

    [Tooltip("Integer value, [0-4].\n\"Happiness is a positive and pleasant " +
        "emotion, ranging from contentment to intense joy.\" - Wikipedia")]
    [vMinMax(0, 4)]
    public int mHappiness = 2;

    [Tooltip("Integer value, [0-4].\n\"Anger, also known as wrath or rage, " +
        "is an intense emotional state involving a strong uncomfortable and " +
        "non-cooperative response to a perceived provocation, hurt or threat.\"" +
        " -Wikipedia")]
    [vMinMax(0, 4)]
    public int mAnger = 2;

    [Tooltip("Integer value, [0-4].\n\"Sarcasm is the caustic use of words, " +
        "often in a humorous way, to mock someone or something.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mSarcasm = 2;

    [Tooltip("List of things this character avoids in conversation, in the" +
        " form, \"Secretly, you...\"")]
    public string[] mSecrets;

    [Tooltip("List of things about themselves this character would love to" +
        " tell you about, in the form \"You want everyone to know...\"")]
    public string[] mShirtSleeve;

    [Tooltip("What this character is doing right now. The tasks at hand.")]
    public string[] mTasks;

    [Tooltip("Subjects this character wants to ask people and talk about.")]
    public string[] mTopics;
    public string[] mTraits;
    public string[] mGoals;

    [Header("Model Paramters")]

    [Tooltip("\"The maximum number of tokens to generate in the completion.\" " +
        "-OpenAI API Documentation")]
    public int mMaxTokens = Defines.MAX_TOKENS;

    [Tooltip("\"What sampling temperature to use, between 0 and 2. Higher" +
        " values like 0.8 will make the output more random, while lower values" +
        " like 0.2 will make it more focused and deterministic.\" " +
        "-OpenAI API Documenation")]
    public float mTemperature = 0.7f;

    [Tooltip("\"Number between -2.0 and 2.0. Positive values penalize new " +
        "tokens based on whether they appear in the text so far, increasing the" +
        " model's likelihood to talk about new topics.\" " +
        "-OpenAI API Documenation")]
    public float mPresencePenalty = 1.0f;

    [Tooltip( "\"Number between - 2.0 and 2.0.Positive values penalize new " +
        "tokens based on their existing frequency in the text so far, " +
        "decreasing the model's likelihood to repeat the same line verbatim.\"" +
        " -OpenAI API Documenation")]
    public float mFrequencyPenalty = 1.0f;

    [Tooltip("How many seconds per char the character should wait before" +
    " doing anything else after saying something.")]
    public float mWaitScalar = 0.1f;

    [Tooltip("Max time to wait before making a new gpt reply request.")]
    public float mMaxReplyWait = 20.0f;


    [Header("Test Features")]

    [Tooltip("Test statement for the character to make manually.")]
    public string mManualStatement = "";

    [Tooltip("Causes character to make a manually entered test statement.")]
    public bool mMakeManualStatment = false;

    [Tooltip("Causes status statements to be printed to console.")]
    public bool mVerbose = false;

    [Tooltip("Whether to immediatly bring character personality to life.")]
    public bool mAutoActivate = false;

    /// <summary>
    /// Personality descriptions based on parameters.
    /// </summary>
    private string[] mDescriptions;

    /// <summary>
    /// Single string representing all aspects of personality.
    /// </summary>
    private string mPersonalityPrompt;

    /// <summary>
    /// String builder used to build prompt strings efficiently.
    /// </summary>
    private StringBuilder mBuilder;

    /// <summary>
    /// Text description of Character's role they are playing.
    /// </summary>
    private string mRole;

    /// <summary>
    /// Description of Character's surroundings.
    /// </summary>
    private string mSurroundings;

    /// <summary>
    /// How long the character should wait before making another statment,
    /// based on the previous statement.
    /// </summary>
    private float mLastStatementWait;

    /// <summary>
    /// The last time a statement was made.
    /// </summary>
    private float mLastStatementTime;

    /// <summary>
    /// Short description of personality, for data collection purposes.
    /// </summary>
    private string mSummary;

    /** Accessors/Setters **/
    public string CharacterName 
    { 
        get => mCharacterName; 
        set => mCharacterName = value; 
    }
    public string BackStory { get => mBackStory; set => mBackStory = value; }
    public float Temperature { get => mTemperature; }
    public float PresencePenalty { get => mPresencePenalty; }
    public float FrequencyPenalty { get => mFrequencyPenalty; }
    public int Openness { get => mOpenness; set => mOpenness = value; }
    public int Conscientiousness 
    { 
        get => mConscientiousness;
        set => mConscientiousness = value;
    }
    public int Extraversion 
    { 
        get => mExtraversion;
        set => mExtraversion = value;
    }
    public int Agreeableness 
    { 
        get => mAgreeableness;
        set => mAgreeableness = value;
    }
    public int Neroticsm { get => mNeuroticsm; set => mNeuroticsm = value; }
    public int Happiness { get => mHappiness; set => mHappiness = value; }
    public int Anger { get => mAnger; set => mAnger = value; }
    public int Sarcasm { get => mSarcasm; set => mSarcasm = value; }
    public string[] Secrets { get => mSecrets; set => mSecrets = value; }
    public string[] ShirtSleeve { get => mShirtSleeve; set => mShirtSleeve = value; }

    public string[] Descriptions { get => mDescriptions; }
    public bool Verbose { get => mVerbose; }
    public string Summary { get => mSummary; }
    public string Tasks { get => TasksDescription(); }
    public string[] TaskList { set => mTasks = value; }
    public string Role { get => BuildRole(); }
    public string Topics { get => TopicsDescription(); }
    public string[] TopicsList { set => mTopics = value; }

    private string BuildRole()
    {
        mRole = $" {Defines.ROLE_HEAD} {CharacterName} with this backstory: {BackStory}" +
            $"{Defines.ROLE_MID} {mPersonalityPrompt} " +
            $"{Tasks}{Topics}{Defines.ROLE_TAIL} {Defines.DIALOGUE_RULE}";
        
        //Debug.Log($"{mCharacterName} is using the following role:" + $"\n\"{mRole}\"");
        return mRole;
    }

    /// <summary>
    /// Builds a description of topics this personality wants to talk about.
    /// </summary>
    /// <returns>
    /// Description of topics this perosnality wants to talk about.
    /// </returns>
    private string TopicsDescription()
    {
        // Description of topics.
        string description = "";

        if (mTopics.Length > 0)
        {
            mBuilder.Clear();
            mBuilder.Append($"{Defines.TOPICS_HEAD} ");
            if (mTopics.Length > 1)
            {
                for (int i = 0; i < mTopics.Length; i++)
                {
                    mBuilder.Append(mTopics[i]);
                    if (i < mTopics.Length - 1)
                        mBuilder.Append(Defines.LIST_TAIL);
                    else
                        mBuilder.Append(Defines.END_TAIL);
                }
            }
            else
                mBuilder.Append($"{mTopics[0]}{Defines.END_TAIL}");
            description = mBuilder.ToString();
        }
        return description;
    }

    /// <summary>
    /// Generates a description of current tasks occupied by this character.
    /// </summary>
    /// <returns>
    /// Task desscription string.
    /// </returns>
    private string TasksDescription()
    {
        // Description of tasks.
        string description = "";

        if (mTasks.Length > 0)
        {
            mBuilder.Clear();
            mBuilder.Append($"{Defines.TASKS_HEAD} ");
            for (int i = 0; i < mTasks.Length; i++)
            {
                mBuilder.Append(mTasks[i]);
                if (i < mTasks.Length - 1)
                    mBuilder.Append(Defines.LIST_TAIL);
                else
                    mBuilder.Append(Defines.END_TAIL);
            }
            description = mBuilder.ToString();
        }
        return description;
    }
} 

// Assets\-ZombieRoyale\Scripts\LLM AI\Personality\PersonalityDefinition.cs:
 using UnityEngine;
using System.Text;


[CreateAssetMenu(menuName = "ScriptableObjects/PersonalityDefinition", fileName = "NewPersonalityDefinition")]
public class PersonalityDefinition : ScriptableObject
{
    [Header("Character Attributes")]

    [Tooltip("The name of this character.")]
    public string mCharacterName = "Bilbo";

    [Tooltip("Who and what this character is. Short and sweet, use as little" +
        " punctuation as possible."), TextArea(6, 10)]
    public string mBackStory = 
        "a simulated video game character";

    [Tooltip("Integer value, [0-4].\n\"Openness is an overarching concept or" +
        " philosophy that is characterized by an emphasis on transparency and " +
        "collaboration.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mOpenness = 2;

    [Tooltip("Integer value, [0-4].\n\"...the personality trait of being " +
        "careful or diligent.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mConscientiousness = 2;

    [Tooltip("Integer value, [0-4].\n\"Extraversion tends to be manifested in " +
        "outgoing, talkative, energetic behavior.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mExtraversion = 2;

    [Tooltip("Integer value, [0-4].\n\"Agreeableness is a personality trait " +
        "that manifests as behavior that is perceived as kind, sympathetic, " +
        "cooperative, warm, frank, and considerate.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mAgreeableness = 2;

    [Tooltip("Integer value, [0-4].\n\"...individuals with high scores for" +
        " neuroticism are more likely than average to be moody and to" +
        " experience such feelings as anxiety, worry, fear, anger," +
        " frustration, envy, jealousy, pessimism, guilt, depressed mood, and" +
        " loneliness.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mNeuroticsm = 2;

    [Tooltip("Integer value, [0-4].\n\"Happiness is a positive and pleasant " +
        "emotion, ranging from contentment to intense joy.\" - Wikipedia")]
    [vMinMax(0, 4)]
    public int mHappiness = 2;

    [Tooltip("Integer value, [0-4].\n\"Anger, also known as wrath or rage, " +
        "is an intense emotional state involving a strong uncomfortable and " +
        "non-cooperative response to a perceived provocation, hurt or threat.\"" +
        " -Wikipedia")]
    [vMinMax(0, 4)]
    public int mAnger = 2;

    [Tooltip("Integer value, [0-4].\n\"Sarcasm is the caustic use of words, " +
        "often in a humorous way, to mock someone or something.\" -Wikipedia")]
    [vMinMax(0, 4)]
    public int mSarcasm = 2;

    [Tooltip("List of things this character avoids in conversation, in the" +
        " form, \"Secretly, you...\"")]
    public string[] mSecrets;

    [Tooltip("List of things about themselves this character would love to" +
        " tell you about, in the form \"You want everyone to know...\"")]
    public string[] mShirtSleeve;

    [Tooltip("What this character is doing right now. The tasks at hand.")]
    public string[] mTasks;

    [Tooltip("Subjects this character wants to ask people and talk about.")]
    public string[] mTopics;
    public string[] mTraits;
    public string[] mGoals;

    [Header("Model Paramters")]

    [Tooltip("\"The maximum number of tokens to generate in the completion.\" " +
        "-OpenAI API Documentation")]
    public int mMaxTokens = Defines.MAX_TOKENS;

    [Tooltip("\"What sampling temperature to use, between 0 and 2. Higher" +
        " values like 0.8 will make the output more random, while lower values" +
        " like 0.2 will make it more focused and deterministic.\" " +
        "-OpenAI API Documenation")]
    public float mTemperature = 0.7f;

    [Tooltip("\"Number between -2.0 and 2.0. Positive values penalize new " +
        "tokens based on whether they appear in the text so far, increasing the" +
        " model's likelihood to talk about new topics.\" " +
        "-OpenAI API Documenation")]
    public float mPresencePenalty = 1.0f;

    [Tooltip( "\"Number between - 2.0 and 2.0.Positive values penalize new " +
        "tokens based on their existing frequency in the text so far, " +
        "decreasing the model's likelihood to repeat the same line verbatim.\"" +
        " -OpenAI API Documenation")]
    public float mFrequencyPenalty = 1.0f;

    [Tooltip("How many seconds per char the character should wait before" +
    " doing anything else after saying something.")]
    public float mWaitScalar = 0.1f;

    [Tooltip("Max time to wait before making a new gpt reply request.")]
    public float mMaxReplyWait = 20.0f;


    [Header("Test Features")]

    [Tooltip("Test statement for the character to make manually.")]
    public string mManualStatement = "";

    [Tooltip("Causes character to make a manually entered test statement.")]
    public bool mMakeManualStatment = false;

    [Tooltip("Causes status statements to be printed to console.")]
    public bool mVerbose = false;

    [Tooltip("Whether to immediatly bring character personality to life.")]
    public bool mAutoActivate = false;

    /// <summary>
    /// Personality descriptions based on parameters.
    /// </summary>
    private string[] mDescriptions;

    /// <summary>
    /// Single string representing all aspects of personality.
    /// </summary>
    private string mPersonalityPrompt;

    /// <summary>
    /// String builder used to build prompt strings efficiently.
    /// </summary>
    private StringBuilder mBuilder;

    /// <summary>
    /// Text description of Character's role they are playing.
    /// </summary>
    private string mRole;

    /// <summary>
    /// Description of Character's surroundings.
    /// </summary>
    private string mSurroundings;

    /// <summary>
    /// How long the character should wait before making another statment,
    /// based on the previous statement.
    /// </summary>
    private float mLastStatementWait;

    /// <summary>
    /// The last time a statement was made.
    /// </summary>
    private float mLastStatementTime;

    /// <summary>
    /// Short description of personality, for data collection purposes.
    /// </summary>
    private string mSummary;

    /** Accessors/Setters **/
    public string CharacterName 
    { 
        get => mCharacterName; 
        set => mCharacterName = value; 
    }
    public string BackStory { get => mBackStory; set => mBackStory = value; }
    public float Temperature { get => mTemperature; }
    public float PresencePenalty { get => mPresencePenalty; }
    public float FrequencyPenalty { get => mFrequencyPenalty; }
    public int Openness { get => mOpenness; set => mOpenness = value; }
    public int Conscientiousness 
    { 
        get => mConscientiousness;
        set => mConscientiousness = value;
    }
    public int Extraversion 
    { 
        get => mExtraversion;
        set => mExtraversion = value;
    }
    public int Agreeableness 
    { 
        get => mAgreeableness;
        set => mAgreeableness = value;
    }
    public int Neroticsm { get => mNeuroticsm; set => mNeuroticsm = value; }
    public int Happiness { get => mHappiness; set => mHappiness = value; }
    public int Anger { get => mAnger; set => mAnger = value; }
    public int Sarcasm { get => mSarcasm; set => mSarcasm = value; }
    public string[] Secrets { get => mSecrets; set => mSecrets = value; }
    public string[] ShirtSleeve { get => mShirtSleeve; set => mShirtSleeve = value; }

    public string[] Descriptions { get => mDescriptions; }
    public bool Verbose { get => mVerbose; }
    public string Summary { get => mSummary; }
    public string Tasks { get => TasksDescription(); }
    public string[] TaskList { set => mTasks = value; }
    public string Role { get => BuildRole(); }
    public string Topics { get => TopicsDescription(); }
    public string[] TopicsList { set => mTopics = value; }

    private string BuildRole()
    {
        mRole = $" {Defines.ROLE_HEAD} {CharacterName} with this backstory: {BackStory}" +
            $"{Defines.ROLE_MID} {mPersonalityPrompt} " +
            $"{Tasks}{Topics}{Defines.ROLE_TAIL} {Defines.DIALOGUE_RULE}";
        
        //Debug.Log($"{mCharacterName} is using the following role:" + $"\n\"{mRole}\"");
        return mRole;
    }

    /// <summary>
    /// Builds a description of topics this personality wants to talk about.
    /// </summary>
    /// <returns>
    /// Description of topics this perosnality wants to talk about.
    /// </returns>
    private string TopicsDescription()
    {
        // Description of topics.
        string description = "";

        if (mTopics.Length > 0)
        {
            mBuilder.Clear();
            mBuilder.Append($"{Defines.TOPICS_HEAD} ");
            if (mTopics.Length > 1)
            {
                for (int i = 0; i < mTopics.Length; i++)
                {
                    mBuilder.Append(mTopics[i]);
                    if (i < mTopics.Length - 1)
                        mBuilder.Append(Defines.LIST_TAIL);
                    else
                        mBuilder.Append(Defines.END_TAIL);
                }
            }
            else
                mBuilder.Append($"{mTopics[0]}{Defines.END_TAIL}");
            description = mBuilder.ToString();
        }
        return description;
    }

    /// <summary>
    /// Generates a description of current tasks occupied by this character.
    /// </summary>
    /// <returns>
    /// Task desscription string.
    /// </returns>
    private string TasksDescription()
    {
        // Description of tasks.
        string description = "";

        if (mTasks.Length > 0)
        {
            mBuilder.Clear();
            mBuilder.Append($"{Defines.TASKS_HEAD} ");
            for (int i = 0; i < mTasks.Length; i++)
            {
                mBuilder.Append(mTasks[i]);
                if (i < mTasks.Length - 1)
                    mBuilder.Append(Defines.LIST_TAIL);
                else
                    mBuilder.Append(Defines.END_TAIL);
            }
            description = mBuilder.ToString();
        }
        return description;
    }
} 

// Assets\-ZombieRoyale\Scripts\Clients\UI\LLMAISettingsController.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class LLMAISettingsController : MonoBehaviour
{
    [SerializeField] private TMPro.TMP_InputField _apiKeyInputField;
    public static string PREFS_GEMINI_API_KEY = "AIStudioAPIKey";
    public static bool IsGeminiApiKeySet => !string.IsNullOrEmpty(PlayerPrefs.GetString(PREFS_GEMINI_API_KEY));
    public static LLMAISettingsController Instance { get; private set; }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void OnApiKeyInserted()
    {
        PlayerPrefs.SetString(PREFS_GEMINI_API_KEY, _apiKeyInputField.text);
        string hiddenString = "";
        for (int i = 0; i < _apiKeyInputField.text.Length; i++)
        {
            hiddenString += "*";
        }
        _apiKeyInputField.text = hiddenString;
    }
    
    public string GeminiApiKey()
    {
        return PlayerPrefs.GetString(PREFS_GEMINI_API_KEY);
    }
    
    public void OpenGeminiWebsite()
    {
        OpenWebsite("https://aistudio.google.com/app/apikey");
    }
    private void OpenWebsite(string url)
    {
        Application.OpenURL(url);
    }
} 

// Assets\-ZombieRoyale\Scripts\Clients\UI\NpcDialogueWindow.cs:
 using UnityEngine;
using TMPro;
using System.Collections.Generic;
using DuloGames.UI;

public class NpcDialogueWindow : UIWindow
{
    [SerializeField] private TextMeshProUGUI playerNameText;
    [SerializeField] private TextMeshProUGUI npcNameText;
    [SerializeField] private TextMeshProUGUI dialogueHistoryText;

    private Queue<string> dialogueHistory = new Queue<string>();
    private const int MaxDialogueHistoryCount = 6;
    public static NpcDialogueWindow Instance { get; private set; }
    
    protected override void Awake()
    {
        base.Awake();
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(this);
        }
    }

    private void Start()
    {
        ClearDialogueHistory();
    }

    public void SetPlayerName(string name)
    {
        playerNameText.text = name;
    }

    public void SetNpcName(string name)
    {
        npcNameText.text = name;
    }

    public void AddDialogueMessage(string speaker, string message)
    {
        string formattedMessage = $"{speaker}: {message}";
        dialogueHistory.Enqueue(formattedMessage);

        if (dialogueHistory.Count > MaxDialogueHistoryCount)
        {
            dialogueHistory.Dequeue();
        }

        UpdateDialogueHistoryText();
    }

    private void UpdateDialogueHistoryText()
    {
        string dialogueHistoryString = string.Join("\n", dialogueHistory.ToArray());
        dialogueHistoryText.text = dialogueHistoryString;
    }

    private void ClearDialogueHistory()
    {
        dialogueHistory.Clear();
        dialogueHistoryText.text = string.Empty;
    }
}
 

// Assets\Bullet UI\Scripts\UI\Window\UIWindow.cs:
 using UnityEngine;
using DuloGames.UI.Tweens;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using System;
using System.Collections.Generic;
using DarkTonic.MasterAudio;

namespace DuloGames.UI
{
	[DisallowMultipleComponent, ExecuteInEditMode, AddComponentMenu("UI/Window", 58), RequireComponent(typeof(CanvasGroup))]
	public class UIWindow : MonoBehaviour, IEventSystemHandler, ISelectHandler, IPointerDownHandler {
		
		public enum Transition
		{
			Instant,
			Fade
		}
		
		public enum VisualState
		{
			Shown,
			Hidden
		}
		
		public enum EscapeKeyAction
		{
			None,
			Hide,
			HideIfFocused,
			Toggle
		}
		
		[Serializable] public class TransitionBeginEvent : UnityEvent<UIWindow, VisualState, bool> {}
		[Serializable] public class TransitionCompleteEvent : UnityEvent<UIWindow, VisualState> {}
		
		protected static UIWindow m_FucusedWindow;
		public static UIWindow FocusedWindow { get { return m_FucusedWindow; } private set { m_FucusedWindow = value; } }
		
		[SerializeField] private UIWindowID m_WindowId = UIWindowID.None;
		[SerializeField] private int m_CustomWindowId = 0;
		[SerializeField] private VisualState m_StartingState = VisualState.Hidden;
		[SerializeField] private EscapeKeyAction m_EscapeKeyAction = EscapeKeyAction.Hide;
		[SerializeField] private bool m_UseBlackOverlay = false;

        [SerializeField] private bool m_FocusAllowReparent = true;

		[SerializeField] private Transition m_Transition = Transition.Instant;
		[SerializeField] private TweenEasing m_TransitionEasing = TweenEasing.InOutQuint;
		[SerializeField] private float m_TransitionDuration = 0.1f;
		
		protected bool m_IsFocused = false;
		private VisualState m_CurrentVisualState = VisualState.Hidden;
		private CanvasGroup m_CanvasGroup;
		
		/// <summary>
		/// Gets or sets the window identifier.
		/// </summary>
		/// <value>The window identifier.</value>
		public UIWindowID ID
		{
			get { return this.m_WindowId; }
			set { this.m_WindowId = value; }
		}
		
		/// <summary>
		/// Gets or sets the custom window identifier.
		/// </summary>
		/// <value>The custom window identifier.</value>
		public int CustomID
		{
			get { return this.m_CustomWindowId; }
			set { this.m_CustomWindowId = value; }
		}
		
        /// <summary>
        /// Gets or sets the escape key action.
        /// </summary>
		public EscapeKeyAction escapeKeyAction
		{
			get { return this.m_EscapeKeyAction; }
			set { this.m_EscapeKeyAction = value; }
		}
		
        /// <summary>
        /// Gets or sets a value indicating whether this window should use the black overlay.
        /// </summary>
        public bool useBlackOverlay
        {
            get { return this.m_UseBlackOverlay; }
            set
            {
                this.m_UseBlackOverlay = value;
                
                if (Application.isPlaying && this.m_UseBlackOverlay && this.isActiveAndEnabled)
                {
                    UIBlackOverlay overlay = UIBlackOverlay.GetOverlay(this.gameObject);

                    if (overlay != null)
                    {
                        if (value) this.onTransitionBegin.AddListener(overlay.OnTransitionBegin);
                        else this.onTransitionBegin.RemoveListener(overlay.OnTransitionBegin);
                    }
                }
            }
        }

        /// <summary>
        /// Allow re-parenting on focus.
        /// </summary>
        public bool focusAllowReparent
        {
            get { return this.m_FocusAllowReparent; }
            set { this.m_FocusAllowReparent = value; }
        }

		/// <summary>
		/// Gets or sets the transition.
		/// </summary>
		/// <value>The transition.</value>
		public Transition transition
		{
			get { return this.m_Transition; }
			set { this.m_Transition = value; }
		}
		
		/// <summary>
		/// Gets or sets the transition easing.
		/// </summary>
		/// <value>The transition easing.</value>
		public TweenEasing transitionEasing
		{
			get { return this.m_TransitionEasing; }
			set { this.m_TransitionEasing = value; }
		}
		
		/// <summary>
		/// Gets or sets the duration of the transition.
		/// </summary>
		/// <value>The duration of the transition.</value>
		public float transitionDuration
		{
			get { return this.m_TransitionDuration; }
			set { this.m_TransitionDuration = value; }
		}
		
		/// <summary>
		/// The transition begin (invoked when a transition begins).
		/// </summary>
		public TransitionBeginEvent onTransitionBegin = new TransitionBeginEvent();
		
		/// <summary>
		/// The transition complete event (invoked when a transition completes).
		/// </summary>
		public TransitionCompleteEvent onTransitionComplete = new TransitionCompleteEvent();
		
		/// <summary>
		/// Gets a value indicating whether this window is visible.
		/// </summary>
		/// <value><c>true</c> if this instance is visible; otherwise, <c>false</c>.</value>
		public bool IsVisible
		{
			get { return (this.m_CanvasGroup != null && this.m_CanvasGroup.alpha > 0f) ? true : false; }
		}
		
		/// <summary>
		/// Gets a value indicating whether this window is open.
		/// </summary>
		/// <value><c>true</c> if this instance is open; otherwise, <c>false</c>.</value>
		public bool IsOpen
		{
			get { return (this.m_CurrentVisualState == VisualState.Shown); }
		}
		
		/// <summary>
		/// Gets a value indicating whether this instance is focused.
		/// </summary>
		/// <value><c>true</c> if this instance is focused; otherwise, <c>false</c>.</value>
		public bool IsFocused
		{
			get { return this.m_IsFocused; }
		}
		
		// Tween controls
		[NonSerialized] private readonly TweenRunner<FloatTween> m_FloatTweenRunner;
		
		// Called by Unity prior to deserialization, 
		// should not be called by users
		protected UIWindow()
		{
			if (this.m_FloatTweenRunner == null)
				this.m_FloatTweenRunner = new TweenRunner<FloatTween>();
			
			this.m_FloatTweenRunner.Init(this);
		}
		
		protected virtual void Awake()
		{
			// Get the canvas group
			this.m_CanvasGroup = this.gameObject.GetComponent<CanvasGroup>();

            // Transition to the starting state
            if (Application.isPlaying)
                this.ApplyVisualState(this.m_StartingState);
        }
		
		protected virtual void Start()
		{
			// Assign new custom ID
			if (this.CustomID == 0)
				this.CustomID = UIWindow.NextUnusedCustomID;
            
            // Make sure we have a window manager in the scene if required
            if (this.m_EscapeKeyAction != EscapeKeyAction.None)
            {
                UIWindowManager manager = Component.FindObjectOfType<UIWindowManager>();

                // Add a manager if not present
                if (manager == null)
                {
                    GameObject newObj = new GameObject("Window Manager");
                    newObj.AddComponent<UIWindowManager>();
                    newObj.transform.SetAsFirstSibling();
                }
            }
        }
		
        protected virtual void OnEnable()
        {
            if (Application.isPlaying && this.m_UseBlackOverlay)
            {
                UIBlackOverlay overlay = UIBlackOverlay.GetOverlay(this.gameObject);

                if (overlay != null)
                    this.onTransitionBegin.AddListener(overlay.OnTransitionBegin);
            }
        }

        protected virtual void OnDisable()
        {
            if (Application.isPlaying && this.m_UseBlackOverlay)
            {
                UIBlackOverlay overlay = UIBlackOverlay.GetOverlay(this.gameObject);

                if (overlay != null)
                    this.onTransitionBegin.RemoveListener(overlay.OnTransitionBegin);
            }
        }

#if UNITY_EDITOR
        protected virtual void OnValidate()
		{
			this.m_TransitionDuration = Mathf.Max(this.m_TransitionDuration, 0f);
		}
#endif
		
		/// <summary>
		/// Determines whether this window is active.
		/// </summary>
		/// <returns><c>true</c> if this instance is active; otherwise, <c>false</c>.</returns>
		protected virtual bool IsActive()
		{
			return (this.enabled && this.gameObject.activeInHierarchy);
		}
		
		/// <summary>
		/// Raises the select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnSelect(BaseEventData eventData)
		{
			// Focus the window
			this.Focus();
		}
        
		/// <summary>
		/// Raises the pointer down event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		public virtual void OnPointerDown(PointerEventData eventData)
		{
			// Focus the window
			this.Focus();
		}
		
		/// <summary>
		/// Focuses this window.
		/// </summary>
		public virtual void Focus()
		{
			if (this.m_IsFocused)
				return;
			
			// Flag as focused
			this.m_IsFocused = true;
			
			// Call the static on focused window
			UIWindow.OnBeforeFocusWindow(this);

            // Bring the window forward
            this.BringToFront();
		}

        /// <summary>
        /// Brings the window to the front.
        /// </summary>
        public void BringToFront()
        {
            UIUtility.BringToFront(this.gameObject, this.m_FocusAllowReparent);
        }

        /// <summary>
        /// Toggle the window Show/Hide.
        /// </summary>
        public virtual void Toggle()
		{
			MusicController.PlayUIClick();
			if (this.m_CurrentVisualState == VisualState.Shown)
				this.Hide();
			else
				this.Show();
		}
        
        public virtual void ToggleNoSound()
        {
	        if (this.m_CurrentVisualState == VisualState.Shown)
		        this.Hide();
	        else
		        this.Show();
        }
		
		/// <summary>
		/// Show the window.
		/// </summary>
		public virtual void Show()
		{
			this.Show(false);
		}
		
		/// <summary>
		/// Show the window.
		/// </summary>
		/// <param name="instant">If set to <c>true</c> instant.</param>
		public virtual void Show(bool instant)
		{
			if (!this.IsActive())
				return;
            
			// Focus the window
			this.Focus();
			
			// Check if the window is already shown
			if (this.m_CurrentVisualState == VisualState.Shown)
				return;
            
            // Transition
            this.EvaluateAndTransitionToVisualState(VisualState.Shown, instant);
		}

		/// <summary>
		/// Hide the window.
		/// </summary>
		public virtual void Hide()
		{
			this.Hide(false);
		}
		
		/// <summary>
		/// Hide the window.
		/// </summary>
		/// <param name="instant">If set to <c>true</c> instant.</param>
		public virtual void Hide(bool instant)
		{
			if (!this.IsActive())
				return;
			
			// Check if the window is already hidden
			if (this.m_CurrentVisualState == VisualState.Hidden)
				return;
			
			// Transition
			this.EvaluateAndTransitionToVisualState(VisualState.Hidden, instant);
		}
		
		/// <summary>
		/// Evaluates and transitions to the specified visual state.
		/// </summary>
		/// <param name="state">The state to transition to.</param>
		/// <param name="instant">If set to <c>true</c> instant.</param>
		protected virtual void EvaluateAndTransitionToVisualState(VisualState state, bool instant)
		{
			float targetAlpha = (state == VisualState.Shown) ? 1f : 0f;
			
			// Call the transition begin event
			if (this.onTransitionBegin != null)
				this.onTransitionBegin.Invoke(this, state, (instant || this.m_Transition == Transition.Instant));
			
			// Do the transition
			if (this.m_Transition == Transition.Fade)
			{
				float duration = (instant) ? 0f : this.m_TransitionDuration;
                
                // Tween the alpha
                this.StartAlphaTween(targetAlpha, duration, true);
			}
			else
			{
				// Set the alpha directly
				this.SetCanvasAlpha(targetAlpha);
				
				// Call the transition complete event, since it's instant
				if (this.onTransitionComplete != null)
					this.onTransitionComplete.Invoke(this, state);
			}
			
			// Save the state
			this.m_CurrentVisualState = state;
			
			// If we are transitioning to show, enable the canvas group raycast blocking
			if (state == VisualState.Shown)
			{
				this.m_CanvasGroup.blocksRaycasts = true;
				this.m_CanvasGroup.interactable = true;
			}
		}

        /// <summary>
        /// Instantly applies the visual state.
        /// </summary>
        /// <param name="state">The state to transition to.</param>
        public virtual void ApplyVisualState(VisualState state)
        {
            float targetAlpha = (state == VisualState.Shown) ? 1f : 0f;

            // Set the alpha directly
            this.SetCanvasAlpha(targetAlpha);

            // Save the state
            this.m_CurrentVisualState = state;

            // If we are transitioning to show, enable the canvas group raycast blocking
            if (state == VisualState.Shown)
            {
                this.m_CanvasGroup.blocksRaycasts = true;
                this.m_CanvasGroup.interactable = true;
            }
            else
            {
                this.m_CanvasGroup.blocksRaycasts = false;
                this.m_CanvasGroup.interactable = false;
            }
        }

        /// <summary>
        /// Starts alpha tween.
        /// </summary>
        /// <param name="targetAlpha">Target alpha.</param>
        /// <param name="duration">Duration.</param>
        /// <param name="ignoreTimeScale">If set to <c>true</c> ignore time scale.</param>
        public void StartAlphaTween(float targetAlpha, float duration, bool ignoreTimeScale)
		{
			if (this.m_CanvasGroup == null)
				return;
            
            var floatTween = new FloatTween { duration = duration, startFloat = this.m_CanvasGroup.alpha, targetFloat = targetAlpha };
			floatTween.AddOnChangedCallback(SetCanvasAlpha);
			floatTween.AddOnFinishCallback(OnTweenFinished);
			floatTween.ignoreTimeScale = ignoreTimeScale;
			floatTween.easing = this.m_TransitionEasing;
			this.m_FloatTweenRunner.StartTween(floatTween);
		}
		
		/// <summary>
		/// Sets the canvas alpha.
		/// </summary>
		/// <param name="alpha">Alpha.</param>
		public void SetCanvasAlpha(float alpha)
		{
			if (this.m_CanvasGroup == null)
				return;
			
			// Set the alpha
			this.m_CanvasGroup.alpha = alpha;
			
			// If the alpha is zero, disable block raycasts
			// Enabling them back on is done in the transition method
			if (alpha == 0f)
			{
				this.m_CanvasGroup.blocksRaycasts = false;
				this.m_CanvasGroup.interactable = false;
			}
		}
		
		/// <summary>
		/// Raises the list tween finished event.
		/// </summary>
		protected virtual void OnTweenFinished()
		{
			// Call the transition complete event
			if (this.onTransitionComplete != null)
				this.onTransitionComplete.Invoke(this, this.m_CurrentVisualState);
		}
		
		#region Static Methods
		/// <summary>
		/// Get all the windows in the scene (Including inactive).
		/// </summary>
		/// <returns>The windows.</returns>
		public static List<UIWindow> GetWindows()
		{
			List<UIWindow> windows = new List<UIWindow>();
			
			UIWindow[] ws = Resources.FindObjectsOfTypeAll<UIWindow>();
			
			foreach (UIWindow w in ws)
			{
				// Check if the window is active in the hierarchy
				if (w.gameObject.activeInHierarchy)
					windows.Add(w);
			}
			
			return windows;
		}
		
		public static int SortByCustomWindowID(UIWindow w1, UIWindow w2)
		{
			return w1.CustomID.CompareTo(w2.CustomID);
		}
		
		/// <summary>
		/// Gets the next unused custom ID for a window.
		/// </summary>
		/// <value>The next unused ID.</value>
		public static int NextUnusedCustomID
		{
			get
			{
				// Get the windows
				List<UIWindow> windows = UIWindow.GetWindows();
				
				if (GetWindows().Count > 0)
				{
					// Sort the windows by id
					windows.Sort(UIWindow.SortByCustomWindowID);
					
					// Return the last window id plus one
					return windows[windows.Count - 1].CustomID + 1;
				}
				
				// No windows, return 0
				return 0;
			}
		}
		
		/// <summary>
		/// Gets the window with the given ID.
		/// </summary>
		/// <returns>The window.</returns>
		/// <param name="id">Identifier.</param>
		public static UIWindow GetWindow(UIWindowID id)
		{
			// Get the windows and try finding the window with the given id
			foreach (UIWindow window in UIWindow.GetWindows())
				if (window.ID == id)
					return window;
			
			return null;
		}
		
		/// <summary>
		/// Gets the window with the given custom ID.
		/// </summary>
		/// <returns>The window.</returns>
		/// <param name="id">The custom identifier.</param>
		public static UIWindow GetWindowByCustomID(int customId)
		{
			// Get the windows and try finding the window with the given id
			foreach (UIWindow window in UIWindow.GetWindows())
				if (window.CustomID == customId)
					return window;
			
			return null;
		}
		
		/// <summary>
		/// Focuses the window with the given ID.
		/// </summary>
		/// <param name="id">Identifier.</param>
		public static void FocusWindow(UIWindowID id)
		{
			// Focus the window
			if (UIWindow.GetWindow(id) != null)
				UIWindow.GetWindow(id).Focus();
		}
		
		/// <summary>
		/// Raises the before focus window event.
		/// </summary>
		/// <param name="window">The window.</param>
		protected static void OnBeforeFocusWindow(UIWindow window)
		{
			if (m_FucusedWindow != null)
				m_FucusedWindow.m_IsFocused = false;
			
			m_FucusedWindow = window;
		}
		#endregion
	}
}
 

// Assets\-ZombieRoyale\Scripts\Clients\NPCSpeechListener.cs:
 using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NPCSpeechListener : MonoBehaviour
{
    public Action<string> OnSpeechTextReceived;

    public bool IsInitialized()
    {
        if (!LLMAISettingsController.IsGeminiApiKeySet)
        {
            return false;
        }
        MicrophoneWhisper.Instance.OnTextReceived += OnTextReceived;
        return true;
    }

    private void OnTextReceived(string inputSpeech)
    {
        throw new System.NotImplementedException();
    }
}
 



# TASK: when Npc receives message it should show it in NpcDialogueWindow